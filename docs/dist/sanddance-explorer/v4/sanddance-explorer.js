(() => {

function $parcel$export(e, n, v, s) {
  Object.defineProperty(e, n, {get: v, set: s, enumerable: true, configurable: true});
}

function $parcel$exportWildcard(dest, source) {
  Object.keys(source).forEach(function(key) {
    if (key === 'default' || key === '__esModule' || Object.prototype.hasOwnProperty.call(dest, key)) {
      return;
    }

    Object.defineProperty(dest, key, {
      enumerable: true,
      get: function get() {
        return source[key];
      }
    });
  });

  return dest;
}

function $parcel$defineInteropFlag(a) {
  Object.defineProperty(a, '__esModule', {value: true, configurable: true});
}

      var $parcel$global = globalThis;
    
var $parcel$modules = {};
var $parcel$inits = {};

var parcelRequire = $parcel$global["parcelRequirec6f8"];

if (parcelRequire == null) {
  parcelRequire = function(id) {
    if (id in $parcel$modules) {
      return $parcel$modules[id].exports;
    }
    if (id in $parcel$inits) {
      var init = $parcel$inits[id];
      delete $parcel$inits[id];
      var module = {id: id, exports: {}};
      $parcel$modules[id] = module;
      init.call(module.exports, module, module.exports);
      return module.exports;
    }
    var err = new Error("Cannot find module '" + id + "'");
    err.code = 'MODULE_NOT_FOUND';
    throw err;
  };

  parcelRequire.register = function register(id, init) {
    $parcel$inits[id] = init;
  };

  $parcel$global["parcelRequirec6f8"] = parcelRequire;
}

var parcelRegister = parcelRequire.register;
parcelRegister("hNlxu", function(module, exports) {

$parcel$export(module.exports, "Color", () => Color);
$parcel$export(module.exports, "darker", () => darker);
$parcel$export(module.exports, "brighter", () => brighter);
$parcel$export(module.exports, "default", () => color);
$parcel$export(module.exports, "hslConvert", () => hslConvert);
$parcel$export(module.exports, "Rgb", () => Rgb);
$parcel$export(module.exports, "rgbConvert", () => rgbConvert);
$parcel$export(module.exports, "rgb", () => rgb);
$parcel$export(module.exports, "hsl", () => hsl);

var $9fd1U = parcelRequire("9fd1U");
function Color() {}
var darker = 0.7;
var brighter = 1 / darker;
var reI = "\\s*([+-]?\\d+)\\s*", reN = "\\s*([+-]?(?:\\d*\\.)?\\d+(?:[eE][+-]?\\d+)?)\\s*", reP = "\\s*([+-]?(?:\\d*\\.)?\\d+(?:[eE][+-]?\\d+)?)%\\s*", reHex = /^#([0-9a-f]{3,8})$/, reRgbInteger = new RegExp(`^rgb\\(${reI},${reI},${reI}\\)$`), reRgbPercent = new RegExp(`^rgb\\(${reP},${reP},${reP}\\)$`), reRgbaInteger = new RegExp(`^rgba\\(${reI},${reI},${reI},${reN}\\)$`), reRgbaPercent = new RegExp(`^rgba\\(${reP},${reP},${reP},${reN}\\)$`), reHslPercent = new RegExp(`^hsl\\(${reN},${reP},${reP}\\)$`), reHslaPercent = new RegExp(`^hsla\\(${reN},${reP},${reP},${reN}\\)$`);
var named = {
    aliceblue: 0xf0f8ff,
    antiquewhite: 0xfaebd7,
    aqua: 0x00ffff,
    aquamarine: 0x7fffd4,
    azure: 0xf0ffff,
    beige: 0xf5f5dc,
    bisque: 0xffe4c4,
    black: 0x000000,
    blanchedalmond: 0xffebcd,
    blue: 0x0000ff,
    blueviolet: 0x8a2be2,
    brown: 0xa52a2a,
    burlywood: 0xdeb887,
    cadetblue: 0x5f9ea0,
    chartreuse: 0x7fff00,
    chocolate: 0xd2691e,
    coral: 0xff7f50,
    cornflowerblue: 0x6495ed,
    cornsilk: 0xfff8dc,
    crimson: 0xdc143c,
    cyan: 0x00ffff,
    darkblue: 0x00008b,
    darkcyan: 0x008b8b,
    darkgoldenrod: 0xb8860b,
    darkgray: 0xa9a9a9,
    darkgreen: 0x006400,
    darkgrey: 0xa9a9a9,
    darkkhaki: 0xbdb76b,
    darkmagenta: 0x8b008b,
    darkolivegreen: 0x556b2f,
    darkorange: 0xff8c00,
    darkorchid: 0x9932cc,
    darkred: 0x8b0000,
    darksalmon: 0xe9967a,
    darkseagreen: 0x8fbc8f,
    darkslateblue: 0x483d8b,
    darkslategray: 0x2f4f4f,
    darkslategrey: 0x2f4f4f,
    darkturquoise: 0x00ced1,
    darkviolet: 0x9400d3,
    deeppink: 0xff1493,
    deepskyblue: 0x00bfff,
    dimgray: 0x696969,
    dimgrey: 0x696969,
    dodgerblue: 0x1e90ff,
    firebrick: 0xb22222,
    floralwhite: 0xfffaf0,
    forestgreen: 0x228b22,
    fuchsia: 0xff00ff,
    gainsboro: 0xdcdcdc,
    ghostwhite: 0xf8f8ff,
    gold: 0xffd700,
    goldenrod: 0xdaa520,
    gray: 0x808080,
    green: 0x008000,
    greenyellow: 0xadff2f,
    grey: 0x808080,
    honeydew: 0xf0fff0,
    hotpink: 0xff69b4,
    indianred: 0xcd5c5c,
    indigo: 0x4b0082,
    ivory: 0xfffff0,
    khaki: 0xf0e68c,
    lavender: 0xe6e6fa,
    lavenderblush: 0xfff0f5,
    lawngreen: 0x7cfc00,
    lemonchiffon: 0xfffacd,
    lightblue: 0xadd8e6,
    lightcoral: 0xf08080,
    lightcyan: 0xe0ffff,
    lightgoldenrodyellow: 0xfafad2,
    lightgray: 0xd3d3d3,
    lightgreen: 0x90ee90,
    lightgrey: 0xd3d3d3,
    lightpink: 0xffb6c1,
    lightsalmon: 0xffa07a,
    lightseagreen: 0x20b2aa,
    lightskyblue: 0x87cefa,
    lightslategray: 0x778899,
    lightslategrey: 0x778899,
    lightsteelblue: 0xb0c4de,
    lightyellow: 0xffffe0,
    lime: 0x00ff00,
    limegreen: 0x32cd32,
    linen: 0xfaf0e6,
    magenta: 0xff00ff,
    maroon: 0x800000,
    mediumaquamarine: 0x66cdaa,
    mediumblue: 0x0000cd,
    mediumorchid: 0xba55d3,
    mediumpurple: 0x9370db,
    mediumseagreen: 0x3cb371,
    mediumslateblue: 0x7b68ee,
    mediumspringgreen: 0x00fa9a,
    mediumturquoise: 0x48d1cc,
    mediumvioletred: 0xc71585,
    midnightblue: 0x191970,
    mintcream: 0xf5fffa,
    mistyrose: 0xffe4e1,
    moccasin: 0xffe4b5,
    navajowhite: 0xffdead,
    navy: 0x000080,
    oldlace: 0xfdf5e6,
    olive: 0x808000,
    olivedrab: 0x6b8e23,
    orange: 0xffa500,
    orangered: 0xff4500,
    orchid: 0xda70d6,
    palegoldenrod: 0xeee8aa,
    palegreen: 0x98fb98,
    paleturquoise: 0xafeeee,
    palevioletred: 0xdb7093,
    papayawhip: 0xffefd5,
    peachpuff: 0xffdab9,
    peru: 0xcd853f,
    pink: 0xffc0cb,
    plum: 0xdda0dd,
    powderblue: 0xb0e0e6,
    purple: 0x800080,
    rebeccapurple: 0x663399,
    red: 0xff0000,
    rosybrown: 0xbc8f8f,
    royalblue: 0x4169e1,
    saddlebrown: 0x8b4513,
    salmon: 0xfa8072,
    sandybrown: 0xf4a460,
    seagreen: 0x2e8b57,
    seashell: 0xfff5ee,
    sienna: 0xa0522d,
    silver: 0xc0c0c0,
    skyblue: 0x87ceeb,
    slateblue: 0x6a5acd,
    slategray: 0x708090,
    slategrey: 0x708090,
    snow: 0xfffafa,
    springgreen: 0x00ff7f,
    steelblue: 0x4682b4,
    tan: 0xd2b48c,
    teal: 0x008080,
    thistle: 0xd8bfd8,
    tomato: 0xff6347,
    turquoise: 0x40e0d0,
    violet: 0xee82ee,
    wheat: 0xf5deb3,
    white: 0xffffff,
    whitesmoke: 0xf5f5f5,
    yellow: 0xffff00,
    yellowgreen: 0x9acd32
};
(0, $9fd1U.default)(Color, color, {
    copy (channels) {
        return Object.assign(new this.constructor, this, channels);
    },
    displayable () {
        return this.rgb().displayable();
    },
    hex: color_formatHex,
    formatHex: color_formatHex,
    formatHex8: color_formatHex8,
    formatHsl: color_formatHsl,
    formatRgb: color_formatRgb,
    toString: color_formatRgb
});
function color_formatHex() {
    return this.rgb().formatHex();
}
function color_formatHex8() {
    return this.rgb().formatHex8();
}
function color_formatHsl() {
    return hslConvert(this).formatHsl();
}
function color_formatRgb() {
    return this.rgb().formatRgb();
}
function color(format) {
    var m, l;
    format = (format + "").trim().toLowerCase();
    return (m = reHex.exec(format)) ? (l = m[1].length, m = parseInt(m[1], 16), l === 6 ? rgbn(m) // #ff0000
     : l === 3 ? new Rgb(m >> 8 & 0xf | m >> 4 & 0xf0, m >> 4 & 0xf | m & 0xf0, (m & 0xf) << 4 | m & 0xf, 1) // #f00
     : l === 8 ? rgba(m >> 24 & 0xff, m >> 16 & 0xff, m >> 8 & 0xff, (m & 0xff) / 0xff) // #ff000000
     : l === 4 ? rgba(m >> 12 & 0xf | m >> 8 & 0xf0, m >> 8 & 0xf | m >> 4 & 0xf0, m >> 4 & 0xf | m & 0xf0, ((m & 0xf) << 4 | m & 0xf) / 0xff) // #f000
     : null // invalid hex
    ) : (m = reRgbInteger.exec(format)) ? new Rgb(m[1], m[2], m[3], 1) // rgb(255, 0, 0)
     : (m = reRgbPercent.exec(format)) ? new Rgb(m[1] * 255 / 100, m[2] * 255 / 100, m[3] * 255 / 100, 1) // rgb(100%, 0%, 0%)
     : (m = reRgbaInteger.exec(format)) ? rgba(m[1], m[2], m[3], m[4]) // rgba(255, 0, 0, 1)
     : (m = reRgbaPercent.exec(format)) ? rgba(m[1] * 255 / 100, m[2] * 255 / 100, m[3] * 255 / 100, m[4]) // rgb(100%, 0%, 0%, 1)
     : (m = reHslPercent.exec(format)) ? hsla(m[1], m[2] / 100, m[3] / 100, 1) // hsl(120, 50%, 50%)
     : (m = reHslaPercent.exec(format)) ? hsla(m[1], m[2] / 100, m[3] / 100, m[4]) // hsla(120, 50%, 50%, 1)
     : named.hasOwnProperty(format) ? rgbn(named[format]) // eslint-disable-line no-prototype-builtins
     : format === "transparent" ? new Rgb(NaN, NaN, NaN, 0) : null;
}
function rgbn(n) {
    return new Rgb(n >> 16 & 0xff, n >> 8 & 0xff, n & 0xff, 1);
}
function rgba(r, g, b, a) {
    if (a <= 0) r = g = b = NaN;
    return new Rgb(r, g, b, a);
}
function rgbConvert(o) {
    if (!(o instanceof Color)) o = color(o);
    if (!o) return new Rgb;
    o = o.rgb();
    return new Rgb(o.r, o.g, o.b, o.opacity);
}
function rgb(r, g, b, opacity) {
    return arguments.length === 1 ? rgbConvert(r) : new Rgb(r, g, b, opacity == null ? 1 : opacity);
}
function Rgb(r, g, b, opacity) {
    this.r = +r;
    this.g = +g;
    this.b = +b;
    this.opacity = +opacity;
}
(0, $9fd1U.default)(Rgb, rgb, (0, $9fd1U.extend)(Color, {
    brighter (k) {
        k = k == null ? brighter : Math.pow(brighter, k);
        return new Rgb(this.r * k, this.g * k, this.b * k, this.opacity);
    },
    darker (k) {
        k = k == null ? darker : Math.pow(darker, k);
        return new Rgb(this.r * k, this.g * k, this.b * k, this.opacity);
    },
    rgb () {
        return this;
    },
    clamp () {
        return new Rgb(clampi(this.r), clampi(this.g), clampi(this.b), clampa(this.opacity));
    },
    displayable () {
        return -0.5 <= this.r && this.r < 255.5 && -0.5 <= this.g && this.g < 255.5 && -0.5 <= this.b && this.b < 255.5 && 0 <= this.opacity && this.opacity <= 1;
    },
    hex: rgb_formatHex,
    formatHex: rgb_formatHex,
    formatHex8: rgb_formatHex8,
    formatRgb: rgb_formatRgb,
    toString: rgb_formatRgb
}));
function rgb_formatHex() {
    return `#${hex(this.r)}${hex(this.g)}${hex(this.b)}`;
}
function rgb_formatHex8() {
    return `#${hex(this.r)}${hex(this.g)}${hex(this.b)}${hex((isNaN(this.opacity) ? 1 : this.opacity) * 255)}`;
}
function rgb_formatRgb() {
    const a = clampa(this.opacity);
    return `${a === 1 ? "rgb(" : "rgba("}${clampi(this.r)}, ${clampi(this.g)}, ${clampi(this.b)}${a === 1 ? ")" : `, ${a})`}`;
}
function clampa(opacity) {
    return isNaN(opacity) ? 1 : Math.max(0, Math.min(1, opacity));
}
function clampi(value) {
    return Math.max(0, Math.min(255, Math.round(value) || 0));
}
function hex(value) {
    value = clampi(value);
    return (value < 16 ? "0" : "") + value.toString(16);
}
function hsla(h, s, l, a) {
    if (a <= 0) h = s = l = NaN;
    else if (l <= 0 || l >= 1) h = s = NaN;
    else if (s <= 0) h = NaN;
    return new Hsl(h, s, l, a);
}
function hslConvert(o) {
    if (o instanceof Hsl) return new Hsl(o.h, o.s, o.l, o.opacity);
    if (!(o instanceof Color)) o = color(o);
    if (!o) return new Hsl;
    if (o instanceof Hsl) return o;
    o = o.rgb();
    var r = o.r / 255, g = o.g / 255, b = o.b / 255, min = Math.min(r, g, b), max = Math.max(r, g, b), h = NaN, s = max - min, l = (max + min) / 2;
    if (s) {
        if (r === max) h = (g - b) / s + (g < b) * 6;
        else if (g === max) h = (b - r) / s + 2;
        else h = (r - g) / s + 4;
        s /= l < 0.5 ? max + min : 2 - max - min;
        h *= 60;
    } else s = l > 0 && l < 1 ? 0 : h;
    return new Hsl(h, s, l, o.opacity);
}
function hsl(h, s, l, opacity) {
    return arguments.length === 1 ? hslConvert(h) : new Hsl(h, s, l, opacity == null ? 1 : opacity);
}
function Hsl(h, s, l, opacity) {
    this.h = +h;
    this.s = +s;
    this.l = +l;
    this.opacity = +opacity;
}
(0, $9fd1U.default)(Hsl, hsl, (0, $9fd1U.extend)(Color, {
    brighter (k) {
        k = k == null ? brighter : Math.pow(brighter, k);
        return new Hsl(this.h, this.s, this.l * k, this.opacity);
    },
    darker (k) {
        k = k == null ? darker : Math.pow(darker, k);
        return new Hsl(this.h, this.s, this.l * k, this.opacity);
    },
    rgb () {
        var h = this.h % 360 + (this.h < 0) * 360, s = isNaN(h) || isNaN(this.s) ? 0 : this.s, l = this.l, m2 = l + (l < 0.5 ? l : 1 - l) * s, m1 = 2 * l - m2;
        return new Rgb(hsl2rgb(h >= 240 ? h - 240 : h + 120, m1, m2), hsl2rgb(h, m1, m2), hsl2rgb(h < 120 ? h + 240 : h - 120, m1, m2), this.opacity);
    },
    clamp () {
        return new Hsl(clamph(this.h), clampt(this.s), clampt(this.l), clampa(this.opacity));
    },
    displayable () {
        return (0 <= this.s && this.s <= 1 || isNaN(this.s)) && 0 <= this.l && this.l <= 1 && 0 <= this.opacity && this.opacity <= 1;
    },
    formatHsl () {
        const a = clampa(this.opacity);
        return `${a === 1 ? "hsl(" : "hsla("}${clamph(this.h)}, ${clampt(this.s) * 100}%, ${clampt(this.l) * 100}%${a === 1 ? ")" : `, ${a})`}`;
    }
}));
function clamph(value) {
    value = (value || 0) % 360;
    return value < 0 ? value + 360 : value;
}
function clampt(value) {
    return Math.max(0, Math.min(1, value || 0));
}
/* From FvD 13.37, CSS Color Module Level 3 */ function hsl2rgb(h, m1, m2) {
    return (h < 60 ? m1 + (m2 - m1) * h / 60 : h < 180 ? m2 : h < 240 ? m1 + (m2 - m1) * (240 - h) / 60 : m1) * 255;
}

});
parcelRegister("9fd1U", function(module, exports) {

$parcel$export(module.exports, "default", () => $6baf9f3c20fde4a8$export$2e2bcd8739ae039);
$parcel$export(module.exports, "extend", () => $6baf9f3c20fde4a8$export$8b58be045bf06082);
function $6baf9f3c20fde4a8$export$2e2bcd8739ae039(constructor, factory, prototype) {
    constructor.prototype = factory.prototype = prototype;
    prototype.constructor = constructor;
}
function $6baf9f3c20fde4a8$export$8b58be045bf06082(parent, definition) {
    var prototype = Object.create(parent.prototype);
    for(var key in definition)prototype[key] = definition[key];
    return prototype;
}

});


parcelRegister("gwbX4", function(module, exports) {
module.exports = JSON.parse("[\"a\",\"abbr\",\"address\",\"area\",\"article\",\"aside\",\"audio\",\"b\",\"base\",\"bdi\",\"bdo\",\"blockquote\",\"body\",\"br\",\"button\",\"canvas\",\"caption\",\"cite\",\"code\",\"col\",\"colgroup\",\"data\",\"datalist\",\"dd\",\"del\",\"details\",\"dfn\",\"dialog\",\"div\",\"dl\",\"dt\",\"em\",\"embed\",\"fieldset\",\"figcaption\",\"figure\",\"footer\",\"form\",\"h1\",\"h2\",\"h3\",\"h4\",\"h5\",\"h6\",\"head\",\"header\",\"hgroup\",\"hr\",\"html\",\"i\",\"iframe\",\"img\",\"input\",\"ins\",\"kbd\",\"keygen\",\"label\",\"legend\",\"li\",\"link\",\"main\",\"map\",\"mark\",\"math\",\"menu\",\"menuitem\",\"meta\",\"meter\",\"nav\",\"noscript\",\"object\",\"ol\",\"optgroup\",\"option\",\"output\",\"p\",\"param\",\"picture\",\"pre\",\"progress\",\"q\",\"rb\",\"rp\",\"rt\",\"rtc\",\"ruby\",\"s\",\"samp\",\"script\",\"section\",\"select\",\"slot\",\"small\",\"source\",\"span\",\"strong\",\"style\",\"sub\",\"summary\",\"sup\",\"svg\",\"table\",\"tbody\",\"td\",\"template\",\"textarea\",\"tfoot\",\"th\",\"thead\",\"time\",\"title\",\"tr\",\"track\",\"u\",\"ul\",\"var\",\"video\",\"wbr\"]");

});

parcelRegister("4T7E6", function(module, exports) {
module.exports = JSON.parse("[\"a\",\"altGlyph\",\"altGlyphDef\",\"altGlyphItem\",\"animate\",\"animateColor\",\"animateMotion\",\"animateTransform\",\"circle\",\"clipPath\",\"color-profile\",\"cursor\",\"defs\",\"desc\",\"ellipse\",\"feBlend\",\"feColorMatrix\",\"feComponentTransfer\",\"feComposite\",\"feConvolveMatrix\",\"feDiffuseLighting\",\"feDisplacementMap\",\"feDistantLight\",\"feFlood\",\"feFuncA\",\"feFuncB\",\"feFuncG\",\"feFuncR\",\"feGaussianBlur\",\"feImage\",\"feMerge\",\"feMergeNode\",\"feMorphology\",\"feOffset\",\"fePointLight\",\"feSpecularLighting\",\"feSpotLight\",\"feTile\",\"feTurbulence\",\"filter\",\"font\",\"font-face\",\"font-face-format\",\"font-face-name\",\"font-face-src\",\"font-face-uri\",\"foreignObject\",\"g\",\"glyph\",\"glyphRef\",\"hkern\",\"image\",\"line\",\"linearGradient\",\"marker\",\"mask\",\"metadata\",\"missing-glyph\",\"mpath\",\"path\",\"pattern\",\"polygon\",\"polyline\",\"radialGradient\",\"rect\",\"script\",\"set\",\"stop\",\"style\",\"svg\",\"switch\",\"symbol\",\"text\",\"textPath\",\"title\",\"tref\",\"tspan\",\"use\",\"view\",\"vkern\"]");

});

parcelRegister("2FnuA", function(module, exports) {
"use strict";
/*!
* Copyright (c) Microsoft Corporation.
* Licensed under the MIT License.
*/ Object.defineProperty(module.exports, "__esModule", {
    value: true
});
module.exports.BarChartRecommender = module.exports.BarChartRecommenderSummary = void 0;

var $1uICa = parcelRequire("1uICa");
var $1f11a233e6d216bf$var$maxDistinctVal = 20;
var $1f11a233e6d216bf$var$minDistinctVal = 2;
var $1f11a233e6d216bf$var$BarChartRecommenderSummary = /** @class */ function() {
    function BarChartRecommenderSummary(columns, data) {
        var score = -1;
        for(var i = 0; i < columns.length; i++){
            var recommendation = new $1f11a233e6d216bf$var$BarChartRecommender(columns[i], data).recommend();
            if (recommendation.score > score) {
                this.best = recommendation;
                score = recommendation.score;
            }
            if (score === 1) break;
        }
        for(var k = 0; k < columns.length; k++){
            var column = columns[k];
            if (column.name === this.best.columns.x || column.stats.isSequential) continue;
            if (column.quantitative || column.stats.distinctValueCount < $1uICa.maxCategoricalColors && column.stats.distinctValueCount > 1) {
                this.best.columns.color = this.best.columns.sort = column.name;
                this.best.scheme = (0, $1uICa.defaultColorScheme)(column);
                if (column.quantitative) this.best.colorBin = 'quantile';
                break;
            }
        }
    }
    BarChartRecommenderSummary.prototype.recommend = function() {
        return this.best;
    };
    return BarChartRecommenderSummary;
}();
module.exports.BarChartRecommenderSummary = $1f11a233e6d216bf$var$BarChartRecommenderSummary;
var $1f11a233e6d216bf$var$BarChartRecommender = /** @class */ function() {
    function BarChartRecommender(column, data) {
        this.score = 0;
        this.column = column;
        //the total score for bar chart is 1
        this.rules = [
            function(column) {
                if (column.stats.isSequential) return false;
                else if (column.quantitative) return true;
                else if (!column.quantitative && column.stats.distinctValueCount <= $1f11a233e6d216bf$var$maxDistinctVal && column.stats.distinctValueCount >= $1f11a233e6d216bf$var$minDistinctVal) return true;
                else return false;
            }
        ];
        for(var i = 0; i < this.rules.length; i++)if (this.rules[i](column)) this.score++;
    }
    BarChartRecommender.prototype.recommend = function() {
        var rec = {
            chart: 'barchart',
            columns: {
                x: this.column.name
            },
            score: this.score,
            scheme: undefined,
            view: '2d'
        };
        return rec;
    };
    return BarChartRecommender;
}();
module.exports.BarChartRecommender = $1f11a233e6d216bf$var$BarChartRecommender;

});
parcelRegister("1uICa", function(module, exports) {
"use strict";
/*!
* Copyright (c) Microsoft Corporation.
* Licensed under the MIT License.
*/ Object.defineProperty(module.exports, "__esModule", {
    value: true
});
module.exports.Recommender = module.exports.maxCategoricalColors = void 0;
module.exports.defaultColorScheme = $116b334d4f77bc48$var$defaultColorScheme;
module.exports.maxCategoricalColors = 20;
var $116b334d4f77bc48$var$Recommender = /** @class */ function() {
    function Recommender(columns, data) {}
    return Recommender;
}();
module.exports.Recommender = $116b334d4f77bc48$var$Recommender;
function $116b334d4f77bc48$var$defaultColorScheme(c) {
    if (c.quantitative) return 'redyellowgreen';
    else if (c.stats.distinctValueCount === 2) return 'dual_redgreen';
    else if (c.stats.distinctValueCount <= 10) return 'category10';
    return 'category20';
}

});


parcelRegister("bvDTm", function(module, exports) {
"use strict";
/*!
* Copyright (c) Microsoft Corporation.
* Licensed under the MIT License.
*/ Object.defineProperty(module.exports, "__esModule", {
    value: true
});
module.exports.isLongitude = $861188ad8c0733db$var$isLongitude;
module.exports.isLatitude = $861188ad8c0733db$var$isLatitude;
module.exports.isGeo = $861188ad8c0733db$var$isGeo;
//TODO: languages other than english
var $861188ad8c0733db$var$longitudeNames = [
    'lon',
    'long',
    'longitude'
];
var $861188ad8c0733db$var$latitudeNames = [
    'lat',
    'latitude'
];
function $861188ad8c0733db$var$isSpec(names, limits, column, data) {
    var is = false;
    var cname = column.name.toLowerCase();
    for(var i = 0; i < names.length; i++)if (names[i] === cname) {
        is = true;
        break;
    }
    data;
    return is;
}
function $861188ad8c0733db$var$isLongitude(column, data) {
    return $861188ad8c0733db$var$isSpec($861188ad8c0733db$var$longitudeNames, [
        -180,
        180
    ], column, data);
}
function $861188ad8c0733db$var$isLatitude(column, data) {
    return $861188ad8c0733db$var$isSpec($861188ad8c0733db$var$latitudeNames, [
        -90,
        90
    ], column, data);
}
function $861188ad8c0733db$var$isGeo(column, data) {
    return $861188ad8c0733db$var$isLatitude(column, data) || $861188ad8c0733db$var$isLongitude(column, data);
}

});

parcelRegister("7Kus9", function(module, exports) {
"use strict";
/*!
* Copyright (c) Microsoft Corporation.
* Licensed under the MIT License.
*/ Object.defineProperty(module.exports, "__esModule", {
    value: true
});
module.exports.ScatterPlotRecommenderSummary = void 0;

var $1uICa = parcelRequire("1uICa");

var $bvDTm = parcelRequire("bvDTm");
var $5a44739e7f49bf14$var$ScatterPlotRecommenderSummary = /** @class */ function() {
    function ScatterPlotRecommenderSummary(columns, data) {
        var rec = {
            chart: 'scatterplot',
            score: undefined,
            columns: {},
            scheme: undefined,
            view: '2d'
        };
        columns.forEach(function(column) {
            if (!rec.columns.x) {
                if (column.name.toLowerCase() === 'x') return rec.columns.x = column.name;
                else if ((0, $bvDTm.isLongitude)(column)) return rec.columns.x = column.name;
            }
            if (!rec.columns.y) {
                if (column.name.toLowerCase() === 'y') return rec.columns.y = column.name;
                else if ((0, $bvDTm.isLatitude)(column)) return rec.columns.y = column.name;
            }
            if (!rec.columns.color && !column.stats.isSequential) {
                if (column.quantitative || column.stats.distinctValueCount < $1uICa.maxCategoricalColors) {
                    rec.columns.color = rec.columns.sort = column.name;
                    rec.scheme = (0, $1uICa.defaultColorScheme)(column);
                    if (column.quantitative) rec.colorBin = 'quantile';
                    return;
                }
            }
        });
        if (rec.columns.x && rec.columns.y) this.best = rec;
    }
    ScatterPlotRecommenderSummary.prototype.recommend = function() {
        return this.best;
    };
    return ScatterPlotRecommenderSummary;
}();
module.exports.ScatterPlotRecommenderSummary = $5a44739e7f49bf14$var$ScatterPlotRecommenderSummary;

});

parcelRegister("lSaje", function(module, exports) {
"use strict";
/*!
* Copyright (c) Microsoft Corporation.
* Licensed under the MIT License.
*/ Object.defineProperty(module.exports, "__esModule", {
    value: true
});
module.exports.preferredColumnForTreemapSize = $fec6a34ab2606213$var$preferredColumnForTreemapSize;

var $bvDTm = parcelRequire("bvDTm");
function $fec6a34ab2606213$var$preferredColumnForTreemapSize(columns, strict) {
    for(var i = 0; i < columns.length; i++){
        var c = columns[i];
        if (c.quantitative) {
            if (strict && c.stats.hasNegative) continue;
            if (strict && c.stats.isSequential) continue;
            if (strict && (0, $bvDTm.isGeo)(c)) continue;
            return c;
        }
    }
}

});

parcelRegister("b7pOC", function(module, exports) {
"use strict";
/*!
* Copyright (c) Microsoft Corporation.
* Licensed under the MIT License.
*/ Object.defineProperty(module.exports, "__esModule", {
    value: true
});
module.exports.RecommenderSummary = void 0;

var $2FnuA = parcelRequire("2FnuA");

var $7Kus9 = parcelRequire("7Kus9");
var $81845f94dbd209f8$var$RecommenderSummary = /** @class */ function() {
    function RecommenderSummary(columns, data) {
        var quickRec = new $7Kus9.ScatterPlotRecommenderSummary(columns, data).recommend();
        if (quickRec) this.rec = quickRec;
        else {
            var barChartrec = new $2FnuA.BarChartRecommenderSummary(columns, data).recommend();
            if (barChartrec && barChartrec.score >= 1) this.rec = barChartrec;
            else this.rec = {
                chart: 'grid',
                columns: {},
                score: 1
            };
        }
    }
    RecommenderSummary.prototype.recommend = function() {
        return this.rec;
    };
    return RecommenderSummary;
}();
module.exports.RecommenderSummary = $81845f94dbd209f8$var$RecommenderSummary;

});

var $fa693121602b4446$exports = {};

$parcel$export($fa693121602b4446$exports, "controls", () => $5d1e60eb15fea085$exports);
$parcel$export($fa693121602b4446$exports, "getEmbedHTML", () => $cff73bb5fafa0795$export$9f4b684ea6be1a90);
$parcel$export($fa693121602b4446$exports, "SideTabId", () => $2752fa503c160704$export$f3b7566ffe363e3b);
$parcel$export($fa693121602b4446$exports, "use", () => $a601a4135959dcb0$export$1f96ae73734a86cc);
$parcel$export($fa693121602b4446$exports, "capabilities", () => $4293b5c02e7b8c3d$export$8e76ac9f37578d1b);
$parcel$export($fa693121602b4446$exports, "getColorSettingsFromThemePalette", () => $a7be03ae5c68c2c3$export$93a255849c3bdb97);
$parcel$export($fa693121602b4446$exports, "themePalettes", () => $a7be03ae5c68c2c3$export$3465a0e7b289ab72);
$parcel$export($fa693121602b4446$exports, "SandDance", () => $1342cf7df79546f0$exports);
$parcel$export($fa693121602b4446$exports, "util", () => $e295d8097c1ad61a$exports);
$parcel$export($fa693121602b4446$exports, "SandDanceReact", () => $b86644fa1aa9b6cb$exports);
$parcel$export($fa693121602b4446$exports, "version", () => $ce16cf456563b677$export$83d89fbfd8236492);
/*!
* Copyright (c) Microsoft Corporation.
* Licensed under the MIT License.
*/ var $5d1e60eb15fea085$exports = {};
/*!
* Copyright (c) Microsoft Corporation.
* Licensed under the MIT License.
*/ var $f4b615ab5c14d90e$exports = {};

$parcel$export($f4b615ab5c14d90e$exports, "Dialog", () => $f4b615ab5c14d90e$export$3ddf2d174ce01153);
/*!
* Copyright (c) Microsoft Corporation.
* Licensed under the MIT License.
*/ /*!
* Copyright (c) Microsoft Corporation.
* Licensed under the MIT License.
*/ /*!
* Copyright (c) Microsoft Corporation.
* Licensed under the MIT License.
*/ 

var $b86644fa1aa9b6cb$exports = {};

$parcel$export($b86644fa1aa9b6cb$exports, "SandDance", () => $1342cf7df79546f0$exports);
$parcel$export($b86644fa1aa9b6cb$exports, "util", () => $e295d8097c1ad61a$exports);
$parcel$export($b86644fa1aa9b6cb$exports, "Viewer", () => $7a3dcfea67f8da12$export$2ec4afd9b3c16a85);
$parcel$export($b86644fa1aa9b6cb$exports, "use", () => $a94804e25c3acfaf$export$1f96ae73734a86cc);
$parcel$export($b86644fa1aa9b6cb$exports, "version", () => $d76008c8107bb02f$export$83d89fbfd8236492);
/*!
* Copyright (c) Microsoft Corporation.
* Licensed under the MIT License.
*/ var $1342cf7df79546f0$exports = {};

$parcel$export($1342cf7df79546f0$exports, "use", () => $1342cf7df79546f0$export$1f96ae73734a86cc);
$parcel$export($1342cf7df79546f0$exports, "colorSchemes", () => $1f9940ddae6f4302$export$2ad73d393c16f81c);
$parcel$export($1342cf7df79546f0$exports, "constants", () => $44b8bb162b63b5b5$exports);
$parcel$export($1342cf7df79546f0$exports, "searchExpression", () => $0d976ebdc81921a3$exports);
$parcel$export($1342cf7df79546f0$exports, "specs", () => $502a84774beeb901$exports);
$parcel$export($1342cf7df79546f0$exports, "types", () => $1a35cc0c54ffaa6e$exports);
$parcel$export($1342cf7df79546f0$exports, "util", () => $048ba25c9a3f4065$exports);
$parcel$export($1342cf7df79546f0$exports, "VegaMorphCharts", () => $e296aaf527fc4d25$exports);
$parcel$export($1342cf7df79546f0$exports, "Viewer", () => $6662f126c1d9f58b$export$2ec4afd9b3c16a85);
$parcel$export($1342cf7df79546f0$exports, "version", () => $59c3ac7cbbe40380$export$83d89fbfd8236492);
/*!
* Copyright (c) Microsoft Corporation.
* Licensed under the MIT License.
*/ var $44b8bb162b63b5b5$exports = {};

$parcel$export($44b8bb162b63b5b5$exports, "GL_ORDINAL", () => $44b8bb162b63b5b5$export$5672246984822a29);
$parcel$export($44b8bb162b63b5b5$exports, "ColorScaleNone", () => $8d0624e259fe9d79$export$c991c3dd58d9959c);
$parcel$export($44b8bb162b63b5b5$exports, "FieldNames", () => $8d0624e259fe9d79$export$10df5429b7082be2);
$parcel$export($44b8bb162b63b5b5$exports, "ScaleNames", () => $8d0624e259fe9d79$export$c9f17d36dfc40d76);
$parcel$export($44b8bb162b63b5b5$exports, "SignalNames", () => $8d0624e259fe9d79$export$809e371dee643808);
/*!
* Copyright (c) Microsoft Corporation.
* Licensed under the MIT License.
*/ var $502a84774beeb901$exports = {};
/*!
* Copyright (c) Microsoft Corporation.
* Licensed under the MIT License.
*/ var $1c081eb26c39473d$exports = {};

$parcel$export($1c081eb26c39473d$exports, "build", () => $1c081eb26c39473d$export$3f8fe6489e95757d);
/*!
* Copyright (c) Microsoft Corporation.
* Licensed under the MIT License.
*/ /*!
* Copyright (c) Microsoft Corporation.
* Licensed under the MIT License.
*/ /*!
* Copyright (c) Microsoft Corporation.
* Licensed under the MIT License.
*/ var $8d0624e259fe9d79$exports = {};

$parcel$export($8d0624e259fe9d79$exports, "FieldNames", () => $8d0624e259fe9d79$export$10df5429b7082be2);
$parcel$export($8d0624e259fe9d79$exports, "ScaleNames", () => $8d0624e259fe9d79$export$c9f17d36dfc40d76);
$parcel$export($8d0624e259fe9d79$exports, "SignalNames", () => $8d0624e259fe9d79$export$809e371dee643808);
$parcel$export($8d0624e259fe9d79$exports, "Other", () => $8d0624e259fe9d79$export$8653a30c44b6e879);
$parcel$export($8d0624e259fe9d79$exports, "ColorScaleNone", () => $8d0624e259fe9d79$export$c991c3dd58d9959c);
/*!
* Copyright (c) Microsoft Corporation.
* Licensed under the MIT License.
*/ const $8d0624e259fe9d79$export$10df5429b7082be2 = {
    Active: '__SandDance__Active',
    Collapsed: '__SandDance__Collapsed',
    Contains: '__SandDance__Contains',
    Count: '__SandDance__Count',
    Sum: '__SandDance__Sum',
    SumOfCount: '__SandDance__CountSum',
    SumOfSum: '__SandDance__SumSum',
    Selected: '__SandDance__Selected',
    First: '__SandDance__First',
    Last: '__SandDance__Last',
    Top: '__SandDance__Top',
    TopColor: '__SandDance__TopColor',
    TopIndex: '__SandDance__TopIndex',
    PowerBISelectionId: '__SandDance__PowerBISelectionId',
    FacetSearch: '__SandDance__FacetSearch',
    FacetTitle: '__SandDance__FacetTitle',
    Ordinal: '__SandDance__Ordinal',
    WrapCol: '__SandDance__WrapCol',
    WrapRow: '__SandDance__WrapRow',
    Value: '__SandDance__Value',
    OffsetX: '__SandDance__X',
    OffsetY: '__SandDance__Y',
    OffsetHeight: '__SandDance__H',
    OffsetWidth: '__SandDance__W'
};
const $8d0624e259fe9d79$export$c9f17d36dfc40d76 = {
    Color: 'scale_color',
    X: 'scale_x',
    Y: 'scale_y',
    Z: 'scale_z'
};
const $8d0624e259fe9d79$export$809e371dee643808 = {
    ViewportWidth: 'ViewportWidth',
    ViewportHeight: 'ViewportHeight',
    MinCellWidth: 'MinCellWidth',
    MinCellHeight: 'MinCellHeight',
    PlotOffsetLeft: 'PlotOffsetLeft',
    PlotOffsetTop: 'PlotOffsetTop',
    PlotOffsetBottom: 'PlotOffsetBottom',
    PlotOffsetRight: 'PlotOffsetRight',
    PlotHeightIn: 'PlotHeightIn',
    PlotWidthIn: 'PlotWidthIn',
    PlotHeightOut: 'PlotHeightOut',
    PlotWidthOut: 'PlotWidthOut',
    ColorBinCount: 'RoleColor_BinCountSignal',
    ColorReverse: 'RoleColor_ReverseSignal',
    FacetAxesAdjustX: 'RoleFacet_AxesAdjustSignalX',
    FacetAxesAdjustY: 'RoleFacet_AxesAdjustSignalY',
    FacetBins: 'RoleFacet_BinsSignal',
    FacetVBins: 'RoleFacetV_BinsSignal',
    FacetPaddingTop: 'FacetPaddingTop',
    FacetPaddingBottom: 'FacetPaddingBottom',
    FacetPaddingLeft: 'FacetPaddingLeft',
    MarkOpacity: 'Mark_OpacitySignal',
    PointScale: 'Chart_PointScaleSignal',
    TextAngleX: 'Text_AngleXSignal',
    TextAngleY: 'Text_AngleYSignal',
    TextScale: 'Text_ScaleSignal',
    TextSize: 'Text_SizeSignal',
    TextTitleSize: 'Text_TitleSizeSignal',
    TreeMapMethod: 'Chart_TreeMapMethodSignal',
    XBins: 'RoleX_BinsSignal',
    YBins: 'RoleY_BinsSignal',
    ZHeight: 'RoleZ_HeightSignal',
    ZGrounded: 'RoleZ_Grounded',
    ZProportion: 'RoleZ_ProportionSignal'
};
const $8d0624e259fe9d79$export$8653a30c44b6e879 = '__Other';
const $8d0624e259fe9d79$export$c991c3dd58d9959c = 'none';


/*!
* Copyright (c) Microsoft Corporation.
* Licensed under the MIT License.
*/ //TODO move these to options
const $72552551eb533aa6$export$4a9b1843df49fbce = 10;
const $72552551eb533aa6$export$15c9d32f115776f9 = 100;
const $72552551eb533aa6$export$929dfe98c4c4722c = 15;
const $72552551eb533aa6$export$7794a0aff56142de = 140;
const $72552551eb533aa6$export$7c432db1d0b63312 = 180;
const $72552551eb533aa6$export$6bd206e55cb747ae = 40;
const $72552551eb533aa6$export$c2b9f0002271e8ba = 40;
const $72552551eb533aa6$export$bdb7a7da14f9ff2b = 40;
const $72552551eb533aa6$export$c11851bee1b89f04 = 40;
const $72552551eb533aa6$export$2aa02e522549e01e = 100;
const $72552551eb533aa6$export$d3da25ad66816957 = 100;
const $72552551eb533aa6$export$2e7279af2df830e3 = 30;
const $72552551eb533aa6$export$f0388d9263db6e5f = 60;
const $72552551eb533aa6$export$fd4a597070549ada = 69;
const $72552551eb533aa6$export$a26a082bf9fa4ca0 = 92;
const $72552551eb533aa6$export$3f5b554d51e74365 = 120;
const $72552551eb533aa6$export$c33f11801bb18430 = 120;
const $72552551eb533aa6$export$e1f76e63dbed4a9a = 10;
const $72552551eb533aa6$export$c223d3ee3c0620d9 = 20;
const $72552551eb533aa6$export$61fc7d43ac8f84b0 = 250;


/*!
* Copyright (c) Microsoft Corporation.
* Licensed under the MIT License.
*/ function $1e4d12c1d1e2ee69$export$d3be63162ba033ae(specContext) {
    switch(specContext.insight.totalStyle){
        case 'sum-strip':
        case 'sum-strip-percent':
        case 'sum-treemap':
            return false;
        default:
            //if totalStyle is blank, count is assumed
            return true;
    }
}


function $75d42c46c533a9fa$export$2e2bcd8739ae039(specContext) {
    var _a, _b, _c, _d;
    const { insight: insight, specColumns: specColumns, specViewOptions: specViewOptions } = specContext;
    const { language: language } = specViewOptions;
    const showAxes = !insight.hideAxes;
    const bandProps = {
        orientation: 'horizontal',
        groupby: {
            column: specColumns.y,
            defaultBins: $72552551eb533aa6$export$4a9b1843df49fbce,
            maxbinsSignalName: (0, $8d0624e259fe9d79$export$809e371dee643808).YBins,
            maxbinsSignalDisplayName: specContext.specViewOptions.language.YMaxBins,
            maxbins: $72552551eb533aa6$export$15c9d32f115776f9
        },
        minBandWidth: (0, $72552551eb533aa6$export$929dfe98c4c4722c),
        showAxes: showAxes
    };
    const x = {
        title: null
    };
    const axisScales = {
        x: x,
        y: {
            title: (_a = specColumns.y) === null || _a === void 0 ? void 0 : _a.name
        },
        z: {
            title: (_b = specColumns.z) === null || _b === void 0 ? void 0 : _b.name
        }
    };
    const layouts = [
        {
            layoutType: 'Band',
            props: bandProps
        }
    ];
    const { totalStyle: totalStyle, view: view } = insight;
    if (totalStyle === 'sum-strip-percent') {
        x.aggregate = 'percent';
        x.title = language.percent;
        const stripProps = {
            addPercentageScale: true,
            sortOrder: 'ascending',
            orientation: 'horizontal',
            size: specColumns.size,
            sort: specColumns.sort,
            z: specColumns.z,
            showAxes: showAxes,
            view: view
        };
        layouts.push({
            layoutType: 'Strip',
            props: stripProps
        });
    } else {
        const aggProps = {
            niceScale: true,
            dock: 'left',
            globalAggregateMaxExtentSignal: 'aggMaxExtent',
            globalAggregateMaxExtentScaledSignal: 'aggMaxExtentScaled',
            sumBy: specColumns.size,
            showAxes: showAxes
        };
        layouts.push({
            layoutType: 'AggregateContainer',
            props: aggProps
        });
        switch(totalStyle){
            case 'sum-treemap':
                {
                    x.aggregate = 'sum';
                    x.title = language.sum;
                    const treemapProps = {
                        corner: 'top-left',
                        size: specColumns.size,
                        treeMapMethod: specViewOptions.language.treeMapMethod,
                        z: specColumns.z,
                        showAxes: showAxes,
                        view: view
                    };
                    layouts.push({
                        layoutType: 'Treemap',
                        props: treemapProps
                    });
                    break;
                }
            case 'sum-strip':
                {
                    x.aggregate = 'sum';
                    x.title = language.sum;
                    const stripProps = {
                        sortOrder: 'ascending',
                        orientation: 'horizontal',
                        size: specColumns.size,
                        sort: specColumns.sort,
                        z: specColumns.z,
                        showAxes: showAxes,
                        view: view
                    };
                    layouts.push({
                        layoutType: 'Strip',
                        props: stripProps
                    });
                    break;
                }
            case 'count-strip':
                {
                    x.aggregate = 'count';
                    x.title = language.count;
                    const stripProps = {
                        sortOrder: 'ascending',
                        orientation: 'horizontal',
                        size: specColumns.size,
                        sort: specColumns.sort,
                        z: specColumns.z,
                        showAxes: showAxes,
                        view: view
                    };
                    layouts.push({
                        layoutType: 'Strip',
                        props: stripProps
                    });
                    break;
                }
            default:
                {
                    x.aggregate = 'count';
                    x.title = language.count;
                    const squareProps = {
                        sortBy: specColumns.sort,
                        fillDirection: 'down-right',
                        z: specColumns.z,
                        maxGroupedUnits: aggProps.globalAggregateMaxExtentSignal,
                        maxGroupedFillSize: aggProps.globalAggregateMaxExtentScaledSignal,
                        showAxes: showAxes,
                        view: view
                    };
                    layouts.push({
                        layoutType: 'Square',
                        props: squareProps
                    });
                    break;
                }
        }
    }
    return {
        axisScales: axisScales,
        layouts: layouts,
        specCapabilities: {
            countsAndSums: true,
            percentage: true,
            roles: [
                {
                    role: 'y',
                    binnable: true,
                    axisSelection: ((_c = specColumns.y) === null || _c === void 0 ? void 0 : _c.quantitative) ? 'range' : 'exact',
                    axisSelectionBetweenTicks: true,
                    signals: [
                        (0, $8d0624e259fe9d79$export$809e371dee643808).YBins
                    ]
                },
                {
                    role: 'z',
                    axisSelection: ((_d = specColumns.z) === null || _d === void 0 ? void 0 : _d.quantitative) ? 'range' : 'exact',
                    allowNone: true,
                    disabled: view === '2d'
                },
                {
                    role: 'color',
                    allowNone: true
                },
                {
                    role: 'sort',
                    allowNone: true
                },
                {
                    role: 'size',
                    allowNone: (0, $1e4d12c1d1e2ee69$export$d3be63162ba033ae),
                    excludeCategoric: true,
                    signals: [
                        (0, $8d0624e259fe9d79$export$809e371dee643808).TreeMapMethod
                    ]
                },
                {
                    role: 'facet',
                    allowNone: true,
                    signals: [
                        (0, $8d0624e259fe9d79$export$809e371dee643808).FacetBins
                    ]
                },
                {
                    role: 'facetV',
                    allowNone: true,
                    signals: [
                        (0, $8d0624e259fe9d79$export$809e371dee643808).FacetVBins
                    ]
                }
            ]
        }
    };
}


/*!
* Copyright (c) Microsoft Corporation.
* Licensed under the MIT License.
*/ 


function $63c963d9a5e0cafb$export$2e2bcd8739ae039(specContext) {
    var _a, _b;
    const { insight: insight, specColumns: specColumns, specViewOptions: specViewOptions } = specContext;
    const { language: language } = specViewOptions;
    const showAxes = !insight.hideAxes;
    const bandProps = {
        orientation: 'vertical',
        groupby: {
            column: specColumns.x,
            defaultBins: $72552551eb533aa6$export$4a9b1843df49fbce,
            maxbinsSignalName: (0, $8d0624e259fe9d79$export$809e371dee643808).XBins,
            maxbinsSignalDisplayName: specContext.specViewOptions.language.XMaxBins,
            maxbins: $72552551eb533aa6$export$15c9d32f115776f9
        },
        minBandWidth: (0, $72552551eb533aa6$export$929dfe98c4c4722c),
        showAxes: showAxes
    };
    const y = {
        title: null
    };
    const axisScales = {
        x: {
            title: specColumns.x && specColumns.x.name
        },
        y: y,
        z: {
            title: specColumns.z && specColumns.z.name
        }
    };
    const layouts = [
        {
            layoutType: 'Band',
            props: bandProps
        }
    ];
    const { totalStyle: totalStyle, view: view } = insight;
    if (totalStyle === 'sum-strip-percent') {
        y.aggregate = 'percent';
        y.title = language.percent;
        const stripProps = {
            addPercentageScale: true,
            sortOrder: 'descending',
            orientation: 'vertical',
            size: specColumns.size,
            sort: specColumns.sort,
            z: specColumns.z,
            showAxes: showAxes,
            view: view
        };
        layouts.push({
            layoutType: 'Strip',
            props: stripProps
        });
    } else {
        const aggProps = {
            niceScale: true,
            dock: 'bottom',
            globalAggregateMaxExtentSignal: 'aggMaxExtent',
            globalAggregateMaxExtentScaledSignal: 'aggMaxExtentScaled',
            sumBy: specColumns.size,
            showAxes: showAxes
        };
        layouts.push({
            layoutType: 'AggregateContainer',
            props: aggProps
        });
        switch(totalStyle){
            case 'sum-treemap':
                {
                    y.aggregate = 'sum';
                    y.title = language.sum;
                    const treemapProps = {
                        corner: 'bottom-left',
                        size: specColumns.size,
                        treeMapMethod: specViewOptions.language.treeMapMethod,
                        z: specColumns.z,
                        showAxes: showAxes,
                        view: view
                    };
                    layouts.push({
                        layoutType: 'Treemap',
                        props: treemapProps
                    });
                    break;
                }
            case 'sum-strip':
                {
                    y.aggregate = 'sum';
                    y.title = language.sum;
                    const stripProps = {
                        sortOrder: 'descending',
                        orientation: 'vertical',
                        size: specColumns.size,
                        sort: specColumns.sort,
                        z: specColumns.z,
                        showAxes: showAxes,
                        view: view
                    };
                    layouts.push({
                        layoutType: 'Strip',
                        props: stripProps
                    });
                    break;
                }
            case 'count-strip':
                {
                    y.aggregate = 'count';
                    y.title = language.count;
                    const stripProps = {
                        sortOrder: 'descending',
                        orientation: 'vertical',
                        sort: specColumns.sort,
                        z: specColumns.z,
                        showAxes: showAxes,
                        view: view
                    };
                    layouts.push({
                        layoutType: 'Strip',
                        props: stripProps
                    });
                    break;
                }
            default:
                {
                    y.aggregate = 'count';
                    y.title = language.count;
                    const squareProps = {
                        sortBy: specColumns.sort,
                        fillDirection: 'right-up',
                        z: specColumns.z,
                        maxGroupedUnits: aggProps.globalAggregateMaxExtentSignal,
                        maxGroupedFillSize: aggProps.globalAggregateMaxExtentScaledSignal,
                        showAxes: showAxes,
                        view: view
                    };
                    layouts.push({
                        layoutType: 'Square',
                        props: squareProps
                    });
                    break;
                }
        }
    }
    return {
        axisScales: axisScales,
        layouts: layouts,
        specCapabilities: {
            countsAndSums: true,
            percentage: true,
            roles: [
                {
                    role: 'x',
                    binnable: true,
                    axisSelection: ((_a = specColumns.x) === null || _a === void 0 ? void 0 : _a.quantitative) ? 'range' : 'exact',
                    axisSelectionBetweenTicks: true,
                    signals: [
                        (0, $8d0624e259fe9d79$export$809e371dee643808).XBins
                    ]
                },
                {
                    role: 'z',
                    axisSelection: ((_b = specColumns.z) === null || _b === void 0 ? void 0 : _b.quantitative) ? 'range' : 'exact',
                    allowNone: true,
                    disabled: view === '2d'
                },
                {
                    role: 'color',
                    allowNone: true
                },
                {
                    role: 'sort',
                    allowNone: true
                },
                {
                    role: 'size',
                    allowNone: (0, $1e4d12c1d1e2ee69$export$d3be63162ba033ae),
                    excludeCategoric: true,
                    signals: [
                        (0, $8d0624e259fe9d79$export$809e371dee643808).TreeMapMethod
                    ]
                },
                {
                    role: 'facet',
                    allowNone: true,
                    signals: [
                        (0, $8d0624e259fe9d79$export$809e371dee643808).FacetBins
                    ]
                },
                {
                    role: 'facetV',
                    allowNone: true,
                    signals: [
                        (0, $8d0624e259fe9d79$export$809e371dee643808).FacetVBins
                    ]
                }
            ]
        }
    };
}


/*!
* Copyright (c) Microsoft Corporation.
* Licensed under the MIT License.
*/ 


function $6043a028cfa184bc$export$2e2bcd8739ae039(specContext) {
    var _a, _b, _c, _d, _e, _f, _g, _h, _j;
    const { insight: insight, specColumns: specColumns, specViewOptions: specViewOptions } = specContext;
    const axisScales = {
        x: {
            title: (_a = specColumns.x) === null || _a === void 0 ? void 0 : _a.name
        },
        y: {
            title: (_b = specColumns.y) === null || _b === void 0 ? void 0 : _b.name
        },
        z: {
            title: (_c = specColumns.z) === null || _c === void 0 ? void 0 : _c.name
        }
    };
    const backgroundImage = ((_d = specColumns.x) === null || _d === void 0 ? void 0 : _d.quantitative) && ((_e = specColumns.y) === null || _e === void 0 ? void 0 : _e.quantitative) && ((_f = insight.backgroundImage) === null || _f === void 0 ? void 0 : _f.extents) && insight.backgroundImage;
    const showAxes = !(backgroundImage || insight.hideAxes);
    const hBandProps = {
        excludeEncodingRuleMap: true,
        orientation: 'horizontal',
        groupby: {
            column: specColumns.y,
            defaultBins: $72552551eb533aa6$export$4a9b1843df49fbce,
            maxbinsSignalName: (0, $8d0624e259fe9d79$export$809e371dee643808).YBins,
            maxbinsSignalDisplayName: specContext.specViewOptions.language.YMaxBins,
            maxbins: $72552551eb533aa6$export$15c9d32f115776f9
        },
        minBandWidth: (0, $72552551eb533aa6$export$929dfe98c4c4722c),
        showAxes: showAxes,
        outerSignalExtents: backgroundImage && {
            max: backgroundImage.extents.top,
            min: backgroundImage.extents.bottom
        }
    };
    const vBandProps = {
        excludeEncodingRuleMap: true,
        orientation: 'vertical',
        groupby: {
            column: specColumns.x,
            defaultBins: $72552551eb533aa6$export$4a9b1843df49fbce,
            maxbinsSignalName: (0, $8d0624e259fe9d79$export$809e371dee643808).XBins,
            maxbinsSignalDisplayName: specContext.specViewOptions.language.XMaxBins,
            maxbins: $72552551eb533aa6$export$15c9d32f115776f9
        },
        minBandWidth: (0, $72552551eb533aa6$export$929dfe98c4c4722c),
        showAxes: showAxes,
        outerSignalExtents: backgroundImage && {
            max: backgroundImage.extents.right,
            min: backgroundImage.extents.left
        }
    };
    const aggProps = {
        onBuild: null,
        aggregation: null,
        sumBy: specColumns.size
    };
    const layouts = [
        {
            layoutType: 'Band',
            props: vBandProps
        },
        {
            layoutType: 'Band',
            props: hBandProps
        },
        {
            layoutType: 'AggregateSquare',
            props: aggProps
        }
    ];
    const { totalStyle: totalStyle, view: view } = insight;
    switch(totalStyle){
        case 'sum-treemap':
            {
                aggProps.aggregation = 'sum';
                const treemapProps = {
                    corner: 'bottom-left',
                    size: specColumns.size,
                    treeMapMethod: specViewOptions.language.treeMapMethod,
                    z: specColumns.z,
                    showAxes: showAxes,
                    view: view
                };
                layouts.push({
                    layoutType: 'Treemap',
                    props: treemapProps
                });
                break;
            }
        case 'sum-strip':
            {
                aggProps.aggregation = 'sum';
                const stripProps = {
                    sortOrder: 'ascending',
                    orientation: 'vertical',
                    size: specColumns.size,
                    sort: specColumns.sort,
                    z: specColumns.z,
                    showAxes: showAxes,
                    view: view
                };
                layouts.push({
                    layoutType: 'Strip',
                    props: stripProps
                });
                break;
            }
        case 'count-strip':
            {
                aggProps.aggregation = 'count';
                const stripProps = {
                    sortOrder: 'ascending',
                    orientation: 'vertical',
                    sort: specColumns.sort,
                    z: specColumns.z,
                    showAxes: showAxes,
                    view: view
                };
                layouts.push({
                    layoutType: 'Strip',
                    props: stripProps
                });
                break;
            }
        default:
            {
                aggProps.aggregation = 'count';
                const squareProps = {
                    sortBy: specColumns.sort,
                    fillDirection: 'right-down',
                    z: specColumns.z,
                    maxGroupedUnits: null,
                    maxGroupedFillSize: null,
                    showAxes: showAxes,
                    view: view
                };
                aggProps.onBuild = (aggMaxExtent, aggMaxExtentScaled)=>{
                    squareProps.maxGroupedUnits = aggMaxExtent;
                    squareProps.maxGroupedFillSize = aggMaxExtentScaled;
                };
                layouts.push({
                    layoutType: 'Square',
                    props: squareProps
                });
                break;
            }
    }
    return {
        axisScales: axisScales,
        layouts: layouts,
        specCapabilities: {
            backgroundImage: true,
            countsAndSums: true,
            roles: [
                {
                    role: 'x',
                    binnable: true,
                    axisSelection: ((_g = specColumns.x) === null || _g === void 0 ? void 0 : _g.quantitative) ? 'range' : 'exact',
                    axisSelectionBetweenTicks: true,
                    signals: [
                        (0, $8d0624e259fe9d79$export$809e371dee643808).XBins
                    ]
                },
                {
                    role: 'y',
                    binnable: true,
                    axisSelection: ((_h = specColumns.y) === null || _h === void 0 ? void 0 : _h.quantitative) ? 'range' : 'exact',
                    axisSelectionBetweenTicks: true,
                    signals: [
                        (0, $8d0624e259fe9d79$export$809e371dee643808).YBins
                    ]
                },
                {
                    role: 'z',
                    axisSelection: ((_j = specColumns.z) === null || _j === void 0 ? void 0 : _j.quantitative) ? 'range' : 'exact',
                    allowNone: true,
                    disabled: view === '2d'
                },
                {
                    role: 'color',
                    allowNone: true
                },
                {
                    role: 'sort',
                    allowNone: true
                },
                {
                    role: 'size',
                    allowNone: (0, $1e4d12c1d1e2ee69$export$d3be63162ba033ae),
                    excludeCategoric: true,
                    signals: [
                        (0, $8d0624e259fe9d79$export$809e371dee643808).TreeMapMethod
                    ]
                },
                {
                    role: 'facet',
                    allowNone: true,
                    signals: [
                        (0, $8d0624e259fe9d79$export$809e371dee643808).FacetBins
                    ]
                },
                {
                    role: 'facetV',
                    allowNone: true,
                    signals: [
                        (0, $8d0624e259fe9d79$export$809e371dee643808).FacetVBins
                    ]
                }
            ]
        }
    };
}


/*!
* Copyright (c) Microsoft Corporation.
* Licensed under the MIT License.
*/ 
function $2bb7eef721096be6$export$2e2bcd8739ae039(specContext) {
    var _a;
    const { insight: insight, specColumns: specColumns } = specContext;
    const { view: view } = insight;
    const squareProps = {
        sortBy: specColumns.sort,
        fillDirection: 'right-down',
        z: specColumns.z,
        collapseYHeight: true,
        showAxes: !insight.hideAxes,
        view: view
    };
    const axisScales = {
        z: {
            title: specColumns.z && specColumns.z.name
        }
    };
    return {
        axisScales: axisScales,
        layouts: [
            {
                layoutType: 'Square',
                props: squareProps
            }
        ],
        specCapabilities: {
            countsAndSums: false,
            roles: [
                {
                    role: 'z',
                    axisSelection: ((_a = specColumns.z) === null || _a === void 0 ? void 0 : _a.quantitative) ? 'range' : 'exact',
                    allowNone: true,
                    disabled: view === '2d'
                },
                {
                    role: 'color',
                    allowNone: true
                },
                {
                    role: 'sort',
                    allowNone: true
                },
                {
                    role: 'facet',
                    allowNone: true,
                    signals: [
                        (0, $8d0624e259fe9d79$export$809e371dee643808).FacetBins
                    ]
                },
                {
                    role: 'facetV',
                    allowNone: true,
                    signals: [
                        (0, $8d0624e259fe9d79$export$809e371dee643808).FacetVBins
                    ]
                }
            ]
        }
    };
}


/*!
* Copyright (c) Microsoft Corporation.
* Licensed under the MIT License.
*/ 
function $4cd411333c3b4045$export$2e2bcd8739ae039(specContext) {
    var _a, _b, _c, _d, _e, _f, _g, _h, _j;
    const { insight: insight, specColumns: specColumns, specViewOptions: specViewOptions } = specContext;
    const backgroundImageExtents = ((_a = specColumns.x) === null || _a === void 0 ? void 0 : _a.quantitative) && ((_b = specColumns.y) === null || _b === void 0 ? void 0 : _b.quantitative) && ((_c = insight.backgroundImage) === null || _c === void 0 ? void 0 : _c.extents);
    const scatterProps = {
        x: specColumns.x,
        y: specColumns.y,
        z: specColumns.z,
        size: specColumns.size,
        scatterPointScaleDisplay: specViewOptions.language.scatterPointScale,
        zGrounded: specViewOptions.language.zGrounded,
        backgroundImageExtents: backgroundImageExtents,
        showAxes: !(backgroundImageExtents || insight.hideAxes),
        view: insight.view
    };
    const axisScales = {
        x: {
            title: (_d = specColumns.x) === null || _d === void 0 ? void 0 : _d.name
        },
        y: {
            title: (_e = specColumns.y) === null || _e === void 0 ? void 0 : _e.name
        },
        z: {
            title: (_f = specColumns.z) === null || _f === void 0 ? void 0 : _f.name
        }
    };
    return {
        axisScales: axisScales,
        layouts: [
            {
                layoutType: 'Scatter',
                props: scatterProps
            }
        ],
        specCapabilities: {
            backgroundImage: true,
            countsAndSums: false,
            roles: [
                {
                    role: 'x',
                    axisSelection: ((_g = specColumns.x) === null || _g === void 0 ? void 0 : _g.quantitative) ? 'range' : 'exact'
                },
                {
                    role: 'y',
                    axisSelection: ((_h = specColumns.y) === null || _h === void 0 ? void 0 : _h.quantitative) ? 'range' : 'exact'
                },
                {
                    role: 'z',
                    axisSelection: ((_j = specColumns.z) === null || _j === void 0 ? void 0 : _j.quantitative) ? 'range' : 'exact',
                    allowNone: true,
                    disabled: false
                },
                {
                    role: 'color',
                    allowNone: true
                },
                {
                    role: 'size',
                    excludeCategoric: true,
                    allowNone: true
                },
                {
                    role: 'facet',
                    allowNone: true,
                    signals: [
                        (0, $8d0624e259fe9d79$export$809e371dee643808).FacetBins
                    ]
                },
                {
                    role: 'facetV',
                    allowNone: true,
                    signals: [
                        (0, $8d0624e259fe9d79$export$809e371dee643808).FacetVBins
                    ]
                }
            ],
            signals: [
                (0, $8d0624e259fe9d79$export$809e371dee643808).PointScale,
                (0, $8d0624e259fe9d79$export$809e371dee643808).ZGrounded
            ]
        }
    };
}


/*!
* Copyright (c) Microsoft Corporation.
* Licensed under the MIT License.
*/ 

function $bb2c02d9777544fd$export$2e2bcd8739ae039(specContext) {
    var _a, _b, _c, _d, _e, _f, _g;
    const { insight: insight, specColumns: specColumns, specViewOptions: specViewOptions } = specContext;
    const axisScales = {
        x: {
            title: (_a = specColumns.x) === null || _a === void 0 ? void 0 : _a.name
        },
        y: {
            title: (_b = specColumns.y) === null || _b === void 0 ? void 0 : _b.name
        },
        z: {
            title: specViewOptions.language.count
        }
    };
    const backgroundImage = ((_c = specColumns.x) === null || _c === void 0 ? void 0 : _c.quantitative) && ((_d = specColumns.y) === null || _d === void 0 ? void 0 : _d.quantitative) && ((_e = insight.backgroundImage) === null || _e === void 0 ? void 0 : _e.extents) && insight.backgroundImage;
    const showAxes = !(backgroundImage || insight.hideAxes);
    const hBandProps = {
        excludeEncodingRuleMap: true,
        orientation: 'horizontal',
        groupby: {
            column: specColumns.y,
            defaultBins: $72552551eb533aa6$export$4a9b1843df49fbce,
            maxbinsSignalName: (0, $8d0624e259fe9d79$export$809e371dee643808).YBins,
            maxbinsSignalDisplayName: specContext.specViewOptions.language.YMaxBins,
            maxbins: $72552551eb533aa6$export$15c9d32f115776f9
        },
        minBandWidth: (0, $72552551eb533aa6$export$929dfe98c4c4722c),
        showAxes: showAxes,
        outerSignalExtents: backgroundImage && {
            max: backgroundImage.extents.top,
            min: backgroundImage.extents.bottom
        }
    };
    const vBandProps = {
        excludeEncodingRuleMap: true,
        orientation: 'vertical',
        groupby: {
            column: specColumns.x,
            defaultBins: $72552551eb533aa6$export$4a9b1843df49fbce,
            maxbinsSignalName: (0, $8d0624e259fe9d79$export$809e371dee643808).XBins,
            maxbinsSignalDisplayName: specContext.specViewOptions.language.XMaxBins,
            maxbins: $72552551eb533aa6$export$15c9d32f115776f9
        },
        minBandWidth: (0, $72552551eb533aa6$export$929dfe98c4c4722c),
        showAxes: showAxes,
        outerSignalExtents: backgroundImage && {
            max: backgroundImage.extents.right,
            min: backgroundImage.extents.left
        }
    };
    const stackProps = {
        sort: specColumns.sort,
        showAxes: showAxes
    };
    return {
        axisScales: axisScales,
        customZScale: true,
        layouts: [
            {
                layoutType: 'Band',
                props: vBandProps
            },
            {
                layoutType: 'Band',
                props: hBandProps
            },
            {
                layoutType: 'Stack',
                props: stackProps
            }
        ],
        specCapabilities: {
            backgroundImage: true,
            countsAndSums: false,
            roles: [
                {
                    role: 'x',
                    binnable: true,
                    axisSelection: ((_f = specColumns.x) === null || _f === void 0 ? void 0 : _f.quantitative) ? 'range' : 'exact',
                    axisSelectionBetweenTicks: true,
                    signals: [
                        (0, $8d0624e259fe9d79$export$809e371dee643808).XBins
                    ]
                },
                {
                    role: 'y',
                    binnable: true,
                    axisSelection: ((_g = specColumns.y) === null || _g === void 0 ? void 0 : _g.quantitative) ? 'range' : 'exact',
                    axisSelectionBetweenTicks: true,
                    signals: [
                        (0, $8d0624e259fe9d79$export$809e371dee643808).YBins
                    ]
                },
                {
                    role: 'color',
                    allowNone: true
                },
                {
                    role: 'sort',
                    allowNone: true
                },
                {
                    role: 'facet',
                    allowNone: true,
                    signals: [
                        (0, $8d0624e259fe9d79$export$809e371dee643808).FacetBins
                    ]
                },
                {
                    role: 'facetV',
                    allowNone: true,
                    signals: [
                        (0, $8d0624e259fe9d79$export$809e371dee643808).FacetVBins
                    ]
                }
            ]
        }
    };
}


/*!
* Copyright (c) Microsoft Corporation.
* Licensed under the MIT License.
*/ 
function $e53dcb83981aa415$export$2e2bcd8739ae039(specContext) {
    var _a;
    const { insight: insight, specColumns: specColumns } = specContext;
    const { view: view } = insight;
    const stripProps = {
        sortOrder: 'ascending',
        orientation: 'vertical',
        size: specColumns.size,
        sort: specColumns.sort,
        z: specColumns.z,
        showAxes: !insight.hideAxes,
        view: view
    };
    const axisScales = {
        z: {
            title: specColumns.z && specColumns.z.name
        }
    };
    const layouts = [];
    if (specColumns.facet) {
        axisScales.y = {
            title: null,
            aggregate: specColumns.size ? 'sum' : 'count'
        };
        const globalAggregateMaxExtentScaledSignal = 'globalAggregateMaxExtentScaledSignal';
        const globalAggregateMaxExtentSignal = 'globalAggregateMaxExtentSignal';
        const props = {
            dock: 'top',
            niceScale: false,
            globalAggregateMaxExtentScaledSignal: globalAggregateMaxExtentScaledSignal,
            globalAggregateMaxExtentSignal: globalAggregateMaxExtentSignal,
            sumBy: specColumns.size,
            showAxes: false
        };
        layouts.push({
            layoutType: 'AggregateContainer',
            props: props
        });
    }
    layouts.push({
        layoutType: 'Strip',
        props: stripProps
    });
    return {
        axisScales: axisScales,
        layouts: layouts,
        specCapabilities: {
            countsAndSums: false,
            roles: [
                {
                    role: 'size',
                    allowNone: true,
                    excludeCategoric: true
                },
                {
                    role: 'z',
                    axisSelection: ((_a = specColumns.z) === null || _a === void 0 ? void 0 : _a.quantitative) ? 'range' : 'exact',
                    allowNone: true,
                    disabled: view === '2d'
                },
                {
                    role: 'color',
                    allowNone: true
                },
                {
                    role: 'sort',
                    allowNone: true
                },
                {
                    role: 'facet',
                    allowNone: true,
                    signals: [
                        (0, $8d0624e259fe9d79$export$809e371dee643808).FacetBins
                    ]
                },
                {
                    role: 'facetV',
                    allowNone: true,
                    signals: [
                        (0, $8d0624e259fe9d79$export$809e371dee643808).FacetVBins
                    ]
                }
            ]
        }
    };
}


/*!
* Copyright (c) Microsoft Corporation.
* Licensed under the MIT License.
*/ 
function $eae080bb50a20c63$export$2e2bcd8739ae039(specContext) {
    var _a;
    const { insight: insight, specColumns: specColumns, specViewOptions: specViewOptions } = specContext;
    const { view: view } = insight;
    const treemapProps = {
        corner: 'top-left',
        group: specColumns.group,
        size: specColumns.size,
        treeMapMethod: specViewOptions.language.treeMapMethod,
        z: specColumns.z,
        showAxes: !insight.hideAxes,
        view: view
    };
    const axisScales = {
        z: {
            title: specColumns.z && specColumns.z.name
        }
    };
    const layouts = [];
    if (specColumns.facet) {
        axisScales.y = {
            title: null,
            aggregate: 'sum'
        };
        const globalAggregateMaxExtentScaledSignal = 'globalAggregateMaxExtentScaledSignal';
        const globalAggregateMaxExtentSignal = 'globalAggregateMaxExtentSignal';
        const props = {
            dock: 'top',
            niceScale: false,
            globalAggregateMaxExtentScaledSignal: globalAggregateMaxExtentScaledSignal,
            globalAggregateMaxExtentSignal: globalAggregateMaxExtentSignal,
            sumBy: specColumns.size,
            showAxes: false
        };
        layouts.push({
            layoutType: 'AggregateContainer',
            props: props
        });
    }
    layouts.push({
        layoutType: 'Treemap',
        props: treemapProps
    });
    return {
        axisScales: axisScales,
        layouts: layouts,
        specCapabilities: {
            countsAndSums: false,
            roles: [
                {
                    role: 'size',
                    excludeCategoric: true
                },
                {
                    role: 'group',
                    allowNone: true
                },
                {
                    role: 'z',
                    axisSelection: ((_a = specColumns.z) === null || _a === void 0 ? void 0 : _a.quantitative) ? 'range' : 'exact',
                    allowNone: true,
                    disabled: view === '2d'
                },
                {
                    role: 'color',
                    allowNone: true
                },
                {
                    role: 'facet',
                    allowNone: true,
                    signals: [
                        (0, $8d0624e259fe9d79$export$809e371dee643808).FacetBins
                    ]
                },
                {
                    role: 'facetV',
                    allowNone: true,
                    signals: [
                        (0, $8d0624e259fe9d79$export$809e371dee643808).FacetVBins
                    ]
                }
            ],
            signals: [
                (0, $8d0624e259fe9d79$export$809e371dee643808).TreeMapMethod
            ]
        }
    };
}


/*!
* Copyright (c) Microsoft Corporation.
* Licensed under the MIT License.
*/ 
function $8f9ca880b84285e9$export$fb43a8c8f10fdc99(facetStyle, facetColumn, facetVColumn, axisTextColor) {
    let layoutPair;
    const groupby = facetColumn;
    const plotPadding = {
        x: 0,
        y: 0
    };
    let facetPadding;
    switch(facetStyle){
        case 'cross':
            {
                const props = {
                    axisTextColor: axisTextColor,
                    colRowTitles: true,
                    groupbyX: groupby,
                    groupbyY: facetVColumn
                };
                layoutPair = {
                    layoutType: 'Cross',
                    props: props
                };
                facetPadding = {
                    bottom: (0, $72552551eb533aa6$export$bdb7a7da14f9ff2b),
                    left: (0, $72552551eb533aa6$export$6bd206e55cb747ae),
                    top: 0
                };
                plotPadding.y = (0, $72552551eb533aa6$export$c2b9f0002271e8ba);
                plotPadding.x = (0, $72552551eb533aa6$export$c11851bee1b89f04);
                break;
            }
        case 'wrap':
        default:
            {
                const props = {
                    axisTextColor: axisTextColor,
                    cellTitles: true,
                    groupby: groupby
                };
                layoutPair = {
                    layoutType: 'Wrap',
                    props: props
                };
                facetPadding = {
                    bottom: (0, $72552551eb533aa6$export$bdb7a7da14f9ff2b),
                    left: (0, $72552551eb533aa6$export$6bd206e55cb747ae),
                    top: (0, $72552551eb533aa6$export$c2b9f0002271e8ba)
                };
                break;
            }
    }
    const facetLayout = {
        facetPadding: facetPadding,
        plotPadding: plotPadding
    };
    return {
        layoutPair: layoutPair,
        facetLayout: facetLayout
    };
}




const $8e72bac502e5efb8$var$map = {
    barchart: (0, $63c963d9a5e0cafb$export$2e2bcd8739ae039),
    barchartH: $75d42c46c533a9fa$export$2e2bcd8739ae039,
    barchartV: $63c963d9a5e0cafb$export$2e2bcd8739ae039,
    density: $6043a028cfa184bc$export$2e2bcd8739ae039,
    grid: $2bb7eef721096be6$export$2e2bcd8739ae039,
    scatterplot: $4cd411333c3b4045$export$2e2bcd8739ae039,
    stacks: $bb2c02d9777544fd$export$2e2bcd8739ae039,
    strips: $e53dcb83981aa415$export$2e2bcd8739ae039,
    treemap: $eae080bb50a20c63$export$2e2bcd8739ae039
};
function $8e72bac502e5efb8$export$104083a36c1647a7(specContext) {
    const { insight: insight, specColumns: specColumns, specViewOptions: specViewOptions } = specContext;
    const fn = $8e72bac502e5efb8$var$map[insight.chart];
    if (fn) {
        const props = fn(specContext);
        if (insight.columns.facet) {
            const discreteFacetColumn = {
                column: specColumns.facet,
                defaultBins: $72552551eb533aa6$export$4a9b1843df49fbce,
                maxbins: $72552551eb533aa6$export$15c9d32f115776f9,
                maxbinsSignalDisplayName: specViewOptions.language.FacetMaxBins,
                maxbinsSignalName: (0, $8d0624e259fe9d79$export$809e371dee643808).FacetBins
            };
            const discreteFacetVColumn = {
                column: specColumns.facetV,
                defaultBins: $72552551eb533aa6$export$4a9b1843df49fbce,
                maxbins: $72552551eb533aa6$export$15c9d32f115776f9,
                maxbinsSignalDisplayName: specViewOptions.language.FacetVMaxBins,
                maxbinsSignalName: (0, $8d0624e259fe9d79$export$809e371dee643808).FacetVBins
            };
            const { facetLayout: facetLayout, layoutPair: layoutPair } = (0, $8f9ca880b84285e9$export$fb43a8c8f10fdc99)(insight.facetStyle, discreteFacetColumn, discreteFacetVColumn, specViewOptions.colors.axisText);
            props.layouts.unshift(layoutPair);
            props.facetLayout = facetLayout;
            props.collapseFacetAxes = specViewOptions.collapseFacetAxes;
        }
        return props;
    }
}


var $2b29a67d615af3f6$exports = {};

$parcel$export($2b29a67d615af3f6$exports, "getSpecColumns", () => $2b29a67d615af3f6$export$9e6128b2231f5173);
$parcel$export($2b29a67d615af3f6$exports, "getColumnsFromData", () => $15b363a2e3ff0bb7$export$3f19ad07848df794);
$parcel$export($2b29a67d615af3f6$exports, "getStats", () => $8e54999951217c95$export$432f698644f45d1);
$parcel$export($2b29a67d615af3f6$exports, "inferAll", () => $15b363a2e3ff0bb7$export$e04a97cc71178399);
/*!
* Copyright (c) Microsoft Corporation.
* Licensed under the MIT License.
*/ /*!
* Copyright (c) Microsoft Corporation.
* Licensed under the MIT License.
*/ /*!
* Copyright (c) Microsoft Corporation.
* Licensed under the MIT License.
*/ 
var $hNlxu = parcelRequire("hNlxu");
function $4794d505cff819ff$export$e82f763eaa28f6fe(cssColorSpecifier) {
    return !!(0, $hNlxu.default)(cssColorSpecifier);
}
function $4794d505cff819ff$export$e439be417b7eac79(data, column) {
    if (!column.stats.hasColorData) {
        column.isColorData = false;
        return;
    }
    for(let i = 0; i < data.length; i++)if (!$4794d505cff819ff$export$e82f763eaa28f6fe(data[i][column.name])) {
        column.isColorData = false;
        return;
    }
    column.isColorData = true;
}


/*!
* Copyright (c) Microsoft Corporation.
* Licensed under the MIT License.
*/ 
/*!
* Copyright (c) Microsoft Corporation.
* Licensed under the MIT License.
*/ function $bdb7710f44ff8c35$export$133e1c446a214d9e(column) {
    return column.type === 'number' || column.type === 'integer';
}
function $bdb7710f44ff8c35$export$dba791c9012d0533(columnName, data) {
    for(let i = 1; i < data.length; i++){
        const value = columnName == null ? data[i] : data[i][columnName];
        if (value < 0) return true;
    }
    return false;
}
function $bdb7710f44ff8c35$export$db772497a07dd838(columnName, data) {
    if (data.length < 2) return false;
    for(let i = 1; i < data.length; i++){
        const curr = columnName == null ? data[i] : data[i][columnName];
        const prev = columnName == null ? data[i - 1] : data[i - 1][columnName];
        if (curr !== prev + 1) return false;
    }
    return true;
}


/*!
* Copyright (c) Microsoft Corporation.
* Licensed under the MIT License.
*/ 

function $8e54999951217c95$export$432f698644f45d1(data, ...args) {
    let columnName;
    let columnType;
    let columnQuantitative;
    let distinctValuesCallback;
    if (args.length <= 2) {
        const column = args[0];
        columnName = column.name;
        columnType = column.type;
        columnQuantitative = column.quantitative;
        distinctValuesCallback = args[1];
    } else {
        columnName = args[0];
        columnType = args[1];
        columnQuantitative = args[2];
        distinctValuesCallback = args[3];
    }
    const distinctMap = {};
    const stats = {
        nonNull: 0,
        distinctValueCount: null,
        max: null,
        mean: null,
        min: null
    };
    const columnIsString = columnType === 'string';
    let sum = 0;
    for(let i = 0; i < data.length; i++){
        const row = data[i];
        const value = columnName == null ? row : row[columnName];
        if (columnIsString) {
            if (value !== '') stats.nonNull++;
        } else if (value != null) stats.nonNull++;
        const num = +value;
        distinctMap[value] = true;
        if (!isNaN(num)) {
            if (stats.max === null || num > stats.max) stats.max = num;
            if (stats.min === null || num < stats.min) stats.min = num;
            sum += num;
        }
        // hex codes, ex. #003300, are parsed as dates
        if ((columnType === 'date' || columnIsString) && !stats.hasColorData && (0, $4794d505cff819ff$export$e82f763eaa28f6fe)(value)) stats.hasColorData = true;
    }
    if (columnQuantitative) {
        stats.mean = data.length > 0 && sum / data.length;
        stats.hasNegative = (0, $bdb7710f44ff8c35$export$dba791c9012d0533)(columnName, data);
        if (columnType === 'integer') stats.isSequential = (0, $bdb7710f44ff8c35$export$db772497a07dd838)(columnName, data);
    }
    const distinctValues = Object.keys(distinctMap);
    if (distinctValuesCallback) {
        distinctValues.sort();
        distinctValuesCallback(distinctValues);
    }
    stats.distinctValueCount = distinctValues.length;
    return stats;
}


function $15b363a2e3ff0bb7$export$3f19ad07848df794(inferTypesFn, data, columnTypes) {
    const sample = data[0];
    const fields = sample ? Object.keys(sample) : [];
    const inferences = Object.assign(Object.assign({}, inferTypesFn(data, fields)), columnTypes);
    const columns = fields.map((name)=>{
        const column = {
            name: name,
            type: inferences[name]
        };
        return column;
    });
    $15b363a2e3ff0bb7$export$e04a97cc71178399(columns, data);
    return columns;
}
function $15b363a2e3ff0bb7$export$e04a97cc71178399(columns, data) {
    columns.forEach((column)=>{
        if (column) {
            if (typeof column.quantitative !== 'boolean') column.quantitative = (0, $bdb7710f44ff8c35$export$133e1c446a214d9e)(column);
            if (!column.stats) column.stats = (0, $8e54999951217c95$export$432f698644f45d1)(data, column);
            // hex codes, ex. #003300, are parsed as dates
            if ((column.type === 'date' || column.type === 'string') && typeof column.isColorData !== 'boolean') (0, $4794d505cff819ff$export$e439be417b7eac79)(data, column);
        }
    });
}




/*!
* Copyright (c) Microsoft Corporation.
* Licensed under the MIT License.
*/ class $01dcf7f195fcc839$var$Table {
    constructor(columns, rows, maxWidth = 80, underlineHeaders = false, align = 'right'){
        this.columns = columns;
        this.rows = rows;
        this.maxWidth = maxWidth;
        this.underlineHeaders = underlineHeaders;
        this.align = align;
        // Calculate maximum width for each column
        this.columnWidths = this.columns.map((col, idx)=>Math.max(col.length, ...this.rows.map((row)=>{
                var _a;
                return ((_a = row[idx]) === null || _a === void 0 ? void 0 : _a.length) || 0;
            })));
    }
    createSpaces(num) {
        return ' '.repeat(num);
    }
    groupColumns() {
        let cumulativeWidth = 0;
        const columnGroups = [];
        let currentGroup = [];
        this.columns.forEach((col, idx)=>{
            const columnSpace = this.columnWidths[idx] + 1; // account for one space between columns
            if (cumulativeWidth + columnSpace > this.maxWidth && currentGroup.length > 0) {
                columnGroups.push(currentGroup);
                cumulativeWidth = columnSpace;
                currentGroup = [
                    col
                ];
            } else {
                cumulativeWidth += columnSpace;
                currentGroup.push(col);
            }
        });
        if (currentGroup.length > 0) columnGroups.push(currentGroup);
        return columnGroups;
    }
    formatRow(row, group) {
        return group.map((col)=>{
            const idx = this.columns.indexOf(col);
            const cellValue = row[idx] == null ? '' : row[idx].toString();
            return this.align === 'right' ? cellValue.padStart(this.columnWidths[idx], ' ') : cellValue.padEnd(this.columnWidths[idx], ' ');
        }).join(this.createSpaces(1));
    }
    formatHeader(group) {
        return group.map((col)=>{
            const idx = this.columns.indexOf(col);
            return this.align === 'right' ? col.padStart(this.columnWidths[idx], ' ') : col.padEnd(this.columnWidths[idx], ' ');
        }).join(this.createSpaces(1));
    }
    underlineHeader(group) {
        return group.map((col)=>'-'.repeat(this.columnWidths[this.columns.indexOf(col)])).join(this.createSpaces(1));
    }
    render() {
        const output = [];
        const columnGroups = this.groupColumns();
        columnGroups.forEach((group, groupIndex)=>{
            const headerRow = this.formatHeader(group);
            let section = headerRow + (groupIndex < columnGroups.length - 1 ? ' \\' : '') + '\n';
            if (this.underlineHeaders) section += this.underlineHeader(group) + '\n';
            this.rows.forEach((row)=>{
                section += this.formatRow(row, group) + '\n';
            });
            output.push(section);
            if (groupIndex < columnGroups.length - 1) output.push('\n');
        });
        return output.join('');
    }
}
var $01dcf7f195fcc839$export$ee3af38fff078f10;
(function(pandasSimulation) {
    // Mapping TypeScript types to Python-like dtypes
    const typeMapping = {
        boolean: 'bool',
        number: 'float64',
        date: 'datetime64[ns]',
        string: 'object',
        integer: 'int64'
    };
    function head(columns, data, maxWidth = 80) {
        const numRows = 5; // Number of rows as in `head(5)` from pandas
        const top = data.slice(0, numRows); // Get the top `numRows` rows
        // Create a "fake" row number column
        const rowNumbers = Array.from({
            length: numRows
        }, (_, i)=>(i + 1).toString());
        // Extract column names and rows for the table
        const columnNames = [
            ''
        ].concat(columns.map((col)=>col.name));
        const rows = top.map((row, i)=>[
                rowNumbers[i]
            ].concat(columns.map((col)=>{
                var _a;
                return ((_a = row[col.name]) === null || _a === void 0 ? void 0 : _a.toString()) || '';
            })));
        // Create and render the table with right alignment
        const table = new $01dcf7f195fcc839$var$Table(columnNames, rows, maxWidth, false, 'right'); // Right alignment
        return table.render();
    }
    pandasSimulation.head = head;
    function info(columns, data, maxWidth = 80) {
        const numRows = data.length;
        const output = [];
        // Summary header
        output.push('<class \'pandas.core.frame.DataFrame\'>');
        output.push(`Index: ${numRows} entries, 0 to ${numRows - 1}`);
        output.push(`Data columns (total ${columns.length} columns):\n`);
        // Column headers and details
        const columnHeaders = [
            '#',
            'Column',
            'Non-Null Count',
            'Dtype'
        ];
        const rows = columns.map((col, idx)=>{
            const nonNullCount = col.stats.nonNull.toString();
            const dtype = typeMapping[col.type] || 'unknown';
            return [
                idx.toString(),
                col.name,
                `${nonNullCount} non-null`,
                dtype
            ];
        });
        // Create and render the table with left alignment and header underline
        const table = new $01dcf7f195fcc839$var$Table(columnHeaders, rows, maxWidth, true, 'left'); // Left alignment
        output.push(table.render());
        // Memory usage estimation
        const memoryUsage = columns.reduce((total, col)=>{
            var _a;
            const exampleValue = (_a = data.find((row)=>row[col.name] != null)) === null || _a === void 0 ? void 0 : _a[col.name];
            if (exampleValue == null) return total;
            const size = new Blob([
                exampleValue.toString()
            ]).size;
            return total + size * numRows;
        }, 0);
        output.push(`\ndtypes: ${columns.filter((col)=>col.type === 'number').length} float64, ` + `${columns.filter((col)=>col.type === 'integer').length} int64, ` + `${columns.filter((col)=>col.type === 'string').length} object`);
        output.push(`memory usage: ${(memoryUsage / 1024).toFixed(1)} KB`);
        return output.join('\n');
    }
    pandasSimulation.info = info;
})($01dcf7f195fcc839$export$ee3af38fff078f10 || ($01dcf7f195fcc839$export$ee3af38fff078f10 = {}));




function $2b29a67d615af3f6$export$9e6128b2231f5173(insight, columns) {
    function getColumnByName(name) {
        return columns.filter((c)=>c.name === name)[0];
    }
    return {
        color: getColumnByName(insight.columns && insight.columns.color),
        facet: getColumnByName(insight.columns && insight.columns.facet),
        facetV: getColumnByName(insight.columns && insight.columns.facetV),
        group: getColumnByName(insight.columns && insight.columns.group),
        size: getColumnByName(insight.columns && insight.columns.size),
        sort: getColumnByName(insight.columns && insight.columns.sort),
        uid: getColumnByName(insight.columns && insight.columns.uid),
        x: getColumnByName(insight.columns && insight.columns.x),
        y: getColumnByName(insight.columns && insight.columns.y),
        z: getColumnByName(insight.columns && insight.columns.z)
    };
}


/*!
* Copyright (c) Microsoft Corporation.
* Licensed under the MIT License.
*/ /*!
* Copyright (c) Microsoft Corporation.
* Licensed under the MIT License.
*/ 

/*!
* Copyright (c) Microsoft Corporation.
* Licensed under the MIT License.
*/ function $29c6c9793f692470$export$b18909608a999daa(scope, ...axes) {
    if (!axes || !axes.length) return;
    if (!scope.axes) scope.axes = [];
    scope.axes.push(...axes.filter(Boolean));
}
function $29c6c9793f692470$export$6853292f627997e4(scope, ...datas) {
    if (!datas || !datas.length) return;
    if (!scope.data) scope.data = [];
    scope.data.push(...datas.filter(Boolean));
}
function $29c6c9793f692470$export$3df320e901c23a48(scope, ...marks) {
    if (!marks || !marks.length) return;
    if (!scope.marks) scope.marks = [];
    scope.marks.push(...marks.filter(Boolean));
}
function $29c6c9793f692470$export$290268902279a991(scope, ...scales) {
    if (!scales || !scales.length) return;
    if (!scope.scales) scope.scales = [];
    scope.scales.push(...scales.filter(Boolean));
}
function $29c6c9793f692470$export$5346a0d8a9111b3f(scope, ...signals) {
    if (!signals || !signals.length) return;
    if (!scope.signals) scope.signals = [];
    scope.signals.push(...signals.filter(Boolean));
}
function $29c6c9793f692470$export$eea5d31e98930019(data, ...transforms) {
    if (!transforms || !transforms.length) return;
    if (!data.transform) data.transform = [];
    data.transform.push(...transforms.filter(Boolean));
}
function $29c6c9793f692470$export$ef4373c7e62b2278(data, dataName) {
    for(let i = 0; i < data.length; i++){
        if (data[i].name === dataName) return {
            data: data[i],
            index: i
        };
    }
}
function $29c6c9793f692470$export$53a21aeef48e14a8(groupings) {
    const groupby = groupings.map((g)=>g.groupby);
    return groupby.reduce((acc, val)=>acc.concat(val), []);
}
function $29c6c9793f692470$export$e6b6683aec0fe907(...offsets) {
    return offsets.filter(Boolean).join(' + ');
}


function $fabd8225a03f89c4$export$3678bfcfeaea7c36(props) {
    const { axesOffsets: axesOffsets, axisScales: axisScales, axesScopes: axesScopes, axesTitlePadding: axesTitlePadding, allGlobalScales: allGlobalScales, globalScope: globalScope, labelBaseline: labelBaseline, plotOffsetSignals: plotOffsetSignals, specColumns: specColumns, specViewOptions: specViewOptions } = props;
    const { scope: scope } = globalScope;
    allGlobalScales.forEach((globalScales)=>{
        const { scales: scales } = globalScales;
        for(const xyz in scales){
            const _scales = scales[xyz];
            if (_scales) {
                (0, $29c6c9793f692470$export$290268902279a991)(scope, ..._scales);
                let { showAxes: showAxes } = globalScales;
                let zindex = undefined;
                if (xyz === 'z') {
                    showAxes = false;
                    if (props.view === '3d' && specViewOptions.zAxisOptions && !props.hideZAxis) {
                        if (specViewOptions.zAxisOptions.showZAxis) {
                            showAxes = true;
                            zindex = specViewOptions.zAxisOptions.zIndex;
                        }
                    }
                }
                if (showAxes && axisScales) {
                    const axisScale = axisScales[xyz];
                    if (axisScale) {
                        const lineColor = specViewOptions.colors.axisLine;
                        const horizontal = xyz === 'x';
                        const column = specColumns[xyz] || {
                            quantitative: true
                        };
                        const title = axisScale.title;
                        const props = {
                            title: title,
                            horizontal: horizontal,
                            column: column,
                            specViewOptions: specViewOptions,
                            lineColor: lineColor,
                            titlePadding: axesTitlePadding[xyz],
                            labelBaseline: labelBaseline[xyz],
                            zindex: zindex
                        };
                        axesScopes['main'].forEach((a)=>(0, $29c6c9793f692470$export$b18909608a999daa)(a.scope, $fabd8225a03f89c4$var$createAxis(Object.assign(Object.assign({}, props), {
                                scale: a.scale || _scales[0],
                                showTitle: a.title,
                                showLabels: a.labels,
                                showLines: a.lines
                            }))));
                        if (axesScopes[xyz]) axesScopes[xyz].forEach((a)=>(0, $29c6c9793f692470$export$b18909608a999daa)(a.scope, $fabd8225a03f89c4$var$createAxis(Object.assign(Object.assign({}, props), {
                                scale: a.scale || _scales[0],
                                showTitle: a.title,
                                showLabels: a.labels,
                                showLines: a.lines
                            }))));
                        if (plotOffsetSignals[xyz] && axesOffsets[xyz]) {
                            const plotOffsetSignal = plotOffsetSignals[xyz];
                            plotOffsetSignal.update = `${axesOffsets[xyz]}`;
                        }
                    }
                }
            }
        }
    });
}
function $fabd8225a03f89c4$var$createAxis(props) {
    const { column: column, horizontal: horizontal, labelBaseline: labelBaseline, lineColor: lineColor, scale: scale, showLabels: showLabels, showTitle: showTitle, showLines: showLines, specViewOptions: specViewOptions, title: title, titlePadding: titlePadding, zindex: zindex } = props;
    const axis = Object.assign(Object.assign(Object.assign(Object.assign({
        zindex: zindex,
        scale: scale.name,
        orient: horizontal ? 'bottom' : 'left',
        domain: showLines,
        ticks: showLines
    }, showLines && {
        domainColor: lineColor,
        tickColor: lineColor,
        tickSize: specViewOptions.tickSize
    }), showTitle && {
        title: title,
        titleAlign: horizontal ? 'left' : 'right',
        titleAngle: {
            signal: horizontal ? (0, $8d0624e259fe9d79$export$809e371dee643808).TextAngleX : (0, $8d0624e259fe9d79$export$809e371dee643808).TextAngleY
        },
        titleColor: specViewOptions.colors.axisText,
        titleFontSize: {
            signal: (0, $8d0624e259fe9d79$export$809e371dee643808).TextTitleSize
        },
        titleLimit: (0, $72552551eb533aa6$export$d3da25ad66816957),
        titlePadding: titlePadding
    }), {
        labels: showLabels
    }), showLabels && {
        labelAlign: horizontal ? 'left' : 'right',
        labelBaseline: labelBaseline,
        labelAngle: {
            signal: horizontal ? (0, $8d0624e259fe9d79$export$809e371dee643808).TextAngleX : (0, $8d0624e259fe9d79$export$809e371dee643808).TextAngleY
        },
        labelColor: specViewOptions.colors.axisText,
        labelFontSize: {
            signal: (0, $8d0624e259fe9d79$export$809e371dee643808).TextSize
        },
        labelLimit: (0, $72552551eb533aa6$export$2aa02e522549e01e)
    });
    if (column.quantitative) axis.format = '~r';
    return axis;
}


/*!
* Copyright (c) Microsoft Corporation.
* Licensed under the MIT License.
*/ 
/*!
* Copyright (c) Microsoft Corporation.
* Licensed under the MIT License.
*/ 
/*!
* Copyright (c) Microsoft Corporation.
* Licensed under the MIT License.
*/ /**
 * Make sure that the field name is accessible via Vega's Field type
 * https://vega.github.io/vega/docs/types/#Field
 * examples: "source.x", "target['x']", "[my.field]"
 */ function $03b4e9c3be7efafd$export$fb70365b00e8cb7b(field) {
    return field.replace(/\\/g, '\\\\') //escape backslashes
    .replace(/'/g, '\\\'') //escape single quotes
    .replace(/"/g, '\\"') //escape double quotes
    .replace(/\./g, '\\.') //escape periods
    .replace(/\[/g, '\\[') //escape left square brackets
    .replace(/\]/g, '\\]') //escape right square brackets
    ;
}
function $03b4e9c3be7efafd$export$74df930fa4adaae4(field) {
    //remove whitespace, period, accessors and logical modifiers
    return field.replace(/[.,:;+=\-/<>{}|~!@#$%^*[\]`'"()?\s\\]/g, '');
}


function $7fac7254f262c640$export$fefe9507ec0904ed(scaleName, domain, range, reverse, zero, nice = true) {
    const scale = {
        name: scaleName,
        type: 'linear',
        range: range,
        round: true,
        reverse: reverse,
        domain: domain,
        zero: zero,
        nice: nice
    };
    return scale;
}
function $7fac7254f262c640$export$b67158f831e00d0d(scaleName, data, range, field, reverse) {
    const scale = {
        name: scaleName,
        type: 'point',
        range: range,
        domain: {
            data: data,
            field: (0, $03b4e9c3be7efafd$export$fb70365b00e8cb7b)(field),
            sort: true
        },
        padding: 0.5
    };
    if (reverse !== undefined) scale.reverse = reverse;
    return scale;
}
function $7fac7254f262c640$export$530110e7506d659d(scaleName, colorBin, data, field, scheme) {
    scheme = scheme || (0, $8d0624e259fe9d79$export$c991c3dd58d9959c);
    const domain = {
        data: data,
        field: (0, $03b4e9c3be7efafd$export$fb70365b00e8cb7b)(field)
    };
    const range = {
        scheme: scheme
    };
    const reverse = {
        signal: (0, $8d0624e259fe9d79$export$809e371dee643808).ColorReverse
    };
    if (colorBin !== 'continuous') range.count = {
        signal: (0, $8d0624e259fe9d79$export$809e371dee643808).ColorBinCount
    };
    switch(colorBin){
        case 'continuous':
            {
                const sequentialScale = {
                    name: scaleName,
                    type: 'linear',
                    domain: domain,
                    range: range,
                    reverse: reverse
                };
                return sequentialScale;
            }
        case 'quantile':
            {
                const quantileScale = {
                    name: scaleName,
                    type: 'quantile',
                    domain: domain,
                    range: range,
                    reverse: reverse
                };
                return quantileScale;
            }
        default:
            {
                const quantizeScale = {
                    name: scaleName,
                    type: 'quantize',
                    domain: domain,
                    range: range,
                    reverse: reverse
                };
                return quantizeScale;
            }
    }
}


/*!
* Copyright (c) Microsoft Corporation.
* Licensed under the MIT License.
*/ 

const $8243f48596a5f195$export$7bc9b23ce3036e78 = 0.6;
function $8243f48596a5f195$export$d9407ec206a3236c(context, heightSignal) {
    const { specViewOptions: specViewOptions } = context;
    const signals = [
        {
            name: (0, $8d0624e259fe9d79$export$809e371dee643808).ZProportion,
            value: $8243f48596a5f195$export$7bc9b23ce3036e78,
            bind: {
                name: specViewOptions.language.zScaleProportion,
                debounce: $72552551eb533aa6$export$61fc7d43ac8f84b0,
                input: 'range',
                min: 0.1,
                max: 2,
                step: 0.1
            }
        },
        {
            name: (0, $8d0624e259fe9d79$export$809e371dee643808).ZHeight,
            update: `${heightSignal} * ${(0, $8d0624e259fe9d79$export$809e371dee643808).ZProportion}`
        },
        {
            name: (0, $8d0624e259fe9d79$export$809e371dee643808).TextScale,
            value: 1.2,
            bind: {
                name: specViewOptions.language.textScaleSignal,
                debounce: $72552551eb533aa6$export$61fc7d43ac8f84b0,
                input: 'range',
                min: 0.5,
                max: 2,
                step: 0.1
            }
        },
        {
            name: (0, $8d0624e259fe9d79$export$809e371dee643808).TextSize,
            update: `${(0, $8d0624e259fe9d79$export$809e371dee643808).TextScale} * 10`
        },
        {
            name: (0, $8d0624e259fe9d79$export$809e371dee643808).TextTitleSize,
            update: `${(0, $8d0624e259fe9d79$export$809e371dee643808).TextScale} * 15`
        },
        {
            name: (0, $8d0624e259fe9d79$export$809e371dee643808).TextAngleX,
            value: 30,
            bind: {
                name: specViewOptions.language.xAxisTextAngleSignal,
                debounce: $72552551eb533aa6$export$61fc7d43ac8f84b0,
                input: 'range',
                min: 0,
                max: 90,
                step: 1
            }
        },
        {
            name: (0, $8d0624e259fe9d79$export$809e371dee643808).TextAngleY,
            value: 0,
            bind: {
                name: specViewOptions.language.yAxisTextAngleSignal,
                debounce: $72552551eb533aa6$export$61fc7d43ac8f84b0,
                input: 'range',
                min: -90,
                max: 0,
                step: 1
            }
        },
        {
            name: (0, $8d0624e259fe9d79$export$809e371dee643808).MarkOpacity,
            value: 1,
            bind: {
                name: specViewOptions.language.markOpacitySignal,
                debounce: $72552551eb533aa6$export$61fc7d43ac8f84b0,
                input: 'range',
                min: 0.1,
                max: 1,
                step: 0.05
            }
        }
    ];
    return signals;
}
function $8243f48596a5f195$export$641fa4f0ca86c2ad(context) {
    const { specViewOptions: specViewOptions } = context;
    const signal = {
        name: (0, $8d0624e259fe9d79$export$809e371dee643808).ColorBinCount,
        value: 7,
        bind: {
            name: specViewOptions.language.colorBinCount,
            debounce: $72552551eb533aa6$export$61fc7d43ac8f84b0,
            input: 'range',
            min: 1,
            max: specViewOptions.maxLegends + 1,
            step: 1
        }
    };
    return signal;
}
function $8243f48596a5f195$export$526461dda4c87775(context) {
    const { specViewOptions: specViewOptions } = context;
    const signal = {
        name: (0, $8d0624e259fe9d79$export$809e371dee643808).ColorReverse,
        value: false,
        bind: {
            name: specViewOptions.language.colorReverse,
            input: 'checkbox'
        }
    };
    return signal;
}
function $8243f48596a5f195$export$cdc9366ba30317bd(s, fn, update) {
    s.update = `${fn}((${s.update}), (${update}))`;
}



/*!
* Copyright (c) Microsoft Corporation.
* Licensed under the MIT License.
*/ function $a522ba8db6676a17$var$legend(column, fill) {
    const legend = {
        orient: 'none',
        title: column.name,
        fill: fill,
        encode: {
            symbols: {
                update: {
                    shape: {
                        value: 'square'
                    }
                }
            }
        }
    };
    if (column.quantitative) {
        legend.type = 'symbol';
        legend.format = '~r';
    }
    return legend;
}
function $a522ba8db6676a17$export$765837a81fadca85(context, fill) {
    const { specColumns: specColumns, insight: insight } = context;
    if (specColumns.color && !insight.hideLegend && !insight.directColor && !specColumns.color.isColorData) return [
        $a522ba8db6676a17$var$legend(specColumns.color, fill)
    ];
}


/*!
* Copyright (c) Microsoft Corporation.
* Licensed under the MIT License.
*/ 

function $38d298d07938d131$export$a4725aa19e8564dd(column, count, source, legend, lookupName, fieldName, indexName) {
    const data = [
        {
            name: lookupName,
            source: source,
            transform: [
                {
                    type: 'aggregate',
                    groupby: [
                        (0, $03b4e9c3be7efafd$export$fb70365b00e8cb7b)(column.name)
                    ]
                },
                {
                    type: 'window',
                    ops: [
                        'count'
                    ],
                    as: [
                        indexName
                    ]
                },
                {
                    type: 'filter',
                    expr: `datum[${JSON.stringify(indexName)}] <= ${count}`
                }
            ]
        },
        {
            name: legend,
            source: source,
            transform: [
                {
                    type: 'lookup',
                    from: lookupName,
                    key: (0, $03b4e9c3be7efafd$export$fb70365b00e8cb7b)(column.name),
                    fields: [
                        column.name
                    ].map((0, $03b4e9c3be7efafd$export$fb70365b00e8cb7b)),
                    values: [
                        column.name
                    ].map((0, $03b4e9c3be7efafd$export$fb70365b00e8cb7b)),
                    as: [
                        fieldName
                    ]
                },
                {
                    type: 'formula',
                    expr: `datum[${JSON.stringify(fieldName)}] == null ? '${(0, $8d0624e259fe9d79$export$8653a30c44b6e879)}' : datum[${JSON.stringify(fieldName)}]`,
                    as: fieldName
                }
            ]
        }
    ];
    return data;
}


function $925be6cd5bedf086$export$4c4d9288a45f1fb3(props) {
    const { colorReverseSignalName: colorReverseSignalName, dataName: dataName, scope: scope, legendDataName: legendDataName, scaleName: scaleName, specContext: specContext, topLookupName: topLookupName } = props;
    let colorDataName = dataName;
    const { insight: insight, specColumns: specColumns, specViewOptions: specViewOptions } = specContext;
    const legends = (0, $a522ba8db6676a17$export$765837a81fadca85)(specContext, scaleName);
    if (legends) scope.legends = legends;
    const categoricalColor = specColumns.color && !specColumns.color.quantitative;
    if (categoricalColor) {
        (0, $29c6c9793f692470$export$6853292f627997e4)(scope, ...(0, $38d298d07938d131$export$a4725aa19e8564dd)(specColumns.color, specViewOptions.maxLegends, dataName, legendDataName, topLookupName, (0, $8d0624e259fe9d79$export$10df5429b7082be2).TopColor, (0, $8d0624e259fe9d79$export$10df5429b7082be2).TopIndex));
        colorDataName = legendDataName;
    }
    if (specColumns.color && !specColumns.color.isColorData && !insight.directColor) {
        if (specColumns.color.quantitative) (0, $29c6c9793f692470$export$290268902279a991)(scope, (0, $7fac7254f262c640$export$530110e7506d659d)(scaleName, insight.colorBin, dataName, specColumns.color.name, insight.scheme));
        else (0, $29c6c9793f692470$export$290268902279a991)(scope, {
            name: scaleName,
            type: 'ordinal',
            domain: {
                data: colorDataName,
                field: (0, $8d0624e259fe9d79$export$10df5429b7082be2).TopColor,
                sort: true
            },
            range: {
                scheme: insight.scheme || (0, $8d0624e259fe9d79$export$c991c3dd58d9959c)
            },
            reverse: {
                signal: colorReverseSignalName
            }
        });
    }
    (0, $29c6c9793f692470$export$5346a0d8a9111b3f)(scope, (0, $8243f48596a5f195$export$641fa4f0ca86c2ad)(specContext), (0, $8243f48596a5f195$export$526461dda4c87775)(specContext));
    return {
        topColorField: (0, $8d0624e259fe9d79$export$10df5429b7082be2).TopColor,
        colorDataName: colorDataName
    };
}




/*!
* Copyright (c) Microsoft Corporation.
* Licensed under the MIT License.
*/ 

function $e298df2c870b2b1c$export$4fec84497b9e6e3f(globalScope, colTitleSource, rowTitleSource, sizeSignals, axisTextColor) {
    const titleSignal = `parent[${JSON.stringify((0, $8d0624e259fe9d79$export$10df5429b7082be2).FacetTitle)}]`;
    const index = `datum[${JSON.stringify((0, $8d0624e259fe9d79$export$10df5429b7082be2).Ordinal)}] - 1`;
    const col = $e298df2c870b2b1c$export$4f57a5f5fbf1456e(colTitleSource.dataName, sizeSignals, index);
    const row = $e298df2c870b2b1c$export$d0cc3dc227001793(rowTitleSource.dataName, sizeSignals, index);
    (0, $29c6c9793f692470$export$3df320e901c23a48)(globalScope, col.header, row.footer);
    (0, $29c6c9793f692470$export$3df320e901c23a48)(col.header, {
        type: 'text',
        encode: {
            enter: {
                align: {
                    value: 'center'
                },
                baseline: {
                    value: 'middle'
                },
                fill: {
                    value: axisTextColor
                }
            },
            update: {
                metaData: {
                    signal: `{search: parent[${JSON.stringify((0, $8d0624e259fe9d79$export$10df5429b7082be2).FacetSearch)}]}`
                },
                x: {
                    signal: `${sizeSignals.layoutWidth} / 2`
                },
                limit: {
                    signal: sizeSignals.layoutWidth
                },
                fontSize: {
                    signal: (0, $8d0624e259fe9d79$export$809e371dee643808).TextSize
                },
                text: {
                    signal: titleSignal
                }
            }
        }
    });
    (0, $29c6c9793f692470$export$3df320e901c23a48)(row.footer, {
        type: 'text',
        encode: {
            enter: {
                align: {
                    value: 'left'
                },
                baseline: {
                    value: 'middle'
                },
                fill: {
                    value: axisTextColor
                }
            },
            update: {
                metaData: {
                    signal: `{search: parent[${JSON.stringify((0, $8d0624e259fe9d79$export$10df5429b7082be2).FacetSearch)}]}`
                },
                y: {
                    signal: `${sizeSignals.layoutHeight} / 2`
                },
                limit: {
                    signal: (0, $8d0624e259fe9d79$export$809e371dee643808).PlotOffsetRight
                },
                fontSize: {
                    signal: (0, $8d0624e259fe9d79$export$809e371dee643808).TextSize
                },
                text: {
                    signal: titleSignal
                }
            }
        }
    });
}
function $e298df2c870b2b1c$export$3735b1dd76112836(scope, sizeSignals, axisTextColor) {
    (0, $29c6c9793f692470$export$3df320e901c23a48)(scope, {
        type: 'text',
        encode: {
            enter: {
                align: {
                    value: 'center'
                },
                baseline: {
                    value: 'bottom'
                },
                fill: {
                    value: axisTextColor
                }
            },
            update: {
                metaData: {
                    signal: `{search: parent[${JSON.stringify((0, $8d0624e259fe9d79$export$10df5429b7082be2).FacetSearch)}]}`
                },
                x: {
                    signal: `(${sizeSignals.layoutWidth}) / 2`
                },
                text: {
                    signal: `parent[${JSON.stringify((0, $8d0624e259fe9d79$export$10df5429b7082be2).FacetTitle)}]`
                },
                fontSize: {
                    signal: (0, $8d0624e259fe9d79$export$809e371dee643808).TextSize
                },
                limit: {
                    signal: sizeSignals.layoutWidth
                },
                y: {
                    signal: `-${(0, $8d0624e259fe9d79$export$809e371dee643808).FacetPaddingTop} / 2`
                }
            }
        }
    });
}
function $e298df2c870b2b1c$export$9f0b19d6fd936707(props) {
    const { colSeqName: colSeqName, colTitleScale: colTitleScale, globalScope: globalScope, facetScope: facetScope, plotScope: plotScope, rowSeqName: rowSeqName, rowTitleScale: rowTitleScale } = props;
    const { sizeSignals: sizeSignals } = facetScope;
    const colSequence = $e298df2c870b2b1c$var$createSequence(colSeqName, sizeSignals.colCount);
    const rowSequence = $e298df2c870b2b1c$var$createSequence(rowSeqName, sizeSignals.rowCount);
    const index = 'datum.data';
    const col = $e298df2c870b2b1c$export$4f57a5f5fbf1456e(colSeqName, sizeSignals, index);
    const row = $e298df2c870b2b1c$export$d0cc3dc227001793(rowSeqName, sizeSignals, index);
    (0, $29c6c9793f692470$export$6853292f627997e4)(globalScope, colSequence, rowSequence);
    (0, $29c6c9793f692470$export$3df320e901c23a48)(globalScope, col.footer, row.header);
    (0, $29c6c9793f692470$export$290268902279a991)(globalScope, colTitleScale, rowTitleScale);
    const map = {
        main: [
            {
                scope: facetScope.facetScope,
                lines: true,
                labels: false,
                title: false
            }
        ],
        x: [
            {
                scope: col.footer,
                lines: true,
                labels: true,
                title: false
            },
            {
                scope: plotScope,
                scale: colTitleScale,
                lines: false,
                labels: false,
                title: true
            }
        ],
        y: [
            {
                scope: row.header,
                lines: true,
                labels: true,
                title: false
            },
            {
                scope: plotScope,
                scale: rowTitleScale,
                lines: false,
                labels: false,
                title: true
            }
        ]
    };
    return map;
}
function $e298df2c870b2b1c$export$d0cc3dc227001793(data, sizeSignals, index) {
    const rowFn = (xSignal)=>{
        return {
            type: 'group',
            from: {
                data: data
            },
            encode: {
                update: {
                    x: {
                        signal: xSignal
                    },
                    y: {
                        signal: `${(0, $8d0624e259fe9d79$export$809e371dee643808).PlotOffsetTop} + ${(0, $8d0624e259fe9d79$export$809e371dee643808).FacetPaddingTop} + (${index}) * (${sizeSignals.layoutHeight} + ${(0, $8d0624e259fe9d79$export$809e371dee643808).FacetPaddingTop} + ${(0, $8d0624e259fe9d79$export$809e371dee643808).FacetPaddingBottom})`
                    },
                    height: {
                        signal: sizeSignals.layoutHeight
                    }
                }
            }
        };
    };
    const header = rowFn((0, $8d0624e259fe9d79$export$809e371dee643808).PlotOffsetLeft);
    const footer = rowFn(`${(0, $8d0624e259fe9d79$export$809e371dee643808).PlotOffsetLeft} + ${(0, $8d0624e259fe9d79$export$809e371dee643808).PlotWidthOut} + ${(0, $8d0624e259fe9d79$export$809e371dee643808).PlotOffsetRight} / 2`);
    return {
        header: header,
        footer: footer
    };
}
function $e298df2c870b2b1c$export$4f57a5f5fbf1456e(data, sizeSignals, index) {
    const colFn = (ySignal)=>{
        return {
            type: 'group',
            from: {
                data: data
            },
            encode: {
                update: {
                    x: {
                        signal: `(${index}) * (${sizeSignals.layoutWidth} + ${(0, $8d0624e259fe9d79$export$809e371dee643808).FacetPaddingLeft}) + ${(0, $8d0624e259fe9d79$export$809e371dee643808).FacetPaddingLeft} + ${(0, $8d0624e259fe9d79$export$809e371dee643808).PlotOffsetLeft} - ${(0, $8d0624e259fe9d79$export$809e371dee643808).FacetAxesAdjustX}`
                    },
                    y: {
                        signal: `${ySignal} - ${(0, $8d0624e259fe9d79$export$809e371dee643808).FacetAxesAdjustY}`
                    },
                    width: {
                        signal: sizeSignals.layoutWidth
                    }
                }
            }
        };
    };
    //create group marks based on data sequences
    const header = colFn(`${(0, $8d0624e259fe9d79$export$809e371dee643808).PlotOffsetTop} / 2`);
    const footer = colFn(`${(0, $8d0624e259fe9d79$export$809e371dee643808).PlotOffsetTop} + ${(0, $8d0624e259fe9d79$export$809e371dee643808).PlotHeightOut}`);
    return {
        header: header,
        footer: footer
    };
}
function $e298df2c870b2b1c$var$createSequence(dataName, countSignal) {
    return {
        name: dataName,
        transform: [
            {
                type: 'sequence',
                start: 0,
                stop: {
                    signal: countSignal
                }
            }
        ]
    };
}


/*!
* Copyright (c) Microsoft Corporation.
* Licensed under the MIT License.
*/ 

function $895ef9e095ded5c9$export$9563e054e6f787fb(context, colorFieldName, scale) {
    const { specColumns: specColumns, insight: insight, specViewOptions: specViewOptions } = context;
    const colorColumn = specColumns.color;
    return colorColumn ? colorColumn.isColorData || insight.directColor ? {
        field: (0, $03b4e9c3be7efafd$export$fb70365b00e8cb7b)(colorColumn.name)
    } : {
        scale: scale,
        field: colorColumn.quantitative ? (0, $03b4e9c3be7efafd$export$fb70365b00e8cb7b)(colorColumn.name) : colorFieldName
    } : {
        value: specViewOptions.colors.defaultCube
    };
}
function $895ef9e095ded5c9$export$c17a3be1057836e(context) {
    const result = {
        signal: (0, $8d0624e259fe9d79$export$809e371dee643808).MarkOpacity
    };
    return result;
}


/*!
* Copyright (c) Microsoft Corporation.
* Licensed under the MIT License.
*/ 

class $cc404f7847ffd5bf$export$5fdf684e73bb2de5 {
    constructor(props){
        const { dataName: dataName, markGroup: markGroup, scope: scope, signals: signals } = props;
        this.scope = scope;
        this._markGroup = markGroup;
        this.signals = signals;
        this.data = (0, $29c6c9793f692470$export$ef4373c7e62b2278)(scope.data, dataName).data;
        this._markDataName = dataName;
        this.offsets = {
            x: '0',
            y: '0',
            h: (0, $8d0624e259fe9d79$export$809e371dee643808).PlotHeightIn,
            w: (0, $8d0624e259fe9d79$export$809e371dee643808).PlotWidthIn
        };
        this.sizeSignals = {
            layoutHeight: (0, $8d0624e259fe9d79$export$809e371dee643808).PlotHeightIn,
            layoutWidth: (0, $8d0624e259fe9d79$export$809e371dee643808).PlotWidthIn
        };
        this.zSize = (0, $8d0624e259fe9d79$export$809e371dee643808).PlotHeightIn;
    }
    get markDataName() {
        return this._markDataName;
    }
    setMarkDataName(markDataName) {
        this._markDataName = markDataName;
    }
    get markGroup() {
        return this._markGroup;
    }
    setMarkGroup(markGroup) {
        this._markGroup = markGroup;
    }
}




/*!
* Copyright (c) Microsoft Corporation.
* Licensed under the MIT License.
*/ /*!
* Copyright (c) Microsoft Corporation.
* Licensed under the MIT License.
*/ /*!
* Copyright (c) Microsoft Corporation.
* Licensed under the MIT License.
*/ class $748726ce52deaf5d$export$c84671f46d6a1ca {
    constructor(props){
        this.props = props;
        this.id = props.id;
    }
    getGrouping() {
        return null;
    }
    getAggregateSumOp() {
        return null;
    }
    build() {
        throw 'Not implemented';
    }
}





/*!
* Copyright (c) Microsoft Corporation.
* Licensed under the MIT License.
*/ 
function $0299c0d9f55fe75f$export$71c45f78b1166d35() {
    return `datum.${(0, $8d0624e259fe9d79$export$10df5429b7082be2).Collapsed}`;
}


class $eff5a80a5e96c249$export$fd744dfcd98e5f49 extends (0, $748726ce52deaf5d$export$c84671f46d6a1ca) {
    constructor(props){
        super(props);
        this.props = props;
        const a = this.aggregation = this.getAggregation();
        const p = this.prefix = `agg_${this.id}`;
        this.names = {
            barCount: `${p}_count`,
            aggregateField: `${p}_aggregate_value`,
            globalAggregateExtentSignal: `${p}_${a}_extent`,
            scale: `scale_${p}`,
            extentData: `data_${p}_extent`,
            offsets: `data_${p}_offsets`
        };
    }
    getAggregateSumOp() {
        if (this.aggregation === 'sum') {
            const fieldOp = {
                field: (0, $03b4e9c3be7efafd$export$fb70365b00e8cb7b)(this.props.sumBy.name),
                op: 'sum',
                as: (0, $8d0624e259fe9d79$export$10df5429b7082be2).Sum
            };
            return fieldOp;
        }
    }
    build() {
        const { aggregation: aggregation, names: names, props: props } = this;
        const { dock: dock, globalScope: globalScope, groupings: groupings, niceScale: niceScale, parentScope: parentScope, showAxes: showAxes } = props;
        (0, $29c6c9793f692470$export$eea5d31e98930019)(globalScope.data, Object.assign(Object.assign({}, this.getTransforms(aggregation, (0, $29c6c9793f692470$export$53a21aeef48e14a8)(groupings))), {
            as: [
                names.aggregateField
            ]
        }), {
            type: 'extent',
            field: (0, $03b4e9c3be7efafd$export$fb70365b00e8cb7b)(names.aggregateField),
            signal: names.globalAggregateExtentSignal
        });
        (0, $29c6c9793f692470$export$5346a0d8a9111b3f)(globalScope.scope, {
            name: props.globalAggregateMaxExtentSignal,
            update: `${names.globalAggregateExtentSignal}[1]`
        });
        const horizontal = dock === 'left';
        const groupScaled = `scale(${JSON.stringify(names.scale)}, datum[${JSON.stringify(names.aggregateField)}])`;
        const offsets = {
            x: parentScope.offsets.x,
            y: (0, $29c6c9793f692470$export$e6b6683aec0fe907)(parentScope.offsets.y, dock === 'bottom' ? groupScaled : ''),
            h: horizontal ? parentScope.offsets.h : dock === 'top' ? groupScaled : `${parentScope.offsets.h} - ${groupScaled}`,
            w: horizontal ? groupScaled : parentScope.offsets.w
        };
        const scale = {
            type: 'linear',
            name: names.scale,
            domain: [
                0,
                {
                    signal: props.globalAggregateMaxExtentSignal
                }
            ],
            range: horizontal ? [
                0,
                {
                    signal: parentScope.sizeSignals.layoutWidth
                }
            ] : [
                {
                    signal: parentScope.sizeSignals.layoutHeight
                },
                0
            ],
            nice: niceScale,
            zero: true,
            reverse: dock === 'top'
        };
        const globalAggregateMaxExtentScaledValue = `scale(${JSON.stringify(names.scale)}, ${props.globalAggregateMaxExtentSignal})`;
        (0, $29c6c9793f692470$export$5346a0d8a9111b3f)(globalScope.scope, {
            name: props.globalAggregateMaxExtentScaledSignal,
            update: dock === 'bottom' ? `${parentScope.sizeSignals.layoutHeight} - ${globalAggregateMaxExtentScaledValue}` : globalAggregateMaxExtentScaledValue
        });
        return {
            offsets: offsets,
            sizeSignals: horizontal ? {
                layoutHeight: parentScope.sizeSignals.layoutHeight,
                layoutWidth: null
            } : {
                layoutHeight: null,
                layoutWidth: parentScope.sizeSignals.layoutWidth
            },
            globalScales: {
                showAxes: showAxes,
                scales: {
                    x: horizontal ? [
                        scale
                    ] : undefined,
                    y: horizontal ? undefined : [
                        scale
                    ]
                }
            },
            encodingRuleMap: horizontal ? {
                x: [
                    {
                        test: (0, $0299c0d9f55fe75f$export$71c45f78b1166d35)(),
                        signal: parentScope.offsets.x
                    }
                ],
                width: [
                    {
                        test: (0, $0299c0d9f55fe75f$export$71c45f78b1166d35)(),
                        value: 0
                    }
                ]
            } : {
                y: [
                    {
                        test: (0, $0299c0d9f55fe75f$export$71c45f78b1166d35)(),
                        signal: dock === 'top' ? parentScope.offsets.y : (0, $29c6c9793f692470$export$e6b6683aec0fe907)(parentScope.offsets.y, parentScope.offsets.h)
                    }
                ],
                height: [
                    {
                        test: (0, $0299c0d9f55fe75f$export$71c45f78b1166d35)(),
                        value: 0
                    }
                ]
            }
        };
    }
    getTransforms(aggregation, groupby) {
        const trans = {
            type: 'joinaggregate',
            groupby: groupby.map((0, $03b4e9c3be7efafd$export$fb70365b00e8cb7b)),
            ops: [
                aggregation
            ]
        };
        if (aggregation === 'sum') trans.fields = [
            this.props.sumBy.name
        ].map((0, $03b4e9c3be7efafd$export$fb70365b00e8cb7b));
        return trans;
    }
    getAggregation() {
        const { props: props } = this;
        let s;
        if (props.dock === 'left') s = props.axesScales.x;
        else s = props.axesScales.y;
        switch(s.aggregate){
            case 'sum':
                return 'sum';
            default:
                return 'count';
        }
    }
}


/*!
* Copyright (c) Microsoft Corporation.
* Licensed under the MIT License.
*/ 



class $efc98e91e3f0ced6$export$7eda37970b01b2c extends (0, $748726ce52deaf5d$export$c84671f46d6a1ca) {
    constructor(props){
        super(props);
        this.props = props;
        const a = this.props.aggregation;
        const p = this.prefix = `agg_${this.id}`;
        this.names = {
            barCount: `${p}_count`,
            aggregateField: `${p}_aggregate_value`,
            globalAggregateExtentSignal: `${p}_${a}_extent`,
            extentData: `data_${p}_extent`
        };
    }
    build() {
        const { names: names, props: props } = this;
        const { aggregation: aggregation, globalScope: globalScope, groupings: groupings, onBuild: onBuild, parentScope: parentScope } = props;
        const { sizeSignals: sizeSignals } = parentScope;
        (0, $29c6c9793f692470$export$eea5d31e98930019)(globalScope.data, Object.assign(Object.assign({}, this.getTransforms(aggregation, (0, $29c6c9793f692470$export$53a21aeef48e14a8)(groupings))), {
            as: [
                names.aggregateField
            ]
        }), {
            type: 'extent',
            field: (0, $03b4e9c3be7efafd$export$fb70365b00e8cb7b)(names.aggregateField),
            signal: names.globalAggregateExtentSignal
        });
        const localAggregateMaxExtent = `datum[${JSON.stringify(names.aggregateField)}]`;
        const squareMaxSide = `min((${sizeSignals.layoutHeight}), (${sizeSignals.layoutWidth}))`;
        const squareMaxArea = `(${[
            squareMaxSide,
            squareMaxSide
        ].join(' * ')})`;
        const shrinkRatio = `((${localAggregateMaxExtent}) / (${names.globalAggregateExtentSignal}[1]))`;
        const squareArea = `(${[
            squareMaxArea,
            shrinkRatio
        ].join(' * ')})`;
        const squareSide = `sqrt(${squareArea})`;
        const localAggregateMaxExtentScaled = squareSide;
        onBuild && onBuild(localAggregateMaxExtent, localAggregateMaxExtentScaled);
        const offsets = {
            x: (0, $29c6c9793f692470$export$e6b6683aec0fe907)(parentScope.offsets.x, `(${parentScope.offsets.w} - ${squareSide}) / 2`),
            y: (0, $29c6c9793f692470$export$e6b6683aec0fe907)(parentScope.offsets.y, `(${parentScope.offsets.h} - ${squareSide}) / 2`),
            h: squareSide,
            w: squareSide
        };
        return {
            offsets: offsets,
            sizeSignals: {
                layoutHeight: null,
                layoutWidth: null
            },
            encodingRuleMap: {
                y: [
                    {
                        test: (0, $0299c0d9f55fe75f$export$71c45f78b1166d35)(),
                        signal: offsets.y
                    }
                ],
                height: [
                    {
                        test: (0, $0299c0d9f55fe75f$export$71c45f78b1166d35)(),
                        value: 0
                    }
                ]
            }
        };
    }
    getTransforms(aggregation, groupby) {
        const trans = {
            type: 'joinaggregate',
            groupby: groupby.map((0, $03b4e9c3be7efafd$export$fb70365b00e8cb7b)),
            ops: [
                aggregation
            ]
        };
        if (aggregation === 'sum') trans.fields = [
            this.props.sumBy.name
        ].map((0, $03b4e9c3be7efafd$export$fb70365b00e8cb7b));
        return trans;
    }
}


/*!
* Copyright (c) Microsoft Corporation.
* Licensed under the MIT License.
*/ 
/*!
* Copyright (c) Microsoft Corporation.
* Licensed under the MIT License.
*/ 


/*!
* Copyright (c) Microsoft Corporation.
* Licensed under the MIT License.
*/ 
function $df1b04e32170cfe5$export$e1e8339c59091971(column, signal) {
    return {
        type: 'extent',
        field: (0, $03b4e9c3be7efafd$export$fb70365b00e8cb7b)(column.name),
        signal: signal
    };
}


function $d832bf01a4278a5e$export$6868fd1605c79d3d(prefix, domainDataName, discreteColumn, outerSignalExtents) {
    const { column: column, defaultBins: defaultBins, maxbins: maxbins, maxbinsSignalDisplayName: maxbinsSignalDisplayName, maxbinsSignalName: maxbinsSignalName } = discreteColumn;
    if (column.quantitative) {
        const field = `${prefix}_bin_${(0, $03b4e9c3be7efafd$export$74df930fa4adaae4)(column.name)}`;
        const fieldEnd = `${field}_end`;
        const binSignal = `${field}_bins`;
        const dataExtentSignal = `${field}_bin_extent`;
        const dataExtentSpanSignal = `${field}_bin_extent_span`;
        const outerSignal = `${field}_outer_extent`;
        domainDataName = `${field}_sequence`; //override the data name
        const extentTransform = (0, $df1b04e32170cfe5$export$e1e8339c59091971)(column, dataExtentSignal);
        let imageSignal;
        if (outerSignalExtents) imageSignal = $d832bf01a4278a5e$export$3794e0ea8ab2e895(outerSignal, outerSignalExtents.min, outerSignalExtents.max, dataExtentSignal);
        const maxbinsSignal = {
            name: maxbinsSignalName,
            value: defaultBins,
            bind: {
                name: maxbinsSignalDisplayName,
                debounce: $72552551eb533aa6$export$61fc7d43ac8f84b0,
                input: 'range',
                min: 1,
                max: maxbins,
                step: 1
            }
        };
        const extentSignal = (imageSignal === null || imageSignal === void 0 ? void 0 : imageSignal.name) || dataExtentSignal;
        const binTransform = {
            type: 'bin',
            field: (0, $03b4e9c3be7efafd$export$fb70365b00e8cb7b)(column.name),
            as: [
                field,
                fieldEnd
            ],
            signal: binSignal,
            extent: {
                signal: `[${extentSignal}[0], ${extentSignal}[1] + 1e-11]`
            },
            minstep: $d832bf01a4278a5e$export$a1300c781a434acb(column) ? 1 : 0,
            maxbins: {
                signal: maxbinsSignalName
            }
        };
        const dataSequence = {
            name: domainDataName,
            transform: [
                {
                    type: 'sequence',
                    start: {
                        signal: `${binSignal}.start`
                    },
                    stop: {
                        signal: `${binSignal}.stop`
                    },
                    step: {
                        signal: `${binSignal}.step`
                    }
                },
                {
                    type: 'formula',
                    expr: 'datum.data',
                    as: field
                },
                {
                    type: 'formula',
                    expr: `datum.data + ${binSignal}.step`,
                    as: fieldEnd
                },
                {
                    type: 'window',
                    ops: [
                        'row_number'
                    ],
                    as: [
                        (0, $8d0624e259fe9d79$export$10df5429b7082be2).Ordinal
                    ]
                },
                {
                    type: 'formula',
                    expr: `datum.data === ${binSignal}.start`,
                    as: (0, $8d0624e259fe9d79$export$10df5429b7082be2).First
                },
                {
                    type: 'formula',
                    expr: `datum.data === ${binSignal}.stop - ${binSignal}.step`,
                    as: (0, $8d0624e259fe9d79$export$10df5429b7082be2).Last
                },
                {
                    // when there is only one bin, use only first sequence element
                    type: 'filter',
                    expr: `${dataExtentSpanSignal} === 0 ? datum[${JSON.stringify((0, $8d0624e259fe9d79$export$10df5429b7082be2).First)}] : true`
                }
            ]
        };
        const signals = [
            maxbinsSignal,
            {
                name: dataExtentSpanSignal,
                update: `${extentSignal}[1] - ${extentSignal}[0]`
            }
        ];
        if (imageSignal) signals.push(imageSignal);
        const augmentBinnable = {
            discreteColumn: discreteColumn,
            native: false,
            transforms: [
                extentTransform,
                binTransform
            ],
            fields: [
                field,
                fieldEnd
            ],
            binSignal: binSignal,
            extentSignal: extentSignal,
            dataSequence: dataSequence,
            domainDataName: domainDataName,
            signals: signals,
            fullScaleDataname: dataSequence.name
        };
        return augmentBinnable;
    } else {
        const nativeBinnable = {
            discreteColumn: discreteColumn,
            native: true,
            fields: [
                column.name
            ],
            domainDataName: domainDataName,
            fullScaleDataname: domainDataName
        };
        return nativeBinnable;
    }
}
function $d832bf01a4278a5e$export$3794e0ea8ab2e895(name, min, max, dataExtent) {
    return {
        name: name,
        update: `[min(${min}, ${dataExtent}[0]), max(${max}, ${dataExtent}[1])]`
    };
}
function $d832bf01a4278a5e$export$a1300c781a434acb(column) {
    //prevent Vega from showing ".5" steps between integer scale values
    return column.quantitative && column.type === 'integer' && column.stats.max - column.stats.min <= 7;
}







const $cef2083591a92ad5$export$d437166a1bdbfdf0 = '_linear';
class $cef2083591a92ad5$export$5b22a87d7feca398 extends (0, $748726ce52deaf5d$export$c84671f46d6a1ca) {
    constructor(props){
        super(props);
        this.props = props;
        const p = this.prefix = `band_${this.id}`;
        this.names = {
            xScale: `scale_${p}_x`,
            yScale: `scale_${p}_y`,
            bandWidth: `${p}_bandwidth`,
            accumulative: `${p}_accumulative`
        };
        this.bin = (0, $d832bf01a4278a5e$export$6868fd1605c79d3d)(this.prefix, props.globalScope.data.name, props.groupby, props.outerSignalExtents);
    }
    getGrouping() {
        return this.bin.fields;
    }
    build() {
        const { bin: bin, names: names, props: props } = this;
        const { globalScope: globalScope, minBandWidth: minBandWidth, orientation: orientation, parentScope: parentScope, showAxes: showAxes } = props;
        const binField = bin.fields[0];
        if (bin.native === false) {
            (0, $29c6c9793f692470$export$5346a0d8a9111b3f)(globalScope.scope, ...bin.signals);
            (0, $29c6c9793f692470$export$eea5d31e98930019)(globalScope.data, ...bin.transforms);
            (0, $29c6c9793f692470$export$6853292f627997e4)(globalScope.scope, bin.dataSequence);
        }
        //TODO don't add this, use existing dataset
        (0, $29c6c9793f692470$export$6853292f627997e4)(globalScope.scope, {
            name: names.accumulative,
            source: bin.fullScaleDataname,
            transform: [
                {
                    type: 'aggregate',
                    groupby: this.getGrouping().map((0, $03b4e9c3be7efafd$export$fb70365b00e8cb7b)),
                    ops: [
                        'count'
                    ]
                }
            ]
        });
        const horizontal = orientation === 'horizontal';
        const minCellSignal = horizontal ? globalScope.signals.minCellHeight : globalScope.signals.minCellWidth;
        (0, $8243f48596a5f195$export$cdc9366ba30317bd)(minCellSignal, 'max', `length(data(${JSON.stringify(names.accumulative)})) * ${minBandWidth}`);
        (0, $29c6c9793f692470$export$5346a0d8a9111b3f)(globalScope.scope, {
            name: names.bandWidth,
            update: `bandwidth(${JSON.stringify(horizontal ? names.yScale : names.xScale)})`
        });
        const scale = this.getScale(bin, horizontal);
        if (props.outerSignalExtents && bin.native === false) //add a linear scale for use by background image
        (0, $29c6c9793f692470$export$290268902279a991)(globalScope.scope, (0, $7fac7254f262c640$export$fefe9507ec0904ed)(scale.name + $cef2083591a92ad5$export$d437166a1bdbfdf0, {
            signal: bin.extentSignal
        }, scale.range, scale.reverse, false, false));
        let encodingRuleMap;
        if (!props.excludeEncodingRuleMap) encodingRuleMap = horizontal ? {
            x: [
                {
                    test: (0, $0299c0d9f55fe75f$export$71c45f78b1166d35)(),
                    signal: parentScope.offsets.x
                }
            ],
            width: [
                {
                    test: (0, $0299c0d9f55fe75f$export$71c45f78b1166d35)(),
                    value: 0
                }
            ]
        } : {
            y: [
                {
                    test: (0, $0299c0d9f55fe75f$export$71c45f78b1166d35)(),
                    signal: (0, $29c6c9793f692470$export$e6b6683aec0fe907)(parentScope.offsets.y, parentScope.offsets.h)
                }
            ],
            height: [
                {
                    test: (0, $0299c0d9f55fe75f$export$71c45f78b1166d35)(),
                    value: 0
                }
            ]
        };
        return {
            offsets: this.getOffset(horizontal, binField),
            sizeSignals: horizontal ? {
                layoutHeight: names.bandWidth,
                layoutWidth: parentScope.sizeSignals.layoutWidth
            } : {
                layoutHeight: parentScope.sizeSignals.layoutHeight,
                layoutWidth: names.bandWidth
            },
            globalScales: {
                showAxes: showAxes,
                scales: {
                    x: horizontal ? undefined : [
                        scale
                    ],
                    y: horizontal ? [
                        scale
                    ] : undefined
                }
            },
            encodingRuleMap: encodingRuleMap
        };
    }
    getOffset(horizontal, binField) {
        const { names: names, props: props } = this;
        const { parentScope: parentScope } = props;
        return {
            x: (0, $29c6c9793f692470$export$e6b6683aec0fe907)(parentScope.offsets.x, horizontal ? '' : `scale(${JSON.stringify(names.xScale)}, datum[${JSON.stringify(binField)}])`),
            y: (0, $29c6c9793f692470$export$e6b6683aec0fe907)(parentScope.offsets.y, horizontal ? `scale(${JSON.stringify(names.yScale)}, datum[${JSON.stringify(binField)}])` : ''),
            h: horizontal ? names.bandWidth : parentScope.offsets.h,
            w: horizontal ? parentScope.offsets.w : names.bandWidth
        };
    }
    getScale(bin, horizontal) {
        const { names: names } = this;
        const { parentScope: parentScope } = this.props;
        const binField = (0, $03b4e9c3be7efafd$export$fb70365b00e8cb7b)(bin.fields[0]);
        let bandScale;
        if (horizontal) bandScale = {
            type: 'band',
            name: names.yScale,
            range: [
                0,
                {
                    signal: parentScope.sizeSignals.layoutHeight
                }
            ],
            padding: 0.1,
            domain: {
                data: bin.domainDataName,
                field: binField,
                sort: true
            },
            reverse: true
        };
        else bandScale = {
            type: 'band',
            name: names.xScale,
            range: [
                0,
                {
                    signal: parentScope.sizeSignals.layoutWidth
                }
            ],
            padding: 0.1,
            domain: {
                data: bin.domainDataName,
                field: binField,
                sort: true
            }
        };
        return bandScale;
    }
}


/*!
* Copyright (c) Microsoft Corporation.
* Licensed under the MIT License.
*/ 


/*!
* Copyright (c) Microsoft Corporation.
* Licensed under the MIT License.
*/ function $b12a1eed38ffb3f0$export$f241323700beca17(bin) {
    const val = (index)=>`datum[${JSON.stringify(bin.fields[index])}]`;
    return bin.discreteColumn.column.quantitative ? `format(${val(0)}, '~r') + ' - ' + format(${val(1)}, '~r')` : val(0);
}
function $b12a1eed38ffb3f0$var$obj(nameValues, clause) {
    if (clause) nameValues = [
        clause,
        ...nameValues
    ];
    return `{${nameValues.join()}}`;
}
function $b12a1eed38ffb3f0$export$b292ca0d4c2e4690(bin, firstFieldName, lastFieldName, clause) {
    if (bin.discreteColumn.column.quantitative) {
        const low = [
            `name:${JSON.stringify(bin.discreteColumn.column.name)}`,
            'operator:\'>=\'',
            `value:datum[${JSON.stringify(bin.fields[0])}]`
        ];
        const high = [
            'clause:\'&&\'',
            `name:${JSON.stringify(bin.discreteColumn.column.name)}`,
            'operator:\'<\'',
            `value:datum[${JSON.stringify(bin.fields[1])}]`
        ];
        return $b12a1eed38ffb3f0$var$obj([
            `expressions:[ datum[${JSON.stringify(firstFieldName)}] ? null : ${$b12a1eed38ffb3f0$var$obj(low)}, datum[${JSON.stringify(lastFieldName)}] ? null : ${$b12a1eed38ffb3f0$var$obj(high)}]`
        ], clause);
    } else {
        const exact = [
            `name:${JSON.stringify(bin.discreteColumn.column.name)}`,
            'operator:\'==\'',
            `value:datum[${JSON.stringify(bin.fields[0])}]`
        ];
        return $b12a1eed38ffb3f0$var$obj([
            `expressions:[${$b12a1eed38ffb3f0$var$obj(exact)}]`
        ], clause);
    }
}



/*!
* Copyright (c) Microsoft Corporation.
* Licensed under the MIT License.
*/ 

function $3aee2b63ed318776$export$71d2e96f63f1ac97(source, prefix, binFields, sortOrder) {
    const _binFields = binFields.map((0, $03b4e9c3be7efafd$export$fb70365b00e8cb7b));
    const dataName = `${prefix}_bin_order`;
    const data = {
        name: dataName,
        source: source,
        transform: [
            {
                type: 'aggregate',
                groupby: _binFields
            },
            {
                type: 'collect',
                sort: {
                    field: _binFields,
                    order: _binFields.map((f)=>sortOrder)
                }
            },
            {
                type: 'window',
                ops: [
                    'row_number'
                ],
                as: [
                    (0, $8d0624e259fe9d79$export$10df5429b7082be2).Ordinal
                ]
            }
        ]
    };
    return {
        data: data,
        scale: $3aee2b63ed318776$export$f85d5aad90241781(dataName, `scale_${prefix}_order`, binFields)
    };
}
function $3aee2b63ed318776$export$f85d5aad90241781(dataName, scaleName, binFields) {
    return {
        type: 'ordinal',
        name: scaleName,
        domain: {
            data: dataName,
            field: (0, $03b4e9c3be7efafd$export$fb70365b00e8cb7b)(binFields[0])
        },
        range: {
            data: dataName,
            field: (0, $8d0624e259fe9d79$export$10df5429b7082be2).Ordinal
        }
    };
}




class $ad34ec84cd0de2bf$export$3c877bb842c36952 extends (0, $748726ce52deaf5d$export$c84671f46d6a1ca) {
    constructor(props){
        super(props);
        this.props = props;
        const p = this.prefix = `cross_${this.id}`;
        this.binX = (0, $d832bf01a4278a5e$export$6868fd1605c79d3d)(`${p}_x`, props.globalScope.data.name, props.groupbyX);
        this.binY = (0, $d832bf01a4278a5e$export$6868fd1605c79d3d)(`${p}_y`, props.globalScope.data.name, props.groupbyY);
        this.names = {
            facetDataName: `data_${p}_facet`,
            searchUnion: `data_${p}_search`,
            dimScale: `scale_${p}`,
            dimCount: `${p}_count`,
            dimCategorical: `data_${p}_cat`,
            dimCellSize: `${p}_cell_size`,
            dimCellSizeCalc: `${p}_cell_calc`
        };
    }
    getGrouping() {
        return this.binX.fields.concat(this.binY.fields);
    }
    build() {
        const { binX: binX, binY: binY, names: names, prefix: prefix, props: props } = this;
        const { axisTextColor: axisTextColor, colRowTitles: colRowTitles, globalScope: globalScope, parentScope: parentScope } = props;
        const titles = {
            x: {
                dataName: null,
                quantitative: null
            },
            y: {
                dataName: null,
                quantitative: null
            }
        };
        const dx = {
            dim: 'x',
            bin: binX,
            sortOrder: 'ascending',
            size: parentScope.sizeSignals.layoutWidth,
            layout: parentScope.sizeSignals.layoutWidth,
            min: globalScope.signals.minCellWidth.name,
            out: globalScope.signals.plotWidthOut,
            offset: (0, $8d0624e259fe9d79$export$809e371dee643808).FacetPaddingLeft,
            padding: (0, $8d0624e259fe9d79$export$809e371dee643808).FacetPaddingLeft,
            dataOut: null,
            scaleName: null,
            position: null
        };
        const dy = {
            dim: 'y',
            bin: binY,
            sortOrder: 'ascending',
            size: parentScope.sizeSignals.layoutHeight,
            layout: parentScope.sizeSignals.layoutHeight,
            min: globalScope.signals.minCellHeight.name,
            out: globalScope.signals.plotHeightOut,
            offset: (0, $8d0624e259fe9d79$export$809e371dee643808).FacetPaddingTop,
            padding: `(${(0, $8d0624e259fe9d79$export$809e371dee643808).FacetPaddingTop} + ${(0, $8d0624e259fe9d79$export$809e371dee643808).FacetPaddingBottom})`,
            dataOut: null,
            scaleName: null,
            position: null
        };
        const dimensions = [
            dx,
            dy
        ];
        dimensions.forEach((d)=>{
            const { bin: bin, dim: dim, padding: padding, sortOrder: sortOrder } = d;
            let data;
            let dataName;
            let countSignal;
            let scale;
            const titleSource = titles[dim];
            if (bin.native === false) {
                (0, $29c6c9793f692470$export$5346a0d8a9111b3f)(globalScope.scope, ...bin.signals);
                (0, $29c6c9793f692470$export$eea5d31e98930019)(globalScope.data, ...bin.transforms);
                (0, $29c6c9793f692470$export$6853292f627997e4)(globalScope.scope, bin.dataSequence);
                (0, $29c6c9793f692470$export$eea5d31e98930019)(bin.dataSequence, {
                    type: 'formula',
                    expr: `indata(${JSON.stringify(globalScope.markDataName)}, ${JSON.stringify(bin.fields[0])}, datum[${JSON.stringify(bin.fields[0])}])`,
                    as: (0, $8d0624e259fe9d79$export$10df5429b7082be2).Contains
                });
                data = bin.dataSequence;
                dataName = bin.dataSequence.name;
                countSignal = `length(data(${JSON.stringify(dataName)}))`;
                scale = (0, $3aee2b63ed318776$export$f85d5aad90241781)(dataName, `${names.dimScale}_${dim}`, bin.fields);
                titleSource.dataName = bin.dataSequence.name;
            } else {
                dataName = globalScope.markDataName;
                const ord = (0, $3aee2b63ed318776$export$71d2e96f63f1ac97)(dataName, `${prefix}_${dim}`, bin.fields, sortOrder);
                data = ord.data;
                (0, $29c6c9793f692470$export$6853292f627997e4)(globalScope.scope, ord.data);
                countSignal = `length(data(${JSON.stringify(ord.data.name)}))`;
                scale = ord.scale;
                titleSource.dataName = ord.data.name;
            }
            titleSource.quantitative = bin.discreteColumn.column.quantitative;
            d.dataOut = data;
            d.scaleName = scale.name;
            (0, $29c6c9793f692470$export$eea5d31e98930019)(data, {
                type: 'formula',
                expr: (0, $b12a1eed38ffb3f0$export$b292ca0d4c2e4690)(bin, (0, $8d0624e259fe9d79$export$10df5429b7082be2).First, (0, $8d0624e259fe9d79$export$10df5429b7082be2).Last),
                as: (0, $8d0624e259fe9d79$export$10df5429b7082be2).FacetSearch
            }, {
                type: 'formula',
                expr: (0, $b12a1eed38ffb3f0$export$f241323700beca17)(bin),
                as: (0, $8d0624e259fe9d79$export$10df5429b7082be2).FacetTitle
            });
            (0, $29c6c9793f692470$export$290268902279a991)(globalScope.scope, scale);
            const count = `${names.dimCount}_${dim}`;
            const calc = `${names.dimCellSizeCalc}_${dim}`;
            const size = `${names.dimCellSize}_${dim}`;
            (0, $29c6c9793f692470$export$5346a0d8a9111b3f)(globalScope.scope, {
                name: count,
                update: countSignal
            });
            (0, $29c6c9793f692470$export$5346a0d8a9111b3f)(globalScope.scope, {
                name: calc,
                update: `${d.layout} / ${count}`
            }, {
                name: size,
                update: `max(${d.min}, (${calc} - ${padding}))`
            });
            (0, $8243f48596a5f195$export$cdc9366ba30317bd)(d.out, 'max', `((${size} + ${padding}) * ${count})`);
            d.position = this.dimensionOffset(d);
        });
        const groupRow = {
            type: 'group',
            encode: {
                update: {
                    y: {
                        signal: dy.position
                    }
                }
            },
            from: {
                data: dy.dataOut.name
            },
            data: [
                {
                    name: names.searchUnion,
                    source: dx.dataOut.name,
                    transform: [
                        {
                            type: 'formula',
                            expr: `[datum[${JSON.stringify((0, $8d0624e259fe9d79$export$10df5429b7082be2).FacetSearch)}], merge(parent[${JSON.stringify((0, $8d0624e259fe9d79$export$10df5429b7082be2).FacetSearch)}], { clause: '&&'})]`,
                            as: (0, $8d0624e259fe9d79$export$10df5429b7082be2).FacetSearch
                        }
                    ]
                }
            ]
        };
        const groupCol = {
            style: 'cell',
            name: prefix,
            type: 'group',
            encode: {
                update: {
                    height: {
                        signal: `${names.dimCellSize}_y`
                    },
                    width: {
                        signal: `${names.dimCellSize}_x`
                    },
                    x: {
                        signal: dx.position
                    }
                }
            },
            from: {
                data: names.searchUnion
            }
        };
        (0, $29c6c9793f692470$export$3df320e901c23a48)(globalScope.markGroup, groupRow);
        (0, $29c6c9793f692470$export$3df320e901c23a48)(groupRow, groupCol);
        const offsets = {
            x: this.dimensionOffset(dx),
            y: this.dimensionOffset(dy),
            h: `${names.dimCellSize}_y`,
            w: `${names.dimCellSize}_x`
        };
        const sizeSignals = {
            layoutHeight: `${names.dimCellSize}_y`,
            layoutWidth: `${names.dimCellSize}_x`,
            colCount: `${names.dimCount}_x`,
            rowCount: `${names.dimCount}_y`
        };
        if (colRowTitles) (0, $e298df2c870b2b1c$export$4fec84497b9e6e3f)(globalScope.scope, titles.x, titles.y, sizeSignals, axisTextColor);
        return {
            facetScope: groupCol,
            offsets: offsets,
            sizeSignals: sizeSignals,
            titles: titles
        };
    }
    dimensionOffset(d) {
        const { names: names } = this;
        return `${d.offset} + (scale(${JSON.stringify(d.scaleName)}, datum[${JSON.stringify(d.bin.fields[0])}]) - 1) * (${names.dimCellSize}_${d.dim} + ${d.padding})`;
    }
}


/*!
* Copyright (c) Microsoft Corporation.
* Licensed under the MIT License.
*/ 








class $400f8948076e2f06$export$1c460fb4285edadc extends (0, $748726ce52deaf5d$export$c84671f46d6a1ca) {
    constructor(props){
        super(props);
        this.props = props;
        const p = this.prefix = `scatter_${this.id}`;
        this.names = {
            aggregateData: `data_${p}_aggregate`,
            markData: `data_${p}_mark`,
            xDataExtent: `${p}_xDataExtent`,
            yDataExtent: `${p}_yDataExtent`,
            xExtent: `${p}_xExtent`,
            yExtent: `${p}_yExtent`,
            sizeExtent: `${p}_sizeExtent`,
            sizeRange: `${p}_sizeRange`,
            sizeScale: `${p}_sizeScale`,
            xScale: `scale_${p}_x`,
            yScale: `scale_${p}_y`,
            zScale: `scale_${p}_z`
        };
    }
    build() {
        const { names: names, prefix: prefix, props: props } = this;
        const { backgroundImageExtents: backgroundImageExtents, globalScope: globalScope, parentScope: parentScope, scatterPointScaleDisplay: scatterPointScaleDisplay, showAxes: showAxes, size: size, view: view, x: x, y: y, z: z, zGrounded: zGrounded } = props;
        const qsize = size && size.quantitative && size;
        (0, $29c6c9793f692470$export$5346a0d8a9111b3f)(globalScope.scope, {
            name: (0, $8d0624e259fe9d79$export$809e371dee643808).PointScale,
            value: 5,
            bind: {
                name: scatterPointScaleDisplay,
                debounce: $72552551eb533aa6$export$61fc7d43ac8f84b0,
                input: 'range',
                min: 1,
                max: 10,
                step: 0.1
            }
        }, {
            name: (0, $8d0624e259fe9d79$export$809e371dee643808).ZGrounded,
            value: false,
            bind: {
                name: zGrounded,
                input: 'checkbox'
            }
        });
        if (backgroundImageExtents) {
            (0, $29c6c9793f692470$export$eea5d31e98930019)(globalScope.data, (0, $df1b04e32170cfe5$export$e1e8339c59091971)(x, names.xDataExtent), (0, $df1b04e32170cfe5$export$e1e8339c59091971)(y, names.yDataExtent));
            const xSignal = (0, $d832bf01a4278a5e$export$3794e0ea8ab2e895)(names.xExtent, backgroundImageExtents.left, backgroundImageExtents.right, names.xDataExtent);
            const ySignal = (0, $d832bf01a4278a5e$export$3794e0ea8ab2e895)(names.yExtent, backgroundImageExtents.bottom, backgroundImageExtents.top, names.yDataExtent);
            (0, $29c6c9793f692470$export$5346a0d8a9111b3f)(globalScope.scope, xSignal, ySignal);
        }
        if (qsize) {
            (0, $29c6c9793f692470$export$eea5d31e98930019)(globalScope.data, {
                type: 'extent',
                field: (0, $03b4e9c3be7efafd$export$fb70365b00e8cb7b)(qsize.name),
                signal: names.sizeExtent
            });
            (0, $29c6c9793f692470$export$290268902279a991)(globalScope.scope, {
                name: names.sizeScale,
                type: 'pow',
                exponent: 0.5,
                domain: [
                    0,
                    {
                        signal: `${names.sizeExtent}[1]`
                    }
                ],
                range: [
                    0,
                    {
                        signal: names.sizeRange
                    }
                ]
            });
            (0, $29c6c9793f692470$export$5346a0d8a9111b3f)(globalScope.scope, {
                name: names.sizeRange,
                update: `min(${parentScope.sizeSignals.layoutHeight}, ${parentScope.sizeSignals.layoutWidth}) / ${(0, $72552551eb533aa6$export$c223d3ee3c0620d9)}`
            });
        }
        (0, $29c6c9793f692470$export$6853292f627997e4)(globalScope.scope, {
            name: names.markData,
            source: globalScope.markDataName,
            transform: [
                x,
                y,
                z
            ].map((c)=>{
                if (!c || !c.quantitative) return;
                const t = {
                    type: 'filter',
                    expr: `isValid(datum[${JSON.stringify(c.name)}])`
                };
                return t;
            }).filter(Boolean)
        });
        globalScope.setMarkDataName(names.markData);
        const globalScales = {
            showAxes: showAxes,
            scales: {}
        };
        const zValue = z ? `scale(${JSON.stringify(names.zScale)}, datum[${JSON.stringify(z.name)}])` : null;
        const sizeValueSignal = qsize ? `scale(${JSON.stringify(names.sizeScale)}, datum[${JSON.stringify(qsize.name)}]) * ${(0, $8d0624e259fe9d79$export$809e371dee643808).PointScale}` : (0, $8d0624e259fe9d79$export$809e371dee643808).PointScale;
        const update = Object.assign({
            height: [
                {
                    test: (0, $0299c0d9f55fe75f$export$71c45f78b1166d35)(),
                    value: 0
                },
                {
                    signal: sizeValueSignal
                }
            ],
            width: {
                signal: sizeValueSignal
            }
        }, z && {
            z: [
                {
                    test: (0, $0299c0d9f55fe75f$export$71c45f78b1166d35)(),
                    value: 0
                },
                {
                    signal: `${(0, $8d0624e259fe9d79$export$809e371dee643808).ZGrounded} ? 0 : ${zValue}`
                }
            ],
            zindex: [
                {
                    signal: `${(0, $8d0624e259fe9d79$export$809e371dee643808).ZGrounded} ? 0 : ${zValue}`
                }
            ],
            depth: [
                {
                    test: (0, $0299c0d9f55fe75f$export$71c45f78b1166d35)(),
                    value: 0
                },
                {
                    signal: view === '3d' ? `${(0, $8d0624e259fe9d79$export$809e371dee643808).ZGrounded} ? ${zValue} : ${sizeValueSignal}` : '0'
                }
            ]
        });
        const columnSignals = [
            {
                column: x,
                xyz: 'x',
                scaleName: names.xScale,
                domain: backgroundImageExtents ? {
                    signal: names.xExtent
                } : {
                    data: globalScope.data.name,
                    field: (0, $03b4e9c3be7efafd$export$fb70365b00e8cb7b)(x.name)
                },
                reverse: false,
                signal: parentScope.sizeSignals.layoutWidth
            },
            {
                column: y,
                xyz: 'y',
                scaleName: names.yScale,
                domain: backgroundImageExtents ? {
                    signal: names.yExtent
                } : {
                    data: globalScope.data.name,
                    field: (0, $03b4e9c3be7efafd$export$fb70365b00e8cb7b)(y.name)
                },
                reverse: true,
                signal: parentScope.sizeSignals.layoutHeight
            },
            {
                column: z,
                xyz: 'z',
                scaleName: names.zScale,
                domain: {
                    data: globalScope.data.name,
                    field: z ? (0, $03b4e9c3be7efafd$export$fb70365b00e8cb7b)(z.name) : null
                },
                reverse: false,
                signal: view === '3d' ? `(${globalScope.zSize}) * ${(0, $8d0624e259fe9d79$export$809e371dee643808).ZProportion}` : `10 * ${(0, $8d0624e259fe9d79$export$809e371dee643808).ZProportion}`
            }
        ];
        columnSignals.forEach((cs)=>{
            const { column: column, domain: domain, reverse: reverse, scaleName: scaleName, signal: signal, xyz: xyz } = cs;
            if (!column) return;
            let scale;
            if (column.quantitative) {
                scale = (0, $7fac7254f262c640$export$fefe9507ec0904ed)(scaleName, domain, [
                    0,
                    {
                        signal: signal
                    }
                ], reverse, false, showAxes);
                if ((0, $d832bf01a4278a5e$export$a1300c781a434acb)(column)) scale.bins = {
                    step: 1
                };
            } else scale = (0, $7fac7254f262c640$export$b67158f831e00d0d)(scaleName, globalScope.data.name, [
                0,
                {
                    signal: signal
                }
            ], column.name, reverse);
            globalScales.scales[xyz] = [
                scale
            ];
        });
        const mark = {
            name: prefix,
            type: 'rect',
            from: {
                data: globalScope.markDataName
            },
            encode: {
                update: update
            }
        };
        (0, $29c6c9793f692470$export$3df320e901c23a48)(globalScope.markGroup, mark);
        return {
            offsets: {
                x: (0, $29c6c9793f692470$export$e6b6683aec0fe907)(parentScope.offsets.x, `scale(${JSON.stringify(names.xScale)}, datum[${JSON.stringify(x.name)}])`),
                y: (0, $29c6c9793f692470$export$e6b6683aec0fe907)(parentScope.offsets.y, `scale(${JSON.stringify(names.yScale)}, datum[${JSON.stringify(y.name)}]) - ${sizeValueSignal}`),
                h: sizeValueSignal,
                w: sizeValueSignal
            },
            sizeSignals: {
                layoutHeight: null,
                layoutWidth: null
            },
            globalScales: globalScales,
            mark: mark,
            encodingRuleMap: {
                y: [
                    {
                        test: (0, $0299c0d9f55fe75f$export$71c45f78b1166d35)(),
                        signal: (0, $29c6c9793f692470$export$e6b6683aec0fe907)(parentScope.offsets.y, parentScope.sizeSignals.layoutHeight)
                    }
                ]
            }
        };
    }
}


/*!
* Copyright (c) Microsoft Corporation.
* Licensed under the MIT License.
*/ 




/*!
* Copyright (c) Microsoft Corporation.
* Licensed under the MIT License.
*/ 


function $a2cc661c2a61585d$export$9e1d5954d0bb865c(z, zSize, dataName, zScaleName) {
    if (z) {
        const zRange = [
            0,
            {
                signal: `(${zSize}) * ${(0, $8d0624e259fe9d79$export$809e371dee643808).ZProportion}`
            }
        ];
        const scale = z.quantitative ? (0, $7fac7254f262c640$export$fefe9507ec0904ed)(zScaleName, {
            data: dataName,
            field: (0, $03b4e9c3be7efafd$export$fb70365b00e8cb7b)(z.name)
        }, zRange, false, true) : (0, $7fac7254f262c640$export$b67158f831e00d0d)(zScaleName, dataName, zRange, z.name, false);
        return scale;
    }
}


class $0921378644518b2d$export$b09fb900337259de extends (0, $748726ce52deaf5d$export$c84671f46d6a1ca) {
    constructor(props){
        super(props);
        this.props = props;
        const p = this.prefix = `square_${this.id}`;
        this.names = {
            bandWidth: this.getBandWidth(),
            maxGroupField: `${p}_max_group`,
            maxGroupSignal: `${p}_max_grouping`,
            stack0: `${p}_stack0`,
            stack1: `${p}_stack1`,
            zScale: `scale_${p}_z`
        };
    }
    build() {
        const { names: names, prefix: prefix, props: props } = this;
        const { fillDirection: fillDirection, globalScope: globalScope, groupings: groupings, parentScope: parentScope, collapseYHeight: collapseYHeight, showAxes: showAxes, sortBy: sortBy, view: view, z: z } = props;
        const zScale = (0, $a2cc661c2a61585d$export$9e1d5954d0bb865c)(z, globalScope.zSize, globalScope.data.name, names.zScale);
        (0, $29c6c9793f692470$export$eea5d31e98930019)(globalScope.data, Object.assign({
            type: 'stack',
            groupby: (0, $29c6c9793f692470$export$53a21aeef48e14a8)(groupings).map((0, $03b4e9c3be7efafd$export$fb70365b00e8cb7b)),
            as: [
                names.stack0,
                names.stack1
            ]
        }, sortBy && {
            sort: {
                field: (0, $03b4e9c3be7efafd$export$fb70365b00e8cb7b)(sortBy.name),
                order: 'ascending'
            }
        }));
        const { gap: gap, levelSize: levelSize, size: size, squaresPerBand: squaresPerBand } = this.addSignals();
        const heightSignal = {
            signal: fillDirection === 'down-right' ? size : levelSize
        };
        const mark = {
            name: prefix,
            type: 'rect',
            from: {
                data: globalScope.markDataName
            },
            encode: {
                update: Object.assign({
                    height: collapseYHeight ? [
                        {
                            test: (0, $0299c0d9f55fe75f$export$71c45f78b1166d35)(),
                            value: 0
                        },
                        heightSignal
                    ] : heightSignal,
                    width: {
                        signal: fillDirection === 'down-right' ? levelSize : size
                    }
                }, z && {
                    z: {
                        value: 0
                    },
                    depth: [
                        {
                            test: (0, $0299c0d9f55fe75f$export$71c45f78b1166d35)(),
                            value: 0
                        },
                        view === '3d' ? {
                            scale: names.zScale,
                            field: (0, $03b4e9c3be7efafd$export$fb70365b00e8cb7b)(z.name)
                        } : {
                            value: 0
                        }
                    ]
                })
            }
        };
        (0, $29c6c9793f692470$export$3df320e901c23a48)(globalScope.markGroup, mark);
        const { tx: tx, ty: ty } = this.transformXY(gap, levelSize, squaresPerBand);
        return Object.assign(Object.assign(Object.assign({}, z && {
            globalScales: {
                showAxes: showAxes,
                scales: {
                    z: [
                        zScale
                    ]
                }
            }
        }), {
            offsets: {
                x: (0, $29c6c9793f692470$export$e6b6683aec0fe907)(parentScope.offsets.x, tx.expr),
                y: (0, $29c6c9793f692470$export$e6b6683aec0fe907)(parentScope.offsets.y, ty.expr),
                h: size,
                w: size
            },
            mark: mark,
            sizeSignals: {
                layoutHeight: size,
                layoutWidth: size
            }
        }), collapseYHeight && {
            encodingRuleMap: {
                y: [
                    {
                        test: (0, $0299c0d9f55fe75f$export$71c45f78b1166d35)(),
                        signal: parentScope.offsets.y
                    }
                ]
            }
        });
    }
    getBandWidth() {
        const { offsets: offsets } = this.props.parentScope;
        switch(this.props.fillDirection){
            case 'down-right':
                return offsets.h;
            default:
                return offsets.w;
        }
    }
    addSignals() {
        const { names: names, props: props } = this;
        const { fillDirection: fillDirection, globalScope: globalScope, groupings: groupings, parentScope: parentScope } = props;
        let { maxGroupedFillSize: maxGroupedFillSize, maxGroupedUnits: maxGroupedUnits } = props;
        if (!maxGroupedUnits) {
            if (groupings) {
                (0, $29c6c9793f692470$export$eea5d31e98930019)(globalScope.data, {
                    type: 'joinaggregate',
                    groupby: (0, $29c6c9793f692470$export$53a21aeef48e14a8)(groupings).map((0, $03b4e9c3be7efafd$export$fb70365b00e8cb7b)),
                    ops: [
                        'count'
                    ],
                    as: [
                        names.maxGroupField
                    ]
                }, {
                    type: 'extent',
                    field: names.maxGroupField,
                    signal: names.maxGroupSignal
                });
                maxGroupedUnits = `(${names.maxGroupSignal}[1])`;
            } else maxGroupedUnits = `length(data(${JSON.stringify(globalScope.data.name)}))`;
        }
        if (!maxGroupedFillSize) maxGroupedFillSize = fillDirection === 'down-right' ? parentScope.offsets.w : parentScope.offsets.h;
        const aspect = `((${names.bandWidth}) / (${maxGroupedFillSize}))`;
        const squaresPerBand = `ceil(sqrt(${maxGroupedUnits} * ${aspect}))`;
        const gap = `min(0.1 * ((${names.bandWidth}) / (${squaresPerBand} - 1)), 1)`;
        const size = `(((${names.bandWidth}) / ${squaresPerBand}) - ${gap})`;
        const levels = `ceil(${maxGroupedUnits} / ${squaresPerBand})`;
        const levelSize = `(((${maxGroupedFillSize}) / ${levels}) - ${gap})`;
        return {
            gap: gap,
            levelSize: levelSize,
            size: size,
            squaresPerBand: squaresPerBand
        };
    }
    transformXY(gap, levelSize, squaresPerBand) {
        const { names: names, prefix: prefix } = this;
        const compartment = `(${names.bandWidth}) / ${squaresPerBand} * ((datum[${JSON.stringify(names.stack0)}]) % ${squaresPerBand})`;
        const level = `floor((datum[${JSON.stringify(names.stack0)}]) / ${squaresPerBand})`;
        const { fillDirection: fillDirection, parentScope: parentScope } = this.props;
        const tx = {
            type: 'formula',
            expr: null,
            as: `${prefix}_${(0, $8d0624e259fe9d79$export$10df5429b7082be2).OffsetX}`
        };
        const ty = {
            type: 'formula',
            expr: null,
            as: `${prefix}_${(0, $8d0624e259fe9d79$export$10df5429b7082be2).OffsetY}`
        };
        switch(fillDirection){
            case 'down-right':
                tx.expr = `${level} * (${levelSize} + ${gap})`;
                ty.expr = compartment;
                break;
            case 'right-up':
                tx.expr = compartment;
                ty.expr = `${parentScope.offsets.h} - ${levelSize} - ${level} * (${levelSize} + ${gap})`;
                break;
            case 'right-down':
            default:
                tx.expr = compartment;
                ty.expr = `${level} * (${levelSize} + ${gap})`;
                break;
        }
        return {
            tx: tx,
            ty: ty
        };
    }
}


/*!
* Copyright (c) Microsoft Corporation.
* Licensed under the MIT License.
*/ 



class $ea238a52b780f861$export$694e0d28c7ffc90c extends (0, $748726ce52deaf5d$export$c84671f46d6a1ca) {
    constructor(props){
        super(props);
        this.props = props;
        const p = this.prefix = `stack_${this.id}`;
        this.names = {
            cube: `${p}_cube`,
            globalDataName: `data_${p}_count`,
            globalExtent: `${p}_global_extent`,
            levelDataName: `data_${p}_level`,
            count: `${p}_count`,
            stack0: `${p}_stack0`,
            stack1: `${p}_stack1`,
            sequence: `data_${p}_sequence`,
            sides: `${p}_sides`,
            size: `${p}_size`,
            squared: `${p}_squared`,
            maxCount: `${p}_maxCount`,
            maxLevels: `${p}_maxLevels`,
            zScale: `${p}_zScale`
        };
    }
    build() {
        const { names: names, props: props } = this;
        const { globalScope: globalScope, groupings: groupings, parentScope: parentScope, showAxes: showAxes, sort: sort } = props;
        const { sizeSignals: sizeSignals } = parentScope;
        (0, $29c6c9793f692470$export$eea5d31e98930019)(globalScope.data, {
            type: 'joinaggregate',
            groupby: (0, $29c6c9793f692470$export$53a21aeef48e14a8)(groupings).map((0, $03b4e9c3be7efafd$export$fb70365b00e8cb7b)),
            ops: [
                'count'
            ],
            as: [
                names.count
            ]
        }, {
            type: 'extent',
            field: names.count,
            signal: names.globalExtent
        }, Object.assign({
            type: 'stack',
            groupby: (0, $29c6c9793f692470$export$53a21aeef48e14a8)(groupings).map((0, $03b4e9c3be7efafd$export$fb70365b00e8cb7b)),
            as: [
                names.stack0,
                names.stack1
            ]
        }, sort && {
            sort: {
                field: (0, $03b4e9c3be7efafd$export$fb70365b00e8cb7b)(sort.name),
                order: 'ascending'
            }
        }));
        (0, $29c6c9793f692470$export$6853292f627997e4)(globalScope.scope, {
            name: names.sequence,
            transform: [
                {
                    type: 'sequence',
                    start: 1,
                    stop: {
                        signal: `sqrt(${names.globalExtent}[1])`
                    }
                },
                {
                    type: 'formula',
                    expr: 'datum.data * datum.data',
                    as: 'squared'
                },
                {
                    type: 'formula',
                    expr: `ceil(${names.globalExtent}[1] / datum.squared)`,
                    as: 'maxlevels'
                },
                {
                    type: 'formula',
                    expr: `(${names.size} - (datum.data - 1) * datum.data) / datum.data`,
                    as: 'side'
                },
                {
                    type: 'formula',
                    expr: 'datum.side * datum.maxlevels + datum.maxlevels - 1',
                    as: 'sidecubeheight'
                },
                {
                    type: 'formula',
                    expr: `abs(${globalScope.zSize} - datum.sidecubeheight)`,
                    as: 'heightmatch'
                },
                {
                    type: 'collect',
                    sort: {
                        field: 'heightmatch',
                        order: 'ascending'
                    }
                },
                {
                    type: 'window',
                    ops: [
                        'row_number'
                    ]
                },
                {
                    type: 'filter',
                    expr: 'datum.row_number === 1'
                }
            ]
        });
        (0, $29c6c9793f692470$export$5346a0d8a9111b3f)(globalScope.scope, {
            name: names.size,
            update: `min((${sizeSignals.layoutHeight}), (${sizeSignals.layoutWidth}))`
        }, {
            name: names.squared,
            update: `data('${names.sequence}')[0].squared`
        }, {
            name: names.sides,
            update: `sqrt(${names.squared})`
        }, {
            name: names.cube,
            update: `(${names.size} - (${names.sides} - 1)) / ${names.sides}`
        }, {
            name: names.maxLevels,
            update: `data('${names.sequence}')[0].maxlevels`
        }, {
            name: names.maxCount,
            update: `${names.maxLevels} * ${names.squared}`
        });
        const zLevel = `floor(datum[${JSON.stringify(names.stack0)}] / ${names.squared})`;
        const layerOrdinal = `(datum[${JSON.stringify(names.stack0)}] % ${names.squared})`;
        const cubeX = `(${layerOrdinal} % ${names.sides})`;
        const cubeY = `floor(${layerOrdinal} / ${names.sides})`;
        const groupX = `(${sizeSignals.layoutWidth} - ${names.size}) / 2`;
        const groupY = `(${sizeSignals.layoutHeight} - ${names.size}) / 2`;
        const offsets = {
            x: (0, $29c6c9793f692470$export$e6b6683aec0fe907)(parentScope.offsets.x, groupX, `${cubeX} * (${names.cube} + 1)`),
            y: (0, $29c6c9793f692470$export$e6b6683aec0fe907)(parentScope.offsets.y, groupY, `${cubeY} * (${names.cube} + 1)`),
            h: names.size,
            w: names.size
        };
        const mark = {
            type: 'rect',
            from: {
                data: this.names.levelDataName
            },
            encode: {
                update: {
                    z: {
                        signal: `${zLevel} * (${names.cube} + 1)`
                    },
                    height: {
                        signal: names.cube
                    },
                    width: {
                        signal: names.cube
                    },
                    depth: {
                        signal: names.cube
                    }
                }
            }
        };
        (0, $29c6c9793f692470$export$3df320e901c23a48)(globalScope.markGroup, mark);
        const zScale = {
            type: 'linear',
            name: names.zScale,
            domain: [
                0,
                {
                    signal: names.maxCount
                }
            ],
            range: [
                0,
                {
                    signal: `${names.maxLevels} * (${names.cube} + 1) - 1`
                }
            ],
            nice: false
        };
        return {
            offsets: offsets,
            mark: mark,
            sizeSignals: {
                layoutHeight: names.size,
                layoutWidth: names.size
            },
            globalScales: {
                showAxes: showAxes,
                scales: {
                    z: [
                        zScale
                    ]
                }
            },
            encodingRuleMap: {
                y: [
                    {
                        test: (0, $0299c0d9f55fe75f$export$71c45f78b1166d35)(),
                        signal: parentScope.offsets.y
                    }
                ],
                z: [
                    {
                        test: (0, $0299c0d9f55fe75f$export$71c45f78b1166d35)(),
                        value: 0
                    }
                ],
                depth: [
                    {
                        test: (0, $0299c0d9f55fe75f$export$71c45f78b1166d35)(),
                        value: 0
                    }
                ],
                height: [
                    {
                        test: (0, $0299c0d9f55fe75f$export$71c45f78b1166d35)(),
                        value: 0
                    }
                ]
            }
        };
    }
}


/*!
* Copyright (c) Microsoft Corporation.
* Licensed under the MIT License.
*/ 





class $e51cd95b5dfb2b00$export$c4df0d8c6c8f50e4 extends (0, $748726ce52deaf5d$export$c84671f46d6a1ca) {
    constructor(props){
        super(props);
        this.props = props;
        const p = this.prefix = `strip_${this.id}`;
        this.names = {
            firstField: `${p}${(0, $8d0624e259fe9d79$export$10df5429b7082be2).First}`,
            lastField: `${p}${(0, $8d0624e259fe9d79$export$10df5429b7082be2).Last}`,
            valueField: `${p}${(0, $8d0624e259fe9d79$export$10df5429b7082be2).Value}`,
            scale: `scale_${p}`,
            zScale: `scale_${p}_z`
        };
    }
    build() {
        const { names: names, prefix: prefix, props: props } = this;
        const { addPercentageScale: addPercentageScale, globalScope: globalScope, groupings: groupings, orientation: orientation, showAxes: showAxes, size: size, sort: sort, sortOrder: sortOrder, parentScope: parentScope, view: view, z: z } = props;
        const zScale = (0, $a2cc661c2a61585d$export$9e1d5954d0bb865c)(z, globalScope.zSize, globalScope.data.name, names.zScale);
        const horizontal = orientation === 'horizontal';
        const transform = [];
        if (sort) transform.push({
            type: 'collect',
            sort: {
                field: (0, $03b4e9c3be7efafd$export$fb70365b00e8cb7b)(sort.name),
                order: sortOrder
            }
        });
        let stackField;
        if (size) {
            stackField = size.name;
            transform.push({
                type: 'filter',
                expr: `datum[${JSON.stringify(size.name)}] > 0`
            });
        } else {
            stackField = names.valueField;
            transform.push({
                type: 'formula',
                expr: '1',
                as: stackField
            });
        }
        const stackTransform = {
            type: 'stack',
            field: (0, $03b4e9c3be7efafd$export$fb70365b00e8cb7b)(stackField),
            offset: 'normalize',
            as: [
                names.firstField,
                names.lastField
            ]
        };
        if (groupings.length) stackTransform.groupby = (0, $29c6c9793f692470$export$53a21aeef48e14a8)(groupings).map((0, $03b4e9c3be7efafd$export$fb70365b00e8cb7b));
        transform.push(stackTransform);
        (0, $29c6c9793f692470$export$eea5d31e98930019)(globalScope.data, ...transform);
        const span = [
            names.lastField,
            names.firstField
        ].map((f)=>`datum[${JSON.stringify(f)}]`).join(' - ');
        const offsets = {
            x: (0, $29c6c9793f692470$export$e6b6683aec0fe907)(parentScope.offsets.x, horizontal ? `datum[${JSON.stringify(names.firstField)}] * (${parentScope.offsets.w})` : ''),
            y: (0, $29c6c9793f692470$export$e6b6683aec0fe907)(parentScope.offsets.y, horizontal ? '' : `datum[${JSON.stringify(names.firstField)}] * (${parentScope.offsets.h})`),
            h: horizontal ? parentScope.offsets.h : `(${span}) * (${parentScope.offsets.h})`,
            w: horizontal ? `(${span}) * (${parentScope.offsets.w})` : parentScope.offsets.w
        };
        const mark = {
            name: prefix,
            type: 'rect',
            from: {
                data: globalScope.markDataName
            },
            encode: {
                update: Object.assign({
                    height: {
                        signal: offsets.h
                    },
                    width: {
                        signal: offsets.w
                    }
                }, z && {
                    z: {
                        value: 0
                    },
                    depth: [
                        {
                            test: (0, $0299c0d9f55fe75f$export$71c45f78b1166d35)(),
                            value: 0
                        },
                        view === '3d' ? {
                            scale: names.zScale,
                            field: (0, $03b4e9c3be7efafd$export$fb70365b00e8cb7b)(z.name)
                        } : {
                            value: 0
                        }
                    ]
                })
            }
        };
        (0, $29c6c9793f692470$export$3df320e901c23a48)(globalScope.markGroup, mark);
        let percentageScale;
        if (addPercentageScale) percentageScale = [
            {
                type: 'linear',
                name: names.scale,
                domain: [
                    0,
                    100
                ],
                range: horizontal ? [
                    0,
                    {
                        signal: parentScope.sizeSignals.layoutWidth
                    }
                ] : [
                    {
                        signal: parentScope.sizeSignals.layoutHeight
                    },
                    0
                ]
            }
        ];
        return {
            globalScales: {
                showAxes: showAxes,
                scales: {
                    x: horizontal ? percentageScale : undefined,
                    y: horizontal ? undefined : percentageScale,
                    z: zScale && [
                        zScale
                    ]
                }
            },
            offsets: offsets,
            sizeSignals: {
                layoutHeight: null,
                layoutWidth: null
            },
            mark: mark
        };
    }
}


/*!
* Copyright (c) Microsoft Corporation.
* Licensed under the MIT License.
*/ 





class $9a589015cb5fa9f5$export$d685cd2b84b49ee extends (0, $748726ce52deaf5d$export$c84671f46d6a1ca) {
    constructor(props){
        super(props);
        this.props = props;
        const p = this.prefix = `treemap_${this.id}`;
        this.names = {
            dataName: `data_${p}`,
            dataHeightWidth: `data_${p}_hw`,
            dataExtents: `data_${p}_extents`,
            dataFacet: `data_${p}_facet`,
            dataFacetMark: `data_${p}_facetMark`,
            fieldChildren: `${p}_children`,
            fieldDepth: `${p}_depth`,
            fieldX0: `${p}_x0`,
            fieldX1: `${p}_x1`,
            fieldY0: `${p}_y0`,
            fieldY1: `${p}_y1`,
            fieldHeight: `${p}_h`,
            fieldWidth: `${p}_w`,
            heightExtent: `${p}_heightExtent`,
            widthExtent: `${p}_widthExtent`,
            zScale: `scale_${p}_z`
        };
    }
    build() {
        const { names: names, props: props } = this;
        const { globalScope: globalScope, parentScope: parentScope, showAxes: showAxes, treeMapMethod: treeMapMethod, z: z } = props;
        const zScale = (0, $a2cc661c2a61585d$export$9e1d5954d0bb865c)(z, globalScope.zSize, globalScope.data.name, names.zScale);
        const offsets = {
            x: (0, $29c6c9793f692470$export$e6b6683aec0fe907)(parentScope.offsets.x, $9a589015cb5fa9f5$var$fn(names.fieldX0)),
            y: (0, $29c6c9793f692470$export$e6b6683aec0fe907)(parentScope.offsets.y, $9a589015cb5fa9f5$var$fn(names.fieldY0)),
            h: $9a589015cb5fa9f5$var$subtract(names.fieldY1, names.fieldY0),
            w: $9a589015cb5fa9f5$var$subtract(names.fieldX1, names.fieldX0)
        };
        const mark = this.transformedMark(offsets);
        (0, $29c6c9793f692470$export$5346a0d8a9111b3f)(globalScope.scope, {
            name: (0, $8d0624e259fe9d79$export$809e371dee643808).TreeMapMethod,
            value: 'squarify',
            bind: {
                name: treeMapMethod,
                input: 'select',
                options: [
                    'squarify',
                    'binary'
                ]
            }
        });
        return Object.assign(Object.assign({}, z && {
            globalScales: {
                showAxes: showAxes,
                scales: {
                    z: [
                        zScale
                    ]
                }
            }
        }), {
            mark: mark,
            offsets: offsets,
            sizeSignals: {
                layoutHeight: null,
                layoutWidth: null
            }
        });
    }
    transformedMark(offsets) {
        const { names: names, props: props } = this;
        const { globalScope: globalScope, groupings: groupings, parentScope: parentScope } = props;
        if (groupings.length) {
            //treemap transform can't have it's boundary size grouped, so we need to facet the data.
            (0, $29c6c9793f692470$export$6853292f627997e4)(globalScope.scope, {
                name: names.dataHeightWidth,
                source: globalScope.markDataName,
                transform: [
                    {
                        type: 'formula',
                        expr: parentScope.offsets.h,
                        as: names.fieldHeight
                    },
                    {
                        type: 'formula',
                        expr: parentScope.offsets.w,
                        as: names.fieldWidth
                    }
                ]
            });
            const treemapData = {
                name: names.dataFacetMark,
                source: names.dataFacet
            };
            const facets = {
                type: 'group',
                from: {
                    facet: {
                        name: names.dataFacet,
                        data: names.dataHeightWidth,
                        groupby: (0, $29c6c9793f692470$export$53a21aeef48e14a8)(groupings).map((0, $03b4e9c3be7efafd$export$fb70365b00e8cb7b))
                    }
                },
                data: [
                    {
                        name: names.dataExtents,
                        source: names.dataFacet,
                        transform: [
                            {
                                type: 'extent',
                                field: names.fieldHeight,
                                signal: names.heightExtent
                            },
                            {
                                type: 'extent',
                                field: names.fieldWidth,
                                signal: names.widthExtent
                            }
                        ]
                    },
                    treemapData
                ]
            };
            globalScope.setMarkDataName(names.dataFacetMark);
            (0, $29c6c9793f692470$export$3df320e901c23a48)(globalScope.markGroup, facets);
            //assign new markgroup after adding mark to original group
            globalScope.setMarkGroup(facets);
            this.treemapTransform(treemapData, `${names.widthExtent}[0]`, `${names.heightExtent}[0]`);
            return this.addMark(offsets, facets, globalScope.markDataName);
        } else {
            this.treemapTransform(globalScope.data, parentScope.offsets.w, parentScope.offsets.h);
            return this.addMark(offsets, globalScope.markGroup, globalScope.markDataName);
        }
    }
    addMark(offsets, markParent, markDataName) {
        const { names: names, prefix: prefix, props: props } = this;
        const { view: view, z: z } = props;
        const mark = {
            name: prefix,
            type: 'rect',
            from: {
                data: markDataName
            },
            encode: {
                update: Object.assign({
                    width: {
                        signal: offsets.w
                    },
                    height: {
                        signal: offsets.h
                    }
                }, z && {
                    z: {
                        value: 0
                    },
                    depth: [
                        {
                            test: (0, $0299c0d9f55fe75f$export$71c45f78b1166d35)(),
                            value: 0
                        },
                        view === '3d' ? {
                            scale: names.zScale,
                            field: (0, $03b4e9c3be7efafd$export$fb70365b00e8cb7b)(z.name)
                        } : {
                            value: 0
                        }
                    ]
                })
            }
        };
        (0, $29c6c9793f692470$export$3df320e901c23a48)(markParent, mark);
        return mark;
    }
    treemapTransform(treemapData, widthSignal, heightSignal) {
        const { names: names, props: props } = this;
        const { group: group, size: size } = props;
        (0, $29c6c9793f692470$export$eea5d31e98930019)(treemapData, {
            type: 'filter',
            expr: `datum[${JSON.stringify(size.name)}] > 0`
        }, {
            type: 'nest',
            keys: [
                group && group.name || '__NONE__'
            ]
        }, {
            type: 'treemap',
            field: (0, $03b4e9c3be7efafd$export$fb70365b00e8cb7b)(size.name),
            sort: {
                field: 'value',
                order: 'descending'
            },
            round: true,
            method: {
                signal: (0, $8d0624e259fe9d79$export$809e371dee643808).TreeMapMethod
            },
            paddingInner: 1,
            paddingOuter: 0,
            size: [
                {
                    signal: widthSignal
                },
                {
                    signal: heightSignal
                }
            ],
            as: [
                names.fieldX0,
                names.fieldY0,
                names.fieldX1,
                names.fieldY1,
                names.fieldDepth,
                names.fieldChildren
            ]
        });
    }
}
function $9a589015cb5fa9f5$var$fn(n) {
    return `datum[${JSON.stringify(n)}]`;
}
function $9a589015cb5fa9f5$var$subtract(...fields) {
    return fields.map((n)=>$9a589015cb5fa9f5$var$fn(n)).join(' - ');
}


/*!
* Copyright (c) Microsoft Corporation.
* Licensed under the MIT License.
*/ 








class $a19e9bd8fb28b427$export$f6b1e3902165e5e1 extends (0, $748726ce52deaf5d$export$c84671f46d6a1ca) {
    constructor(props){
        super(props);
        this.props = props;
        const p = this.prefix = `wrap_${this.id}`;
        this.bin = (0, $d832bf01a4278a5e$export$6868fd1605c79d3d)(this.prefix, props.globalScope.data.name, props.groupby);
        this.names = {
            outputData: `data_${p}_out`,
            rowColumnDataName: `data_${p}_row_col`,
            cellHeight: `${p}_cellHeight`,
            cellWidth: `${p}_cellWidth`,
            fits: `${p}_fits`,
            target: `${p}_target`,
            minArea: `${p}_minArea`,
            aspect: `${p}_aspect`,
            minAspect: `${p}_minAspect`,
            idealAspect: `${p}_idealAspect`,
            dataLength: `${p}_dataLength`,
            rxc0: `${p}_rxc0`,
            rxc1: `${p}_rxc1`,
            rxc2: `${p}_rxc2`,
            rxc: `${p}_rxc`,
            growColCount: `${p}_growColCount`,
            growCellWidth: `${p}_growCellWidth`,
            fitsArea: `${p}_fitsArea`,
            colCount: `${p}_colCount`
        };
    }
    getGrouping() {
        return this.bin.fields;
    }
    build() {
        const { bin: bin, names: names, prefix: prefix, props: props } = this;
        const { axisTextColor: axisTextColor, cellTitles: cellTitles, globalScope: globalScope, parentScope: parentScope } = props;
        let ordinalBinData;
        if (bin.native === false) {
            (0, $29c6c9793f692470$export$5346a0d8a9111b3f)(globalScope.scope, ...bin.signals);
            (0, $29c6c9793f692470$export$eea5d31e98930019)(globalScope.data, ...bin.transforms);
            (0, $29c6c9793f692470$export$6853292f627997e4)(globalScope.scope, bin.dataSequence);
            (0, $29c6c9793f692470$export$eea5d31e98930019)(bin.dataSequence, {
                type: 'formula',
                expr: `indata(${JSON.stringify(globalScope.data.name)}, ${JSON.stringify(bin.fields[0])}, datum[${JSON.stringify(bin.fields[0])}])`,
                as: (0, $8d0624e259fe9d79$export$10df5429b7082be2).Contains
            });
            ordinalBinData = bin.dataSequence.name;
        } else {
            const ord = (0, $3aee2b63ed318776$export$71d2e96f63f1ac97)(globalScope.data.name, prefix, bin.fields, 'ascending');
            (0, $29c6c9793f692470$export$6853292f627997e4)(globalScope.scope, ord.data);
            ordinalBinData = ord.data.name;
        }
        (0, $29c6c9793f692470$export$6853292f627997e4)(globalScope.scope, {
            name: names.rxc0,
            transform: [
                {
                    type: 'sequence',
                    start: 1,
                    stop: {
                        signal: `ceil(sqrt(${names.dataLength})) + 1`
                    }
                },
                {
                    type: 'formula',
                    expr: `ceil(${names.dataLength} / datum.data)`,
                    as: 'complement'
                }
            ]
        }, {
            name: names.rxc1,
            source: names.rxc0,
            transform: [
                {
                    type: 'project',
                    fields: [
                        'data'
                    ],
                    as: [
                        'cols'
                    ]
                }
            ]
        }, {
            name: names.rxc2,
            source: names.rxc0,
            transform: [
                {
                    type: 'project',
                    fields: [
                        'complement'
                    ],
                    as: [
                        'cols'
                    ]
                }
            ]
        }, {
            name: names.rxc,
            source: [
                names.rxc1,
                names.rxc2
            ],
            transform: [
                {
                    type: 'formula',
                    expr: `ceil(${names.dataLength} / datum.cols)`,
                    as: 'rows'
                },
                {
                    type: 'formula',
                    expr: `${parentScope.sizeSignals.layoutWidth} / datum.cols`,
                    as: 'cellw'
                },
                {
                    type: 'formula',
                    expr: `datum.cols === 1 ? max(datum.cellw, ${(0, $8d0624e259fe9d79$export$809e371dee643808).MinCellWidth}) : datum.cellw`,
                    as: 'cellw'
                },
                {
                    type: 'formula',
                    expr: `${parentScope.sizeSignals.layoutHeight} / datum.rows`,
                    as: 'cellh'
                },
                {
                    type: 'formula',
                    expr: `datum.rows === 1 ? max(datum.cellh, ${(0, $8d0624e259fe9d79$export$809e371dee643808).MinCellHeight}) : datum.cellh`,
                    as: 'cellh'
                },
                {
                    type: 'formula',
                    expr: `(datum.cellw >= ${(0, $8d0624e259fe9d79$export$809e371dee643808).MinCellWidth} && datum.cellh >= ${(0, $8d0624e259fe9d79$export$809e371dee643808).MinCellHeight})`,
                    as: 'meetsmin'
                },
                {
                    type: 'filter',
                    expr: 'datum.meetsmin'
                },
                {
                    type: 'formula',
                    expr: 'datum.cellw / datum.cellh',
                    as: names.aspect
                },
                {
                    type: 'formula',
                    expr: `abs(datum.${names.aspect} - ${names.target})`,
                    as: names.idealAspect
                },
                {
                    type: 'formula',
                    expr: `${names.dataLength} / (datum.cols * datum.rows)`,
                    as: 'coverage'
                },
                {
                    type: 'collect',
                    sort: {
                        field: [
                            names.idealAspect,
                            'coverage'
                        ],
                        order: [
                            'ascending',
                            'descending'
                        ]
                    }
                }
            ]
        }, {
            name: names.rowColumnDataName,
            source: ordinalBinData,
            transform: [
                {
                    type: 'formula',
                    expr: `floor((datum[${JSON.stringify((0, $8d0624e259fe9d79$export$10df5429b7082be2).Ordinal)}] - 1) / ${names.colCount})`,
                    as: (0, $8d0624e259fe9d79$export$10df5429b7082be2).WrapRow
                },
                {
                    type: 'formula',
                    expr: `(datum[${JSON.stringify((0, $8d0624e259fe9d79$export$10df5429b7082be2).Ordinal)}] - 1) % ${names.colCount}`,
                    as: (0, $8d0624e259fe9d79$export$10df5429b7082be2).WrapCol
                },
                {
                    type: 'formula',
                    expr: (0, $b12a1eed38ffb3f0$export$b292ca0d4c2e4690)(bin, (0, $8d0624e259fe9d79$export$10df5429b7082be2).First, (0, $8d0624e259fe9d79$export$10df5429b7082be2).Last),
                    as: (0, $8d0624e259fe9d79$export$10df5429b7082be2).FacetSearch
                },
                {
                    type: 'formula',
                    expr: (0, $b12a1eed38ffb3f0$export$f241323700beca17)(bin),
                    as: (0, $8d0624e259fe9d79$export$10df5429b7082be2).FacetTitle
                }
            ]
        });
        const dataOut = {
            name: names.outputData,
            source: globalScope.data.name,
            transform: [
                {
                    type: 'lookup',
                    from: names.rowColumnDataName,
                    key: (0, $03b4e9c3be7efafd$export$fb70365b00e8cb7b)(bin.fields[0]),
                    fields: [
                        bin.fields[0]
                    ].map((0, $03b4e9c3be7efafd$export$fb70365b00e8cb7b)),
                    values: [
                        (0, $8d0624e259fe9d79$export$10df5429b7082be2).WrapRow,
                        (0, $8d0624e259fe9d79$export$10df5429b7082be2).WrapCol
                    ]
                }
            ]
        };
        (0, $29c6c9793f692470$export$6853292f627997e4)(globalScope.scope, dataOut);
        globalScope.setMarkDataName(names.outputData);
        (0, $29c6c9793f692470$export$5346a0d8a9111b3f)(globalScope.scope, {
            name: names.minAspect,
            update: `${(0, $8d0624e259fe9d79$export$809e371dee643808).MinCellWidth} / ${(0, $8d0624e259fe9d79$export$809e371dee643808).MinCellHeight}`
        }, {
            name: names.target,
            update: `${names.minAspect} === 1 ? ${1.2} : ${names.minAspect}`
        }, {
            name: names.minArea,
            update: `${(0, $8d0624e259fe9d79$export$809e371dee643808).MinCellWidth}*${(0, $8d0624e259fe9d79$export$809e371dee643808).MinCellHeight}`
        }, {
            name: names.aspect,
            update: `${parentScope.sizeSignals.layoutWidth} / ${parentScope.sizeSignals.layoutHeight}`
        }, {
            name: names.dataLength,
            update: `data(${JSON.stringify(ordinalBinData)}).length`
        }, {
            name: names.growColCount,
            update: `max(floor(${parentScope.sizeSignals.layoutWidth} / ${(0, $8d0624e259fe9d79$export$809e371dee643808).MinCellWidth}), 1)`
        }, {
            name: names.growCellWidth,
            update: `${parentScope.sizeSignals.layoutWidth} / ${names.growColCount}`
        }, {
            name: names.fitsArea,
            update: `((${names.dataLength} * ${names.minArea}) <= (${parentScope.sizeSignals.layoutWidth} * ${parentScope.sizeSignals.layoutHeight}))`
        }, {
            name: names.fits,
            update: `${names.fitsArea} && length(data(${JSON.stringify(names.rxc)})) > 0`
        }, {
            name: names.colCount,
            update: `${names.fits} ? data(${JSON.stringify(names.rxc)})[0].cols : ${names.growColCount}`
        }, {
            name: names.cellWidth,
            update: `${names.fits} ? data(${JSON.stringify(names.rxc)})[0].cellw : ${names.growCellWidth}`
        }, {
            name: names.cellHeight,
            update: `${names.fits} ? data(${JSON.stringify(names.rxc)})[0].cellh : ${(0, $8d0624e259fe9d79$export$809e371dee643808).MinCellHeight}`
        });
        (0, $8243f48596a5f195$export$cdc9366ba30317bd)(globalScope.signals.plotHeightOut, 'max', `(${names.cellHeight} * ceil(${names.dataLength} / ${names.colCount}))`);
        (0, $8243f48596a5f195$export$cdc9366ba30317bd)(globalScope.signals.plotWidthOut, 'max', `(${names.cellWidth} * ${names.colCount})`);
        const signalH = [
            names.cellHeight,
            (0, $8d0624e259fe9d79$export$809e371dee643808).FacetPaddingTop,
            (0, $8d0624e259fe9d79$export$809e371dee643808).FacetPaddingBottom
        ].join(' - ');
        const signalW = [
            names.cellWidth,
            (0, $8d0624e259fe9d79$export$809e371dee643808).FacetPaddingLeft
        ].join(' - ');
        const signalX = (0, $29c6c9793f692470$export$e6b6683aec0fe907)(parentScope.offsets.x, `datum[${JSON.stringify((0, $8d0624e259fe9d79$export$10df5429b7082be2).WrapCol)}] * ${names.cellWidth}`, (0, $8d0624e259fe9d79$export$809e371dee643808).FacetPaddingLeft);
        const signalY = (0, $29c6c9793f692470$export$e6b6683aec0fe907)(parentScope.offsets.y, `datum[${JSON.stringify((0, $8d0624e259fe9d79$export$10df5429b7082be2).WrapRow)}] * ${names.cellHeight}`, (0, $8d0624e259fe9d79$export$809e371dee643808).FacetPaddingTop);
        const update = {
            height: {
                signal: signalH
            },
            width: {
                signal: signalW
            },
            x: {
                signal: signalX
            },
            y: {
                signal: signalY
            }
        };
        const offsets = {
            x: signalX,
            y: signalY,
            h: signalH,
            w: signalW
        };
        const group = {
            style: 'cell',
            name: prefix,
            type: 'group',
            from: {
                data: names.rowColumnDataName
            },
            encode: {
                update: update
            }
        };
        (0, $29c6c9793f692470$export$3df320e901c23a48)(globalScope.markGroup, group);
        const sizeSignals = {
            layoutHeight: `(${names.cellHeight} - ${(0, $8d0624e259fe9d79$export$809e371dee643808).FacetPaddingTop} - ${(0, $8d0624e259fe9d79$export$809e371dee643808).FacetPaddingBottom})`,
            layoutWidth: `(${names.cellWidth} - ${(0, $8d0624e259fe9d79$export$809e371dee643808).FacetPaddingLeft})`,
            colCount: names.colCount,
            rowCount: `ceil(${names.dataLength} / ${names.colCount})`
        };
        if (cellTitles) (0, $e298df2c870b2b1c$export$3735b1dd76112836)(group, sizeSignals, axisTextColor);
        return {
            facetScope: group,
            sizeSignals: sizeSignals,
            offsets: offsets
        };
    }
}


const $d2f9d48e526138d2$export$8b2ec0ba67742226 = {
    AggregateContainer: $eff5a80a5e96c249$export$fd744dfcd98e5f49,
    AggregateSquare: $efc98e91e3f0ced6$export$7eda37970b01b2c,
    Band: $cef2083591a92ad5$export$5b22a87d7feca398,
    Cross: $ad34ec84cd0de2bf$export$3c877bb842c36952,
    Scatter: $400f8948076e2f06$export$1c460fb4285edadc,
    Square: $0921378644518b2d$export$b09fb900337259de,
    Stack: $ea238a52b780f861$export$694e0d28c7ffc90c,
    Strip: $e51cd95b5dfb2b00$export$c4df0d8c6c8f50e4,
    Treemap: $9a589015cb5fa9f5$export$d685cd2b84b49ee,
    Wrap: $a19e9bd8fb28b427$export$f6b1e3902165e5e1
};


/*!
* Copyright (c) Microsoft Corporation.
* Licensed under the MIT License.
*/ 
function $3793daba4819864c$export$f4cf47d56985b7f(backgroundImage, allGlobalScales) {
    const xScale = allGlobalScales.filter((s)=>s.scales.x)[0].scales.x[0];
    const yScale = allGlobalScales.filter((s)=>s.scales.y)[0].scales.y[0];
    const [xScaleName, yScaleName] = [
        xScale,
        yScale
    ].map((s)=>s.name + (xScale.type === 'band' ? (0, $cef2083591a92ad5$export$d437166a1bdbfdf0) : ''));
    return {
        type: 'image',
        encode: {
            update: {
                url: {
                    value: backgroundImage.url
                },
                aspect: {
                    value: false
                },
                baseline: {
                    value: 'bottom'
                },
                height: {
                    signal: $3793daba4819864c$var$getScaledSpan(yScaleName, backgroundImage.extents.bottom, backgroundImage.extents.top)
                },
                y: {
                    signal: $3793daba4819864c$var$getScaledValue(yScaleName, backgroundImage.extents.bottom)
                },
                width: {
                    signal: $3793daba4819864c$var$getScaledSpan(xScaleName, backgroundImage.extents.right, backgroundImage.extents.left)
                },
                x: {
                    signal: $3793daba4819864c$var$getScaledValue(xScaleName, backgroundImage.extents.left)
                }
            }
        }
    };
}
function $3793daba4819864c$var$getScaledSpan(scaleName, low, high) {
    return `abs(scale('${scaleName}', ${low}) - scale('${scaleName}', ${high}))`;
}
function $3793daba4819864c$var$getScaledValue(scaleName, value) {
    return `scale('${scaleName}', ${value})`;
}


class $6425b6452dfc228b$export$e2e6dd2b1097c25b {
    constructor(props, specContext){
        this.props = props;
        this.specContext = specContext;
        this.globalSignals = {
            facetAxesAdjustX: {
                name: (0, $8d0624e259fe9d79$export$809e371dee643808).FacetAxesAdjustX,
                update: props.facetLayout && props.collapseFacetAxes ? (0, $72552551eb533aa6$export$6bd206e55cb747ae).toString() : '0'
            },
            facetAxesAdjustY: {
                name: (0, $8d0624e259fe9d79$export$809e371dee643808).FacetAxesAdjustY,
                update: props.facetLayout && props.collapseFacetAxes ? (0, $72552551eb533aa6$export$bdb7a7da14f9ff2b).toString() : '0'
            },
            minCellWidth: {
                name: (0, $8d0624e259fe9d79$export$809e371dee643808).MinCellWidth,
                update: `${0, $72552551eb533aa6$export$7794a0aff56142de}`
            },
            minCellHeight: {
                name: (0, $8d0624e259fe9d79$export$809e371dee643808).MinCellHeight,
                update: `${0, $72552551eb533aa6$export$7c432db1d0b63312}`
            },
            plotOffsetLeft: {
                name: (0, $8d0624e259fe9d79$export$809e371dee643808).PlotOffsetLeft,
                update: '0'
            },
            plotOffsetTop: {
                name: (0, $8d0624e259fe9d79$export$809e371dee643808).PlotOffsetTop,
                update: '0'
            },
            plotOffsetBottom: {
                name: (0, $8d0624e259fe9d79$export$809e371dee643808).PlotOffsetBottom,
                update: '0'
            },
            plotOffsetRight: {
                name: (0, $8d0624e259fe9d79$export$809e371dee643808).PlotOffsetRight,
                update: '0'
            },
            plotHeightOut: {
                name: (0, $8d0624e259fe9d79$export$809e371dee643808).PlotHeightOut,
                update: (0, $8d0624e259fe9d79$export$809e371dee643808).PlotHeightIn
            },
            plotWidthOut: {
                name: (0, $8d0624e259fe9d79$export$809e371dee643808).PlotWidthOut,
                update: (0, $8d0624e259fe9d79$export$809e371dee643808).PlotWidthIn
            }
        };
    }
    validate() {
        const { specContext: specContext } = this;
        const { specCapabilities: specCapabilities } = this.props;
        const { roles: roles } = specCapabilities;
        const required = roles.filter((r)=>{
            switch(typeof r.allowNone){
                case 'boolean':
                    return !r.allowNone;
                case 'undefined':
                    return true;
                case 'function':
                    return !r.allowNone(specContext);
            }
        });
        const numeric = roles.filter((r)=>r.excludeCategoric);
        const errors = required.map((r)=>{
            if (specContext.specColumns[r.role]) return null;
            else return `Field ${r.role} is required.`;
        }).concat(numeric.map((r)=>{
            if (specContext.specColumns[r.role] && !specContext.specColumns[r.role].quantitative) return `Field ${r.role} must be quantitative.`;
            else return null;
        })).filter(Boolean);
        const { backgroundImage: backgroundImage } = specContext.insight;
        if (backgroundImage && !backgroundImage.extents) errors.push('BackgroundImage must have extents.');
        return errors;
    }
    build() {
        var _a, _b;
        const { globalSignals: globalSignals, specContext: specContext } = this;
        const { facetLayout: facetLayout, specCapabilities: specCapabilities } = this.props;
        const { insight: insight, specColumns: specColumns, specViewOptions: specViewOptions } = specContext;
        const dataName = 'data_source';
        const { vegaSpec: vegaSpec, groupMark: groupMark } = this.initSpec(dataName);
        const { topColorField: topColorField, colorDataName: colorDataName } = (0, $925be6cd5bedf086$export$4c4d9288a45f1fb3)({
            scope: vegaSpec,
            dataName: dataName,
            specContext: specContext,
            scaleName: (0, $8d0624e259fe9d79$export$c9f17d36dfc40d76).Color,
            legendDataName: 'data_legend',
            topLookupName: 'data_topcolorlookup',
            colorReverseSignalName: (0, $8d0624e259fe9d79$export$809e371dee643808).ColorReverse
        });
        const globalScope = new (0, $cc404f7847ffd5bf$export$5fdf684e73bb2de5)({
            dataName: colorDataName,
            markGroup: groupMark,
            scope: vegaSpec,
            signals: globalSignals
        });
        if (facetLayout) {
            (0, $29c6c9793f692470$export$5346a0d8a9111b3f)(vegaSpec, {
                name: (0, $8d0624e259fe9d79$export$809e371dee643808).FacetPaddingBottom,
                update: `${facetLayout.facetPadding.bottom}`
            }, {
                name: (0, $8d0624e259fe9d79$export$809e371dee643808).FacetPaddingLeft,
                update: `${facetLayout.facetPadding.left}`
            }, {
                name: (0, $8d0624e259fe9d79$export$809e371dee643808).FacetPaddingTop,
                update: `${facetLayout.facetPadding.top}`
            });
            globalSignals.plotOffsetTop.update = `${facetLayout.plotPadding.y}`;
            globalSignals.plotOffsetRight.update = `${facetLayout.plotPadding.x}`;
        }
        const { firstScope: firstScope, finalScope: finalScope, specResult: specResult, allGlobalScales: allGlobalScales, allEncodingRules: allEncodingRules } = this.iterateLayouts(globalScope, (i, innerScope)=>{
            if (facetLayout && i === 0) globalScope.zSize = innerScope.offsets.h;
        });
        if (specResult) return specResult;
        if (allGlobalScales.length > 0) {
            const plotHeightOut = globalSignals.plotHeightOut.name;
            const plotWidthOut = globalSignals.plotWidthOut.name;
            const colTitleScale = {
                type: 'linear',
                name: 'scale_facet_col_title',
                domain: [
                    0,
                    1
                ],
                range: [
                    0,
                    {
                        signal: plotWidthOut
                    }
                ]
            };
            const rowTitleScale = {
                type: 'linear',
                name: 'scale_facet_row_title',
                domain: [
                    0,
                    1
                ],
                range: [
                    {
                        signal: plotHeightOut
                    },
                    0
                ]
            };
            const facetScope = facetLayout ? firstScope : null;
            const backgroundGroup = facetLayout ? facetScope.facetScope : groupMark;
            //TODO if capability and numeric x,y
            if (insight.backgroundImage && specCapabilities.backgroundImage && ((_a = specColumns.x) === null || _a === void 0 ? void 0 : _a.quantitative) && ((_b = specColumns.y) === null || _b === void 0 ? void 0 : _b.quantitative)) {
                //backgroundGroup.encode.update.fill = { value: 'pink' }
                if (!backgroundGroup.marks) backgroundGroup.marks = [];
                const imageMark = (0, $3793daba4819864c$export$f4cf47d56985b7f)(insight.backgroundImage, allGlobalScales);
                backgroundGroup.marks.unshift(imageMark);
            }
            const axesScopes = facetLayout ? (0, $e298df2c870b2b1c$export$9f0b19d6fd936707)({
                globalScope: globalScope.scope,
                plotScope: groupMark,
                facetScope: facetScope,
                colTitleScale: colTitleScale,
                rowTitleScale: rowTitleScale,
                colSeqName: 'data_FacetCellColTitles',
                rowSeqName: 'data_FacetCellRowTitles'
            }) : {
                main: [
                    {
                        scope: groupMark,
                        lines: true,
                        labels: true,
                        title: true
                    }
                ]
            };
            (0, $fabd8225a03f89c4$export$3678bfcfeaea7c36)({
                globalScope: globalScope,
                allGlobalScales: allGlobalScales,
                axisScales: this.props.axisScales,
                plotOffsetSignals: {
                    x: globalSignals.plotOffsetLeft,
                    y: globalSignals.plotOffsetBottom
                },
                axesOffsets: {
                    x: (0, $72552551eb533aa6$export$3f5b554d51e74365),
                    y: (0, $72552551eb533aa6$export$c33f11801bb18430)
                },
                axesTitlePadding: facetLayout ? {
                    x: (0, $72552551eb533aa6$export$fd4a597070549ada),
                    y: (0, $72552551eb533aa6$export$a26a082bf9fa4ca0)
                } : {
                    x: (0, $72552551eb533aa6$export$2e7279af2df830e3),
                    y: (0, $72552551eb533aa6$export$f0388d9263db6e5f)
                },
                labelBaseline: {
                    x: 'top',
                    y: 'middle'
                },
                specColumns: specColumns,
                specViewOptions: specViewOptions,
                axesScopes: axesScopes,
                hideZAxis: !!facetLayout,
                view: insight.view
            });
        }
        //add mark to the final scope
        if (finalScope.mark) {
            const { update: update } = finalScope.mark.encode;
            const outputDataName = 'output';
            finalScope.mark.from.data = outputDataName;
            (0, $29c6c9793f692470$export$6853292f627997e4)(globalScope.markGroup, {
                name: outputDataName,
                source: globalScope.markDataName,
                transform: [
                    {
                        type: 'formula',
                        expr: finalScope.offsets.x,
                        as: (0, $8d0624e259fe9d79$export$10df5429b7082be2).OffsetX
                    },
                    {
                        type: 'formula',
                        expr: finalScope.offsets.y,
                        as: (0, $8d0624e259fe9d79$export$10df5429b7082be2).OffsetY
                    }
                ]
            });
            update.x = {
                field: (0, $8d0624e259fe9d79$export$10df5429b7082be2).OffsetX
            };
            update.y = {
                field: (0, $8d0624e259fe9d79$export$10df5429b7082be2).OffsetY
            };
            allEncodingRules.forEach((map)=>{
                for(const key in map)if (update[key]) {
                    const arrIn = map[key];
                    if (!Array.isArray(update[key])) {
                        const value = update[key];
                        const arrOut = [];
                        update[key] = arrOut;
                        arrIn.forEach((rule)=>arrOut.push(rule));
                        arrOut.push(value);
                    } else {
                        const arrOut = update[key];
                        arrIn.forEach((rule)=>arrOut.unshift(rule));
                    }
                }
            });
            update.fill = (0, $895ef9e095ded5c9$export$9563e054e6f787fb)(specContext, topColorField, (0, $8d0624e259fe9d79$export$c9f17d36dfc40d76).Color);
            update.opacity = (0, $895ef9e095ded5c9$export$c17a3be1057836e)(specContext);
        }
        return {
            specCapabilities: specCapabilities,
            vegaSpec: vegaSpec
        };
    }
    initSpec(dataName) {
        const { globalSignals: globalSignals } = this;
        const { facetAxesAdjustX: facetAxesAdjustX, facetAxesAdjustY: facetAxesAdjustY, minCellWidth: minCellWidth, minCellHeight: minCellHeight, plotOffsetLeft: plotOffsetLeft, plotOffsetBottom: plotOffsetBottom, plotOffsetTop: plotOffsetTop, plotOffsetRight: plotOffsetRight, plotHeightOut: plotHeightOut, plotWidthOut: plotWidthOut } = globalSignals;
        const { specContext: specContext } = this;
        const { insight: insight } = specContext;
        const groupMark = {
            type: 'group',
            //style: 'cell',
            encode: {
                update: {
                    x: {
                        signal: `${(0, $8d0624e259fe9d79$export$809e371dee643808).PlotOffsetLeft} - ${(0, $8d0624e259fe9d79$export$809e371dee643808).FacetAxesAdjustX}`
                    },
                    y: {
                        signal: (0, $8d0624e259fe9d79$export$809e371dee643808).PlotOffsetTop
                    },
                    height: {
                        signal: `${(0, $8d0624e259fe9d79$export$809e371dee643808).PlotHeightOut} - ${(0, $8d0624e259fe9d79$export$809e371dee643808).FacetAxesAdjustY}`
                    },
                    width: {
                        signal: `${(0, $8d0624e259fe9d79$export$809e371dee643808).PlotWidthOut} + ${(0, $8d0624e259fe9d79$export$809e371dee643808).FacetAxesAdjustX}`
                    }
                }
            }
        };
        const inputDataname = 'input';
        const vegaSpec = {
            $schema: 'https://vega.github.io/schema/vega/v5.json',
            //style: 'cell',
            data: [
                {
                    name: inputDataname
                },
                {
                    name: dataName,
                    source: inputDataname,
                    transform: []
                }
            ],
            marks: [
                groupMark
            ],
            signals: (0, $8243f48596a5f195$export$d9407ec206a3236c)(specContext, (0, $8d0624e259fe9d79$export$809e371dee643808).ViewportHeight).concat([
                minCellWidth,
                minCellHeight,
                {
                    name: (0, $8d0624e259fe9d79$export$809e371dee643808).ViewportHeight,
                    update: `max(${(0, $8d0624e259fe9d79$export$809e371dee643808).MinCellHeight}, ${insight.size.height})`
                },
                {
                    name: (0, $8d0624e259fe9d79$export$809e371dee643808).ViewportWidth,
                    update: `max(${(0, $8d0624e259fe9d79$export$809e371dee643808).MinCellWidth}, ${insight.size.width})`
                },
                plotOffsetLeft,
                plotOffsetTop,
                plotOffsetBottom,
                plotOffsetRight,
                facetAxesAdjustX,
                facetAxesAdjustY,
                {
                    name: (0, $8d0624e259fe9d79$export$809e371dee643808).PlotHeightIn,
                    update: `${(0, $8d0624e259fe9d79$export$809e371dee643808).ViewportHeight} - ${(0, $8d0624e259fe9d79$export$809e371dee643808).PlotOffsetBottom} + ${(0, $8d0624e259fe9d79$export$809e371dee643808).FacetAxesAdjustY}`
                },
                {
                    name: (0, $8d0624e259fe9d79$export$809e371dee643808).PlotWidthIn,
                    update: `${(0, $8d0624e259fe9d79$export$809e371dee643808).ViewportWidth} - ${(0, $8d0624e259fe9d79$export$809e371dee643808).PlotOffsetLeft} - ${(0, $8d0624e259fe9d79$export$809e371dee643808).PlotOffsetRight}`
                },
                plotHeightOut,
                plotWidthOut,
                {
                    name: 'height',
                    update: `${(0, $8d0624e259fe9d79$export$809e371dee643808).PlotOffsetTop} + ${(0, $8d0624e259fe9d79$export$809e371dee643808).PlotHeightOut} + ${(0, $8d0624e259fe9d79$export$809e371dee643808).PlotOffsetBottom} - ${(0, $8d0624e259fe9d79$export$809e371dee643808).FacetAxesAdjustY}`
                },
                {
                    name: 'width',
                    update: `${(0, $8d0624e259fe9d79$export$809e371dee643808).PlotWidthOut} + ${(0, $8d0624e259fe9d79$export$809e371dee643808).PlotOffsetLeft} + ${(0, $8d0624e259fe9d79$export$809e371dee643808).PlotOffsetRight}`
                }
            ])
        };
        return {
            vegaSpec: vegaSpec,
            groupMark: groupMark
        };
    }
    iterateLayouts(globalScope, onLayoutBuild) {
        let specResult;
        let parentScope = {
            sizeSignals: globalScope.sizeSignals,
            offsets: globalScope.offsets
        };
        let firstScope;
        let childScope;
        const groupings = [];
        const { layouts: layouts, specCapabilities: specCapabilities } = this.props;
        const allGlobalScales = [];
        const allEncodingRules = [];
        for(let i = 0; i < layouts.length; i++){
            if (!parentScope) continue;
            const buildProps = {
                globalScope: globalScope,
                parentScope: parentScope,
                axesScales: this.props.axisScales,
                groupings: groupings,
                id: i
            };
            const layout = this.createLayout(layouts[i], buildProps);
            try {
                childScope = layout.build();
                childScope.id = i;
                const groupby = layout.getGrouping();
                if (groupby) groupings.push({
                    id: i,
                    groupby: groupby,
                    fieldOps: [
                        {
                            field: null,
                            op: 'count',
                            as: (0, $8d0624e259fe9d79$export$10df5429b7082be2).Count
                        }
                    ]
                });
                const sumOp = layout.getAggregateSumOp();
                if (sumOp) groupings[groupings.length - 1].fieldOps.push(sumOp);
                onLayoutBuild(i, childScope);
            } catch (e) {
                specResult = {
                    errors: [
                        e.stack
                    ],
                    specCapabilities: specCapabilities,
                    vegaSpec: null
                };
                break;
            }
            if (childScope && childScope.globalScales) allGlobalScales.push(childScope.globalScales);
            if (childScope.encodingRuleMap) allEncodingRules.push(childScope.encodingRuleMap);
            if (i === 0) firstScope = childScope;
            parentScope = childScope;
        }
        return {
            firstScope: firstScope,
            finalScope: parentScope,
            specResult: specResult,
            allGlobalScales: allGlobalScales,
            allEncodingRules: allEncodingRules
        };
    }
    createLayout(layoutPair, buildProps) {
        const { layoutType: layoutType, props: props } = layoutPair;
        const layoutBuildProps = Object.assign(Object.assign({}, props), buildProps);
        const layoutClass = (0, $d2f9d48e526138d2$export$8b2ec0ba67742226)[layoutType];
        const layout = new layoutClass(layoutBuildProps);
        layout.id = buildProps.id;
        return layout;
    }
}


function $1c081eb26c39473d$export$3f8fe6489e95757d(specContext, currData) {
    const { specColumns: specColumns } = specContext;
    const columns = [
        specColumns.color,
        specColumns.facet,
        specColumns.facetV,
        specColumns.group,
        specColumns.size,
        specColumns.sort,
        specColumns.x,
        specColumns.y,
        specColumns.z
    ];
    (0, $15b363a2e3ff0bb7$export$e04a97cc71178399)(columns, currData);
    const specBuilderProps = (0, $8e72bac502e5efb8$export$104083a36c1647a7)(specContext);
    const specBuilder = new (0, $6425b6452dfc228b$export$e2e6dd2b1097c25b)(specBuilderProps, specContext);
    let specResult;
    if (specBuilder) {
        try {
            const errors = specBuilder.validate();
            if (errors.length) specResult = {
                errors: errors,
                specCapabilities: specBuilderProps.specCapabilities,
                vegaSpec: null
            };
            else specResult = specBuilder.build();
        } catch (e) {
            specResult = {
                specCapabilities: null,
                vegaSpec: null,
                errors: [
                    e.stack
                ]
            };
        }
        if (!specResult.errors) {
            const data0 = specResult.vegaSpec.data[0];
            data0.values = currData;
        }
    } else specResult = {
        specCapabilities: null,
        vegaSpec: null,
        errors: [
            `could not build spec for ${specContext.insight.chart}`
        ]
    };
    return specResult;
}




var $ca675dc6df12c0ef$exports = {};
/*!
* Copyright (c) Microsoft Corporation.
* Licensed under the MIT License.
*/ 

var $46296c7ebdd844d1$exports = {};
/*!
* Copyright (c) Microsoft Corporation.
* Licensed under the MIT License.
*/ 

$parcel$exportWildcard($502a84774beeb901$exports, $1c081eb26c39473d$exports);
$parcel$exportWildcard($502a84774beeb901$exports, $8d0624e259fe9d79$exports);
$parcel$exportWildcard($502a84774beeb901$exports, $2b29a67d615af3f6$exports);
$parcel$exportWildcard($502a84774beeb901$exports, $ca675dc6df12c0ef$exports);
$parcel$exportWildcard($502a84774beeb901$exports, $46296c7ebdd844d1$exports);


const $44b8bb162b63b5b5$export$5672246984822a29 = 'GL_ORDINAL';


var $0d976ebdc81921a3$exports = {};
/*!
* Copyright (c) Microsoft Corporation.
* Licensed under the MIT License.
*/ var $4c4e2fc4d7da02f0$exports = {};

$parcel$export($4c4e2fc4d7da02f0$exports, "compareExpression", () => $4c4e2fc4d7da02f0$export$4787a3c825f2af47);
$parcel$export($4c4e2fc4d7da02f0$exports, "compareGroup", () => $4c4e2fc4d7da02f0$export$bc9dff9b0aa0e5b);
$parcel$export($4c4e2fc4d7da02f0$exports, "compare", () => $4c4e2fc4d7da02f0$export$398604a469f7de9a);
$parcel$export($4c4e2fc4d7da02f0$exports, "startsWith", () => $4c4e2fc4d7da02f0$export$68326237475e9a7d);
/*!
* Copyright (c) Microsoft Corporation.
* Licensed under the MIT License.
*/ var $ba55906944328f12$exports = {};

$parcel$export($ba55906944328f12$exports, "isSearchExpressionGroup", () => $ba55906944328f12$export$ab134d298d957272);
$parcel$export($ba55906944328f12$exports, "createGroupFromExpression", () => $ba55906944328f12$export$cf32a499fcfecacd);
$parcel$export($ba55906944328f12$exports, "ensureSearchExpressionGroupArray", () => $ba55906944328f12$export$b5d04ce3dd7ae29e);
/*!
* Copyright (c) Microsoft Corporation.
* Licensed under the MIT License.
*/ function $ba55906944328f12$export$ab134d298d957272(search) {
    if (!search) return false;
    return !!search.expressions;
}
function $ba55906944328f12$export$cf32a499fcfecacd(input) {
    const output = {
        expressions: [
            input
        ]
    };
    return output;
}
function $ba55906944328f12$export$b5d04ce3dd7ae29e(search) {
    if (Array.isArray(search)) return [
        ...search
    ];
    else if ($ba55906944328f12$export$ab134d298d957272(search)) return [
        search
    ];
    else return [
        $ba55906944328f12$export$cf32a499fcfecacd(search)
    ];
}


const $4c4e2fc4d7da02f0$var$expressionKeys = Object.keys({
    clause: null,
    name: null,
    operator: null,
    value: null
});
function $4c4e2fc4d7da02f0$export$4787a3c825f2af47(a, b) {
    if (a && b) for(let k = 0; k < $4c4e2fc4d7da02f0$var$expressionKeys.length; k++){
        const key = $4c4e2fc4d7da02f0$var$expressionKeys[k];
        if (a[key] != b[key]) return false;
    }
    else return !a && !b;
    return true;
}
const $4c4e2fc4d7da02f0$var$groupKeys = Object.keys({
    clause: null
});
function $4c4e2fc4d7da02f0$export$bc9dff9b0aa0e5b(a, b) {
    for(let k = 0; k < $4c4e2fc4d7da02f0$var$groupKeys.length; k++){
        const key = $4c4e2fc4d7da02f0$var$groupKeys[k];
        if (a[key] != b[key]) return false;
    }
    if (!a.expressions && !b.expressions) return true;
    if (!a.expressions || !b.expressions) return false;
    if (a.expressions.length != b.expressions.length) return false;
    for(let i = 0; i < a.expressions.length; i++){
        if (!$4c4e2fc4d7da02f0$export$4787a3c825f2af47(a.expressions[i], b.expressions[i])) return false;
    }
    return true;
}
function $4c4e2fc4d7da02f0$export$398604a469f7de9a(a, b) {
    if (a == b) return true;
    if (!a || !b) return false;
    const arrs = [
        a,
        b
    ].map((0, $ba55906944328f12$export$b5d04ce3dd7ae29e));
    const [arrA, arrB] = arrs;
    if (arrA.length != arrB.length) return false;
    for(let i = 0; i < arrA.length; i++){
        if (!$4c4e2fc4d7da02f0$export$bc9dff9b0aa0e5b(arrA[i], arrB[i])) return false;
    }
    return true;
}
function $4c4e2fc4d7da02f0$export$68326237475e9a7d(whole, part) {
    if (!part) return true;
    const arrs = [
        whole,
        part
    ].map((0, $ba55906944328f12$export$b5d04ce3dd7ae29e));
    const [wholeArray, partArray] = arrs;
    if (partArray.length > wholeArray.length) return false;
    for(let i = 0; i < partArray.length; i++){
        if (!$4c4e2fc4d7da02f0$export$bc9dff9b0aa0e5b(wholeArray[i], partArray[i])) return false;
    }
    return true;
}


var $60ec9c9c9a132a89$exports = {};

$parcel$export($60ec9c9c9a132a89$exports, "Exec", () => $60ec9c9c9a132a89$export$bbfd672d43392844);
/*!
* Copyright (c) Microsoft Corporation.
* Licensed under the MIT License.
*/ 
function $60ec9c9c9a132a89$var$valueToBoolean(value) {
    if (typeof value === 'string') switch(value.toLowerCase()){
        case 'true':
            return true;
        case 'false':
            return false;
    }
    return !!value;
}
function $60ec9c9c9a132a89$var$valueToString(value) {
    if (value == null) return '';
    switch(typeof value){
        case 'string':
            return value;
        case 'boolean':
        case 'number':
            return value.toString();
    }
    return '';
}
function $60ec9c9c9a132a89$var$isStringOperation(ex) {
    switch(ex.operator){
        case 'contains':
        case '!contains':
        case 'starts':
        case '!starts':
            return true;
    }
    return false;
}
function $60ec9c9c9a132a89$var$isnullorEmpty(value) {
    if (value == null) return true; //double equal sign to also catch undefined
    if (typeof value === 'string' && value.length === 0) return true;
    return false;
}
class $60ec9c9c9a132a89$export$bbfd672d43392844 {
    constructor(search, columns){
        this.columns = columns;
        this.groups = (0, $ba55906944328f12$export$b5d04ce3dd7ae29e)(search).map((g)=>{
            const expressions = g.expressions.filter(Boolean);
            expressions.forEach((ex)=>{
                ex.column = this.getColumn(ex.name);
                ex.valueBool = $60ec9c9c9a132a89$var$valueToBoolean(ex.value);
                ex.valueLow = $60ec9c9c9a132a89$var$valueToString(ex.value).toLocaleLowerCase();
                ex.stringOperation = $60ec9c9c9a132a89$var$isStringOperation(ex);
            });
            const group = Object.assign(Object.assign({}, g), {
                expressions: expressions
            });
            return group;
        });
    }
    getColumn(name) {
        for(let i = 0; i < this.columns.length; i++){
            if (this.columns[i].name == name) return this.columns[i];
        }
    }
    runExpressionOnColumn(datum, ex) {
        const actualDataValue = datum[ex.name];
        if (ex.operator === 'isnullorEmpty') return $60ec9c9c9a132a89$var$isnullorEmpty(actualDataValue);
        else if (ex.operator === '!isnullorEmpty') return !$60ec9c9c9a132a89$var$isnullorEmpty(actualDataValue);
        let dataValue = actualDataValue;
        let expressionValue = ex.value;
        if (ex.column) {
            if (ex.column.type === 'string' || ex.stringOperation) {
                dataValue = $60ec9c9c9a132a89$var$valueToString(actualDataValue).toLocaleLowerCase();
                expressionValue = ex.valueLow;
            } else if (ex.column.type === 'boolean') {
                dataValue = $60ec9c9c9a132a89$var$valueToBoolean(actualDataValue);
                expressionValue = ex.valueBool;
            } else if (ex.column.quantitative) {
                dataValue = +actualDataValue;
                expressionValue = +ex.value;
            }
        }
        switch(ex.operator){
            case '!=':
                return dataValue != expressionValue;
            case '<':
                return dataValue < expressionValue;
            case '<=':
                return dataValue <= expressionValue;
            case '==':
                return dataValue == expressionValue;
            case '>':
                return dataValue > expressionValue;
            case '>=':
                return dataValue >= expressionValue;
            case 'contains':
                return dataValue.indexOf(expressionValue) >= 0;
            case '!contains':
                return dataValue.indexOf(expressionValue) < 0;
            case 'starts':
                return dataValue.indexOf(expressionValue) == 0;
            case '!starts':
                return dataValue.indexOf(expressionValue) !== 0;
        }
    }
    runExpression(datum, ex) {
        if (ex.name == null) {
            //run on all columns
            const group = {
                expressions: this.columns.map((column, i)=>{
                    const ex2 = Object.assign(Object.assign({}, ex), {
                        column: column,
                        name: column.name
                    });
                    if (i) ex2.clause = '||';
                    return ex2;
                })
            };
            return this.runGroup(datum, group);
        } else return this.runExpressionOnColumn(datum, ex);
    }
    runGroup(datum, group) {
        let accumulator = this.runExpression(datum, group.expressions[0]);
        for(let i = 1; i < group.expressions.length; i++){
            const ex = group.expressions[i];
            switch(ex.clause){
                case '&&':
                    accumulator = accumulator && this.runExpression(datum, ex);
                    break;
                case '||':
                    accumulator = accumulator || this.runExpression(datum, ex);
                    break;
            }
        }
        return accumulator;
    }
    run(datum) {
        let accumulator = this.runGroup(datum, this.groups[0]);
        for(let i = 1; i < this.groups.length; i++){
            const group = this.groups[i];
            switch(group.clause){
                case '&&':
                    accumulator = accumulator && this.runGroup(datum, group);
                    break;
                case '||':
                    accumulator = accumulator || this.runGroup(datum, group);
                    break;
            }
        }
        return accumulator;
    }
}



var $b144ef381004fc94$exports = {};

$parcel$export($b144ef381004fc94$exports, "invert", () => $b144ef381004fc94$export$6897c284b6f9f4dc);
/*!
* Copyright (c) Microsoft Corporation.
* Licensed under the MIT License.
*/ 
function $b144ef381004fc94$var$invertSearchExpressionGroup(input) {
    //this only works if all expressions in this group have the same clause
    const output = {
        expressions: input.expressions.map($b144ef381004fc94$var$invertSearchExpression)
    };
    if (input.clause) output.clause = $b144ef381004fc94$var$invertedClauses[input.clause];
    return output;
}
const $b144ef381004fc94$var$invertedOperators = {
    '!=': '==',
    '==': '!=',
    '<': '>=',
    '>=': '<',
    '<=': '>',
    '>': '<=',
    '!contains': 'contains',
    'contains': '!contains',
    '!isnullorEmpty': 'isnullorEmpty',
    'isnullorEmpty': '!isnullorEmpty',
    '!starts': 'starts',
    'starts': '!starts'
};
const $b144ef381004fc94$var$invertedClauses = {
    '&&': '||',
    '||': '&&'
};
function $b144ef381004fc94$var$invertSearchExpression(input) {
    const operator = $b144ef381004fc94$var$invertedOperators[input.operator];
    const output = Object.assign(Object.assign({}, input), {
        operator: operator
    });
    if (input.clause) output.clause = $b144ef381004fc94$var$invertedClauses[input.clause];
    return output;
}
function $b144ef381004fc94$export$6897c284b6f9f4dc(search) {
    if (Array.isArray(search)) return search.map($b144ef381004fc94$var$invertSearchExpressionGroup);
    else if ((0, $ba55906944328f12$export$ab134d298d957272)(search)) return $b144ef381004fc94$var$invertSearchExpressionGroup(search);
    else return $b144ef381004fc94$var$invertSearchExpression(search);
}


var $ed08d33b174a5471$exports = {};

$parcel$export($ed08d33b174a5471$exports, "narrow", () => $ed08d33b174a5471$export$ec67f55c222e1546);
/*!
* Copyright (c) Microsoft Corporation.
* Licensed under the MIT License.
*/ 
function $ed08d33b174a5471$export$ec67f55c222e1546(a, b) {
    if (!a) return b;
    const arrs = [
        a,
        b
    ].map((0, $ba55906944328f12$export$b5d04ce3dd7ae29e));
    const [arrA, arrB] = arrs;
    arrB[0].clause = '&&';
    return arrA.concat(arrB);
}


var $3d52d518cda5876a$exports = {};
/*!
* Copyright (c) Microsoft Corporation.
* Licensed under the MIT License.
*/ 

$parcel$exportWildcard($0d976ebdc81921a3$exports, $4c4e2fc4d7da02f0$exports);
$parcel$exportWildcard($0d976ebdc81921a3$exports, $60ec9c9c9a132a89$exports);
$parcel$exportWildcard($0d976ebdc81921a3$exports, $ba55906944328f12$exports);
$parcel$exportWildcard($0d976ebdc81921a3$exports, $b144ef381004fc94$exports);
$parcel$exportWildcard($0d976ebdc81921a3$exports, $ed08d33b174a5471$exports);
$parcel$exportWildcard($0d976ebdc81921a3$exports, $3d52d518cda5876a$exports);



var $1a35cc0c54ffaa6e$exports = {};
/*!
* Copyright (c) Microsoft Corporation.
* Licensed under the MIT License.
*/ 

var $048ba25c9a3f4065$exports = {};

$parcel$export($048ba25c9a3f4065$exports, "isInternalFieldName", () => $048ba25c9a3f4065$export$81adea670bebefbe);
$parcel$export($048ba25c9a3f4065$exports, "getColumnsFromData", () => $15b363a2e3ff0bb7$export$3f19ad07848df794);
$parcel$export($048ba25c9a3f4065$exports, "getStats", () => $8e54999951217c95$export$432f698644f45d1);
$parcel$export($048ba25c9a3f4065$exports, "inferAll", () => $15b363a2e3ff0bb7$export$e04a97cc71178399);
$parcel$export($048ba25c9a3f4065$exports, "getPresenterStyle", () => $16f9e3e56a5dcd59$export$c4db461e5e345a8);
/*!
* Copyright (c) Microsoft Corporation.
* Licensed under the MIT License.
*/ 

/*!
* Copyright (c) Microsoft Corporation.
* Licensed under the MIT License.
*/ var $e296aaf527fc4d25$exports = {};

$parcel$export($e296aaf527fc4d25$exports, "base", () => $94b078fc391e7135$export$e2253033e6e1df16);
$parcel$export($e296aaf527fc4d25$exports, "use", () => $94b078fc391e7135$export$1f96ae73734a86cc);
$parcel$export($e296aaf527fc4d25$exports, "Presenter", () => $6dfc103fcb41a0e6$export$893c88c42e3630f9);
$parcel$export($e296aaf527fc4d25$exports, "ViewGl", () => $51fbad27d38c01a6$export$6d8f9057dcd7f9e6);
$parcel$export($e296aaf527fc4d25$exports, "controls", () => $230d9e8a9013f7fd$exports);
$parcel$export($e296aaf527fc4d25$exports, "defaults", () => $a2698ea08ecf5377$exports);
$parcel$export($e296aaf527fc4d25$exports, "types", () => $4ef7f72d8d2a203c$exports);
$parcel$export($e296aaf527fc4d25$exports, "util", () => $c5578f8838abba3d$exports);
$parcel$export($e296aaf527fc4d25$exports, "version", () => $f6508cfd53d266a5$export$83d89fbfd8236492);
/*!
* Copyright (c) Microsoft Corporation.
* Licensed under the MIT License.
*/ var $230d9e8a9013f7fd$exports = {};

$parcel$export($230d9e8a9013f7fd$exports, "Table", () => $837e7efbc300fecc$export$54ec01a60f47d33d);
/*!
* Copyright (c) Microsoft Corporation.
* Licensed under the MIT License.
*/ /**
 * This file is for external facing export only, do not use this for internal references,
 * as it may cause circular dependencies in Rollup.
 */ /*!
* Copyright (c) Microsoft Corporation.
* Licensed under the MIT License.
*/ var $141b8f2471dc141e$exports = {};
'use strict';

$141b8f2471dc141e$exports = (parcelRequire("gwbX4"));


var $d92af7c54cf4754b$exports = {};

$d92af7c54cf4754b$exports = (parcelRequire("4T7E6"));


const $fe86f88c0c9aea93$var$htmlTagArray = $141b8f2471dc141e$exports.default || $141b8f2471dc141e$exports;
const $fe86f88c0c9aea93$var$svgTagArray = $d92af7c54cf4754b$exports.default || $d92af7c54cf4754b$exports;
/**
 * Decamelizes a string with/without a custom separator (hyphen by default).
 * from: https://ourcodeworld.com/articles/read/608/how-to-camelize-and-decamelize-strings-in-javascript
 *
 * @param str String in camelcase
 * @param separator Separator for the new decamelized string.
 */ function $fe86f88c0c9aea93$var$decamelize(str, separator = '-') {
    return str.replace(/([a-z\d])([A-Z])/g, '$1' + separator + '$2').replace(/([A-Z]+)([A-Z][a-z\d]+)/g, '$1' + separator + '$2').toLowerCase();
}
function $fe86f88c0c9aea93$export$c8a8987d4410bf2d(tag, attrs, ...children) {
    if (typeof tag === 'function') {
        const fn = tag;
        const props = attrs;
        props.children = children;
        return fn(props);
    } else {
        const ns = $fe86f88c0c9aea93$var$tagNamespace(tag);
        const el = ns ? document.createElementNS(ns, tag) : document.createElement(tag);
        const map = attrs;
        let ref;
        for(let name in map)if (name && map.hasOwnProperty(name)) {
            let value = map[name];
            if (name === 'className' && value !== void 0) $fe86f88c0c9aea93$var$setAttribute(el, ns, 'class', value.toString());
            else if (name === 'disabled' && !value) ;
            else if (value === null || value === undefined) continue;
            else if (value === true) $fe86f88c0c9aea93$var$setAttribute(el, ns, name, name);
            else if (typeof value === 'function') {
                if (name === 'ref') ref = value;
                else el[name.toLowerCase()] = value;
            } else if (typeof value === 'object') $fe86f88c0c9aea93$var$setAttribute(el, ns, name, $fe86f88c0c9aea93$var$flatten(value));
            else $fe86f88c0c9aea93$var$setAttribute(el, ns, name, value.toString());
        }
        if (children && children.length > 0) $fe86f88c0c9aea93$var$appendChildren(el, children);
        if (ref) ref(el);
        return el;
    }
}
function $fe86f88c0c9aea93$var$setAttribute(el, ns, name, value) {
    if (ns) el.setAttributeNS(null, name, value);
    else el.setAttribute(name, value);
}
function $fe86f88c0c9aea93$var$flatten(o) {
    const arr = [];
    for(let prop in o)arr.push(`${$fe86f88c0c9aea93$var$decamelize(prop, '-')}:${o[prop]}`);
    return arr.join(';');
}
function $fe86f88c0c9aea93$export$59da04d16460addd(parentElement, child) {
    if (child === null || child === undefined || typeof child === "boolean") return;
    else if (Array.isArray(child)) $fe86f88c0c9aea93$var$appendChildren(parentElement, child);
    else if ($fe86f88c0c9aea93$var$isElement(child)) parentElement.appendChild(child);
    else parentElement.appendChild(document.createTextNode(child.toString()));
}
function $fe86f88c0c9aea93$var$appendChildren(parentElement, children) {
    children.forEach((child)=>$fe86f88c0c9aea93$export$59da04d16460addd(parentElement, child));
}
function $fe86f88c0c9aea93$var$isElement(el) {
    //nodeType cannot be zero https://developer.mozilla.org/en-US/docs/Web/API/Node/nodeType
    return !!el.nodeType;
}
function $fe86f88c0c9aea93$export$186d02efde07ef98(element, container) {
    container.innerHTML = '';
    if (element) $fe86f88c0c9aea93$export$59da04d16460addd(container, element);
}
function $fe86f88c0c9aea93$export$d0bfd83e3f838e5e(childPositions, container) {
    let element = container || document.body;
    let childPosition;
    while(element && childPositions.length){
        childPosition = childPositions.shift();
        element = element.children.item(childPosition);
    }
    if (element) return element;
}
function $fe86f88c0c9aea93$export$8a664f09713ad850(element, activeElementInfo) {
    element.focus();
    element.scrollTop = activeElementInfo.scrollTop;
    const input = element;
    if (input.setSelectionRange && activeElementInfo && activeElementInfo.selectionStart != null && activeElementInfo.selectionEnd != null) input.setSelectionRange(activeElementInfo.selectionStart, activeElementInfo.selectionEnd, activeElementInfo.selectionDirection);
}
function $fe86f88c0c9aea93$export$7d007ff58288f238(activeElementInfo, container) {
    if (activeElementInfo) {
        const element = $fe86f88c0c9aea93$export$d0bfd83e3f838e5e(activeElementInfo.childPositions, container);
        if (element) $fe86f88c0c9aea93$export$8a664f09713ad850(element, activeElementInfo);
    }
}
function $fe86f88c0c9aea93$export$5ec2c407fb44f02(container) {
    let element = document.activeElement;
    const { scrollTop: scrollTop, selectionDirection: selectionDirection, selectionEnd: selectionEnd, selectionStart: selectionStart } = element;
    const activeElementInfo = {
        childPositions: [],
        scrollTop: scrollTop,
        selectionDirection: selectionDirection,
        selectionEnd: selectionEnd,
        selectionStart: selectionStart
    };
    while(element && element !== document.body && element !== container){
        activeElementInfo.childPositions.unshift($fe86f88c0c9aea93$var$getChildPosition(element));
        element = element.parentElement;
    }
    if ((element === document.body || element === container) && activeElementInfo.childPositions.length) return activeElementInfo;
}
function $fe86f88c0c9aea93$var$getChildPosition(element) {
    let childPosition = 0;
    while(element = element.previousElementSibling)childPosition++;
    return childPosition;
}
function $fe86f88c0c9aea93$var$tagNamespace(tag) {
    //issue: this won't disambiguate certain tags which exist in both svg and html: <a>, <title> ...
    if (tag === 'svg' || $fe86f88c0c9aea93$var$svgTagArray.indexOf(tag) >= 0 && !($fe86f88c0c9aea93$var$htmlTagArray.indexOf(tag) >= 0)) return "http://www.w3.org/2000/svg";
}


const $837e7efbc300fecc$var$KeyCodes = {
    ENTER: 'Enter'
};
const $837e7efbc300fecc$export$54ec01a60f47d33d = (props)=>{
    return (0, $fe86f88c0c9aea93$export$c8a8987d4410bf2d)("table", {
        className: props.className
    }, props.children, props.rows.map((row, i)=>(0, $fe86f88c0c9aea93$export$c8a8987d4410bf2d)("tr", {
            className: props.rowClassName || '',
            onClick: (e)=>props.onRowClick && props.onRowClick(e, i),
            tabIndex: props.onRowClick ? 0 : -1,
            onKeyUp: (e)=>{
                if (e.key === $837e7efbc300fecc$var$KeyCodes.ENTER && props.onRowClick) props.onRowClick(e, i);
            }
        }, row.cells.map((cell, i)=>(0, $fe86f88c0c9aea93$export$c8a8987d4410bf2d)("td", {
                className: cell.className || '',
                title: cell.title || ''
            }, cell.content)))));
};




var $4ef7f72d8d2a203c$exports = {};

$parcel$export($4ef7f72d8d2a203c$exports, "MorphChartsCore", () => $4a6417d29706362f$export$4143ab5b91744744);
/*!
* Copyright (c) Microsoft Corporation.
* Licensed under the MIT License.
*/ /**
 * This file is for external facing export only, do not use this for internal references,
 * as it may cause circular dependencies in Rollup.
 */ /*!
* Copyright (c) Microsoft Corporation.
* Licensed under the MIT License.
*/ /*!
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 */ /*!
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 */ var $14f38b7dd89457d7$exports = {};

$parcel$export($14f38b7dd89457d7$exports, "EPSILON", () => $14f38b7dd89457d7$export$fd293b15f47e270);
$parcel$export($14f38b7dd89457d7$exports, "ARRAY_TYPE", () => $14f38b7dd89457d7$export$b67359430d3b1b2);
$parcel$export($14f38b7dd89457d7$exports, "RANDOM", () => $14f38b7dd89457d7$export$5ada478c8a628231);
$parcel$export($14f38b7dd89457d7$exports, "setMatrixArrayType", () => $14f38b7dd89457d7$export$cb2c0eb57f5e532c);
$parcel$export($14f38b7dd89457d7$exports, "toRadian", () => $14f38b7dd89457d7$export$408b8ee5959eefd5);
$parcel$export($14f38b7dd89457d7$exports, "equals", () => $14f38b7dd89457d7$export$e9bab7fafb253603);
/**
 * Common utilities
 * @module glMatrix
 */ // Configuration Constants
var $14f38b7dd89457d7$export$fd293b15f47e270 = 0.000001;
var $14f38b7dd89457d7$export$b67359430d3b1b2 = typeof Float32Array !== 'undefined' ? Float32Array : Array;
var $14f38b7dd89457d7$export$5ada478c8a628231 = Math.random;
function $14f38b7dd89457d7$export$cb2c0eb57f5e532c(type) {
    $14f38b7dd89457d7$export$b67359430d3b1b2 = type;
}
var $14f38b7dd89457d7$var$degree = Math.PI / 180;
function $14f38b7dd89457d7$export$408b8ee5959eefd5(a) {
    return a * $14f38b7dd89457d7$var$degree;
}
function $14f38b7dd89457d7$export$e9bab7fafb253603(a, b) {
    return Math.abs(a - b) <= $14f38b7dd89457d7$export$fd293b15f47e270 * Math.max(1.0, Math.abs(a), Math.abs(b));
}
if (!Math.hypot) Math.hypot = function() {
    var y = 0, i = arguments.length;
    while(i--)y += arguments[i] * arguments[i];
    return Math.sqrt(y);
};

var $1ac1b59392edf35b$exports = {};

$parcel$export($1ac1b59392edf35b$exports, "create", () => $1ac1b59392edf35b$export$185802fd694ee1f5);
$parcel$export($1ac1b59392edf35b$exports, "clone", () => $1ac1b59392edf35b$export$9cd59f9826255e47);
$parcel$export($1ac1b59392edf35b$exports, "copy", () => $1ac1b59392edf35b$export$784d13d8ee351f07);
$parcel$export($1ac1b59392edf35b$exports, "fromValues", () => $1ac1b59392edf35b$export$a82be99ed2a44a7d);
$parcel$export($1ac1b59392edf35b$exports, "set", () => $1ac1b59392edf35b$export$adaa4cf7ef1b65be);
$parcel$export($1ac1b59392edf35b$exports, "identity", () => $1ac1b59392edf35b$export$f0954fd7d5368655);
$parcel$export($1ac1b59392edf35b$exports, "transpose", () => $1ac1b59392edf35b$export$9cb09a71b7d66923);
$parcel$export($1ac1b59392edf35b$exports, "invert", () => $1ac1b59392edf35b$export$6897c284b6f9f4dc);
$parcel$export($1ac1b59392edf35b$exports, "adjoint", () => $1ac1b59392edf35b$export$33f3c024b4ae00a1);
$parcel$export($1ac1b59392edf35b$exports, "determinant", () => $1ac1b59392edf35b$export$a04698f914c55ed9);
$parcel$export($1ac1b59392edf35b$exports, "multiply", () => $1ac1b59392edf35b$export$2060d2db72cce88f);
$parcel$export($1ac1b59392edf35b$exports, "translate", () => $1ac1b59392edf35b$export$d73ee8ef04f5226a);
$parcel$export($1ac1b59392edf35b$exports, "scale", () => $1ac1b59392edf35b$export$dcdf75081b88279d);
$parcel$export($1ac1b59392edf35b$exports, "rotate", () => $1ac1b59392edf35b$export$bb628a54ab399bc9);
$parcel$export($1ac1b59392edf35b$exports, "rotateX", () => $1ac1b59392edf35b$export$a59c8716592e09af);
$parcel$export($1ac1b59392edf35b$exports, "rotateY", () => $1ac1b59392edf35b$export$cf71e4d4ca4d1cfd);
$parcel$export($1ac1b59392edf35b$exports, "rotateZ", () => $1ac1b59392edf35b$export$ea6eae3365de5b9c);
$parcel$export($1ac1b59392edf35b$exports, "fromTranslation", () => $1ac1b59392edf35b$export$bc9e79e74e9fddf6);
$parcel$export($1ac1b59392edf35b$exports, "fromScaling", () => $1ac1b59392edf35b$export$832ca188ffb1955d);
$parcel$export($1ac1b59392edf35b$exports, "fromRotation", () => $1ac1b59392edf35b$export$926fc125ff3c666c);
$parcel$export($1ac1b59392edf35b$exports, "fromXRotation", () => $1ac1b59392edf35b$export$dd47cc2f828c32ef);
$parcel$export($1ac1b59392edf35b$exports, "fromYRotation", () => $1ac1b59392edf35b$export$7dc997d67d2b7f33);
$parcel$export($1ac1b59392edf35b$exports, "fromZRotation", () => $1ac1b59392edf35b$export$ad5ddaedc8f405df);
$parcel$export($1ac1b59392edf35b$exports, "fromRotationTranslation", () => $1ac1b59392edf35b$export$9545ac307f2a256b);
$parcel$export($1ac1b59392edf35b$exports, "fromQuat2", () => $1ac1b59392edf35b$export$ff497f2be31cc6a);
$parcel$export($1ac1b59392edf35b$exports, "getTranslation", () => $1ac1b59392edf35b$export$202e99f82f7f0395);
$parcel$export($1ac1b59392edf35b$exports, "getScaling", () => $1ac1b59392edf35b$export$71dc54d92bd04b57);
$parcel$export($1ac1b59392edf35b$exports, "getRotation", () => $1ac1b59392edf35b$export$df3937d3b537df0a);
$parcel$export($1ac1b59392edf35b$exports, "fromRotationTranslationScale", () => $1ac1b59392edf35b$export$ddf9c55c9f2be172);
$parcel$export($1ac1b59392edf35b$exports, "fromRotationTranslationScaleOrigin", () => $1ac1b59392edf35b$export$1def1f860edc4b1f);
$parcel$export($1ac1b59392edf35b$exports, "fromQuat", () => $1ac1b59392edf35b$export$2ff2bbe382249af7);
$parcel$export($1ac1b59392edf35b$exports, "frustum", () => $1ac1b59392edf35b$export$89b5708c387cac6c);
$parcel$export($1ac1b59392edf35b$exports, "perspectiveNO", () => $1ac1b59392edf35b$export$4cf19729ec9a96b8);
$parcel$export($1ac1b59392edf35b$exports, "perspective", () => $1ac1b59392edf35b$export$541149539f3a4684);
$parcel$export($1ac1b59392edf35b$exports, "perspectiveZO", () => $1ac1b59392edf35b$export$294bba99a6af0c0c);
$parcel$export($1ac1b59392edf35b$exports, "perspectiveFromFieldOfView", () => $1ac1b59392edf35b$export$58ae211c788e338f);
$parcel$export($1ac1b59392edf35b$exports, "orthoNO", () => $1ac1b59392edf35b$export$c5f65ef3eb668f27);
$parcel$export($1ac1b59392edf35b$exports, "ortho", () => $1ac1b59392edf35b$export$4f2167e613cfc87b);
$parcel$export($1ac1b59392edf35b$exports, "orthoZO", () => $1ac1b59392edf35b$export$b1d31ea7b4d854e);
$parcel$export($1ac1b59392edf35b$exports, "lookAt", () => $1ac1b59392edf35b$export$d924e14fd6d9aa66);
$parcel$export($1ac1b59392edf35b$exports, "targetTo", () => $1ac1b59392edf35b$export$aa67782f4dc9e52c);
$parcel$export($1ac1b59392edf35b$exports, "str", () => $1ac1b59392edf35b$export$42d51816ce590c93);
$parcel$export($1ac1b59392edf35b$exports, "frob", () => $1ac1b59392edf35b$export$326827e8268e9cdb);
$parcel$export($1ac1b59392edf35b$exports, "add", () => $1ac1b59392edf35b$export$e16d8520af44a096);
$parcel$export($1ac1b59392edf35b$exports, "subtract", () => $1ac1b59392edf35b$export$4e2d2ead65e5f7e3);
$parcel$export($1ac1b59392edf35b$exports, "multiplyScalar", () => $1ac1b59392edf35b$export$c697bed75648cdb7);
$parcel$export($1ac1b59392edf35b$exports, "multiplyScalarAndAdd", () => $1ac1b59392edf35b$export$553579f63bdd7137);
$parcel$export($1ac1b59392edf35b$exports, "exactEquals", () => $1ac1b59392edf35b$export$f2599a5cf1109d8);
$parcel$export($1ac1b59392edf35b$exports, "equals", () => $1ac1b59392edf35b$export$e9bab7fafb253603);
$parcel$export($1ac1b59392edf35b$exports, "mul", () => $1ac1b59392edf35b$export$6e3a27864ab166fe);
$parcel$export($1ac1b59392edf35b$exports, "sub", () => $1ac1b59392edf35b$export$f93b5905241a7cca);

function $1ac1b59392edf35b$export$185802fd694ee1f5() {
    var out = new $14f38b7dd89457d7$export$b67359430d3b1b2(16);
    if ($14f38b7dd89457d7$export$b67359430d3b1b2 != Float32Array) {
        out[1] = 0;
        out[2] = 0;
        out[3] = 0;
        out[4] = 0;
        out[6] = 0;
        out[7] = 0;
        out[8] = 0;
        out[9] = 0;
        out[11] = 0;
        out[12] = 0;
        out[13] = 0;
        out[14] = 0;
    }
    out[0] = 1;
    out[5] = 1;
    out[10] = 1;
    out[15] = 1;
    return out;
}
function $1ac1b59392edf35b$export$9cd59f9826255e47(a) {
    var out = new $14f38b7dd89457d7$export$b67359430d3b1b2(16);
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[3];
    out[4] = a[4];
    out[5] = a[5];
    out[6] = a[6];
    out[7] = a[7];
    out[8] = a[8];
    out[9] = a[9];
    out[10] = a[10];
    out[11] = a[11];
    out[12] = a[12];
    out[13] = a[13];
    out[14] = a[14];
    out[15] = a[15];
    return out;
}
function $1ac1b59392edf35b$export$784d13d8ee351f07(out, a) {
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[3];
    out[4] = a[4];
    out[5] = a[5];
    out[6] = a[6];
    out[7] = a[7];
    out[8] = a[8];
    out[9] = a[9];
    out[10] = a[10];
    out[11] = a[11];
    out[12] = a[12];
    out[13] = a[13];
    out[14] = a[14];
    out[15] = a[15];
    return out;
}
function $1ac1b59392edf35b$export$a82be99ed2a44a7d(m00, m01, m02, m03, m10, m11, m12, m13, m20, m21, m22, m23, m30, m31, m32, m33) {
    var out = new $14f38b7dd89457d7$export$b67359430d3b1b2(16);
    out[0] = m00;
    out[1] = m01;
    out[2] = m02;
    out[3] = m03;
    out[4] = m10;
    out[5] = m11;
    out[6] = m12;
    out[7] = m13;
    out[8] = m20;
    out[9] = m21;
    out[10] = m22;
    out[11] = m23;
    out[12] = m30;
    out[13] = m31;
    out[14] = m32;
    out[15] = m33;
    return out;
}
function $1ac1b59392edf35b$export$adaa4cf7ef1b65be(out, m00, m01, m02, m03, m10, m11, m12, m13, m20, m21, m22, m23, m30, m31, m32, m33) {
    out[0] = m00;
    out[1] = m01;
    out[2] = m02;
    out[3] = m03;
    out[4] = m10;
    out[5] = m11;
    out[6] = m12;
    out[7] = m13;
    out[8] = m20;
    out[9] = m21;
    out[10] = m22;
    out[11] = m23;
    out[12] = m30;
    out[13] = m31;
    out[14] = m32;
    out[15] = m33;
    return out;
}
function $1ac1b59392edf35b$export$f0954fd7d5368655(out) {
    out[0] = 1;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = 1;
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[10] = 1;
    out[11] = 0;
    out[12] = 0;
    out[13] = 0;
    out[14] = 0;
    out[15] = 1;
    return out;
}
function $1ac1b59392edf35b$export$9cb09a71b7d66923(out, a) {
    // If we are transposing ourselves we can skip a few steps but have to cache some values
    if (out === a) {
        var a01 = a[1], a02 = a[2], a03 = a[3];
        var a12 = a[6], a13 = a[7];
        var a23 = a[11];
        out[1] = a[4];
        out[2] = a[8];
        out[3] = a[12];
        out[4] = a01;
        out[6] = a[9];
        out[7] = a[13];
        out[8] = a02;
        out[9] = a12;
        out[11] = a[14];
        out[12] = a03;
        out[13] = a13;
        out[14] = a23;
    } else {
        out[0] = a[0];
        out[1] = a[4];
        out[2] = a[8];
        out[3] = a[12];
        out[4] = a[1];
        out[5] = a[5];
        out[6] = a[9];
        out[7] = a[13];
        out[8] = a[2];
        out[9] = a[6];
        out[10] = a[10];
        out[11] = a[14];
        out[12] = a[3];
        out[13] = a[7];
        out[14] = a[11];
        out[15] = a[15];
    }
    return out;
}
function $1ac1b59392edf35b$export$6897c284b6f9f4dc(out, a) {
    var a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3];
    var a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7];
    var a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11];
    var a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15];
    var b00 = a00 * a11 - a01 * a10;
    var b01 = a00 * a12 - a02 * a10;
    var b02 = a00 * a13 - a03 * a10;
    var b03 = a01 * a12 - a02 * a11;
    var b04 = a01 * a13 - a03 * a11;
    var b05 = a02 * a13 - a03 * a12;
    var b06 = a20 * a31 - a21 * a30;
    var b07 = a20 * a32 - a22 * a30;
    var b08 = a20 * a33 - a23 * a30;
    var b09 = a21 * a32 - a22 * a31;
    var b10 = a21 * a33 - a23 * a31;
    var b11 = a22 * a33 - a23 * a32; // Calculate the determinant
    var det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;
    if (!det) return null;
    det = 1.0 / det;
    out[0] = (a11 * b11 - a12 * b10 + a13 * b09) * det;
    out[1] = (a02 * b10 - a01 * b11 - a03 * b09) * det;
    out[2] = (a31 * b05 - a32 * b04 + a33 * b03) * det;
    out[3] = (a22 * b04 - a21 * b05 - a23 * b03) * det;
    out[4] = (a12 * b08 - a10 * b11 - a13 * b07) * det;
    out[5] = (a00 * b11 - a02 * b08 + a03 * b07) * det;
    out[6] = (a32 * b02 - a30 * b05 - a33 * b01) * det;
    out[7] = (a20 * b05 - a22 * b02 + a23 * b01) * det;
    out[8] = (a10 * b10 - a11 * b08 + a13 * b06) * det;
    out[9] = (a01 * b08 - a00 * b10 - a03 * b06) * det;
    out[10] = (a30 * b04 - a31 * b02 + a33 * b00) * det;
    out[11] = (a21 * b02 - a20 * b04 - a23 * b00) * det;
    out[12] = (a11 * b07 - a10 * b09 - a12 * b06) * det;
    out[13] = (a00 * b09 - a01 * b07 + a02 * b06) * det;
    out[14] = (a31 * b01 - a30 * b03 - a32 * b00) * det;
    out[15] = (a20 * b03 - a21 * b01 + a22 * b00) * det;
    return out;
}
function $1ac1b59392edf35b$export$33f3c024b4ae00a1(out, a) {
    var a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3];
    var a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7];
    var a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11];
    var a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15];
    out[0] = a11 * (a22 * a33 - a23 * a32) - a21 * (a12 * a33 - a13 * a32) + a31 * (a12 * a23 - a13 * a22);
    out[1] = -(a01 * (a22 * a33 - a23 * a32) - a21 * (a02 * a33 - a03 * a32) + a31 * (a02 * a23 - a03 * a22));
    out[2] = a01 * (a12 * a33 - a13 * a32) - a11 * (a02 * a33 - a03 * a32) + a31 * (a02 * a13 - a03 * a12);
    out[3] = -(a01 * (a12 * a23 - a13 * a22) - a11 * (a02 * a23 - a03 * a22) + a21 * (a02 * a13 - a03 * a12));
    out[4] = -(a10 * (a22 * a33 - a23 * a32) - a20 * (a12 * a33 - a13 * a32) + a30 * (a12 * a23 - a13 * a22));
    out[5] = a00 * (a22 * a33 - a23 * a32) - a20 * (a02 * a33 - a03 * a32) + a30 * (a02 * a23 - a03 * a22);
    out[6] = -(a00 * (a12 * a33 - a13 * a32) - a10 * (a02 * a33 - a03 * a32) + a30 * (a02 * a13 - a03 * a12));
    out[7] = a00 * (a12 * a23 - a13 * a22) - a10 * (a02 * a23 - a03 * a22) + a20 * (a02 * a13 - a03 * a12);
    out[8] = a10 * (a21 * a33 - a23 * a31) - a20 * (a11 * a33 - a13 * a31) + a30 * (a11 * a23 - a13 * a21);
    out[9] = -(a00 * (a21 * a33 - a23 * a31) - a20 * (a01 * a33 - a03 * a31) + a30 * (a01 * a23 - a03 * a21));
    out[10] = a00 * (a11 * a33 - a13 * a31) - a10 * (a01 * a33 - a03 * a31) + a30 * (a01 * a13 - a03 * a11);
    out[11] = -(a00 * (a11 * a23 - a13 * a21) - a10 * (a01 * a23 - a03 * a21) + a20 * (a01 * a13 - a03 * a11));
    out[12] = -(a10 * (a21 * a32 - a22 * a31) - a20 * (a11 * a32 - a12 * a31) + a30 * (a11 * a22 - a12 * a21));
    out[13] = a00 * (a21 * a32 - a22 * a31) - a20 * (a01 * a32 - a02 * a31) + a30 * (a01 * a22 - a02 * a21);
    out[14] = -(a00 * (a11 * a32 - a12 * a31) - a10 * (a01 * a32 - a02 * a31) + a30 * (a01 * a12 - a02 * a11));
    out[15] = a00 * (a11 * a22 - a12 * a21) - a10 * (a01 * a22 - a02 * a21) + a20 * (a01 * a12 - a02 * a11);
    return out;
}
function $1ac1b59392edf35b$export$a04698f914c55ed9(a) {
    var a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3];
    var a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7];
    var a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11];
    var a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15];
    var b00 = a00 * a11 - a01 * a10;
    var b01 = a00 * a12 - a02 * a10;
    var b02 = a00 * a13 - a03 * a10;
    var b03 = a01 * a12 - a02 * a11;
    var b04 = a01 * a13 - a03 * a11;
    var b05 = a02 * a13 - a03 * a12;
    var b06 = a20 * a31 - a21 * a30;
    var b07 = a20 * a32 - a22 * a30;
    var b08 = a20 * a33 - a23 * a30;
    var b09 = a21 * a32 - a22 * a31;
    var b10 = a21 * a33 - a23 * a31;
    var b11 = a22 * a33 - a23 * a32; // Calculate the determinant
    return b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;
}
function $1ac1b59392edf35b$export$2060d2db72cce88f(out, a, b) {
    var a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3];
    var a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7];
    var a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11];
    var a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15]; // Cache only the current line of the second matrix
    var b0 = b[0], b1 = b[1], b2 = b[2], b3 = b[3];
    out[0] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
    out[1] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
    out[2] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
    out[3] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
    b0 = b[4];
    b1 = b[5];
    b2 = b[6];
    b3 = b[7];
    out[4] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
    out[5] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
    out[6] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
    out[7] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
    b0 = b[8];
    b1 = b[9];
    b2 = b[10];
    b3 = b[11];
    out[8] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
    out[9] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
    out[10] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
    out[11] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
    b0 = b[12];
    b1 = b[13];
    b2 = b[14];
    b3 = b[15];
    out[12] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
    out[13] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
    out[14] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
    out[15] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
    return out;
}
function $1ac1b59392edf35b$export$d73ee8ef04f5226a(out, a, v) {
    var x = v[0], y = v[1], z = v[2];
    var a00, a01, a02, a03;
    var a10, a11, a12, a13;
    var a20, a21, a22, a23;
    if (a === out) {
        out[12] = a[0] * x + a[4] * y + a[8] * z + a[12];
        out[13] = a[1] * x + a[5] * y + a[9] * z + a[13];
        out[14] = a[2] * x + a[6] * y + a[10] * z + a[14];
        out[15] = a[3] * x + a[7] * y + a[11] * z + a[15];
    } else {
        a00 = a[0];
        a01 = a[1];
        a02 = a[2];
        a03 = a[3];
        a10 = a[4];
        a11 = a[5];
        a12 = a[6];
        a13 = a[7];
        a20 = a[8];
        a21 = a[9];
        a22 = a[10];
        a23 = a[11];
        out[0] = a00;
        out[1] = a01;
        out[2] = a02;
        out[3] = a03;
        out[4] = a10;
        out[5] = a11;
        out[6] = a12;
        out[7] = a13;
        out[8] = a20;
        out[9] = a21;
        out[10] = a22;
        out[11] = a23;
        out[12] = a00 * x + a10 * y + a20 * z + a[12];
        out[13] = a01 * x + a11 * y + a21 * z + a[13];
        out[14] = a02 * x + a12 * y + a22 * z + a[14];
        out[15] = a03 * x + a13 * y + a23 * z + a[15];
    }
    return out;
}
function $1ac1b59392edf35b$export$dcdf75081b88279d(out, a, v) {
    var x = v[0], y = v[1], z = v[2];
    out[0] = a[0] * x;
    out[1] = a[1] * x;
    out[2] = a[2] * x;
    out[3] = a[3] * x;
    out[4] = a[4] * y;
    out[5] = a[5] * y;
    out[6] = a[6] * y;
    out[7] = a[7] * y;
    out[8] = a[8] * z;
    out[9] = a[9] * z;
    out[10] = a[10] * z;
    out[11] = a[11] * z;
    out[12] = a[12];
    out[13] = a[13];
    out[14] = a[14];
    out[15] = a[15];
    return out;
}
function $1ac1b59392edf35b$export$bb628a54ab399bc9(out, a, rad, axis) {
    var x = axis[0], y = axis[1], z = axis[2];
    var len = Math.hypot(x, y, z);
    var s, c, t;
    var a00, a01, a02, a03;
    var a10, a11, a12, a13;
    var a20, a21, a22, a23;
    var b00, b01, b02;
    var b10, b11, b12;
    var b20, b21, b22;
    if (len < $14f38b7dd89457d7$export$fd293b15f47e270) return null;
    len = 1 / len;
    x *= len;
    y *= len;
    z *= len;
    s = Math.sin(rad);
    c = Math.cos(rad);
    t = 1 - c;
    a00 = a[0];
    a01 = a[1];
    a02 = a[2];
    a03 = a[3];
    a10 = a[4];
    a11 = a[5];
    a12 = a[6];
    a13 = a[7];
    a20 = a[8];
    a21 = a[9];
    a22 = a[10];
    a23 = a[11]; // Construct the elements of the rotation matrix
    b00 = x * x * t + c;
    b01 = y * x * t + z * s;
    b02 = z * x * t - y * s;
    b10 = x * y * t - z * s;
    b11 = y * y * t + c;
    b12 = z * y * t + x * s;
    b20 = x * z * t + y * s;
    b21 = y * z * t - x * s;
    b22 = z * z * t + c; // Perform rotation-specific matrix multiplication
    out[0] = a00 * b00 + a10 * b01 + a20 * b02;
    out[1] = a01 * b00 + a11 * b01 + a21 * b02;
    out[2] = a02 * b00 + a12 * b01 + a22 * b02;
    out[3] = a03 * b00 + a13 * b01 + a23 * b02;
    out[4] = a00 * b10 + a10 * b11 + a20 * b12;
    out[5] = a01 * b10 + a11 * b11 + a21 * b12;
    out[6] = a02 * b10 + a12 * b11 + a22 * b12;
    out[7] = a03 * b10 + a13 * b11 + a23 * b12;
    out[8] = a00 * b20 + a10 * b21 + a20 * b22;
    out[9] = a01 * b20 + a11 * b21 + a21 * b22;
    out[10] = a02 * b20 + a12 * b21 + a22 * b22;
    out[11] = a03 * b20 + a13 * b21 + a23 * b22;
    if (a !== out) {
        // If the source and destination differ, copy the unchanged last row
        out[12] = a[12];
        out[13] = a[13];
        out[14] = a[14];
        out[15] = a[15];
    }
    return out;
}
function $1ac1b59392edf35b$export$a59c8716592e09af(out, a, rad) {
    var s = Math.sin(rad);
    var c = Math.cos(rad);
    var a10 = a[4];
    var a11 = a[5];
    var a12 = a[6];
    var a13 = a[7];
    var a20 = a[8];
    var a21 = a[9];
    var a22 = a[10];
    var a23 = a[11];
    if (a !== out) {
        // If the source and destination differ, copy the unchanged rows
        out[0] = a[0];
        out[1] = a[1];
        out[2] = a[2];
        out[3] = a[3];
        out[12] = a[12];
        out[13] = a[13];
        out[14] = a[14];
        out[15] = a[15];
    } // Perform axis-specific matrix multiplication
    out[4] = a10 * c + a20 * s;
    out[5] = a11 * c + a21 * s;
    out[6] = a12 * c + a22 * s;
    out[7] = a13 * c + a23 * s;
    out[8] = a20 * c - a10 * s;
    out[9] = a21 * c - a11 * s;
    out[10] = a22 * c - a12 * s;
    out[11] = a23 * c - a13 * s;
    return out;
}
function $1ac1b59392edf35b$export$cf71e4d4ca4d1cfd(out, a, rad) {
    var s = Math.sin(rad);
    var c = Math.cos(rad);
    var a00 = a[0];
    var a01 = a[1];
    var a02 = a[2];
    var a03 = a[3];
    var a20 = a[8];
    var a21 = a[9];
    var a22 = a[10];
    var a23 = a[11];
    if (a !== out) {
        // If the source and destination differ, copy the unchanged rows
        out[4] = a[4];
        out[5] = a[5];
        out[6] = a[6];
        out[7] = a[7];
        out[12] = a[12];
        out[13] = a[13];
        out[14] = a[14];
        out[15] = a[15];
    } // Perform axis-specific matrix multiplication
    out[0] = a00 * c - a20 * s;
    out[1] = a01 * c - a21 * s;
    out[2] = a02 * c - a22 * s;
    out[3] = a03 * c - a23 * s;
    out[8] = a00 * s + a20 * c;
    out[9] = a01 * s + a21 * c;
    out[10] = a02 * s + a22 * c;
    out[11] = a03 * s + a23 * c;
    return out;
}
function $1ac1b59392edf35b$export$ea6eae3365de5b9c(out, a, rad) {
    var s = Math.sin(rad);
    var c = Math.cos(rad);
    var a00 = a[0];
    var a01 = a[1];
    var a02 = a[2];
    var a03 = a[3];
    var a10 = a[4];
    var a11 = a[5];
    var a12 = a[6];
    var a13 = a[7];
    if (a !== out) {
        // If the source and destination differ, copy the unchanged last row
        out[8] = a[8];
        out[9] = a[9];
        out[10] = a[10];
        out[11] = a[11];
        out[12] = a[12];
        out[13] = a[13];
        out[14] = a[14];
        out[15] = a[15];
    } // Perform axis-specific matrix multiplication
    out[0] = a00 * c + a10 * s;
    out[1] = a01 * c + a11 * s;
    out[2] = a02 * c + a12 * s;
    out[3] = a03 * c + a13 * s;
    out[4] = a10 * c - a00 * s;
    out[5] = a11 * c - a01 * s;
    out[6] = a12 * c - a02 * s;
    out[7] = a13 * c - a03 * s;
    return out;
}
function $1ac1b59392edf35b$export$bc9e79e74e9fddf6(out, v) {
    out[0] = 1;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = 1;
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[10] = 1;
    out[11] = 0;
    out[12] = v[0];
    out[13] = v[1];
    out[14] = v[2];
    out[15] = 1;
    return out;
}
function $1ac1b59392edf35b$export$832ca188ffb1955d(out, v) {
    out[0] = v[0];
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = v[1];
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[10] = v[2];
    out[11] = 0;
    out[12] = 0;
    out[13] = 0;
    out[14] = 0;
    out[15] = 1;
    return out;
}
function $1ac1b59392edf35b$export$926fc125ff3c666c(out, rad, axis) {
    var x = axis[0], y = axis[1], z = axis[2];
    var len = Math.hypot(x, y, z);
    var s, c, t;
    if (len < $14f38b7dd89457d7$export$fd293b15f47e270) return null;
    len = 1 / len;
    x *= len;
    y *= len;
    z *= len;
    s = Math.sin(rad);
    c = Math.cos(rad);
    t = 1 - c; // Perform rotation-specific matrix multiplication
    out[0] = x * x * t + c;
    out[1] = y * x * t + z * s;
    out[2] = z * x * t - y * s;
    out[3] = 0;
    out[4] = x * y * t - z * s;
    out[5] = y * y * t + c;
    out[6] = z * y * t + x * s;
    out[7] = 0;
    out[8] = x * z * t + y * s;
    out[9] = y * z * t - x * s;
    out[10] = z * z * t + c;
    out[11] = 0;
    out[12] = 0;
    out[13] = 0;
    out[14] = 0;
    out[15] = 1;
    return out;
}
function $1ac1b59392edf35b$export$dd47cc2f828c32ef(out, rad) {
    var s = Math.sin(rad);
    var c = Math.cos(rad); // Perform axis-specific matrix multiplication
    out[0] = 1;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = c;
    out[6] = s;
    out[7] = 0;
    out[8] = 0;
    out[9] = -s;
    out[10] = c;
    out[11] = 0;
    out[12] = 0;
    out[13] = 0;
    out[14] = 0;
    out[15] = 1;
    return out;
}
function $1ac1b59392edf35b$export$7dc997d67d2b7f33(out, rad) {
    var s = Math.sin(rad);
    var c = Math.cos(rad); // Perform axis-specific matrix multiplication
    out[0] = c;
    out[1] = 0;
    out[2] = -s;
    out[3] = 0;
    out[4] = 0;
    out[5] = 1;
    out[6] = 0;
    out[7] = 0;
    out[8] = s;
    out[9] = 0;
    out[10] = c;
    out[11] = 0;
    out[12] = 0;
    out[13] = 0;
    out[14] = 0;
    out[15] = 1;
    return out;
}
function $1ac1b59392edf35b$export$ad5ddaedc8f405df(out, rad) {
    var s = Math.sin(rad);
    var c = Math.cos(rad); // Perform axis-specific matrix multiplication
    out[0] = c;
    out[1] = s;
    out[2] = 0;
    out[3] = 0;
    out[4] = -s;
    out[5] = c;
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[10] = 1;
    out[11] = 0;
    out[12] = 0;
    out[13] = 0;
    out[14] = 0;
    out[15] = 1;
    return out;
}
function $1ac1b59392edf35b$export$9545ac307f2a256b(out, q, v) {
    // Quaternion math
    var x = q[0], y = q[1], z = q[2], w = q[3];
    var x2 = x + x;
    var y2 = y + y;
    var z2 = z + z;
    var xx = x * x2;
    var xy = x * y2;
    var xz = x * z2;
    var yy = y * y2;
    var yz = y * z2;
    var zz = z * z2;
    var wx = w * x2;
    var wy = w * y2;
    var wz = w * z2;
    out[0] = 1 - (yy + zz);
    out[1] = xy + wz;
    out[2] = xz - wy;
    out[3] = 0;
    out[4] = xy - wz;
    out[5] = 1 - (xx + zz);
    out[6] = yz + wx;
    out[7] = 0;
    out[8] = xz + wy;
    out[9] = yz - wx;
    out[10] = 1 - (xx + yy);
    out[11] = 0;
    out[12] = v[0];
    out[13] = v[1];
    out[14] = v[2];
    out[15] = 1;
    return out;
}
function $1ac1b59392edf35b$export$ff497f2be31cc6a(out, a) {
    var translation = new $14f38b7dd89457d7$export$b67359430d3b1b2(3);
    var bx = -a[0], by = -a[1], bz = -a[2], bw = a[3], ax = a[4], ay = a[5], az = a[6], aw = a[7];
    var magnitude = bx * bx + by * by + bz * bz + bw * bw; //Only scale if it makes sense
    if (magnitude > 0) {
        translation[0] = (ax * bw + aw * bx + ay * bz - az * by) * 2 / magnitude;
        translation[1] = (ay * bw + aw * by + az * bx - ax * bz) * 2 / magnitude;
        translation[2] = (az * bw + aw * bz + ax * by - ay * bx) * 2 / magnitude;
    } else {
        translation[0] = (ax * bw + aw * bx + ay * bz - az * by) * 2;
        translation[1] = (ay * bw + aw * by + az * bx - ax * bz) * 2;
        translation[2] = (az * bw + aw * bz + ax * by - ay * bx) * 2;
    }
    $1ac1b59392edf35b$export$9545ac307f2a256b(out, a, translation);
    return out;
}
function $1ac1b59392edf35b$export$202e99f82f7f0395(out, mat) {
    out[0] = mat[12];
    out[1] = mat[13];
    out[2] = mat[14];
    return out;
}
function $1ac1b59392edf35b$export$71dc54d92bd04b57(out, mat) {
    var m11 = mat[0];
    var m12 = mat[1];
    var m13 = mat[2];
    var m21 = mat[4];
    var m22 = mat[5];
    var m23 = mat[6];
    var m31 = mat[8];
    var m32 = mat[9];
    var m33 = mat[10];
    out[0] = Math.hypot(m11, m12, m13);
    out[1] = Math.hypot(m21, m22, m23);
    out[2] = Math.hypot(m31, m32, m33);
    return out;
}
function $1ac1b59392edf35b$export$df3937d3b537df0a(out, mat) {
    var scaling = new $14f38b7dd89457d7$export$b67359430d3b1b2(3);
    $1ac1b59392edf35b$export$71dc54d92bd04b57(scaling, mat);
    var is1 = 1 / scaling[0];
    var is2 = 1 / scaling[1];
    var is3 = 1 / scaling[2];
    var sm11 = mat[0] * is1;
    var sm12 = mat[1] * is2;
    var sm13 = mat[2] * is3;
    var sm21 = mat[4] * is1;
    var sm22 = mat[5] * is2;
    var sm23 = mat[6] * is3;
    var sm31 = mat[8] * is1;
    var sm32 = mat[9] * is2;
    var sm33 = mat[10] * is3;
    var trace = sm11 + sm22 + sm33;
    var S = 0;
    if (trace > 0) {
        S = Math.sqrt(trace + 1.0) * 2;
        out[3] = 0.25 * S;
        out[0] = (sm23 - sm32) / S;
        out[1] = (sm31 - sm13) / S;
        out[2] = (sm12 - sm21) / S;
    } else if (sm11 > sm22 && sm11 > sm33) {
        S = Math.sqrt(1.0 + sm11 - sm22 - sm33) * 2;
        out[3] = (sm23 - sm32) / S;
        out[0] = 0.25 * S;
        out[1] = (sm12 + sm21) / S;
        out[2] = (sm31 + sm13) / S;
    } else if (sm22 > sm33) {
        S = Math.sqrt(1.0 + sm22 - sm11 - sm33) * 2;
        out[3] = (sm31 - sm13) / S;
        out[0] = (sm12 + sm21) / S;
        out[1] = 0.25 * S;
        out[2] = (sm23 + sm32) / S;
    } else {
        S = Math.sqrt(1.0 + sm33 - sm11 - sm22) * 2;
        out[3] = (sm12 - sm21) / S;
        out[0] = (sm31 + sm13) / S;
        out[1] = (sm23 + sm32) / S;
        out[2] = 0.25 * S;
    }
    return out;
}
function $1ac1b59392edf35b$export$ddf9c55c9f2be172(out, q, v, s) {
    // Quaternion math
    var x = q[0], y = q[1], z = q[2], w = q[3];
    var x2 = x + x;
    var y2 = y + y;
    var z2 = z + z;
    var xx = x * x2;
    var xy = x * y2;
    var xz = x * z2;
    var yy = y * y2;
    var yz = y * z2;
    var zz = z * z2;
    var wx = w * x2;
    var wy = w * y2;
    var wz = w * z2;
    var sx = s[0];
    var sy = s[1];
    var sz = s[2];
    out[0] = (1 - (yy + zz)) * sx;
    out[1] = (xy + wz) * sx;
    out[2] = (xz - wy) * sx;
    out[3] = 0;
    out[4] = (xy - wz) * sy;
    out[5] = (1 - (xx + zz)) * sy;
    out[6] = (yz + wx) * sy;
    out[7] = 0;
    out[8] = (xz + wy) * sz;
    out[9] = (yz - wx) * sz;
    out[10] = (1 - (xx + yy)) * sz;
    out[11] = 0;
    out[12] = v[0];
    out[13] = v[1];
    out[14] = v[2];
    out[15] = 1;
    return out;
}
function $1ac1b59392edf35b$export$1def1f860edc4b1f(out, q, v, s, o) {
    // Quaternion math
    var x = q[0], y = q[1], z = q[2], w = q[3];
    var x2 = x + x;
    var y2 = y + y;
    var z2 = z + z;
    var xx = x * x2;
    var xy = x * y2;
    var xz = x * z2;
    var yy = y * y2;
    var yz = y * z2;
    var zz = z * z2;
    var wx = w * x2;
    var wy = w * y2;
    var wz = w * z2;
    var sx = s[0];
    var sy = s[1];
    var sz = s[2];
    var ox = o[0];
    var oy = o[1];
    var oz = o[2];
    var out0 = (1 - (yy + zz)) * sx;
    var out1 = (xy + wz) * sx;
    var out2 = (xz - wy) * sx;
    var out4 = (xy - wz) * sy;
    var out5 = (1 - (xx + zz)) * sy;
    var out6 = (yz + wx) * sy;
    var out8 = (xz + wy) * sz;
    var out9 = (yz - wx) * sz;
    var out10 = (1 - (xx + yy)) * sz;
    out[0] = out0;
    out[1] = out1;
    out[2] = out2;
    out[3] = 0;
    out[4] = out4;
    out[5] = out5;
    out[6] = out6;
    out[7] = 0;
    out[8] = out8;
    out[9] = out9;
    out[10] = out10;
    out[11] = 0;
    out[12] = v[0] + ox - (out0 * ox + out4 * oy + out8 * oz);
    out[13] = v[1] + oy - (out1 * ox + out5 * oy + out9 * oz);
    out[14] = v[2] + oz - (out2 * ox + out6 * oy + out10 * oz);
    out[15] = 1;
    return out;
}
function $1ac1b59392edf35b$export$2ff2bbe382249af7(out, q) {
    var x = q[0], y = q[1], z = q[2], w = q[3];
    var x2 = x + x;
    var y2 = y + y;
    var z2 = z + z;
    var xx = x * x2;
    var yx = y * x2;
    var yy = y * y2;
    var zx = z * x2;
    var zy = z * y2;
    var zz = z * z2;
    var wx = w * x2;
    var wy = w * y2;
    var wz = w * z2;
    out[0] = 1 - yy - zz;
    out[1] = yx + wz;
    out[2] = zx - wy;
    out[3] = 0;
    out[4] = yx - wz;
    out[5] = 1 - xx - zz;
    out[6] = zy + wx;
    out[7] = 0;
    out[8] = zx + wy;
    out[9] = zy - wx;
    out[10] = 1 - xx - yy;
    out[11] = 0;
    out[12] = 0;
    out[13] = 0;
    out[14] = 0;
    out[15] = 1;
    return out;
}
function $1ac1b59392edf35b$export$89b5708c387cac6c(out, left, right, bottom, top, near, far) {
    var rl = 1 / (right - left);
    var tb = 1 / (top - bottom);
    var nf = 1 / (near - far);
    out[0] = near * 2 * rl;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = near * 2 * tb;
    out[6] = 0;
    out[7] = 0;
    out[8] = (right + left) * rl;
    out[9] = (top + bottom) * tb;
    out[10] = (far + near) * nf;
    out[11] = -1;
    out[12] = 0;
    out[13] = 0;
    out[14] = far * near * 2 * nf;
    out[15] = 0;
    return out;
}
function $1ac1b59392edf35b$export$4cf19729ec9a96b8(out, fovy, aspect, near, far) {
    var f = 1.0 / Math.tan(fovy / 2), nf;
    out[0] = f / aspect;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = f;
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[11] = -1;
    out[12] = 0;
    out[13] = 0;
    out[15] = 0;
    if (far != null && far !== Infinity) {
        nf = 1 / (near - far);
        out[10] = (far + near) * nf;
        out[14] = 2 * far * near * nf;
    } else {
        out[10] = -1;
        out[14] = -2 * near;
    }
    return out;
}
var $1ac1b59392edf35b$export$541149539f3a4684 = $1ac1b59392edf35b$export$4cf19729ec9a96b8;
function $1ac1b59392edf35b$export$294bba99a6af0c0c(out, fovy, aspect, near, far) {
    var f = 1.0 / Math.tan(fovy / 2), nf;
    out[0] = f / aspect;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = f;
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[11] = -1;
    out[12] = 0;
    out[13] = 0;
    out[15] = 0;
    if (far != null && far !== Infinity) {
        nf = 1 / (near - far);
        out[10] = far * nf;
        out[14] = far * near * nf;
    } else {
        out[10] = -1;
        out[14] = -near;
    }
    return out;
}
function $1ac1b59392edf35b$export$58ae211c788e338f(out, fov, near, far) {
    var upTan = Math.tan(fov.upDegrees * Math.PI / 180.0);
    var downTan = Math.tan(fov.downDegrees * Math.PI / 180.0);
    var leftTan = Math.tan(fov.leftDegrees * Math.PI / 180.0);
    var rightTan = Math.tan(fov.rightDegrees * Math.PI / 180.0);
    var xScale = 2.0 / (leftTan + rightTan);
    var yScale = 2.0 / (upTan + downTan);
    out[0] = xScale;
    out[1] = 0.0;
    out[2] = 0.0;
    out[3] = 0.0;
    out[4] = 0.0;
    out[5] = yScale;
    out[6] = 0.0;
    out[7] = 0.0;
    out[8] = -((leftTan - rightTan) * xScale * 0.5);
    out[9] = (upTan - downTan) * yScale * 0.5;
    out[10] = far / (near - far);
    out[11] = -1;
    out[12] = 0.0;
    out[13] = 0.0;
    out[14] = far * near / (near - far);
    out[15] = 0.0;
    return out;
}
function $1ac1b59392edf35b$export$c5f65ef3eb668f27(out, left, right, bottom, top, near, far) {
    var lr = 1 / (left - right);
    var bt = 1 / (bottom - top);
    var nf = 1 / (near - far);
    out[0] = -2 * lr;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = -2 * bt;
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[10] = 2 * nf;
    out[11] = 0;
    out[12] = (left + right) * lr;
    out[13] = (top + bottom) * bt;
    out[14] = (far + near) * nf;
    out[15] = 1;
    return out;
}
var $1ac1b59392edf35b$export$4f2167e613cfc87b = $1ac1b59392edf35b$export$c5f65ef3eb668f27;
function $1ac1b59392edf35b$export$b1d31ea7b4d854e(out, left, right, bottom, top, near, far) {
    var lr = 1 / (left - right);
    var bt = 1 / (bottom - top);
    var nf = 1 / (near - far);
    out[0] = -2 * lr;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = -2 * bt;
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[10] = nf;
    out[11] = 0;
    out[12] = (left + right) * lr;
    out[13] = (top + bottom) * bt;
    out[14] = near * nf;
    out[15] = 1;
    return out;
}
function $1ac1b59392edf35b$export$d924e14fd6d9aa66(out, eye, center, up) {
    var x0, x1, x2, y0, y1, y2, z0, z1, z2, len;
    var eyex = eye[0];
    var eyey = eye[1];
    var eyez = eye[2];
    var upx = up[0];
    var upy = up[1];
    var upz = up[2];
    var centerx = center[0];
    var centery = center[1];
    var centerz = center[2];
    if (Math.abs(eyex - centerx) < $14f38b7dd89457d7$export$fd293b15f47e270 && Math.abs(eyey - centery) < $14f38b7dd89457d7$export$fd293b15f47e270 && Math.abs(eyez - centerz) < $14f38b7dd89457d7$export$fd293b15f47e270) return $1ac1b59392edf35b$export$f0954fd7d5368655(out);
    z0 = eyex - centerx;
    z1 = eyey - centery;
    z2 = eyez - centerz;
    len = 1 / Math.hypot(z0, z1, z2);
    z0 *= len;
    z1 *= len;
    z2 *= len;
    x0 = upy * z2 - upz * z1;
    x1 = upz * z0 - upx * z2;
    x2 = upx * z1 - upy * z0;
    len = Math.hypot(x0, x1, x2);
    if (!len) {
        x0 = 0;
        x1 = 0;
        x2 = 0;
    } else {
        len = 1 / len;
        x0 *= len;
        x1 *= len;
        x2 *= len;
    }
    y0 = z1 * x2 - z2 * x1;
    y1 = z2 * x0 - z0 * x2;
    y2 = z0 * x1 - z1 * x0;
    len = Math.hypot(y0, y1, y2);
    if (!len) {
        y0 = 0;
        y1 = 0;
        y2 = 0;
    } else {
        len = 1 / len;
        y0 *= len;
        y1 *= len;
        y2 *= len;
    }
    out[0] = x0;
    out[1] = y0;
    out[2] = z0;
    out[3] = 0;
    out[4] = x1;
    out[5] = y1;
    out[6] = z1;
    out[7] = 0;
    out[8] = x2;
    out[9] = y2;
    out[10] = z2;
    out[11] = 0;
    out[12] = -(x0 * eyex + x1 * eyey + x2 * eyez);
    out[13] = -(y0 * eyex + y1 * eyey + y2 * eyez);
    out[14] = -(z0 * eyex + z1 * eyey + z2 * eyez);
    out[15] = 1;
    return out;
}
function $1ac1b59392edf35b$export$aa67782f4dc9e52c(out, eye, target, up) {
    var eyex = eye[0], eyey = eye[1], eyez = eye[2], upx = up[0], upy = up[1], upz = up[2];
    var z0 = eyex - target[0], z1 = eyey - target[1], z2 = eyez - target[2];
    var len = z0 * z0 + z1 * z1 + z2 * z2;
    if (len > 0) {
        len = 1 / Math.sqrt(len);
        z0 *= len;
        z1 *= len;
        z2 *= len;
    }
    var x0 = upy * z2 - upz * z1, x1 = upz * z0 - upx * z2, x2 = upx * z1 - upy * z0;
    len = x0 * x0 + x1 * x1 + x2 * x2;
    if (len > 0) {
        len = 1 / Math.sqrt(len);
        x0 *= len;
        x1 *= len;
        x2 *= len;
    }
    out[0] = x0;
    out[1] = x1;
    out[2] = x2;
    out[3] = 0;
    out[4] = z1 * x2 - z2 * x1;
    out[5] = z2 * x0 - z0 * x2;
    out[6] = z0 * x1 - z1 * x0;
    out[7] = 0;
    out[8] = z0;
    out[9] = z1;
    out[10] = z2;
    out[11] = 0;
    out[12] = eyex;
    out[13] = eyey;
    out[14] = eyez;
    out[15] = 1;
    return out;
}
function $1ac1b59392edf35b$export$42d51816ce590c93(a) {
    return "mat4(" + a[0] + ", " + a[1] + ", " + a[2] + ", " + a[3] + ", " + a[4] + ", " + a[5] + ", " + a[6] + ", " + a[7] + ", " + a[8] + ", " + a[9] + ", " + a[10] + ", " + a[11] + ", " + a[12] + ", " + a[13] + ", " + a[14] + ", " + a[15] + ")";
}
function $1ac1b59392edf35b$export$326827e8268e9cdb(a) {
    return Math.hypot(a[0], a[1], a[2], a[3], a[4], a[5], a[6], a[7], a[8], a[9], a[10], a[11], a[12], a[13], a[14], a[15]);
}
function $1ac1b59392edf35b$export$e16d8520af44a096(out, a, b) {
    out[0] = a[0] + b[0];
    out[1] = a[1] + b[1];
    out[2] = a[2] + b[2];
    out[3] = a[3] + b[3];
    out[4] = a[4] + b[4];
    out[5] = a[5] + b[5];
    out[6] = a[6] + b[6];
    out[7] = a[7] + b[7];
    out[8] = a[8] + b[8];
    out[9] = a[9] + b[9];
    out[10] = a[10] + b[10];
    out[11] = a[11] + b[11];
    out[12] = a[12] + b[12];
    out[13] = a[13] + b[13];
    out[14] = a[14] + b[14];
    out[15] = a[15] + b[15];
    return out;
}
function $1ac1b59392edf35b$export$4e2d2ead65e5f7e3(out, a, b) {
    out[0] = a[0] - b[0];
    out[1] = a[1] - b[1];
    out[2] = a[2] - b[2];
    out[3] = a[3] - b[3];
    out[4] = a[4] - b[4];
    out[5] = a[5] - b[5];
    out[6] = a[6] - b[6];
    out[7] = a[7] - b[7];
    out[8] = a[8] - b[8];
    out[9] = a[9] - b[9];
    out[10] = a[10] - b[10];
    out[11] = a[11] - b[11];
    out[12] = a[12] - b[12];
    out[13] = a[13] - b[13];
    out[14] = a[14] - b[14];
    out[15] = a[15] - b[15];
    return out;
}
function $1ac1b59392edf35b$export$c697bed75648cdb7(out, a, b) {
    out[0] = a[0] * b;
    out[1] = a[1] * b;
    out[2] = a[2] * b;
    out[3] = a[3] * b;
    out[4] = a[4] * b;
    out[5] = a[5] * b;
    out[6] = a[6] * b;
    out[7] = a[7] * b;
    out[8] = a[8] * b;
    out[9] = a[9] * b;
    out[10] = a[10] * b;
    out[11] = a[11] * b;
    out[12] = a[12] * b;
    out[13] = a[13] * b;
    out[14] = a[14] * b;
    out[15] = a[15] * b;
    return out;
}
function $1ac1b59392edf35b$export$553579f63bdd7137(out, a, b, scale) {
    out[0] = a[0] + b[0] * scale;
    out[1] = a[1] + b[1] * scale;
    out[2] = a[2] + b[2] * scale;
    out[3] = a[3] + b[3] * scale;
    out[4] = a[4] + b[4] * scale;
    out[5] = a[5] + b[5] * scale;
    out[6] = a[6] + b[6] * scale;
    out[7] = a[7] + b[7] * scale;
    out[8] = a[8] + b[8] * scale;
    out[9] = a[9] + b[9] * scale;
    out[10] = a[10] + b[10] * scale;
    out[11] = a[11] + b[11] * scale;
    out[12] = a[12] + b[12] * scale;
    out[13] = a[13] + b[13] * scale;
    out[14] = a[14] + b[14] * scale;
    out[15] = a[15] + b[15] * scale;
    return out;
}
function $1ac1b59392edf35b$export$f2599a5cf1109d8(a, b) {
    return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3] && a[4] === b[4] && a[5] === b[5] && a[6] === b[6] && a[7] === b[7] && a[8] === b[8] && a[9] === b[9] && a[10] === b[10] && a[11] === b[11] && a[12] === b[12] && a[13] === b[13] && a[14] === b[14] && a[15] === b[15];
}
function $1ac1b59392edf35b$export$e9bab7fafb253603(a, b) {
    var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3];
    var a4 = a[4], a5 = a[5], a6 = a[6], a7 = a[7];
    var a8 = a[8], a9 = a[9], a10 = a[10], a11 = a[11];
    var a12 = a[12], a13 = a[13], a14 = a[14], a15 = a[15];
    var b0 = b[0], b1 = b[1], b2 = b[2], b3 = b[3];
    var b4 = b[4], b5 = b[5], b6 = b[6], b7 = b[7];
    var b8 = b[8], b9 = b[9], b10 = b[10], b11 = b[11];
    var b12 = b[12], b13 = b[13], b14 = b[14], b15 = b[15];
    return Math.abs(a0 - b0) <= $14f38b7dd89457d7$export$fd293b15f47e270 * Math.max(1.0, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= $14f38b7dd89457d7$export$fd293b15f47e270 * Math.max(1.0, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= $14f38b7dd89457d7$export$fd293b15f47e270 * Math.max(1.0, Math.abs(a2), Math.abs(b2)) && Math.abs(a3 - b3) <= $14f38b7dd89457d7$export$fd293b15f47e270 * Math.max(1.0, Math.abs(a3), Math.abs(b3)) && Math.abs(a4 - b4) <= $14f38b7dd89457d7$export$fd293b15f47e270 * Math.max(1.0, Math.abs(a4), Math.abs(b4)) && Math.abs(a5 - b5) <= $14f38b7dd89457d7$export$fd293b15f47e270 * Math.max(1.0, Math.abs(a5), Math.abs(b5)) && Math.abs(a6 - b6) <= $14f38b7dd89457d7$export$fd293b15f47e270 * Math.max(1.0, Math.abs(a6), Math.abs(b6)) && Math.abs(a7 - b7) <= $14f38b7dd89457d7$export$fd293b15f47e270 * Math.max(1.0, Math.abs(a7), Math.abs(b7)) && Math.abs(a8 - b8) <= $14f38b7dd89457d7$export$fd293b15f47e270 * Math.max(1.0, Math.abs(a8), Math.abs(b8)) && Math.abs(a9 - b9) <= $14f38b7dd89457d7$export$fd293b15f47e270 * Math.max(1.0, Math.abs(a9), Math.abs(b9)) && Math.abs(a10 - b10) <= $14f38b7dd89457d7$export$fd293b15f47e270 * Math.max(1.0, Math.abs(a10), Math.abs(b10)) && Math.abs(a11 - b11) <= $14f38b7dd89457d7$export$fd293b15f47e270 * Math.max(1.0, Math.abs(a11), Math.abs(b11)) && Math.abs(a12 - b12) <= $14f38b7dd89457d7$export$fd293b15f47e270 * Math.max(1.0, Math.abs(a12), Math.abs(b12)) && Math.abs(a13 - b13) <= $14f38b7dd89457d7$export$fd293b15f47e270 * Math.max(1.0, Math.abs(a13), Math.abs(b13)) && Math.abs(a14 - b14) <= $14f38b7dd89457d7$export$fd293b15f47e270 * Math.max(1.0, Math.abs(a14), Math.abs(b14)) && Math.abs(a15 - b15) <= $14f38b7dd89457d7$export$fd293b15f47e270 * Math.max(1.0, Math.abs(a15), Math.abs(b15));
}
var $1ac1b59392edf35b$export$6e3a27864ab166fe = $1ac1b59392edf35b$export$2060d2db72cce88f;
var $1ac1b59392edf35b$export$f93b5905241a7cca = $1ac1b59392edf35b$export$4e2d2ead65e5f7e3;

var $39ece26d1239bb77$exports = {};

$parcel$export($39ece26d1239bb77$exports, "create", () => $39ece26d1239bb77$export$185802fd694ee1f5);
$parcel$export($39ece26d1239bb77$exports, "identity", () => $39ece26d1239bb77$export$f0954fd7d5368655);
$parcel$export($39ece26d1239bb77$exports, "setAxisAngle", () => $39ece26d1239bb77$export$4286ddefc8f49512);
$parcel$export($39ece26d1239bb77$exports, "getAxisAngle", () => $39ece26d1239bb77$export$3f70be5e7d7dc51);
$parcel$export($39ece26d1239bb77$exports, "getAngle", () => $39ece26d1239bb77$export$b363da9ded343252);
$parcel$export($39ece26d1239bb77$exports, "dot", () => $39ece26d1239bb77$export$94132a0e348806d4);
$parcel$export($39ece26d1239bb77$exports, "multiply", () => $39ece26d1239bb77$export$2060d2db72cce88f);
$parcel$export($39ece26d1239bb77$exports, "rotateX", () => $39ece26d1239bb77$export$a59c8716592e09af);
$parcel$export($39ece26d1239bb77$exports, "rotateY", () => $39ece26d1239bb77$export$cf71e4d4ca4d1cfd);
$parcel$export($39ece26d1239bb77$exports, "rotateZ", () => $39ece26d1239bb77$export$ea6eae3365de5b9c);
$parcel$export($39ece26d1239bb77$exports, "calculateW", () => $39ece26d1239bb77$export$fb72b72e8d764d4e);
$parcel$export($39ece26d1239bb77$exports, "exp", () => $39ece26d1239bb77$export$b310ec824aaee37f);
$parcel$export($39ece26d1239bb77$exports, "ln", () => $39ece26d1239bb77$export$876cb1b29620556f);
$parcel$export($39ece26d1239bb77$exports, "pow", () => $39ece26d1239bb77$export$9c297f60e22e3389);
$parcel$export($39ece26d1239bb77$exports, "scale", () => $39ece26d1239bb77$export$dcdf75081b88279d);
$parcel$export($39ece26d1239bb77$exports, "slerp", () => $39ece26d1239bb77$export$1544d9bc2995de08);
$parcel$export($39ece26d1239bb77$exports, "random", () => $39ece26d1239bb77$export$4385e60b38654f68);
$parcel$export($39ece26d1239bb77$exports, "invert", () => $39ece26d1239bb77$export$6897c284b6f9f4dc);
$parcel$export($39ece26d1239bb77$exports, "conjugate", () => $39ece26d1239bb77$export$7679f47e72c62560);
$parcel$export($39ece26d1239bb77$exports, "fromMat3", () => $39ece26d1239bb77$export$272a1eb8e5a4b55b);
$parcel$export($39ece26d1239bb77$exports, "fromEuler", () => $39ece26d1239bb77$export$7a404a587ea85af);
$parcel$export($39ece26d1239bb77$exports, "str", () => $39ece26d1239bb77$export$42d51816ce590c93);
$parcel$export($39ece26d1239bb77$exports, "clone", () => $39ece26d1239bb77$export$9cd59f9826255e47);
$parcel$export($39ece26d1239bb77$exports, "fromValues", () => $39ece26d1239bb77$export$a82be99ed2a44a7d);
$parcel$export($39ece26d1239bb77$exports, "copy", () => $39ece26d1239bb77$export$784d13d8ee351f07);
$parcel$export($39ece26d1239bb77$exports, "set", () => $39ece26d1239bb77$export$adaa4cf7ef1b65be);
$parcel$export($39ece26d1239bb77$exports, "add", () => $39ece26d1239bb77$export$e16d8520af44a096);
$parcel$export($39ece26d1239bb77$exports, "mul", () => $39ece26d1239bb77$export$6e3a27864ab166fe);
$parcel$export($39ece26d1239bb77$exports, "lerp", () => $39ece26d1239bb77$export$3a89f8d6f6bf6c9f);
$parcel$export($39ece26d1239bb77$exports, "length", () => $39ece26d1239bb77$export$f24224f1c91d8156);
$parcel$export($39ece26d1239bb77$exports, "len", () => $39ece26d1239bb77$export$fc1400facf92c78);
$parcel$export($39ece26d1239bb77$exports, "squaredLength", () => $39ece26d1239bb77$export$ab44e1323ffc8376);
$parcel$export($39ece26d1239bb77$exports, "sqrLen", () => $39ece26d1239bb77$export$99d8dd3f32a3435);
$parcel$export($39ece26d1239bb77$exports, "normalize", () => $39ece26d1239bb77$export$a3295358bff77e);
$parcel$export($39ece26d1239bb77$exports, "exactEquals", () => $39ece26d1239bb77$export$f2599a5cf1109d8);
$parcel$export($39ece26d1239bb77$exports, "equals", () => $39ece26d1239bb77$export$e9bab7fafb253603);
$parcel$export($39ece26d1239bb77$exports, "rotationTo", () => $39ece26d1239bb77$export$72d66f5842c00904);
$parcel$export($39ece26d1239bb77$exports, "sqlerp", () => $39ece26d1239bb77$export$699b0866ca50f6cb);
$parcel$export($39ece26d1239bb77$exports, "setAxes", () => $39ece26d1239bb77$export$937ca0a544b2d712);

var $ba3ca37806a2b6fa$exports = {};

$parcel$export($ba3ca37806a2b6fa$exports, "create", () => $ba3ca37806a2b6fa$export$185802fd694ee1f5);
$parcel$export($ba3ca37806a2b6fa$exports, "fromMat4", () => $ba3ca37806a2b6fa$export$b4ad467060d346fe);
$parcel$export($ba3ca37806a2b6fa$exports, "clone", () => $ba3ca37806a2b6fa$export$9cd59f9826255e47);
$parcel$export($ba3ca37806a2b6fa$exports, "copy", () => $ba3ca37806a2b6fa$export$784d13d8ee351f07);
$parcel$export($ba3ca37806a2b6fa$exports, "fromValues", () => $ba3ca37806a2b6fa$export$a82be99ed2a44a7d);
$parcel$export($ba3ca37806a2b6fa$exports, "set", () => $ba3ca37806a2b6fa$export$adaa4cf7ef1b65be);
$parcel$export($ba3ca37806a2b6fa$exports, "identity", () => $ba3ca37806a2b6fa$export$f0954fd7d5368655);
$parcel$export($ba3ca37806a2b6fa$exports, "transpose", () => $ba3ca37806a2b6fa$export$9cb09a71b7d66923);
$parcel$export($ba3ca37806a2b6fa$exports, "invert", () => $ba3ca37806a2b6fa$export$6897c284b6f9f4dc);
$parcel$export($ba3ca37806a2b6fa$exports, "adjoint", () => $ba3ca37806a2b6fa$export$33f3c024b4ae00a1);
$parcel$export($ba3ca37806a2b6fa$exports, "determinant", () => $ba3ca37806a2b6fa$export$a04698f914c55ed9);
$parcel$export($ba3ca37806a2b6fa$exports, "multiply", () => $ba3ca37806a2b6fa$export$2060d2db72cce88f);
$parcel$export($ba3ca37806a2b6fa$exports, "translate", () => $ba3ca37806a2b6fa$export$d73ee8ef04f5226a);
$parcel$export($ba3ca37806a2b6fa$exports, "rotate", () => $ba3ca37806a2b6fa$export$bb628a54ab399bc9);
$parcel$export($ba3ca37806a2b6fa$exports, "scale", () => $ba3ca37806a2b6fa$export$dcdf75081b88279d);
$parcel$export($ba3ca37806a2b6fa$exports, "fromTranslation", () => $ba3ca37806a2b6fa$export$bc9e79e74e9fddf6);
$parcel$export($ba3ca37806a2b6fa$exports, "fromRotation", () => $ba3ca37806a2b6fa$export$926fc125ff3c666c);
$parcel$export($ba3ca37806a2b6fa$exports, "fromScaling", () => $ba3ca37806a2b6fa$export$832ca188ffb1955d);
$parcel$export($ba3ca37806a2b6fa$exports, "fromMat2d", () => $ba3ca37806a2b6fa$export$68f5977575fae9bf);
$parcel$export($ba3ca37806a2b6fa$exports, "fromQuat", () => $ba3ca37806a2b6fa$export$2ff2bbe382249af7);
$parcel$export($ba3ca37806a2b6fa$exports, "normalFromMat4", () => $ba3ca37806a2b6fa$export$966b25ab6dc1b1f9);
$parcel$export($ba3ca37806a2b6fa$exports, "projection", () => $ba3ca37806a2b6fa$export$b74061472fe7c07);
$parcel$export($ba3ca37806a2b6fa$exports, "str", () => $ba3ca37806a2b6fa$export$42d51816ce590c93);
$parcel$export($ba3ca37806a2b6fa$exports, "frob", () => $ba3ca37806a2b6fa$export$326827e8268e9cdb);
$parcel$export($ba3ca37806a2b6fa$exports, "add", () => $ba3ca37806a2b6fa$export$e16d8520af44a096);
$parcel$export($ba3ca37806a2b6fa$exports, "subtract", () => $ba3ca37806a2b6fa$export$4e2d2ead65e5f7e3);
$parcel$export($ba3ca37806a2b6fa$exports, "multiplyScalar", () => $ba3ca37806a2b6fa$export$c697bed75648cdb7);
$parcel$export($ba3ca37806a2b6fa$exports, "multiplyScalarAndAdd", () => $ba3ca37806a2b6fa$export$553579f63bdd7137);
$parcel$export($ba3ca37806a2b6fa$exports, "exactEquals", () => $ba3ca37806a2b6fa$export$f2599a5cf1109d8);
$parcel$export($ba3ca37806a2b6fa$exports, "equals", () => $ba3ca37806a2b6fa$export$e9bab7fafb253603);
$parcel$export($ba3ca37806a2b6fa$exports, "mul", () => $ba3ca37806a2b6fa$export$6e3a27864ab166fe);
$parcel$export($ba3ca37806a2b6fa$exports, "sub", () => $ba3ca37806a2b6fa$export$f93b5905241a7cca);

function $ba3ca37806a2b6fa$export$185802fd694ee1f5() {
    var out = new $14f38b7dd89457d7$export$b67359430d3b1b2(9);
    if ($14f38b7dd89457d7$export$b67359430d3b1b2 != Float32Array) {
        out[1] = 0;
        out[2] = 0;
        out[3] = 0;
        out[5] = 0;
        out[6] = 0;
        out[7] = 0;
    }
    out[0] = 1;
    out[4] = 1;
    out[8] = 1;
    return out;
}
function $ba3ca37806a2b6fa$export$b4ad467060d346fe(out, a) {
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[4];
    out[4] = a[5];
    out[5] = a[6];
    out[6] = a[8];
    out[7] = a[9];
    out[8] = a[10];
    return out;
}
function $ba3ca37806a2b6fa$export$9cd59f9826255e47(a) {
    var out = new $14f38b7dd89457d7$export$b67359430d3b1b2(9);
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[3];
    out[4] = a[4];
    out[5] = a[5];
    out[6] = a[6];
    out[7] = a[7];
    out[8] = a[8];
    return out;
}
function $ba3ca37806a2b6fa$export$784d13d8ee351f07(out, a) {
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[3];
    out[4] = a[4];
    out[5] = a[5];
    out[6] = a[6];
    out[7] = a[7];
    out[8] = a[8];
    return out;
}
function $ba3ca37806a2b6fa$export$a82be99ed2a44a7d(m00, m01, m02, m10, m11, m12, m20, m21, m22) {
    var out = new $14f38b7dd89457d7$export$b67359430d3b1b2(9);
    out[0] = m00;
    out[1] = m01;
    out[2] = m02;
    out[3] = m10;
    out[4] = m11;
    out[5] = m12;
    out[6] = m20;
    out[7] = m21;
    out[8] = m22;
    return out;
}
function $ba3ca37806a2b6fa$export$adaa4cf7ef1b65be(out, m00, m01, m02, m10, m11, m12, m20, m21, m22) {
    out[0] = m00;
    out[1] = m01;
    out[2] = m02;
    out[3] = m10;
    out[4] = m11;
    out[5] = m12;
    out[6] = m20;
    out[7] = m21;
    out[8] = m22;
    return out;
}
function $ba3ca37806a2b6fa$export$f0954fd7d5368655(out) {
    out[0] = 1;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 1;
    out[5] = 0;
    out[6] = 0;
    out[7] = 0;
    out[8] = 1;
    return out;
}
function $ba3ca37806a2b6fa$export$9cb09a71b7d66923(out, a) {
    // If we are transposing ourselves we can skip a few steps but have to cache some values
    if (out === a) {
        var a01 = a[1], a02 = a[2], a12 = a[5];
        out[1] = a[3];
        out[2] = a[6];
        out[3] = a01;
        out[5] = a[7];
        out[6] = a02;
        out[7] = a12;
    } else {
        out[0] = a[0];
        out[1] = a[3];
        out[2] = a[6];
        out[3] = a[1];
        out[4] = a[4];
        out[5] = a[7];
        out[6] = a[2];
        out[7] = a[5];
        out[8] = a[8];
    }
    return out;
}
function $ba3ca37806a2b6fa$export$6897c284b6f9f4dc(out, a) {
    var a00 = a[0], a01 = a[1], a02 = a[2];
    var a10 = a[3], a11 = a[4], a12 = a[5];
    var a20 = a[6], a21 = a[7], a22 = a[8];
    var b01 = a22 * a11 - a12 * a21;
    var b11 = -a22 * a10 + a12 * a20;
    var b21 = a21 * a10 - a11 * a20; // Calculate the determinant
    var det = a00 * b01 + a01 * b11 + a02 * b21;
    if (!det) return null;
    det = 1.0 / det;
    out[0] = b01 * det;
    out[1] = (-a22 * a01 + a02 * a21) * det;
    out[2] = (a12 * a01 - a02 * a11) * det;
    out[3] = b11 * det;
    out[4] = (a22 * a00 - a02 * a20) * det;
    out[5] = (-a12 * a00 + a02 * a10) * det;
    out[6] = b21 * det;
    out[7] = (-a21 * a00 + a01 * a20) * det;
    out[8] = (a11 * a00 - a01 * a10) * det;
    return out;
}
function $ba3ca37806a2b6fa$export$33f3c024b4ae00a1(out, a) {
    var a00 = a[0], a01 = a[1], a02 = a[2];
    var a10 = a[3], a11 = a[4], a12 = a[5];
    var a20 = a[6], a21 = a[7], a22 = a[8];
    out[0] = a11 * a22 - a12 * a21;
    out[1] = a02 * a21 - a01 * a22;
    out[2] = a01 * a12 - a02 * a11;
    out[3] = a12 * a20 - a10 * a22;
    out[4] = a00 * a22 - a02 * a20;
    out[5] = a02 * a10 - a00 * a12;
    out[6] = a10 * a21 - a11 * a20;
    out[7] = a01 * a20 - a00 * a21;
    out[8] = a00 * a11 - a01 * a10;
    return out;
}
function $ba3ca37806a2b6fa$export$a04698f914c55ed9(a) {
    var a00 = a[0], a01 = a[1], a02 = a[2];
    var a10 = a[3], a11 = a[4], a12 = a[5];
    var a20 = a[6], a21 = a[7], a22 = a[8];
    return a00 * (a22 * a11 - a12 * a21) + a01 * (-a22 * a10 + a12 * a20) + a02 * (a21 * a10 - a11 * a20);
}
function $ba3ca37806a2b6fa$export$2060d2db72cce88f(out, a, b) {
    var a00 = a[0], a01 = a[1], a02 = a[2];
    var a10 = a[3], a11 = a[4], a12 = a[5];
    var a20 = a[6], a21 = a[7], a22 = a[8];
    var b00 = b[0], b01 = b[1], b02 = b[2];
    var b10 = b[3], b11 = b[4], b12 = b[5];
    var b20 = b[6], b21 = b[7], b22 = b[8];
    out[0] = b00 * a00 + b01 * a10 + b02 * a20;
    out[1] = b00 * a01 + b01 * a11 + b02 * a21;
    out[2] = b00 * a02 + b01 * a12 + b02 * a22;
    out[3] = b10 * a00 + b11 * a10 + b12 * a20;
    out[4] = b10 * a01 + b11 * a11 + b12 * a21;
    out[5] = b10 * a02 + b11 * a12 + b12 * a22;
    out[6] = b20 * a00 + b21 * a10 + b22 * a20;
    out[7] = b20 * a01 + b21 * a11 + b22 * a21;
    out[8] = b20 * a02 + b21 * a12 + b22 * a22;
    return out;
}
function $ba3ca37806a2b6fa$export$d73ee8ef04f5226a(out, a, v) {
    var a00 = a[0], a01 = a[1], a02 = a[2], a10 = a[3], a11 = a[4], a12 = a[5], a20 = a[6], a21 = a[7], a22 = a[8], x = v[0], y = v[1];
    out[0] = a00;
    out[1] = a01;
    out[2] = a02;
    out[3] = a10;
    out[4] = a11;
    out[5] = a12;
    out[6] = x * a00 + y * a10 + a20;
    out[7] = x * a01 + y * a11 + a21;
    out[8] = x * a02 + y * a12 + a22;
    return out;
}
function $ba3ca37806a2b6fa$export$bb628a54ab399bc9(out, a, rad) {
    var a00 = a[0], a01 = a[1], a02 = a[2], a10 = a[3], a11 = a[4], a12 = a[5], a20 = a[6], a21 = a[7], a22 = a[8], s = Math.sin(rad), c = Math.cos(rad);
    out[0] = c * a00 + s * a10;
    out[1] = c * a01 + s * a11;
    out[2] = c * a02 + s * a12;
    out[3] = c * a10 - s * a00;
    out[4] = c * a11 - s * a01;
    out[5] = c * a12 - s * a02;
    out[6] = a20;
    out[7] = a21;
    out[8] = a22;
    return out;
}
function $ba3ca37806a2b6fa$export$dcdf75081b88279d(out, a, v) {
    var x = v[0], y = v[1];
    out[0] = x * a[0];
    out[1] = x * a[1];
    out[2] = x * a[2];
    out[3] = y * a[3];
    out[4] = y * a[4];
    out[5] = y * a[5];
    out[6] = a[6];
    out[7] = a[7];
    out[8] = a[8];
    return out;
}
function $ba3ca37806a2b6fa$export$bc9e79e74e9fddf6(out, v) {
    out[0] = 1;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 1;
    out[5] = 0;
    out[6] = v[0];
    out[7] = v[1];
    out[8] = 1;
    return out;
}
function $ba3ca37806a2b6fa$export$926fc125ff3c666c(out, rad) {
    var s = Math.sin(rad), c = Math.cos(rad);
    out[0] = c;
    out[1] = s;
    out[2] = 0;
    out[3] = -s;
    out[4] = c;
    out[5] = 0;
    out[6] = 0;
    out[7] = 0;
    out[8] = 1;
    return out;
}
function $ba3ca37806a2b6fa$export$832ca188ffb1955d(out, v) {
    out[0] = v[0];
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = v[1];
    out[5] = 0;
    out[6] = 0;
    out[7] = 0;
    out[8] = 1;
    return out;
}
function $ba3ca37806a2b6fa$export$68f5977575fae9bf(out, a) {
    out[0] = a[0];
    out[1] = a[1];
    out[2] = 0;
    out[3] = a[2];
    out[4] = a[3];
    out[5] = 0;
    out[6] = a[4];
    out[7] = a[5];
    out[8] = 1;
    return out;
}
function $ba3ca37806a2b6fa$export$2ff2bbe382249af7(out, q) {
    var x = q[0], y = q[1], z = q[2], w = q[3];
    var x2 = x + x;
    var y2 = y + y;
    var z2 = z + z;
    var xx = x * x2;
    var yx = y * x2;
    var yy = y * y2;
    var zx = z * x2;
    var zy = z * y2;
    var zz = z * z2;
    var wx = w * x2;
    var wy = w * y2;
    var wz = w * z2;
    out[0] = 1 - yy - zz;
    out[3] = yx - wz;
    out[6] = zx + wy;
    out[1] = yx + wz;
    out[4] = 1 - xx - zz;
    out[7] = zy - wx;
    out[2] = zx - wy;
    out[5] = zy + wx;
    out[8] = 1 - xx - yy;
    return out;
}
function $ba3ca37806a2b6fa$export$966b25ab6dc1b1f9(out, a) {
    var a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3];
    var a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7];
    var a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11];
    var a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15];
    var b00 = a00 * a11 - a01 * a10;
    var b01 = a00 * a12 - a02 * a10;
    var b02 = a00 * a13 - a03 * a10;
    var b03 = a01 * a12 - a02 * a11;
    var b04 = a01 * a13 - a03 * a11;
    var b05 = a02 * a13 - a03 * a12;
    var b06 = a20 * a31 - a21 * a30;
    var b07 = a20 * a32 - a22 * a30;
    var b08 = a20 * a33 - a23 * a30;
    var b09 = a21 * a32 - a22 * a31;
    var b10 = a21 * a33 - a23 * a31;
    var b11 = a22 * a33 - a23 * a32; // Calculate the determinant
    var det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;
    if (!det) return null;
    det = 1.0 / det;
    out[0] = (a11 * b11 - a12 * b10 + a13 * b09) * det;
    out[1] = (a12 * b08 - a10 * b11 - a13 * b07) * det;
    out[2] = (a10 * b10 - a11 * b08 + a13 * b06) * det;
    out[3] = (a02 * b10 - a01 * b11 - a03 * b09) * det;
    out[4] = (a00 * b11 - a02 * b08 + a03 * b07) * det;
    out[5] = (a01 * b08 - a00 * b10 - a03 * b06) * det;
    out[6] = (a31 * b05 - a32 * b04 + a33 * b03) * det;
    out[7] = (a32 * b02 - a30 * b05 - a33 * b01) * det;
    out[8] = (a30 * b04 - a31 * b02 + a33 * b00) * det;
    return out;
}
function $ba3ca37806a2b6fa$export$b74061472fe7c07(out, width, height) {
    out[0] = 2 / width;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = -2 / height;
    out[5] = 0;
    out[6] = -1;
    out[7] = 1;
    out[8] = 1;
    return out;
}
function $ba3ca37806a2b6fa$export$42d51816ce590c93(a) {
    return "mat3(" + a[0] + ", " + a[1] + ", " + a[2] + ", " + a[3] + ", " + a[4] + ", " + a[5] + ", " + a[6] + ", " + a[7] + ", " + a[8] + ")";
}
function $ba3ca37806a2b6fa$export$326827e8268e9cdb(a) {
    return Math.hypot(a[0], a[1], a[2], a[3], a[4], a[5], a[6], a[7], a[8]);
}
function $ba3ca37806a2b6fa$export$e16d8520af44a096(out, a, b) {
    out[0] = a[0] + b[0];
    out[1] = a[1] + b[1];
    out[2] = a[2] + b[2];
    out[3] = a[3] + b[3];
    out[4] = a[4] + b[4];
    out[5] = a[5] + b[5];
    out[6] = a[6] + b[6];
    out[7] = a[7] + b[7];
    out[8] = a[8] + b[8];
    return out;
}
function $ba3ca37806a2b6fa$export$4e2d2ead65e5f7e3(out, a, b) {
    out[0] = a[0] - b[0];
    out[1] = a[1] - b[1];
    out[2] = a[2] - b[2];
    out[3] = a[3] - b[3];
    out[4] = a[4] - b[4];
    out[5] = a[5] - b[5];
    out[6] = a[6] - b[6];
    out[7] = a[7] - b[7];
    out[8] = a[8] - b[8];
    return out;
}
function $ba3ca37806a2b6fa$export$c697bed75648cdb7(out, a, b) {
    out[0] = a[0] * b;
    out[1] = a[1] * b;
    out[2] = a[2] * b;
    out[3] = a[3] * b;
    out[4] = a[4] * b;
    out[5] = a[5] * b;
    out[6] = a[6] * b;
    out[7] = a[7] * b;
    out[8] = a[8] * b;
    return out;
}
function $ba3ca37806a2b6fa$export$553579f63bdd7137(out, a, b, scale) {
    out[0] = a[0] + b[0] * scale;
    out[1] = a[1] + b[1] * scale;
    out[2] = a[2] + b[2] * scale;
    out[3] = a[3] + b[3] * scale;
    out[4] = a[4] + b[4] * scale;
    out[5] = a[5] + b[5] * scale;
    out[6] = a[6] + b[6] * scale;
    out[7] = a[7] + b[7] * scale;
    out[8] = a[8] + b[8] * scale;
    return out;
}
function $ba3ca37806a2b6fa$export$f2599a5cf1109d8(a, b) {
    return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3] && a[4] === b[4] && a[5] === b[5] && a[6] === b[6] && a[7] === b[7] && a[8] === b[8];
}
function $ba3ca37806a2b6fa$export$e9bab7fafb253603(a, b) {
    var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3], a4 = a[4], a5 = a[5], a6 = a[6], a7 = a[7], a8 = a[8];
    var b0 = b[0], b1 = b[1], b2 = b[2], b3 = b[3], b4 = b[4], b5 = b[5], b6 = b[6], b7 = b[7], b8 = b[8];
    return Math.abs(a0 - b0) <= $14f38b7dd89457d7$export$fd293b15f47e270 * Math.max(1.0, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= $14f38b7dd89457d7$export$fd293b15f47e270 * Math.max(1.0, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= $14f38b7dd89457d7$export$fd293b15f47e270 * Math.max(1.0, Math.abs(a2), Math.abs(b2)) && Math.abs(a3 - b3) <= $14f38b7dd89457d7$export$fd293b15f47e270 * Math.max(1.0, Math.abs(a3), Math.abs(b3)) && Math.abs(a4 - b4) <= $14f38b7dd89457d7$export$fd293b15f47e270 * Math.max(1.0, Math.abs(a4), Math.abs(b4)) && Math.abs(a5 - b5) <= $14f38b7dd89457d7$export$fd293b15f47e270 * Math.max(1.0, Math.abs(a5), Math.abs(b5)) && Math.abs(a6 - b6) <= $14f38b7dd89457d7$export$fd293b15f47e270 * Math.max(1.0, Math.abs(a6), Math.abs(b6)) && Math.abs(a7 - b7) <= $14f38b7dd89457d7$export$fd293b15f47e270 * Math.max(1.0, Math.abs(a7), Math.abs(b7)) && Math.abs(a8 - b8) <= $14f38b7dd89457d7$export$fd293b15f47e270 * Math.max(1.0, Math.abs(a8), Math.abs(b8));
}
var $ba3ca37806a2b6fa$export$6e3a27864ab166fe = $ba3ca37806a2b6fa$export$2060d2db72cce88f;
var $ba3ca37806a2b6fa$export$f93b5905241a7cca = $ba3ca37806a2b6fa$export$4e2d2ead65e5f7e3;


var $31054a6c69637582$exports = {};

$parcel$export($31054a6c69637582$exports, "create", () => $31054a6c69637582$export$185802fd694ee1f5);
$parcel$export($31054a6c69637582$exports, "clone", () => $31054a6c69637582$export$9cd59f9826255e47);
$parcel$export($31054a6c69637582$exports, "length", () => $31054a6c69637582$export$f24224f1c91d8156);
$parcel$export($31054a6c69637582$exports, "fromValues", () => $31054a6c69637582$export$a82be99ed2a44a7d);
$parcel$export($31054a6c69637582$exports, "copy", () => $31054a6c69637582$export$784d13d8ee351f07);
$parcel$export($31054a6c69637582$exports, "set", () => $31054a6c69637582$export$adaa4cf7ef1b65be);
$parcel$export($31054a6c69637582$exports, "add", () => $31054a6c69637582$export$e16d8520af44a096);
$parcel$export($31054a6c69637582$exports, "subtract", () => $31054a6c69637582$export$4e2d2ead65e5f7e3);
$parcel$export($31054a6c69637582$exports, "multiply", () => $31054a6c69637582$export$2060d2db72cce88f);
$parcel$export($31054a6c69637582$exports, "divide", () => $31054a6c69637582$export$cd007d971a5a2143);
$parcel$export($31054a6c69637582$exports, "ceil", () => $31054a6c69637582$export$803ce6b71a0a94b2);
$parcel$export($31054a6c69637582$exports, "floor", () => $31054a6c69637582$export$a3fe094919f356fd);
$parcel$export($31054a6c69637582$exports, "min", () => $31054a6c69637582$export$96ec731ed4dcb222);
$parcel$export($31054a6c69637582$exports, "max", () => $31054a6c69637582$export$8960430cfd85939f);
$parcel$export($31054a6c69637582$exports, "round", () => $31054a6c69637582$export$2077e0241d6afd3c);
$parcel$export($31054a6c69637582$exports, "scale", () => $31054a6c69637582$export$dcdf75081b88279d);
$parcel$export($31054a6c69637582$exports, "scaleAndAdd", () => $31054a6c69637582$export$19cedf1da84ba854);
$parcel$export($31054a6c69637582$exports, "distance", () => $31054a6c69637582$export$9f17032d917177de);
$parcel$export($31054a6c69637582$exports, "squaredDistance", () => $31054a6c69637582$export$88e6ebb4fe54f538);
$parcel$export($31054a6c69637582$exports, "squaredLength", () => $31054a6c69637582$export$ab44e1323ffc8376);
$parcel$export($31054a6c69637582$exports, "negate", () => $31054a6c69637582$export$aef51622e549b8b0);
$parcel$export($31054a6c69637582$exports, "inverse", () => $31054a6c69637582$export$70ae2c07e401031b);
$parcel$export($31054a6c69637582$exports, "normalize", () => $31054a6c69637582$export$a3295358bff77e);
$parcel$export($31054a6c69637582$exports, "dot", () => $31054a6c69637582$export$94132a0e348806d4);
$parcel$export($31054a6c69637582$exports, "cross", () => $31054a6c69637582$export$bb646b20bb93d339);
$parcel$export($31054a6c69637582$exports, "lerp", () => $31054a6c69637582$export$3a89f8d6f6bf6c9f);
$parcel$export($31054a6c69637582$exports, "hermite", () => $31054a6c69637582$export$ae8865616f30561c);
$parcel$export($31054a6c69637582$exports, "bezier", () => $31054a6c69637582$export$b9c5f84610baddaf);
$parcel$export($31054a6c69637582$exports, "random", () => $31054a6c69637582$export$4385e60b38654f68);
$parcel$export($31054a6c69637582$exports, "transformMat4", () => $31054a6c69637582$export$5ffbd13800309d59);
$parcel$export($31054a6c69637582$exports, "transformMat3", () => $31054a6c69637582$export$f0bfa0a0024626ee);
$parcel$export($31054a6c69637582$exports, "transformQuat", () => $31054a6c69637582$export$c32adef9e939ce85);
$parcel$export($31054a6c69637582$exports, "rotateX", () => $31054a6c69637582$export$a59c8716592e09af);
$parcel$export($31054a6c69637582$exports, "rotateY", () => $31054a6c69637582$export$cf71e4d4ca4d1cfd);
$parcel$export($31054a6c69637582$exports, "rotateZ", () => $31054a6c69637582$export$ea6eae3365de5b9c);
$parcel$export($31054a6c69637582$exports, "angle", () => $31054a6c69637582$export$944b09d2ad10b378);
$parcel$export($31054a6c69637582$exports, "zero", () => $31054a6c69637582$export$7f9972325ebfd559);
$parcel$export($31054a6c69637582$exports, "str", () => $31054a6c69637582$export$42d51816ce590c93);
$parcel$export($31054a6c69637582$exports, "exactEquals", () => $31054a6c69637582$export$f2599a5cf1109d8);
$parcel$export($31054a6c69637582$exports, "equals", () => $31054a6c69637582$export$e9bab7fafb253603);
$parcel$export($31054a6c69637582$exports, "sub", () => $31054a6c69637582$export$f93b5905241a7cca);
$parcel$export($31054a6c69637582$exports, "mul", () => $31054a6c69637582$export$6e3a27864ab166fe);
$parcel$export($31054a6c69637582$exports, "div", () => $31054a6c69637582$export$159d9494db57879b);
$parcel$export($31054a6c69637582$exports, "dist", () => $31054a6c69637582$export$6c4a311cc157c764);
$parcel$export($31054a6c69637582$exports, "sqrDist", () => $31054a6c69637582$export$2422cd6c492a8b3a);
$parcel$export($31054a6c69637582$exports, "len", () => $31054a6c69637582$export$fc1400facf92c78);
$parcel$export($31054a6c69637582$exports, "sqrLen", () => $31054a6c69637582$export$99d8dd3f32a3435);
$parcel$export($31054a6c69637582$exports, "forEach", () => $31054a6c69637582$export$4b80e395e36b5a56);

function $31054a6c69637582$export$185802fd694ee1f5() {
    var out = new $14f38b7dd89457d7$export$b67359430d3b1b2(3);
    if ($14f38b7dd89457d7$export$b67359430d3b1b2 != Float32Array) {
        out[0] = 0;
        out[1] = 0;
        out[2] = 0;
    }
    return out;
}
function $31054a6c69637582$export$9cd59f9826255e47(a) {
    var out = new $14f38b7dd89457d7$export$b67359430d3b1b2(3);
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    return out;
}
function $31054a6c69637582$export$f24224f1c91d8156(a) {
    var x = a[0];
    var y = a[1];
    var z = a[2];
    return Math.hypot(x, y, z);
}
function $31054a6c69637582$export$a82be99ed2a44a7d(x, y, z) {
    var out = new $14f38b7dd89457d7$export$b67359430d3b1b2(3);
    out[0] = x;
    out[1] = y;
    out[2] = z;
    return out;
}
function $31054a6c69637582$export$784d13d8ee351f07(out, a) {
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    return out;
}
function $31054a6c69637582$export$adaa4cf7ef1b65be(out, x, y, z) {
    out[0] = x;
    out[1] = y;
    out[2] = z;
    return out;
}
function $31054a6c69637582$export$e16d8520af44a096(out, a, b) {
    out[0] = a[0] + b[0];
    out[1] = a[1] + b[1];
    out[2] = a[2] + b[2];
    return out;
}
function $31054a6c69637582$export$4e2d2ead65e5f7e3(out, a, b) {
    out[0] = a[0] - b[0];
    out[1] = a[1] - b[1];
    out[2] = a[2] - b[2];
    return out;
}
function $31054a6c69637582$export$2060d2db72cce88f(out, a, b) {
    out[0] = a[0] * b[0];
    out[1] = a[1] * b[1];
    out[2] = a[2] * b[2];
    return out;
}
function $31054a6c69637582$export$cd007d971a5a2143(out, a, b) {
    out[0] = a[0] / b[0];
    out[1] = a[1] / b[1];
    out[2] = a[2] / b[2];
    return out;
}
function $31054a6c69637582$export$803ce6b71a0a94b2(out, a) {
    out[0] = Math.ceil(a[0]);
    out[1] = Math.ceil(a[1]);
    out[2] = Math.ceil(a[2]);
    return out;
}
function $31054a6c69637582$export$a3fe094919f356fd(out, a) {
    out[0] = Math.floor(a[0]);
    out[1] = Math.floor(a[1]);
    out[2] = Math.floor(a[2]);
    return out;
}
function $31054a6c69637582$export$96ec731ed4dcb222(out, a, b) {
    out[0] = Math.min(a[0], b[0]);
    out[1] = Math.min(a[1], b[1]);
    out[2] = Math.min(a[2], b[2]);
    return out;
}
function $31054a6c69637582$export$8960430cfd85939f(out, a, b) {
    out[0] = Math.max(a[0], b[0]);
    out[1] = Math.max(a[1], b[1]);
    out[2] = Math.max(a[2], b[2]);
    return out;
}
function $31054a6c69637582$export$2077e0241d6afd3c(out, a) {
    out[0] = Math.round(a[0]);
    out[1] = Math.round(a[1]);
    out[2] = Math.round(a[2]);
    return out;
}
function $31054a6c69637582$export$dcdf75081b88279d(out, a, b) {
    out[0] = a[0] * b;
    out[1] = a[1] * b;
    out[2] = a[2] * b;
    return out;
}
function $31054a6c69637582$export$19cedf1da84ba854(out, a, b, scale) {
    out[0] = a[0] + b[0] * scale;
    out[1] = a[1] + b[1] * scale;
    out[2] = a[2] + b[2] * scale;
    return out;
}
function $31054a6c69637582$export$9f17032d917177de(a, b) {
    var x = b[0] - a[0];
    var y = b[1] - a[1];
    var z = b[2] - a[2];
    return Math.hypot(x, y, z);
}
function $31054a6c69637582$export$88e6ebb4fe54f538(a, b) {
    var x = b[0] - a[0];
    var y = b[1] - a[1];
    var z = b[2] - a[2];
    return x * x + y * y + z * z;
}
function $31054a6c69637582$export$ab44e1323ffc8376(a) {
    var x = a[0];
    var y = a[1];
    var z = a[2];
    return x * x + y * y + z * z;
}
function $31054a6c69637582$export$aef51622e549b8b0(out, a) {
    out[0] = -a[0];
    out[1] = -a[1];
    out[2] = -a[2];
    return out;
}
function $31054a6c69637582$export$70ae2c07e401031b(out, a) {
    out[0] = 1.0 / a[0];
    out[1] = 1.0 / a[1];
    out[2] = 1.0 / a[2];
    return out;
}
function $31054a6c69637582$export$a3295358bff77e(out, a) {
    var x = a[0];
    var y = a[1];
    var z = a[2];
    var len = x * x + y * y + z * z;
    if (len > 0) //TODO: evaluate use of glm_invsqrt here?
    len = 1 / Math.sqrt(len);
    out[0] = a[0] * len;
    out[1] = a[1] * len;
    out[2] = a[2] * len;
    return out;
}
function $31054a6c69637582$export$94132a0e348806d4(a, b) {
    return a[0] * b[0] + a[1] * b[1] + a[2] * b[2];
}
function $31054a6c69637582$export$bb646b20bb93d339(out, a, b) {
    var ax = a[0], ay = a[1], az = a[2];
    var bx = b[0], by = b[1], bz = b[2];
    out[0] = ay * bz - az * by;
    out[1] = az * bx - ax * bz;
    out[2] = ax * by - ay * bx;
    return out;
}
function $31054a6c69637582$export$3a89f8d6f6bf6c9f(out, a, b, t) {
    var ax = a[0];
    var ay = a[1];
    var az = a[2];
    out[0] = ax + t * (b[0] - ax);
    out[1] = ay + t * (b[1] - ay);
    out[2] = az + t * (b[2] - az);
    return out;
}
function $31054a6c69637582$export$ae8865616f30561c(out, a, b, c, d, t) {
    var factorTimes2 = t * t;
    var factor1 = factorTimes2 * (2 * t - 3) + 1;
    var factor2 = factorTimes2 * (t - 2) + t;
    var factor3 = factorTimes2 * (t - 1);
    var factor4 = factorTimes2 * (3 - 2 * t);
    out[0] = a[0] * factor1 + b[0] * factor2 + c[0] * factor3 + d[0] * factor4;
    out[1] = a[1] * factor1 + b[1] * factor2 + c[1] * factor3 + d[1] * factor4;
    out[2] = a[2] * factor1 + b[2] * factor2 + c[2] * factor3 + d[2] * factor4;
    return out;
}
function $31054a6c69637582$export$b9c5f84610baddaf(out, a, b, c, d, t) {
    var inverseFactor = 1 - t;
    var inverseFactorTimesTwo = inverseFactor * inverseFactor;
    var factorTimes2 = t * t;
    var factor1 = inverseFactorTimesTwo * inverseFactor;
    var factor2 = 3 * t * inverseFactorTimesTwo;
    var factor3 = 3 * factorTimes2 * inverseFactor;
    var factor4 = factorTimes2 * t;
    out[0] = a[0] * factor1 + b[0] * factor2 + c[0] * factor3 + d[0] * factor4;
    out[1] = a[1] * factor1 + b[1] * factor2 + c[1] * factor3 + d[1] * factor4;
    out[2] = a[2] * factor1 + b[2] * factor2 + c[2] * factor3 + d[2] * factor4;
    return out;
}
function $31054a6c69637582$export$4385e60b38654f68(out, scale) {
    scale = scale || 1.0;
    var r = $14f38b7dd89457d7$export$5ada478c8a628231() * 2.0 * Math.PI;
    var z = $14f38b7dd89457d7$export$5ada478c8a628231() * 2.0 - 1.0;
    var zScale = Math.sqrt(1.0 - z * z) * scale;
    out[0] = Math.cos(r) * zScale;
    out[1] = Math.sin(r) * zScale;
    out[2] = z * scale;
    return out;
}
function $31054a6c69637582$export$5ffbd13800309d59(out, a, m) {
    var x = a[0], y = a[1], z = a[2];
    var w = m[3] * x + m[7] * y + m[11] * z + m[15];
    w = w || 1.0;
    out[0] = (m[0] * x + m[4] * y + m[8] * z + m[12]) / w;
    out[1] = (m[1] * x + m[5] * y + m[9] * z + m[13]) / w;
    out[2] = (m[2] * x + m[6] * y + m[10] * z + m[14]) / w;
    return out;
}
function $31054a6c69637582$export$f0bfa0a0024626ee(out, a, m) {
    var x = a[0], y = a[1], z = a[2];
    out[0] = x * m[0] + y * m[3] + z * m[6];
    out[1] = x * m[1] + y * m[4] + z * m[7];
    out[2] = x * m[2] + y * m[5] + z * m[8];
    return out;
}
function $31054a6c69637582$export$c32adef9e939ce85(out, a, q) {
    // benchmarks: https://jsperf.com/quaternion-transform-vec3-implementations-fixed
    var qx = q[0], qy = q[1], qz = q[2], qw = q[3];
    var x = a[0], y = a[1], z = a[2]; // var qvec = [qx, qy, qz];
    // var uv = vec3.cross([], qvec, a);
    var uvx = qy * z - qz * y, uvy = qz * x - qx * z, uvz = qx * y - qy * x; // var uuv = vec3.cross([], qvec, uv);
    var uuvx = qy * uvz - qz * uvy, uuvy = qz * uvx - qx * uvz, uuvz = qx * uvy - qy * uvx; // vec3.scale(uv, uv, 2 * w);
    var w2 = qw * 2;
    uvx *= w2;
    uvy *= w2;
    uvz *= w2; // vec3.scale(uuv, uuv, 2);
    uuvx *= 2;
    uuvy *= 2;
    uuvz *= 2; // return vec3.add(out, a, vec3.add(out, uv, uuv));
    out[0] = x + uvx + uuvx;
    out[1] = y + uvy + uuvy;
    out[2] = z + uvz + uuvz;
    return out;
}
function $31054a6c69637582$export$a59c8716592e09af(out, a, b, rad) {
    var p = [], r = []; //Translate point to the origin
    p[0] = a[0] - b[0];
    p[1] = a[1] - b[1];
    p[2] = a[2] - b[2]; //perform rotation
    r[0] = p[0];
    r[1] = p[1] * Math.cos(rad) - p[2] * Math.sin(rad);
    r[2] = p[1] * Math.sin(rad) + p[2] * Math.cos(rad); //translate to correct position
    out[0] = r[0] + b[0];
    out[1] = r[1] + b[1];
    out[2] = r[2] + b[2];
    return out;
}
function $31054a6c69637582$export$cf71e4d4ca4d1cfd(out, a, b, rad) {
    var p = [], r = []; //Translate point to the origin
    p[0] = a[0] - b[0];
    p[1] = a[1] - b[1];
    p[2] = a[2] - b[2]; //perform rotation
    r[0] = p[2] * Math.sin(rad) + p[0] * Math.cos(rad);
    r[1] = p[1];
    r[2] = p[2] * Math.cos(rad) - p[0] * Math.sin(rad); //translate to correct position
    out[0] = r[0] + b[0];
    out[1] = r[1] + b[1];
    out[2] = r[2] + b[2];
    return out;
}
function $31054a6c69637582$export$ea6eae3365de5b9c(out, a, b, rad) {
    var p = [], r = []; //Translate point to the origin
    p[0] = a[0] - b[0];
    p[1] = a[1] - b[1];
    p[2] = a[2] - b[2]; //perform rotation
    r[0] = p[0] * Math.cos(rad) - p[1] * Math.sin(rad);
    r[1] = p[0] * Math.sin(rad) + p[1] * Math.cos(rad);
    r[2] = p[2]; //translate to correct position
    out[0] = r[0] + b[0];
    out[1] = r[1] + b[1];
    out[2] = r[2] + b[2];
    return out;
}
function $31054a6c69637582$export$944b09d2ad10b378(a, b) {
    var ax = a[0], ay = a[1], az = a[2], bx = b[0], by = b[1], bz = b[2], mag1 = Math.sqrt(ax * ax + ay * ay + az * az), mag2 = Math.sqrt(bx * bx + by * by + bz * bz), mag = mag1 * mag2, cosine = mag && $31054a6c69637582$export$94132a0e348806d4(a, b) / mag;
    return Math.acos(Math.min(Math.max(cosine, -1), 1));
}
function $31054a6c69637582$export$7f9972325ebfd559(out) {
    out[0] = 0.0;
    out[1] = 0.0;
    out[2] = 0.0;
    return out;
}
function $31054a6c69637582$export$42d51816ce590c93(a) {
    return "vec3(" + a[0] + ", " + a[1] + ", " + a[2] + ")";
}
function $31054a6c69637582$export$f2599a5cf1109d8(a, b) {
    return a[0] === b[0] && a[1] === b[1] && a[2] === b[2];
}
function $31054a6c69637582$export$e9bab7fafb253603(a, b) {
    var a0 = a[0], a1 = a[1], a2 = a[2];
    var b0 = b[0], b1 = b[1], b2 = b[2];
    return Math.abs(a0 - b0) <= $14f38b7dd89457d7$export$fd293b15f47e270 * Math.max(1.0, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= $14f38b7dd89457d7$export$fd293b15f47e270 * Math.max(1.0, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= $14f38b7dd89457d7$export$fd293b15f47e270 * Math.max(1.0, Math.abs(a2), Math.abs(b2));
}
var $31054a6c69637582$export$f93b5905241a7cca = $31054a6c69637582$export$4e2d2ead65e5f7e3;
var $31054a6c69637582$export$6e3a27864ab166fe = $31054a6c69637582$export$2060d2db72cce88f;
var $31054a6c69637582$export$159d9494db57879b = $31054a6c69637582$export$cd007d971a5a2143;
var $31054a6c69637582$export$6c4a311cc157c764 = $31054a6c69637582$export$9f17032d917177de;
var $31054a6c69637582$export$2422cd6c492a8b3a = $31054a6c69637582$export$88e6ebb4fe54f538;
var $31054a6c69637582$export$fc1400facf92c78 = $31054a6c69637582$export$f24224f1c91d8156;
var $31054a6c69637582$export$99d8dd3f32a3435 = $31054a6c69637582$export$ab44e1323ffc8376;
var $31054a6c69637582$export$4b80e395e36b5a56 = function() {
    var vec = $31054a6c69637582$export$185802fd694ee1f5();
    return function(a, stride, offset, count, fn, arg) {
        var i, l;
        if (!stride) stride = 3;
        if (!offset) offset = 0;
        if (count) l = Math.min(count * stride + offset, a.length);
        else l = a.length;
        for(i = offset; i < l; i += stride){
            vec[0] = a[i];
            vec[1] = a[i + 1];
            vec[2] = a[i + 2];
            fn(vec, vec, arg);
            a[i] = vec[0];
            a[i + 1] = vec[1];
            a[i + 2] = vec[2];
        }
        return a;
    };
}();


var $4c4ac78b213a9c07$exports = {};

$parcel$export($4c4ac78b213a9c07$exports, "create", () => $4c4ac78b213a9c07$export$185802fd694ee1f5);
$parcel$export($4c4ac78b213a9c07$exports, "clone", () => $4c4ac78b213a9c07$export$9cd59f9826255e47);
$parcel$export($4c4ac78b213a9c07$exports, "fromValues", () => $4c4ac78b213a9c07$export$a82be99ed2a44a7d);
$parcel$export($4c4ac78b213a9c07$exports, "copy", () => $4c4ac78b213a9c07$export$784d13d8ee351f07);
$parcel$export($4c4ac78b213a9c07$exports, "set", () => $4c4ac78b213a9c07$export$adaa4cf7ef1b65be);
$parcel$export($4c4ac78b213a9c07$exports, "add", () => $4c4ac78b213a9c07$export$e16d8520af44a096);
$parcel$export($4c4ac78b213a9c07$exports, "subtract", () => $4c4ac78b213a9c07$export$4e2d2ead65e5f7e3);
$parcel$export($4c4ac78b213a9c07$exports, "multiply", () => $4c4ac78b213a9c07$export$2060d2db72cce88f);
$parcel$export($4c4ac78b213a9c07$exports, "divide", () => $4c4ac78b213a9c07$export$cd007d971a5a2143);
$parcel$export($4c4ac78b213a9c07$exports, "ceil", () => $4c4ac78b213a9c07$export$803ce6b71a0a94b2);
$parcel$export($4c4ac78b213a9c07$exports, "floor", () => $4c4ac78b213a9c07$export$a3fe094919f356fd);
$parcel$export($4c4ac78b213a9c07$exports, "min", () => $4c4ac78b213a9c07$export$96ec731ed4dcb222);
$parcel$export($4c4ac78b213a9c07$exports, "max", () => $4c4ac78b213a9c07$export$8960430cfd85939f);
$parcel$export($4c4ac78b213a9c07$exports, "round", () => $4c4ac78b213a9c07$export$2077e0241d6afd3c);
$parcel$export($4c4ac78b213a9c07$exports, "scale", () => $4c4ac78b213a9c07$export$dcdf75081b88279d);
$parcel$export($4c4ac78b213a9c07$exports, "scaleAndAdd", () => $4c4ac78b213a9c07$export$19cedf1da84ba854);
$parcel$export($4c4ac78b213a9c07$exports, "distance", () => $4c4ac78b213a9c07$export$9f17032d917177de);
$parcel$export($4c4ac78b213a9c07$exports, "squaredDistance", () => $4c4ac78b213a9c07$export$88e6ebb4fe54f538);
$parcel$export($4c4ac78b213a9c07$exports, "length", () => $4c4ac78b213a9c07$export$f24224f1c91d8156);
$parcel$export($4c4ac78b213a9c07$exports, "squaredLength", () => $4c4ac78b213a9c07$export$ab44e1323ffc8376);
$parcel$export($4c4ac78b213a9c07$exports, "negate", () => $4c4ac78b213a9c07$export$aef51622e549b8b0);
$parcel$export($4c4ac78b213a9c07$exports, "inverse", () => $4c4ac78b213a9c07$export$70ae2c07e401031b);
$parcel$export($4c4ac78b213a9c07$exports, "normalize", () => $4c4ac78b213a9c07$export$a3295358bff77e);
$parcel$export($4c4ac78b213a9c07$exports, "dot", () => $4c4ac78b213a9c07$export$94132a0e348806d4);
$parcel$export($4c4ac78b213a9c07$exports, "cross", () => $4c4ac78b213a9c07$export$bb646b20bb93d339);
$parcel$export($4c4ac78b213a9c07$exports, "lerp", () => $4c4ac78b213a9c07$export$3a89f8d6f6bf6c9f);
$parcel$export($4c4ac78b213a9c07$exports, "random", () => $4c4ac78b213a9c07$export$4385e60b38654f68);
$parcel$export($4c4ac78b213a9c07$exports, "transformMat4", () => $4c4ac78b213a9c07$export$5ffbd13800309d59);
$parcel$export($4c4ac78b213a9c07$exports, "transformQuat", () => $4c4ac78b213a9c07$export$c32adef9e939ce85);
$parcel$export($4c4ac78b213a9c07$exports, "zero", () => $4c4ac78b213a9c07$export$7f9972325ebfd559);
$parcel$export($4c4ac78b213a9c07$exports, "str", () => $4c4ac78b213a9c07$export$42d51816ce590c93);
$parcel$export($4c4ac78b213a9c07$exports, "exactEquals", () => $4c4ac78b213a9c07$export$f2599a5cf1109d8);
$parcel$export($4c4ac78b213a9c07$exports, "equals", () => $4c4ac78b213a9c07$export$e9bab7fafb253603);
$parcel$export($4c4ac78b213a9c07$exports, "sub", () => $4c4ac78b213a9c07$export$f93b5905241a7cca);
$parcel$export($4c4ac78b213a9c07$exports, "mul", () => $4c4ac78b213a9c07$export$6e3a27864ab166fe);
$parcel$export($4c4ac78b213a9c07$exports, "div", () => $4c4ac78b213a9c07$export$159d9494db57879b);
$parcel$export($4c4ac78b213a9c07$exports, "dist", () => $4c4ac78b213a9c07$export$6c4a311cc157c764);
$parcel$export($4c4ac78b213a9c07$exports, "sqrDist", () => $4c4ac78b213a9c07$export$2422cd6c492a8b3a);
$parcel$export($4c4ac78b213a9c07$exports, "len", () => $4c4ac78b213a9c07$export$fc1400facf92c78);
$parcel$export($4c4ac78b213a9c07$exports, "sqrLen", () => $4c4ac78b213a9c07$export$99d8dd3f32a3435);
$parcel$export($4c4ac78b213a9c07$exports, "forEach", () => $4c4ac78b213a9c07$export$4b80e395e36b5a56);

function $4c4ac78b213a9c07$export$185802fd694ee1f5() {
    var out = new $14f38b7dd89457d7$export$b67359430d3b1b2(4);
    if ($14f38b7dd89457d7$export$b67359430d3b1b2 != Float32Array) {
        out[0] = 0;
        out[1] = 0;
        out[2] = 0;
        out[3] = 0;
    }
    return out;
}
function $4c4ac78b213a9c07$export$9cd59f9826255e47(a) {
    var out = new $14f38b7dd89457d7$export$b67359430d3b1b2(4);
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[3];
    return out;
}
function $4c4ac78b213a9c07$export$a82be99ed2a44a7d(x, y, z, w) {
    var out = new $14f38b7dd89457d7$export$b67359430d3b1b2(4);
    out[0] = x;
    out[1] = y;
    out[2] = z;
    out[3] = w;
    return out;
}
function $4c4ac78b213a9c07$export$784d13d8ee351f07(out, a) {
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[3];
    return out;
}
function $4c4ac78b213a9c07$export$adaa4cf7ef1b65be(out, x, y, z, w) {
    out[0] = x;
    out[1] = y;
    out[2] = z;
    out[3] = w;
    return out;
}
function $4c4ac78b213a9c07$export$e16d8520af44a096(out, a, b) {
    out[0] = a[0] + b[0];
    out[1] = a[1] + b[1];
    out[2] = a[2] + b[2];
    out[3] = a[3] + b[3];
    return out;
}
function $4c4ac78b213a9c07$export$4e2d2ead65e5f7e3(out, a, b) {
    out[0] = a[0] - b[0];
    out[1] = a[1] - b[1];
    out[2] = a[2] - b[2];
    out[3] = a[3] - b[3];
    return out;
}
function $4c4ac78b213a9c07$export$2060d2db72cce88f(out, a, b) {
    out[0] = a[0] * b[0];
    out[1] = a[1] * b[1];
    out[2] = a[2] * b[2];
    out[3] = a[3] * b[3];
    return out;
}
function $4c4ac78b213a9c07$export$cd007d971a5a2143(out, a, b) {
    out[0] = a[0] / b[0];
    out[1] = a[1] / b[1];
    out[2] = a[2] / b[2];
    out[3] = a[3] / b[3];
    return out;
}
function $4c4ac78b213a9c07$export$803ce6b71a0a94b2(out, a) {
    out[0] = Math.ceil(a[0]);
    out[1] = Math.ceil(a[1]);
    out[2] = Math.ceil(a[2]);
    out[3] = Math.ceil(a[3]);
    return out;
}
function $4c4ac78b213a9c07$export$a3fe094919f356fd(out, a) {
    out[0] = Math.floor(a[0]);
    out[1] = Math.floor(a[1]);
    out[2] = Math.floor(a[2]);
    out[3] = Math.floor(a[3]);
    return out;
}
function $4c4ac78b213a9c07$export$96ec731ed4dcb222(out, a, b) {
    out[0] = Math.min(a[0], b[0]);
    out[1] = Math.min(a[1], b[1]);
    out[2] = Math.min(a[2], b[2]);
    out[3] = Math.min(a[3], b[3]);
    return out;
}
function $4c4ac78b213a9c07$export$8960430cfd85939f(out, a, b) {
    out[0] = Math.max(a[0], b[0]);
    out[1] = Math.max(a[1], b[1]);
    out[2] = Math.max(a[2], b[2]);
    out[3] = Math.max(a[3], b[3]);
    return out;
}
function $4c4ac78b213a9c07$export$2077e0241d6afd3c(out, a) {
    out[0] = Math.round(a[0]);
    out[1] = Math.round(a[1]);
    out[2] = Math.round(a[2]);
    out[3] = Math.round(a[3]);
    return out;
}
function $4c4ac78b213a9c07$export$dcdf75081b88279d(out, a, b) {
    out[0] = a[0] * b;
    out[1] = a[1] * b;
    out[2] = a[2] * b;
    out[3] = a[3] * b;
    return out;
}
function $4c4ac78b213a9c07$export$19cedf1da84ba854(out, a, b, scale) {
    out[0] = a[0] + b[0] * scale;
    out[1] = a[1] + b[1] * scale;
    out[2] = a[2] + b[2] * scale;
    out[3] = a[3] + b[3] * scale;
    return out;
}
function $4c4ac78b213a9c07$export$9f17032d917177de(a, b) {
    var x = b[0] - a[0];
    var y = b[1] - a[1];
    var z = b[2] - a[2];
    var w = b[3] - a[3];
    return Math.hypot(x, y, z, w);
}
function $4c4ac78b213a9c07$export$88e6ebb4fe54f538(a, b) {
    var x = b[0] - a[0];
    var y = b[1] - a[1];
    var z = b[2] - a[2];
    var w = b[3] - a[3];
    return x * x + y * y + z * z + w * w;
}
function $4c4ac78b213a9c07$export$f24224f1c91d8156(a) {
    var x = a[0];
    var y = a[1];
    var z = a[2];
    var w = a[3];
    return Math.hypot(x, y, z, w);
}
function $4c4ac78b213a9c07$export$ab44e1323ffc8376(a) {
    var x = a[0];
    var y = a[1];
    var z = a[2];
    var w = a[3];
    return x * x + y * y + z * z + w * w;
}
function $4c4ac78b213a9c07$export$aef51622e549b8b0(out, a) {
    out[0] = -a[0];
    out[1] = -a[1];
    out[2] = -a[2];
    out[3] = -a[3];
    return out;
}
function $4c4ac78b213a9c07$export$70ae2c07e401031b(out, a) {
    out[0] = 1.0 / a[0];
    out[1] = 1.0 / a[1];
    out[2] = 1.0 / a[2];
    out[3] = 1.0 / a[3];
    return out;
}
function $4c4ac78b213a9c07$export$a3295358bff77e(out, a) {
    var x = a[0];
    var y = a[1];
    var z = a[2];
    var w = a[3];
    var len = x * x + y * y + z * z + w * w;
    if (len > 0) len = 1 / Math.sqrt(len);
    out[0] = x * len;
    out[1] = y * len;
    out[2] = z * len;
    out[3] = w * len;
    return out;
}
function $4c4ac78b213a9c07$export$94132a0e348806d4(a, b) {
    return a[0] * b[0] + a[1] * b[1] + a[2] * b[2] + a[3] * b[3];
}
function $4c4ac78b213a9c07$export$bb646b20bb93d339(out, u, v, w) {
    var A = v[0] * w[1] - v[1] * w[0], B = v[0] * w[2] - v[2] * w[0], C = v[0] * w[3] - v[3] * w[0], D = v[1] * w[2] - v[2] * w[1], E = v[1] * w[3] - v[3] * w[1], F = v[2] * w[3] - v[3] * w[2];
    var G = u[0];
    var H = u[1];
    var I = u[2];
    var J = u[3];
    out[0] = H * F - I * E + J * D;
    out[1] = -(G * F) + I * C - J * B;
    out[2] = G * E - H * C + J * A;
    out[3] = -(G * D) + H * B - I * A;
    return out;
}
function $4c4ac78b213a9c07$export$3a89f8d6f6bf6c9f(out, a, b, t) {
    var ax = a[0];
    var ay = a[1];
    var az = a[2];
    var aw = a[3];
    out[0] = ax + t * (b[0] - ax);
    out[1] = ay + t * (b[1] - ay);
    out[2] = az + t * (b[2] - az);
    out[3] = aw + t * (b[3] - aw);
    return out;
}
function $4c4ac78b213a9c07$export$4385e60b38654f68(out, scale) {
    scale = scale || 1.0; // Marsaglia, George. Choosing a Point from the Surface of a
    // Sphere. Ann. Math. Statist. 43 (1972), no. 2, 645--646.
    // http://projecteuclid.org/euclid.aoms/1177692644;
    var v1, v2, v3, v4;
    var s1, s2;
    do {
        v1 = $14f38b7dd89457d7$export$5ada478c8a628231() * 2 - 1;
        v2 = $14f38b7dd89457d7$export$5ada478c8a628231() * 2 - 1;
        s1 = v1 * v1 + v2 * v2;
    }while (s1 >= 1);
    do {
        v3 = $14f38b7dd89457d7$export$5ada478c8a628231() * 2 - 1;
        v4 = $14f38b7dd89457d7$export$5ada478c8a628231() * 2 - 1;
        s2 = v3 * v3 + v4 * v4;
    }while (s2 >= 1);
    var d = Math.sqrt((1 - s1) / s2);
    out[0] = scale * v1;
    out[1] = scale * v2;
    out[2] = scale * v3 * d;
    out[3] = scale * v4 * d;
    return out;
}
function $4c4ac78b213a9c07$export$5ffbd13800309d59(out, a, m) {
    var x = a[0], y = a[1], z = a[2], w = a[3];
    out[0] = m[0] * x + m[4] * y + m[8] * z + m[12] * w;
    out[1] = m[1] * x + m[5] * y + m[9] * z + m[13] * w;
    out[2] = m[2] * x + m[6] * y + m[10] * z + m[14] * w;
    out[3] = m[3] * x + m[7] * y + m[11] * z + m[15] * w;
    return out;
}
function $4c4ac78b213a9c07$export$c32adef9e939ce85(out, a, q) {
    var x = a[0], y = a[1], z = a[2];
    var qx = q[0], qy = q[1], qz = q[2], qw = q[3]; // calculate quat * vec
    var ix = qw * x + qy * z - qz * y;
    var iy = qw * y + qz * x - qx * z;
    var iz = qw * z + qx * y - qy * x;
    var iw = -qx * x - qy * y - qz * z; // calculate result * inverse quat
    out[0] = ix * qw + iw * -qx + iy * -qz - iz * -qy;
    out[1] = iy * qw + iw * -qy + iz * -qx - ix * -qz;
    out[2] = iz * qw + iw * -qz + ix * -qy - iy * -qx;
    out[3] = a[3];
    return out;
}
function $4c4ac78b213a9c07$export$7f9972325ebfd559(out) {
    out[0] = 0.0;
    out[1] = 0.0;
    out[2] = 0.0;
    out[3] = 0.0;
    return out;
}
function $4c4ac78b213a9c07$export$42d51816ce590c93(a) {
    return "vec4(" + a[0] + ", " + a[1] + ", " + a[2] + ", " + a[3] + ")";
}
function $4c4ac78b213a9c07$export$f2599a5cf1109d8(a, b) {
    return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3];
}
function $4c4ac78b213a9c07$export$e9bab7fafb253603(a, b) {
    var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3];
    var b0 = b[0], b1 = b[1], b2 = b[2], b3 = b[3];
    return Math.abs(a0 - b0) <= $14f38b7dd89457d7$export$fd293b15f47e270 * Math.max(1.0, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= $14f38b7dd89457d7$export$fd293b15f47e270 * Math.max(1.0, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= $14f38b7dd89457d7$export$fd293b15f47e270 * Math.max(1.0, Math.abs(a2), Math.abs(b2)) && Math.abs(a3 - b3) <= $14f38b7dd89457d7$export$fd293b15f47e270 * Math.max(1.0, Math.abs(a3), Math.abs(b3));
}
var $4c4ac78b213a9c07$export$f93b5905241a7cca = $4c4ac78b213a9c07$export$4e2d2ead65e5f7e3;
var $4c4ac78b213a9c07$export$6e3a27864ab166fe = $4c4ac78b213a9c07$export$2060d2db72cce88f;
var $4c4ac78b213a9c07$export$159d9494db57879b = $4c4ac78b213a9c07$export$cd007d971a5a2143;
var $4c4ac78b213a9c07$export$6c4a311cc157c764 = $4c4ac78b213a9c07$export$9f17032d917177de;
var $4c4ac78b213a9c07$export$2422cd6c492a8b3a = $4c4ac78b213a9c07$export$88e6ebb4fe54f538;
var $4c4ac78b213a9c07$export$fc1400facf92c78 = $4c4ac78b213a9c07$export$f24224f1c91d8156;
var $4c4ac78b213a9c07$export$99d8dd3f32a3435 = $4c4ac78b213a9c07$export$ab44e1323ffc8376;
var $4c4ac78b213a9c07$export$4b80e395e36b5a56 = function() {
    var vec = $4c4ac78b213a9c07$export$185802fd694ee1f5();
    return function(a, stride, offset, count, fn, arg) {
        var i, l;
        if (!stride) stride = 4;
        if (!offset) offset = 0;
        if (count) l = Math.min(count * stride + offset, a.length);
        else l = a.length;
        for(i = offset; i < l; i += stride){
            vec[0] = a[i];
            vec[1] = a[i + 1];
            vec[2] = a[i + 2];
            vec[3] = a[i + 3];
            fn(vec, vec, arg);
            a[i] = vec[0];
            a[i + 1] = vec[1];
            a[i + 2] = vec[2];
            a[i + 3] = vec[3];
        }
        return a;
    };
}();


function $39ece26d1239bb77$export$185802fd694ee1f5() {
    var out = new $14f38b7dd89457d7$export$b67359430d3b1b2(4);
    if ($14f38b7dd89457d7$export$b67359430d3b1b2 != Float32Array) {
        out[0] = 0;
        out[1] = 0;
        out[2] = 0;
    }
    out[3] = 1;
    return out;
}
function $39ece26d1239bb77$export$f0954fd7d5368655(out) {
    out[0] = 0;
    out[1] = 0;
    out[2] = 0;
    out[3] = 1;
    return out;
}
function $39ece26d1239bb77$export$4286ddefc8f49512(out, axis, rad) {
    rad = rad * 0.5;
    var s = Math.sin(rad);
    out[0] = s * axis[0];
    out[1] = s * axis[1];
    out[2] = s * axis[2];
    out[3] = Math.cos(rad);
    return out;
}
function $39ece26d1239bb77$export$3f70be5e7d7dc51(out_axis, q) {
    var rad = Math.acos(q[3]) * 2.0;
    var s = Math.sin(rad / 2.0);
    if (s > $14f38b7dd89457d7$export$fd293b15f47e270) {
        out_axis[0] = q[0] / s;
        out_axis[1] = q[1] / s;
        out_axis[2] = q[2] / s;
    } else {
        // If s is zero, return any axis (no rotation - axis does not matter)
        out_axis[0] = 1;
        out_axis[1] = 0;
        out_axis[2] = 0;
    }
    return rad;
}
function $39ece26d1239bb77$export$b363da9ded343252(a, b) {
    var dotproduct = $39ece26d1239bb77$export$94132a0e348806d4(a, b);
    return Math.acos(2 * dotproduct * dotproduct - 1);
}
function $39ece26d1239bb77$export$2060d2db72cce88f(out, a, b) {
    var ax = a[0], ay = a[1], az = a[2], aw = a[3];
    var bx = b[0], by = b[1], bz = b[2], bw = b[3];
    out[0] = ax * bw + aw * bx + ay * bz - az * by;
    out[1] = ay * bw + aw * by + az * bx - ax * bz;
    out[2] = az * bw + aw * bz + ax * by - ay * bx;
    out[3] = aw * bw - ax * bx - ay * by - az * bz;
    return out;
}
function $39ece26d1239bb77$export$a59c8716592e09af(out, a, rad) {
    rad *= 0.5;
    var ax = a[0], ay = a[1], az = a[2], aw = a[3];
    var bx = Math.sin(rad), bw = Math.cos(rad);
    out[0] = ax * bw + aw * bx;
    out[1] = ay * bw + az * bx;
    out[2] = az * bw - ay * bx;
    out[3] = aw * bw - ax * bx;
    return out;
}
function $39ece26d1239bb77$export$cf71e4d4ca4d1cfd(out, a, rad) {
    rad *= 0.5;
    var ax = a[0], ay = a[1], az = a[2], aw = a[3];
    var by = Math.sin(rad), bw = Math.cos(rad);
    out[0] = ax * bw - az * by;
    out[1] = ay * bw + aw * by;
    out[2] = az * bw + ax * by;
    out[3] = aw * bw - ay * by;
    return out;
}
function $39ece26d1239bb77$export$ea6eae3365de5b9c(out, a, rad) {
    rad *= 0.5;
    var ax = a[0], ay = a[1], az = a[2], aw = a[3];
    var bz = Math.sin(rad), bw = Math.cos(rad);
    out[0] = ax * bw + ay * bz;
    out[1] = ay * bw - ax * bz;
    out[2] = az * bw + aw * bz;
    out[3] = aw * bw - az * bz;
    return out;
}
function $39ece26d1239bb77$export$fb72b72e8d764d4e(out, a) {
    var x = a[0], y = a[1], z = a[2];
    out[0] = x;
    out[1] = y;
    out[2] = z;
    out[3] = Math.sqrt(Math.abs(1.0 - x * x - y * y - z * z));
    return out;
}
function $39ece26d1239bb77$export$b310ec824aaee37f(out, a) {
    var x = a[0], y = a[1], z = a[2], w = a[3];
    var r = Math.sqrt(x * x + y * y + z * z);
    var et = Math.exp(w);
    var s = r > 0 ? et * Math.sin(r) / r : 0;
    out[0] = x * s;
    out[1] = y * s;
    out[2] = z * s;
    out[3] = et * Math.cos(r);
    return out;
}
function $39ece26d1239bb77$export$876cb1b29620556f(out, a) {
    var x = a[0], y = a[1], z = a[2], w = a[3];
    var r = Math.sqrt(x * x + y * y + z * z);
    var t = r > 0 ? Math.atan2(r, w) / r : 0;
    out[0] = x * t;
    out[1] = y * t;
    out[2] = z * t;
    out[3] = 0.5 * Math.log(x * x + y * y + z * z + w * w);
    return out;
}
function $39ece26d1239bb77$export$9c297f60e22e3389(out, a, b) {
    $39ece26d1239bb77$export$876cb1b29620556f(out, a);
    $39ece26d1239bb77$export$dcdf75081b88279d(out, out, b);
    $39ece26d1239bb77$export$b310ec824aaee37f(out, out);
    return out;
}
function $39ece26d1239bb77$export$1544d9bc2995de08(out, a, b, t) {
    // benchmarks:
    //    http://jsperf.com/quaternion-slerp-implementations
    var ax = a[0], ay = a[1], az = a[2], aw = a[3];
    var bx = b[0], by = b[1], bz = b[2], bw = b[3];
    var omega, cosom, sinom, scale0, scale1; // calc cosine
    cosom = ax * bx + ay * by + az * bz + aw * bw; // adjust signs (if necessary)
    if (cosom < 0.0) {
        cosom = -cosom;
        bx = -bx;
        by = -by;
        bz = -bz;
        bw = -bw;
    } // calculate coefficients
    if (1.0 - cosom > $14f38b7dd89457d7$export$fd293b15f47e270) {
        // standard case (slerp)
        omega = Math.acos(cosom);
        sinom = Math.sin(omega);
        scale0 = Math.sin((1.0 - t) * omega) / sinom;
        scale1 = Math.sin(t * omega) / sinom;
    } else {
        // "from" and "to" quaternions are very close
        //  ... so we can do a linear interpolation
        scale0 = 1.0 - t;
        scale1 = t;
    } // calculate final values
    out[0] = scale0 * ax + scale1 * bx;
    out[1] = scale0 * ay + scale1 * by;
    out[2] = scale0 * az + scale1 * bz;
    out[3] = scale0 * aw + scale1 * bw;
    return out;
}
function $39ece26d1239bb77$export$4385e60b38654f68(out) {
    // Implementation of http://planning.cs.uiuc.edu/node198.html
    // TODO: Calling random 3 times is probably not the fastest solution
    var u1 = $14f38b7dd89457d7$export$5ada478c8a628231();
    var u2 = $14f38b7dd89457d7$export$5ada478c8a628231();
    var u3 = $14f38b7dd89457d7$export$5ada478c8a628231();
    var sqrt1MinusU1 = Math.sqrt(1 - u1);
    var sqrtU1 = Math.sqrt(u1);
    out[0] = sqrt1MinusU1 * Math.sin(2.0 * Math.PI * u2);
    out[1] = sqrt1MinusU1 * Math.cos(2.0 * Math.PI * u2);
    out[2] = sqrtU1 * Math.sin(2.0 * Math.PI * u3);
    out[3] = sqrtU1 * Math.cos(2.0 * Math.PI * u3);
    return out;
}
function $39ece26d1239bb77$export$6897c284b6f9f4dc(out, a) {
    var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3];
    var dot = a0 * a0 + a1 * a1 + a2 * a2 + a3 * a3;
    var invDot = dot ? 1.0 / dot : 0; // TODO: Would be faster to return [0,0,0,0] immediately if dot == 0
    out[0] = -a0 * invDot;
    out[1] = -a1 * invDot;
    out[2] = -a2 * invDot;
    out[3] = a3 * invDot;
    return out;
}
function $39ece26d1239bb77$export$7679f47e72c62560(out, a) {
    out[0] = -a[0];
    out[1] = -a[1];
    out[2] = -a[2];
    out[3] = a[3];
    return out;
}
function $39ece26d1239bb77$export$272a1eb8e5a4b55b(out, m) {
    // Algorithm in Ken Shoemake's article in 1987 SIGGRAPH course notes
    // article "Quaternion Calculus and Fast Animation".
    var fTrace = m[0] + m[4] + m[8];
    var fRoot;
    if (fTrace > 0.0) {
        // |w| > 1/2, may as well choose w > 1/2
        fRoot = Math.sqrt(fTrace + 1.0); // 2w
        out[3] = 0.5 * fRoot;
        fRoot = 0.5 / fRoot; // 1/(4w)
        out[0] = (m[5] - m[7]) * fRoot;
        out[1] = (m[6] - m[2]) * fRoot;
        out[2] = (m[1] - m[3]) * fRoot;
    } else {
        // |w| <= 1/2
        var i = 0;
        if (m[4] > m[0]) i = 1;
        if (m[8] > m[i * 3 + i]) i = 2;
        var j = (i + 1) % 3;
        var k = (i + 2) % 3;
        fRoot = Math.sqrt(m[i * 3 + i] - m[j * 3 + j] - m[k * 3 + k] + 1.0);
        out[i] = 0.5 * fRoot;
        fRoot = 0.5 / fRoot;
        out[3] = (m[j * 3 + k] - m[k * 3 + j]) * fRoot;
        out[j] = (m[j * 3 + i] + m[i * 3 + j]) * fRoot;
        out[k] = (m[k * 3 + i] + m[i * 3 + k]) * fRoot;
    }
    return out;
}
function $39ece26d1239bb77$export$7a404a587ea85af(out, x, y, z) {
    var halfToRad = 0.5 * Math.PI / 180.0;
    x *= halfToRad;
    y *= halfToRad;
    z *= halfToRad;
    var sx = Math.sin(x);
    var cx = Math.cos(x);
    var sy = Math.sin(y);
    var cy = Math.cos(y);
    var sz = Math.sin(z);
    var cz = Math.cos(z);
    out[0] = sx * cy * cz - cx * sy * sz;
    out[1] = cx * sy * cz + sx * cy * sz;
    out[2] = cx * cy * sz - sx * sy * cz;
    out[3] = cx * cy * cz + sx * sy * sz;
    return out;
}
function $39ece26d1239bb77$export$42d51816ce590c93(a) {
    return "quat(" + a[0] + ", " + a[1] + ", " + a[2] + ", " + a[3] + ")";
}
var $39ece26d1239bb77$export$9cd59f9826255e47 = $4c4ac78b213a9c07$export$9cd59f9826255e47;
var $39ece26d1239bb77$export$a82be99ed2a44a7d = $4c4ac78b213a9c07$export$a82be99ed2a44a7d;
var $39ece26d1239bb77$export$784d13d8ee351f07 = $4c4ac78b213a9c07$export$784d13d8ee351f07;
var $39ece26d1239bb77$export$adaa4cf7ef1b65be = $4c4ac78b213a9c07$export$adaa4cf7ef1b65be;
var $39ece26d1239bb77$export$e16d8520af44a096 = $4c4ac78b213a9c07$export$e16d8520af44a096;
var $39ece26d1239bb77$export$6e3a27864ab166fe = $39ece26d1239bb77$export$2060d2db72cce88f;
var $39ece26d1239bb77$export$dcdf75081b88279d = $4c4ac78b213a9c07$export$dcdf75081b88279d;
var $39ece26d1239bb77$export$94132a0e348806d4 = $4c4ac78b213a9c07$export$94132a0e348806d4;
var $39ece26d1239bb77$export$3a89f8d6f6bf6c9f = $4c4ac78b213a9c07$export$3a89f8d6f6bf6c9f;
var $39ece26d1239bb77$export$f24224f1c91d8156 = $4c4ac78b213a9c07$export$f24224f1c91d8156;
var $39ece26d1239bb77$export$fc1400facf92c78 = $39ece26d1239bb77$export$f24224f1c91d8156;
var $39ece26d1239bb77$export$ab44e1323ffc8376 = $4c4ac78b213a9c07$export$ab44e1323ffc8376;
var $39ece26d1239bb77$export$99d8dd3f32a3435 = $39ece26d1239bb77$export$ab44e1323ffc8376;
var $39ece26d1239bb77$export$a3295358bff77e = $4c4ac78b213a9c07$export$a3295358bff77e;
var $39ece26d1239bb77$export$f2599a5cf1109d8 = $4c4ac78b213a9c07$export$f2599a5cf1109d8;
var $39ece26d1239bb77$export$e9bab7fafb253603 = $4c4ac78b213a9c07$export$e9bab7fafb253603;
var $39ece26d1239bb77$export$72d66f5842c00904 = function() {
    var tmpvec3 = $31054a6c69637582$export$185802fd694ee1f5();
    var xUnitVec3 = $31054a6c69637582$export$a82be99ed2a44a7d(1, 0, 0);
    var yUnitVec3 = $31054a6c69637582$export$a82be99ed2a44a7d(0, 1, 0);
    return function(out, a, b) {
        var dot = $31054a6c69637582$export$94132a0e348806d4(a, b);
        if (dot < -0.999999) {
            $31054a6c69637582$export$bb646b20bb93d339(tmpvec3, xUnitVec3, a);
            if ($31054a6c69637582$export$fc1400facf92c78(tmpvec3) < 0.000001) $31054a6c69637582$export$bb646b20bb93d339(tmpvec3, yUnitVec3, a);
            $31054a6c69637582$export$a3295358bff77e(tmpvec3, tmpvec3);
            $39ece26d1239bb77$export$4286ddefc8f49512(out, tmpvec3, Math.PI);
            return out;
        } else if (dot > 0.999999) {
            out[0] = 0;
            out[1] = 0;
            out[2] = 0;
            out[3] = 1;
            return out;
        } else {
            $31054a6c69637582$export$bb646b20bb93d339(tmpvec3, a, b);
            out[0] = tmpvec3[0];
            out[1] = tmpvec3[1];
            out[2] = tmpvec3[2];
            out[3] = 1 + dot;
            return $39ece26d1239bb77$export$a3295358bff77e(out, out);
        }
    };
}();
var $39ece26d1239bb77$export$699b0866ca50f6cb = function() {
    var temp1 = $39ece26d1239bb77$export$185802fd694ee1f5();
    var temp2 = $39ece26d1239bb77$export$185802fd694ee1f5();
    return function(out, a, b, c, d, t) {
        $39ece26d1239bb77$export$1544d9bc2995de08(temp1, a, d, t);
        $39ece26d1239bb77$export$1544d9bc2995de08(temp2, b, c, t);
        $39ece26d1239bb77$export$1544d9bc2995de08(out, temp1, temp2, 2 * t * (1 - t));
        return out;
    };
}();
var $39ece26d1239bb77$export$937ca0a544b2d712 = function() {
    var matr = $ba3ca37806a2b6fa$export$185802fd694ee1f5();
    return function(out, view, right, up) {
        matr[0] = right[0];
        matr[3] = right[1];
        matr[6] = right[2];
        matr[1] = up[0];
        matr[4] = up[1];
        matr[7] = up[2];
        matr[2] = -view[0];
        matr[5] = -view[1];
        matr[8] = -view[2];
        return $39ece26d1239bb77$export$a3295358bff77e(out, $39ece26d1239bb77$export$272a1eb8e5a4b55b(out, matr));
    };
}();


/*!
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 */ 
/*!
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 */ var $91b0cc4981465964$exports = {};

$parcel$export($91b0cc4981465964$exports, "create", () => $91b0cc4981465964$export$185802fd694ee1f5);
$parcel$export($91b0cc4981465964$exports, "clone", () => $91b0cc4981465964$export$9cd59f9826255e47);
$parcel$export($91b0cc4981465964$exports, "fromValues", () => $91b0cc4981465964$export$a82be99ed2a44a7d);
$parcel$export($91b0cc4981465964$exports, "copy", () => $91b0cc4981465964$export$784d13d8ee351f07);
$parcel$export($91b0cc4981465964$exports, "set", () => $91b0cc4981465964$export$adaa4cf7ef1b65be);
$parcel$export($91b0cc4981465964$exports, "add", () => $91b0cc4981465964$export$e16d8520af44a096);
$parcel$export($91b0cc4981465964$exports, "subtract", () => $91b0cc4981465964$export$4e2d2ead65e5f7e3);
$parcel$export($91b0cc4981465964$exports, "multiply", () => $91b0cc4981465964$export$2060d2db72cce88f);
$parcel$export($91b0cc4981465964$exports, "divide", () => $91b0cc4981465964$export$cd007d971a5a2143);
$parcel$export($91b0cc4981465964$exports, "ceil", () => $91b0cc4981465964$export$803ce6b71a0a94b2);
$parcel$export($91b0cc4981465964$exports, "floor", () => $91b0cc4981465964$export$a3fe094919f356fd);
$parcel$export($91b0cc4981465964$exports, "min", () => $91b0cc4981465964$export$96ec731ed4dcb222);
$parcel$export($91b0cc4981465964$exports, "max", () => $91b0cc4981465964$export$8960430cfd85939f);
$parcel$export($91b0cc4981465964$exports, "round", () => $91b0cc4981465964$export$2077e0241d6afd3c);
$parcel$export($91b0cc4981465964$exports, "scale", () => $91b0cc4981465964$export$dcdf75081b88279d);
$parcel$export($91b0cc4981465964$exports, "scaleAndAdd", () => $91b0cc4981465964$export$19cedf1da84ba854);
$parcel$export($91b0cc4981465964$exports, "distance", () => $91b0cc4981465964$export$9f17032d917177de);
$parcel$export($91b0cc4981465964$exports, "squaredDistance", () => $91b0cc4981465964$export$88e6ebb4fe54f538);
$parcel$export($91b0cc4981465964$exports, "length", () => $91b0cc4981465964$export$f24224f1c91d8156);
$parcel$export($91b0cc4981465964$exports, "squaredLength", () => $91b0cc4981465964$export$ab44e1323ffc8376);
$parcel$export($91b0cc4981465964$exports, "negate", () => $91b0cc4981465964$export$aef51622e549b8b0);
$parcel$export($91b0cc4981465964$exports, "inverse", () => $91b0cc4981465964$export$70ae2c07e401031b);
$parcel$export($91b0cc4981465964$exports, "normalize", () => $91b0cc4981465964$export$a3295358bff77e);
$parcel$export($91b0cc4981465964$exports, "dot", () => $91b0cc4981465964$export$94132a0e348806d4);
$parcel$export($91b0cc4981465964$exports, "cross", () => $91b0cc4981465964$export$bb646b20bb93d339);
$parcel$export($91b0cc4981465964$exports, "lerp", () => $91b0cc4981465964$export$3a89f8d6f6bf6c9f);
$parcel$export($91b0cc4981465964$exports, "random", () => $91b0cc4981465964$export$4385e60b38654f68);
$parcel$export($91b0cc4981465964$exports, "transformMat2", () => $91b0cc4981465964$export$b732428d73874bfc);
$parcel$export($91b0cc4981465964$exports, "transformMat2d", () => $91b0cc4981465964$export$3e55bc4b3707dfd3);
$parcel$export($91b0cc4981465964$exports, "transformMat3", () => $91b0cc4981465964$export$f0bfa0a0024626ee);
$parcel$export($91b0cc4981465964$exports, "transformMat4", () => $91b0cc4981465964$export$5ffbd13800309d59);
$parcel$export($91b0cc4981465964$exports, "rotate", () => $91b0cc4981465964$export$bb628a54ab399bc9);
$parcel$export($91b0cc4981465964$exports, "angle", () => $91b0cc4981465964$export$944b09d2ad10b378);
$parcel$export($91b0cc4981465964$exports, "zero", () => $91b0cc4981465964$export$7f9972325ebfd559);
$parcel$export($91b0cc4981465964$exports, "str", () => $91b0cc4981465964$export$42d51816ce590c93);
$parcel$export($91b0cc4981465964$exports, "exactEquals", () => $91b0cc4981465964$export$f2599a5cf1109d8);
$parcel$export($91b0cc4981465964$exports, "equals", () => $91b0cc4981465964$export$e9bab7fafb253603);
$parcel$export($91b0cc4981465964$exports, "len", () => $91b0cc4981465964$export$fc1400facf92c78);
$parcel$export($91b0cc4981465964$exports, "sub", () => $91b0cc4981465964$export$f93b5905241a7cca);
$parcel$export($91b0cc4981465964$exports, "mul", () => $91b0cc4981465964$export$6e3a27864ab166fe);
$parcel$export($91b0cc4981465964$exports, "div", () => $91b0cc4981465964$export$159d9494db57879b);
$parcel$export($91b0cc4981465964$exports, "dist", () => $91b0cc4981465964$export$6c4a311cc157c764);
$parcel$export($91b0cc4981465964$exports, "sqrDist", () => $91b0cc4981465964$export$2422cd6c492a8b3a);
$parcel$export($91b0cc4981465964$exports, "sqrLen", () => $91b0cc4981465964$export$99d8dd3f32a3435);
$parcel$export($91b0cc4981465964$exports, "forEach", () => $91b0cc4981465964$export$4b80e395e36b5a56);

function $91b0cc4981465964$export$185802fd694ee1f5() {
    var out = new $14f38b7dd89457d7$export$b67359430d3b1b2(2);
    if ($14f38b7dd89457d7$export$b67359430d3b1b2 != Float32Array) {
        out[0] = 0;
        out[1] = 0;
    }
    return out;
}
function $91b0cc4981465964$export$9cd59f9826255e47(a) {
    var out = new $14f38b7dd89457d7$export$b67359430d3b1b2(2);
    out[0] = a[0];
    out[1] = a[1];
    return out;
}
function $91b0cc4981465964$export$a82be99ed2a44a7d(x, y) {
    var out = new $14f38b7dd89457d7$export$b67359430d3b1b2(2);
    out[0] = x;
    out[1] = y;
    return out;
}
function $91b0cc4981465964$export$784d13d8ee351f07(out, a) {
    out[0] = a[0];
    out[1] = a[1];
    return out;
}
function $91b0cc4981465964$export$adaa4cf7ef1b65be(out, x, y) {
    out[0] = x;
    out[1] = y;
    return out;
}
function $91b0cc4981465964$export$e16d8520af44a096(out, a, b) {
    out[0] = a[0] + b[0];
    out[1] = a[1] + b[1];
    return out;
}
function $91b0cc4981465964$export$4e2d2ead65e5f7e3(out, a, b) {
    out[0] = a[0] - b[0];
    out[1] = a[1] - b[1];
    return out;
}
function $91b0cc4981465964$export$2060d2db72cce88f(out, a, b) {
    out[0] = a[0] * b[0];
    out[1] = a[1] * b[1];
    return out;
}
function $91b0cc4981465964$export$cd007d971a5a2143(out, a, b) {
    out[0] = a[0] / b[0];
    out[1] = a[1] / b[1];
    return out;
}
function $91b0cc4981465964$export$803ce6b71a0a94b2(out, a) {
    out[0] = Math.ceil(a[0]);
    out[1] = Math.ceil(a[1]);
    return out;
}
function $91b0cc4981465964$export$a3fe094919f356fd(out, a) {
    out[0] = Math.floor(a[0]);
    out[1] = Math.floor(a[1]);
    return out;
}
function $91b0cc4981465964$export$96ec731ed4dcb222(out, a, b) {
    out[0] = Math.min(a[0], b[0]);
    out[1] = Math.min(a[1], b[1]);
    return out;
}
function $91b0cc4981465964$export$8960430cfd85939f(out, a, b) {
    out[0] = Math.max(a[0], b[0]);
    out[1] = Math.max(a[1], b[1]);
    return out;
}
function $91b0cc4981465964$export$2077e0241d6afd3c(out, a) {
    out[0] = Math.round(a[0]);
    out[1] = Math.round(a[1]);
    return out;
}
function $91b0cc4981465964$export$dcdf75081b88279d(out, a, b) {
    out[0] = a[0] * b;
    out[1] = a[1] * b;
    return out;
}
function $91b0cc4981465964$export$19cedf1da84ba854(out, a, b, scale) {
    out[0] = a[0] + b[0] * scale;
    out[1] = a[1] + b[1] * scale;
    return out;
}
function $91b0cc4981465964$export$9f17032d917177de(a, b) {
    var x = b[0] - a[0], y = b[1] - a[1];
    return Math.hypot(x, y);
}
function $91b0cc4981465964$export$88e6ebb4fe54f538(a, b) {
    var x = b[0] - a[0], y = b[1] - a[1];
    return x * x + y * y;
}
function $91b0cc4981465964$export$f24224f1c91d8156(a) {
    var x = a[0], y = a[1];
    return Math.hypot(x, y);
}
function $91b0cc4981465964$export$ab44e1323ffc8376(a) {
    var x = a[0], y = a[1];
    return x * x + y * y;
}
function $91b0cc4981465964$export$aef51622e549b8b0(out, a) {
    out[0] = -a[0];
    out[1] = -a[1];
    return out;
}
function $91b0cc4981465964$export$70ae2c07e401031b(out, a) {
    out[0] = 1.0 / a[0];
    out[1] = 1.0 / a[1];
    return out;
}
function $91b0cc4981465964$export$a3295358bff77e(out, a) {
    var x = a[0], y = a[1];
    var len = x * x + y * y;
    if (len > 0) //TODO: evaluate use of glm_invsqrt here?
    len = 1 / Math.sqrt(len);
    out[0] = a[0] * len;
    out[1] = a[1] * len;
    return out;
}
function $91b0cc4981465964$export$94132a0e348806d4(a, b) {
    return a[0] * b[0] + a[1] * b[1];
}
function $91b0cc4981465964$export$bb646b20bb93d339(out, a, b) {
    var z = a[0] * b[1] - a[1] * b[0];
    out[0] = out[1] = 0;
    out[2] = z;
    return out;
}
function $91b0cc4981465964$export$3a89f8d6f6bf6c9f(out, a, b, t) {
    var ax = a[0], ay = a[1];
    out[0] = ax + t * (b[0] - ax);
    out[1] = ay + t * (b[1] - ay);
    return out;
}
function $91b0cc4981465964$export$4385e60b38654f68(out, scale) {
    scale = scale || 1.0;
    var r = $14f38b7dd89457d7$export$5ada478c8a628231() * 2.0 * Math.PI;
    out[0] = Math.cos(r) * scale;
    out[1] = Math.sin(r) * scale;
    return out;
}
function $91b0cc4981465964$export$b732428d73874bfc(out, a, m) {
    var x = a[0], y = a[1];
    out[0] = m[0] * x + m[2] * y;
    out[1] = m[1] * x + m[3] * y;
    return out;
}
function $91b0cc4981465964$export$3e55bc4b3707dfd3(out, a, m) {
    var x = a[0], y = a[1];
    out[0] = m[0] * x + m[2] * y + m[4];
    out[1] = m[1] * x + m[3] * y + m[5];
    return out;
}
function $91b0cc4981465964$export$f0bfa0a0024626ee(out, a, m) {
    var x = a[0], y = a[1];
    out[0] = m[0] * x + m[3] * y + m[6];
    out[1] = m[1] * x + m[4] * y + m[7];
    return out;
}
function $91b0cc4981465964$export$5ffbd13800309d59(out, a, m) {
    var x = a[0];
    var y = a[1];
    out[0] = m[0] * x + m[4] * y + m[12];
    out[1] = m[1] * x + m[5] * y + m[13];
    return out;
}
function $91b0cc4981465964$export$bb628a54ab399bc9(out, a, b, rad) {
    //Translate point to the origin
    var p0 = a[0] - b[0], p1 = a[1] - b[1], sinC = Math.sin(rad), cosC = Math.cos(rad); //perform rotation and translate to correct position
    out[0] = p0 * cosC - p1 * sinC + b[0];
    out[1] = p0 * sinC + p1 * cosC + b[1];
    return out;
}
function $91b0cc4981465964$export$944b09d2ad10b378(a, b) {
    var x1 = a[0], y1 = a[1], x2 = b[0], y2 = b[1], // mag is the product of the magnitudes of a and b
    mag = Math.sqrt(x1 * x1 + y1 * y1) * Math.sqrt(x2 * x2 + y2 * y2), // mag &&.. short circuits if mag == 0
    cosine = mag && (x1 * x2 + y1 * y2) / mag; // Math.min(Math.max(cosine, -1), 1) clamps the cosine between -1 and 1
    return Math.acos(Math.min(Math.max(cosine, -1), 1));
}
function $91b0cc4981465964$export$7f9972325ebfd559(out) {
    out[0] = 0.0;
    out[1] = 0.0;
    return out;
}
function $91b0cc4981465964$export$42d51816ce590c93(a) {
    return "vec2(" + a[0] + ", " + a[1] + ")";
}
function $91b0cc4981465964$export$f2599a5cf1109d8(a, b) {
    return a[0] === b[0] && a[1] === b[1];
}
function $91b0cc4981465964$export$e9bab7fafb253603(a, b) {
    var a0 = a[0], a1 = a[1];
    var b0 = b[0], b1 = b[1];
    return Math.abs(a0 - b0) <= $14f38b7dd89457d7$export$fd293b15f47e270 * Math.max(1.0, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= $14f38b7dd89457d7$export$fd293b15f47e270 * Math.max(1.0, Math.abs(a1), Math.abs(b1));
}
var $91b0cc4981465964$export$fc1400facf92c78 = $91b0cc4981465964$export$f24224f1c91d8156;
var $91b0cc4981465964$export$f93b5905241a7cca = $91b0cc4981465964$export$4e2d2ead65e5f7e3;
var $91b0cc4981465964$export$6e3a27864ab166fe = $91b0cc4981465964$export$2060d2db72cce88f;
var $91b0cc4981465964$export$159d9494db57879b = $91b0cc4981465964$export$cd007d971a5a2143;
var $91b0cc4981465964$export$6c4a311cc157c764 = $91b0cc4981465964$export$9f17032d917177de;
var $91b0cc4981465964$export$2422cd6c492a8b3a = $91b0cc4981465964$export$88e6ebb4fe54f538;
var $91b0cc4981465964$export$99d8dd3f32a3435 = $91b0cc4981465964$export$ab44e1323ffc8376;
var $91b0cc4981465964$export$4b80e395e36b5a56 = function() {
    var vec = $91b0cc4981465964$export$185802fd694ee1f5();
    return function(a, stride, offset, count, fn, arg) {
        var i, l;
        if (!stride) stride = 2;
        if (!offset) offset = 0;
        if (count) l = Math.min(count * stride + offset, a.length);
        else l = a.length;
        for(i = offset; i < l; i += stride){
            vec[0] = a[i];
            vec[1] = a[i + 1];
            fn(vec, vec, arg);
            a[i] = vec[0];
            a[i + 1] = vec[1];
        }
        return a;
    };
}();


class $d4d7bd6cc65a5081$export$a002182e51710d39 {
}
$d4d7bd6cc65a5081$export$a002182e51710d39.TWO_PI = 6.283185307179586;
$d4d7bd6cc65a5081$export$a002182e51710d39.PI = 3.141592653589793;
$d4d7bd6cc65a5081$export$a002182e51710d39.PI_OVER_TWO = 1.5707963267948966;
$d4d7bd6cc65a5081$export$a002182e51710d39.PI_OVER_THREE = 1.0471975511965976;
$d4d7bd6cc65a5081$export$a002182e51710d39.PI_OVER_FOUR = 0.7853981633974483;
$d4d7bd6cc65a5081$export$a002182e51710d39.PI_OVER_SIX = 0.5235987755982988;
$d4d7bd6cc65a5081$export$a002182e51710d39.LOG_2 = 0.6931471805599453;
$d4d7bd6cc65a5081$export$a002182e51710d39.RADIANS_PER_DEGREE = 0.017453292519943295;
$d4d7bd6cc65a5081$export$a002182e51710d39.DEGREES_PER_RADIAN = 57.29577951308232;
$d4d7bd6cc65a5081$export$a002182e51710d39.ROOT_TWO = 1.4142135623730951;
$d4d7bd6cc65a5081$export$a002182e51710d39.ROOT_TWO_OVER_TWO = 0.7071067811865476;
$d4d7bd6cc65a5081$export$a002182e51710d39.ROOT_THREE = 1.7320508075688772;
$d4d7bd6cc65a5081$export$a002182e51710d39.ROOT_THREE_OVER_TWO = 0.8660254037844386;
$d4d7bd6cc65a5081$export$a002182e51710d39.ROOT_THREE_OVER_THREE = 0.5773502691896257;
$d4d7bd6cc65a5081$export$a002182e51710d39.VECTOR2_ZERO = (0, $91b0cc4981465964$exports).fromValues(0, 0);
$d4d7bd6cc65a5081$export$a002182e51710d39.VECTOR2_ONE = (0, $91b0cc4981465964$exports).fromValues(1, 1);
$d4d7bd6cc65a5081$export$a002182e51710d39.VECTOR2_UNITX = (0, $91b0cc4981465964$exports).fromValues(1, 0);
$d4d7bd6cc65a5081$export$a002182e51710d39.VECTOR2_UNITY = (0, $91b0cc4981465964$exports).fromValues(0, 1);
$d4d7bd6cc65a5081$export$a002182e51710d39.VECTOR3_ZERO = (0, $31054a6c69637582$exports).fromValues(0, 0, 0);
$d4d7bd6cc65a5081$export$a002182e51710d39.VECTOR3_ONE = (0, $31054a6c69637582$exports).fromValues(1, 1, 1);
$d4d7bd6cc65a5081$export$a002182e51710d39.VECTOR3_UNITX = (0, $31054a6c69637582$exports).fromValues(1, 0, 0);
$d4d7bd6cc65a5081$export$a002182e51710d39.VECTOR3_UNITY = (0, $31054a6c69637582$exports).fromValues(0, 1, 0);
$d4d7bd6cc65a5081$export$a002182e51710d39.VECTOR3_UNITZ = (0, $31054a6c69637582$exports).fromValues(0, 0, 1);
$d4d7bd6cc65a5081$export$a002182e51710d39.VECTOR3_REFLECTX = (0, $31054a6c69637582$exports).fromValues(1, -1, -1);
$d4d7bd6cc65a5081$export$a002182e51710d39.VECTOR3_REFLECTY = (0, $31054a6c69637582$exports).fromValues(-1, 1, -1);
$d4d7bd6cc65a5081$export$a002182e51710d39.VECTOR3_REFLECTZ = (0, $31054a6c69637582$exports).fromValues(-1, -1, 1);
$d4d7bd6cc65a5081$export$a002182e51710d39.VECTOR4_ZERO = (0, $4c4ac78b213a9c07$exports).fromValues(0, 0, 0, 0);
$d4d7bd6cc65a5081$export$a002182e51710d39.VECTOR4_ONE = (0, $4c4ac78b213a9c07$exports).fromValues(1, 1, 1, 1);
$d4d7bd6cc65a5081$export$a002182e51710d39.VECTOR4_UNITX = (0, $4c4ac78b213a9c07$exports).fromValues(1, 0, 0, 0);
$d4d7bd6cc65a5081$export$a002182e51710d39.VECTOR4_UNITY = (0, $4c4ac78b213a9c07$exports).fromValues(0, 1, 0, 0);
$d4d7bd6cc65a5081$export$a002182e51710d39.VECTOR4_UNITZ = (0, $4c4ac78b213a9c07$exports).fromValues(0, 0, 1, 0);
$d4d7bd6cc65a5081$export$a002182e51710d39.VECTOR4_UNITW = (0, $4c4ac78b213a9c07$exports).fromValues(0, 0, 0, 1);
$d4d7bd6cc65a5081$export$a002182e51710d39.MAT3_IDENTITY = (0, $ba3ca37806a2b6fa$exports).create();
$d4d7bd6cc65a5081$export$a002182e51710d39.MAT4_IDENTITY = (0, $1ac1b59392edf35b$exports).create();
$d4d7bd6cc65a5081$export$a002182e51710d39.MAT4_ROTATION_MINUS_90 = (0, $1ac1b59392edf35b$exports).fromValues(0, -1, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);
$d4d7bd6cc65a5081$export$a002182e51710d39.QUAT_IDENTITY = (0, $39ece26d1239bb77$exports).create();
$d4d7bd6cc65a5081$export$a002182e51710d39.QUAT_ROTATEX_PLUS_90 = (0, $39ece26d1239bb77$exports).fromValues($d4d7bd6cc65a5081$export$a002182e51710d39.ROOT_TWO_OVER_TWO, 0, 0, $d4d7bd6cc65a5081$export$a002182e51710d39.ROOT_TWO_OVER_TWO);
$d4d7bd6cc65a5081$export$a002182e51710d39.QUAT_ROTATEX_MINUS_90 = (0, $39ece26d1239bb77$exports).fromValues(-$d4d7bd6cc65a5081$export$a002182e51710d39.ROOT_TWO_OVER_TWO, 0, 0, $d4d7bd6cc65a5081$export$a002182e51710d39.ROOT_TWO_OVER_TWO);
$d4d7bd6cc65a5081$export$a002182e51710d39.QUAT_ROTATEY_PLUS_90 = (0, $39ece26d1239bb77$exports).fromValues(0, $d4d7bd6cc65a5081$export$a002182e51710d39.ROOT_TWO_OVER_TWO, 0, $d4d7bd6cc65a5081$export$a002182e51710d39.ROOT_TWO_OVER_TWO);
$d4d7bd6cc65a5081$export$a002182e51710d39.QUAT_ROTATEY_MINUS_90 = (0, $39ece26d1239bb77$exports).fromValues(0, -$d4d7bd6cc65a5081$export$a002182e51710d39.ROOT_TWO_OVER_TWO, 0, $d4d7bd6cc65a5081$export$a002182e51710d39.ROOT_TWO_OVER_TWO);
$d4d7bd6cc65a5081$export$a002182e51710d39.QUAT_ROTATEZ_PLUS_90 = (0, $39ece26d1239bb77$exports).fromValues(0, 0, $d4d7bd6cc65a5081$export$a002182e51710d39.ROOT_TWO_OVER_TWO, $d4d7bd6cc65a5081$export$a002182e51710d39.ROOT_TWO_OVER_TWO);
$d4d7bd6cc65a5081$export$a002182e51710d39.QUAT_ROTATEZ_MINUS_90 = (0, $39ece26d1239bb77$exports).fromValues(0, 0, -$d4d7bd6cc65a5081$export$a002182e51710d39.ROOT_TWO_OVER_TWO, $d4d7bd6cc65a5081$export$a002182e51710d39.ROOT_TWO_OVER_TWO);
$d4d7bd6cc65a5081$export$a002182e51710d39.MILLISECONDS_PER_DAY = 86400000;


/*!
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 */ 
/*!
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 */ class $2d4d1eb6f32f02f2$export$80a8c44b8858d625 {
    static simpleLinearRegression(points) {
        const n = points.length;
        let sumX = 0;
        let sumY = 0;
        let sumXY = 0;
        let sumXX = 0;
        for(let i = 0; i < n; i++){
            sumX += points[i].x;
            sumY += points[i].y;
            sumXY += points[i].x * points[i].y;
            sumXX += points[i].x * points[i].x;
        }
        const slope = (n * sumXY - sumX * sumY) / (n * sumXX - sumX * sumX);
        const yIntercept = (sumY - slope * sumX) / n;
        return {
            slope: slope,
            yIntercept: yIntercept
        };
    }
    static clamp(value, min, max) {
        return Math.max(Math.min(value, max), min);
    }
    static lerp(value1, value2, amount) {
        return value1 + (value2 - value1) * amount;
    }
    static normalize(value, min, max, from = 0, to = 1) {
        return max - min == 0 ? 0 : Math.max(Math.min((to - from) * (value - min) / (max - min) + from, to), from);
    }
    static splitExponent(value, result) {
        let exponent = Math.round(Math.log10(Math.abs(value)));
        let coefficient = value / Math.pow(10, exponent);
        if (coefficient < 1) {
            coefficient *= 10;
            exponent--;
        }
        result[0] = coefficient;
        result[1] = exponent;
    }
    static combineExponent(mantissa, exponent) {
        return mantissa * Math.pow(10, exponent);
    }
    static isPowerOf2(value) {
        return (value & value - 1) == 0;
    }
}
class $2d4d1eb6f32f02f2$export$b8e288c3467acb0e {
    constructor(seed){
        this._seed = seed % 2147483647;
        if (this._seed <= 0) this._seed += 2147483646;
    }
    next() {
        return this._seed = this._seed * 16807 % 2147483647;
    }
    nextFloat() {
        return (this.next() - 1) / 2147483646;
    }
    nextInteger(min, max) {
        return Math.floor(this.nextFloat() * (max - min + 1) + min);
    }
}



class $a49c65c28e06311e$export$210d3b2db589eb5c {
    static degreesToRadians(degrees) {
        return degrees * (0, $d4d7bd6cc65a5081$export$a002182e51710d39).RADIANS_PER_DEGREE;
    }
    static radiansToDegrees(radians) {
        return radians * (0, $d4d7bd6cc65a5081$export$a002182e51710d39).DEGREES_PER_RADIAN;
    }
    static wrapAngle(angle) {
        if (angle > (0, $d4d7bd6cc65a5081$export$a002182e51710d39).PI) angle = angle - (0, $d4d7bd6cc65a5081$export$a002182e51710d39).TWO_PI;
        else if (angle < -(0, $d4d7bd6cc65a5081$export$a002182e51710d39).PI) angle += (0, $d4d7bd6cc65a5081$export$a002182e51710d39).TWO_PI;
        return angle;
    }
    static sphericalToCartesian(altitude, longitude, latitude, result) {
        latitude = $a49c65c28e06311e$export$210d3b2db589eb5c.degreesToRadians(latitude);
        longitude = $a49c65c28e06311e$export$210d3b2db589eb5c.degreesToRadians(longitude);
        const scale = Math.cos(latitude);
        result[0] = altitude * scale * Math.sin(longitude);
        result[1] = altitude * Math.sin(latitude);
        result[2] = altitude * scale * Math.cos(longitude);
    }
    static cartesianToSpherical(x, y, z, result) {
        result[0] = Math.atan2(x, z);
        result[1] = Math.asin(y);
    }
    static angleBetweenVectors(from, to) {
        if ((0, $31054a6c69637582$exports).exactEquals(from, to)) return 0;
        else {
            const dot = (0, $2d4d1eb6f32f02f2$export$80a8c44b8858d625).clamp((0, $31054a6c69637582$exports).dot(from, to), -1, 1);
            return Math.acos(dot);
        }
    }
    static signedAngleBetweenVectors(from, to, up) {
        if ((0, $31054a6c69637582$exports).exactEquals(from, to)) return 0;
        else {
            const dot = (0, $2d4d1eb6f32f02f2$export$80a8c44b8858d625).clamp((0, $31054a6c69637582$exports).dot(from, to), -1, 1);
            let angle = Math.acos(dot);
            (0, $31054a6c69637582$exports).cross($a49c65c28e06311e$export$210d3b2db589eb5c._vec3, from, to);
            if ((0, $31054a6c69637582$exports).dot($a49c65c28e06311e$export$210d3b2db589eb5c._vec3, up) < 0) angle = -angle;
            return angle;
        }
    }
}
$a49c65c28e06311e$export$210d3b2db589eb5c._vec3 = (0, $31054a6c69637582$exports).create();



/*!
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 */ 


class $ec7cf7ba687c1511$export$ea4bacb7eec73803 {
    constructor(core){
        this.position = (0, $31054a6c69637582$exports).create();
    }
}
class $ec7cf7ba687c1511$export$c755714d282122f0 {
    getView(view) {
        this.getPosition(view.position);
    }
    setView(view, isSmooth) {
        this.setPosition(view.position, isSmooth);
    }
    lerpView(from, to, time) {
        (0, $31054a6c69637582$exports).lerp(this._vec3, from.position, to.position, time);
        this.setPosition(this._vec3, false);
    }
    get vMatrices() {
        return this._vMatrices;
    }
    get inverseVMatrices() {
        return this._inverseVMatrices;
    }
    get mvMatrices() {
        return this._mvMatrices;
    }
    get pMatrices() {
        return this._pMatrices;
    }
    get inversePMatrices() {
        return this._inversePMatrices;
    }
    get pickVMatrix() {
        return this._pickVMatrix;
    }
    get rMatrix() {
        return this._mat3;
    }
    getOrbit(value) {
        (0, $39ece26d1239bb77$exports).copy(value, this._orbitRotation);
    }
    setOrbit(value, isSmooth) {
        (0, $39ece26d1239bb77$exports).copy(this._orbitRotation, value);
        if (!isSmooth) (0, $39ece26d1239bb77$exports).copy(this._smoothedOrbitRotation, value);
    }
    getPosition(value) {
        (0, $31054a6c69637582$exports).copy(value, this._cameraPosition);
    }
    setPosition(value, isSmooth) {
        (0, $31054a6c69637582$exports).copy(this._cameraPosition, value);
        if (!isSmooth) (0, $31054a6c69637582$exports).copy(this._smoothedCameraPosition, value);
    }
    constructor(core){
        this._core = core;
        this._vec3 = (0, $31054a6c69637582$exports).create();
        this._quat = (0, $39ece26d1239bb77$exports).create();
        this._mat3 = (0, $ba3ca37806a2b6fa$exports).create();
        this._right = (0, $31054a6c69637582$exports).create();
        this._up = (0, $31054a6c69637582$exports).create();
        this._forward = (0, $31054a6c69637582$exports).create();
        this._modelManipulationOrigin = (0, $31054a6c69637582$exports).create();
        this.modelPosition = (0, $31054a6c69637582$exports).create();
        this.modelScale = (0, $31054a6c69637582$exports).create();
        this.modelRotation = (0, $39ece26d1239bb77$exports).create();
        this._orbitRotation = (0, $39ece26d1239bb77$exports).create();
        this._orbitDirection = (0, $39ece26d1239bb77$exports).create();
        this._smoothedOrbitRotation = (0, $39ece26d1239bb77$exports).create();
        this._smoothedCameraPosition = (0, $31054a6c69637582$exports).create();
        this._smoothedCameraRotation = (0, $39ece26d1239bb77$exports).create();
        this._cameraPosition = (0, $31054a6c69637582$exports).create();
        this._cameraRotation = (0, $39ece26d1239bb77$exports).create();
        this._combinedPosition = (0, $31054a6c69637582$exports).create();
        this._combinedRotation = (0, $39ece26d1239bb77$exports).create();
        this._leftToRightEye = (0, $31054a6c69637582$exports).create();
        this._pickVMatrix = (0, $1ac1b59392edf35b$exports).create();
        this._eyePositions = [
            (0, $31054a6c69637582$exports).create(),
            (0, $31054a6c69637582$exports).create()
        ];
        this._vMatrices = [
            (0, $1ac1b59392edf35b$exports).create(),
            (0, $1ac1b59392edf35b$exports).create()
        ];
        this._mvMatrices = [
            (0, $1ac1b59392edf35b$exports).create(),
            (0, $1ac1b59392edf35b$exports).create()
        ];
        this._pMatrices = [
            (0, $1ac1b59392edf35b$exports).create(),
            (0, $1ac1b59392edf35b$exports).create()
        ];
        this._inverseVMatrices = [
            (0, $1ac1b59392edf35b$exports).create(),
            (0, $1ac1b59392edf35b$exports).create()
        ];
        this._inversePMatrices = [
            (0, $1ac1b59392edf35b$exports).create(),
            (0, $1ac1b59392edf35b$exports).create()
        ];
    }
    reset(isSmooth) {
        (0, $31054a6c69637582$exports).copy(this._cameraPosition, (0, $d4d7bd6cc65a5081$export$a002182e51710d39).VECTOR3_ZERO);
        (0, $39ece26d1239bb77$exports).copy(this._cameraRotation, (0, $d4d7bd6cc65a5081$export$a002182e51710d39).QUAT_IDENTITY);
        (0, $39ece26d1239bb77$exports).copy(this._orbitRotation, (0, $d4d7bd6cc65a5081$export$a002182e51710d39).QUAT_IDENTITY);
        if (!isSmooth) this.syncSmooth();
    }
    update(elapsedTime) {
        let amount = Math.min(elapsedTime * this._core.config.positionSmoothing, 1);
        (0, $31054a6c69637582$exports).lerp(this._smoothedCameraPosition, this._smoothedCameraPosition, this._cameraPosition, amount);
        amount = Math.min(elapsedTime * this._core.config.rotationSmoothing, 1);
        (0, $39ece26d1239bb77$exports).slerp(this._smoothedCameraRotation, this._smoothedCameraRotation, this._cameraRotation, amount);
        (0, $39ece26d1239bb77$exports).slerp(this._smoothedOrbitRotation, this._smoothedOrbitRotation, this._orbitRotation, amount);
        const epsilon = 0.000001;
        let x;
        let y;
        let z;
        let w;
        x = this._smoothedCameraPosition[0] - this._cameraPosition[0];
        y = this._smoothedCameraPosition[1] - this._cameraPosition[1];
        z = this._smoothedCameraPosition[2] - this._cameraPosition[2];
        if (Math.abs(x) < epsilon && Math.abs(y) < epsilon && Math.abs(z) < epsilon) (0, $31054a6c69637582$exports).copy(this._smoothedCameraPosition, this._cameraPosition);
        x = this._smoothedCameraRotation[0] - this._cameraRotation[0];
        y = this._smoothedCameraRotation[1] - this._cameraRotation[1];
        z = this._smoothedCameraRotation[2] - this._cameraRotation[2];
        w = this._smoothedCameraRotation[3] - this._cameraRotation[3];
        if (Math.abs(x) < epsilon && Math.abs(y) < epsilon && Math.abs(z) < epsilon && Math.abs(w) < epsilon) (0, $39ece26d1239bb77$exports).copy(this._smoothedCameraRotation, this._cameraRotation);
        x = this._smoothedOrbitRotation[0] - this._orbitRotation[0];
        y = this._smoothedOrbitRotation[1] - this._orbitRotation[1];
        z = this._smoothedOrbitRotation[2] - this._orbitRotation[2];
        w = this._smoothedOrbitRotation[3] - this._orbitRotation[3];
        if (Math.abs(x) < epsilon && Math.abs(y) < epsilon && Math.abs(z) < epsilon && Math.abs(w) < epsilon) (0, $39ece26d1239bb77$exports).copy(this._smoothedOrbitRotation, this._orbitRotation);
        (0, $39ece26d1239bb77$exports).normalize(this._smoothedCameraRotation, this._smoothedCameraRotation);
        (0, $39ece26d1239bb77$exports).normalize(this._smoothedOrbitRotation, this._smoothedOrbitRotation);
        (0, $39ece26d1239bb77$exports).conjugate(this._orbitDirection, this._smoothedOrbitRotation);
        (0, $31054a6c69637582$exports).transformMat4(this._modelManipulationOrigin, this.modelManipulationOrigin, this.modelMMatrix);
        (0, $31054a6c69637582$exports).subtract(this._vec3, this._smoothedCameraPosition, this._modelManipulationOrigin);
        (0, $31054a6c69637582$exports).transformQuat(this._combinedPosition, this._vec3, this._orbitDirection);
        (0, $31054a6c69637582$exports).add(this._combinedPosition, this._combinedPosition, this._modelManipulationOrigin);
        (0, $39ece26d1239bb77$exports).multiply(this._combinedRotation, this._orbitDirection, this._smoothedCameraRotation);
        (0, $ba3ca37806a2b6fa$exports).fromQuat(this._mat3, this._combinedRotation);
        this._right[0] = this._mat3[0];
        this._right[1] = this._mat3[1];
        this._right[2] = this._mat3[2];
        this._up[0] = this._mat3[3];
        this._up[1] = this._mat3[4];
        this._up[2] = this._mat3[5];
        this._forward[0] = this._mat3[6];
        this._forward[1] = this._mat3[7];
        this._forward[2] = this._mat3[8];
        const view = this._vMatrices[0];
        view[0] = this._right[0];
        view[1] = this._up[0];
        view[2] = this._forward[0];
        view[4] = this._right[1];
        view[5] = this._up[1];
        view[6] = this._forward[1];
        view[8] = this._right[2];
        view[9] = this._up[2];
        view[10] = this._forward[2];
        view[12] = -(0, $31054a6c69637582$exports).dot(this._right, this._combinedPosition);
        view[13] = -(0, $31054a6c69637582$exports).dot(this._up, this._combinedPosition);
        view[14] = -(0, $31054a6c69637582$exports).dot(this._forward, this._combinedPosition);
        const aspectRatio = this.width / this.height;
        if (this._core.config.stereoMode == (0, $4a6417d29706362f$export$ec20dfa68810b176).none) {
            if (this._core.config.tilesX != 1 || this._core.config.tilesY != 1) {
                const top = Math.tan(this._core.config.fov * 0.5) * this._core.config.nearPlane;
                const bottom = -top;
                const left = -aspectRatio * top;
                const right = aspectRatio * top;
                const width = right - left;
                const height = top - bottom;
                const tileWidth = width / this._core.config.tilesX;
                const tileHeight = height / this._core.config.tilesY;
                (0, $1ac1b59392edf35b$exports).frustum(this._pMatrices[0], left + this._core.config.tileOffsetX * tileWidth, left + (this._core.config.tileOffsetX + 1) * tileWidth, bottom + (this._core.config.tilesY - this._core.config.tileOffsetY - 1) * tileHeight, bottom + (this._core.config.tilesY - this._core.config.tileOffsetY) * tileHeight, this._core.config.nearPlane, this._core.config.farPlane);
            } else (0, $1ac1b59392edf35b$exports).perspective(this.pMatrices[0], this._core.config.fov, aspectRatio, this._core.config.nearPlane, this._core.config.farPlane);
            (0, $1ac1b59392edf35b$exports).multiply(this._mvMatrices[0], this._vMatrices[0], this.modelMMatrix);
            (0, $1ac1b59392edf35b$exports).invert(this._inverseVMatrices[0], this.vMatrices[0]);
            (0, $1ac1b59392edf35b$exports).invert(this._inversePMatrices[0], this.pMatrices[0]);
        } else {
            (0, $31054a6c69637582$exports).cross(this._leftToRightEye, this._forward, this._up);
            (0, $31054a6c69637582$exports).normalize(this._leftToRightEye, this._leftToRightEye);
            (0, $31054a6c69637582$exports).scaleAndAdd(this._eyePositions[0], this._combinedPosition, this._leftToRightEye, -this._core.config.ipd);
            (0, $31054a6c69637582$exports).scaleAndAdd(this._eyePositions[1], this._combinedPosition, this._leftToRightEye, this._core.config.ipd);
            this._vMatrices[0][12] += this._core.config.ipd * 0.5;
            (0, $1ac1b59392edf35b$exports).copy(this._vMatrices[1], this._vMatrices[0]);
            this._vMatrices[1][12] -= this._core.config.ipd;
            const frustumShift = this._core.config.ipd * 0.5 * this._core.config.nearPlane / this._core.config.screenDistance;
            const top = Math.tan(this._core.config.fov * 0.5) * this._core.config.nearPlane;
            const bottom = -top;
            let left = -aspectRatio * top + frustumShift;
            let right = aspectRatio * top + frustumShift;
            (0, $1ac1b59392edf35b$exports).frustum(this._pMatrices[0], left, right, bottom, top, this._core.config.nearPlane, this._core.config.farPlane);
            left = -aspectRatio * top - frustumShift;
            right = aspectRatio * top - frustumShift;
            (0, $1ac1b59392edf35b$exports).frustum(this._pMatrices[1], left, right, bottom, top, this._core.config.nearPlane, this._core.config.farPlane);
            (0, $1ac1b59392edf35b$exports).multiply(this._mvMatrices[0], this._vMatrices[0], this.modelMMatrix);
            (0, $1ac1b59392edf35b$exports).multiply(this._mvMatrices[1], this._vMatrices[1], this.modelMMatrix);
            (0, $1ac1b59392edf35b$exports).invert(this._inverseVMatrices[0], this._vMatrices[0]);
            (0, $1ac1b59392edf35b$exports).invert(this._inversePMatrices[0], this._pMatrices[0]);
            (0, $1ac1b59392edf35b$exports).copy(this._inverseVMatrices[1], this._inverseVMatrices[0]);
            this._inverseVMatrices[1][12] += this._core.config.ipd;
            (0, $1ac1b59392edf35b$exports).invert(this._inversePMatrices[1], this._pMatrices[1]);
        }
        if (this._core.config.isDebugVisible) {
            this._core.debugText.addLine(`cam off ${this._cameraPosition[0] < 0 ? "" : " "}${this._cameraPosition[0].toFixed(3)},${this._cameraPosition[1] < 0 ? "" : " "}${this._cameraPosition[1].toFixed(3)},${this._cameraPosition[2] < 0 ? "" : " "}${this._cameraPosition[2].toFixed(3)}`);
            this._core.debugText.addLine(`cam pos ${this._combinedPosition[0] < 0 ? "" : " "}${this._combinedPosition[0].toFixed(3)},${this._combinedPosition[1] < 0 ? "" : " "}${this._combinedPosition[1].toFixed(3)},${this._combinedPosition[2] < 0 ? "" : " "}${this._combinedPosition[2].toFixed(3)}`);
            this._core.debugText.addLine(`cam rot ${this._combinedRotation[0] < 0 ? "" : " "}${this._combinedRotation[0].toFixed(3)},${this._combinedRotation[1] < 0 ? "" : " "}${this._combinedRotation[1].toFixed(3)},${this._combinedRotation[2] < 0 ? "" : " "}${this._combinedRotation[2].toFixed(3)},${this._combinedRotation[3] < 0 ? "" : " "}${this._combinedRotation[3].toFixed(3)}`);
        }
    }
    _zoom(direction, distance) {
        (0, $31054a6c69637582$exports).scaleAndAdd(this._cameraPosition, this._cameraPosition, direction, distance);
    }
    rotate(translationDelta) {}
    zoom(zoomDelta, x, y) {
        this.unproject(this._vec3, x, y, 1);
        (0, $31054a6c69637582$exports).normalize(this._vec3, this._vec3);
        const distance = zoomDelta * (0, $31054a6c69637582$exports).distance(this._combinedPosition, this.modelPosition);
        (0, $31054a6c69637582$exports).transformQuat(this._vec3, this._vec3, this._orbitRotation);
        this._zoom(this._vec3, distance);
    }
    _twist(axis, angle) {}
    twist(angle, x, y) {}
    updatePickVMatrix(x, y) {
        this.unproject(this._vec3, x, y, 1);
        (0, $1ac1b59392edf35b$exports).lookAt(this._pickVMatrix, this._combinedPosition, this._vec3, this._up);
    }
    syncSmooth() {
        (0, $31054a6c69637582$exports).copy(this._smoothedCameraPosition, this._cameraPosition);
        (0, $39ece26d1239bb77$exports).copy(this._smoothedCameraRotation, this._cameraRotation);
        (0, $39ece26d1239bb77$exports).copy(this._smoothedOrbitRotation, this._orbitRotation);
    }
    updateModelManipulationOrigin(from, to) {
        const a = (0, $31054a6c69637582$exports).create();
        const b = (0, $31054a6c69637582$exports).create();
        const c = (0, $31054a6c69637582$exports).create();
        const d = (0, $31054a6c69637582$exports).create();
        (0, $31054a6c69637582$exports).transformMat4(a, from, this.modelMMatrix);
        (0, $31054a6c69637582$exports).transformMat4(b, to, this.modelMMatrix);
        (0, $31054a6c69637582$exports).subtract(a, this._cameraPosition, a);
        (0, $31054a6c69637582$exports).subtract(b, this._cameraPosition, b);
        (0, $31054a6c69637582$exports).transformQuat(c, a, this._orbitDirection);
        (0, $31054a6c69637582$exports).transformQuat(d, b, this._orbitDirection);
        (0, $31054a6c69637582$exports).subtract(c, c, a);
        (0, $31054a6c69637582$exports).subtract(d, d, b);
        (0, $31054a6c69637582$exports).subtract(this._vec3, c, d);
        (0, $31054a6c69637582$exports).transformQuat(this._vec3, this._vec3, this._orbitRotation);
        (0, $31054a6c69637582$exports).add(this._cameraPosition, this._cameraPosition, this._vec3);
        (0, $31054a6c69637582$exports).add(this._smoothedCameraPosition, this._smoothedCameraPosition, this._vec3);
    }
    unproject(position, x, y, z) {
        (0, $31054a6c69637582$exports).set(position, 2 * x / this.width - 1, 1 - 2 * y / this.height, z);
        (0, $31054a6c69637582$exports).transformMat4(position, position, this._inversePMatrices[0]);
        (0, $31054a6c69637582$exports).transformMat4(position, position, this._inverseVMatrices[0]);
    }
    translate(translationDelta) {
        const distance = (0, $31054a6c69637582$exports).distance(this.modelPosition, this._combinedPosition);
        const height = 2 * Math.tan(this._core.config.fov / 2) * distance / this.height;
        (0, $31054a6c69637582$exports).set(this._vec3, height * translationDelta[0], -height * translationDelta[1], 0);
        (0, $31054a6c69637582$exports).transformQuat(this._vec3, this._vec3, this._combinedRotation);
        (0, $31054a6c69637582$exports).transformQuat(this._vec3, this._vec3, this._orbitRotation);
        (0, $31054a6c69637582$exports).subtract(this._cameraPosition, this._cameraPosition, this._vec3);
    }
}


class $242ad176fe12a941$export$d6a870718daa1f38 extends (0, $ec7cf7ba687c1511$export$ea4bacb7eec73803) {
    constructor(core){
        super(core);
        this.fov = core.config.fov;
        this.altitude = 0;
        this.azimuth = 0;
    }
}
class $242ad176fe12a941$export$cf22ae31f9260ad2 extends (0, $ec7cf7ba687c1511$export$c755714d282122f0) {
    getView(view) {
        super.getView(view);
        view.altitude = this.altitude;
        view.azimuth = this.azimuth;
        view.fov = this._core.config.fov;
    }
    setView(view, isSmooth) {
        super.setView(view, isSmooth);
        this.setAltAzimuth(view.altitude, view.azimuth, isSmooth);
        this._core.config.fov = view.fov;
    }
    lerpView(from, to, time) {
        super.lerpView(from, to, time);
        this.setAltAzimuth((0, $2d4d1eb6f32f02f2$export$80a8c44b8858d625).lerp(from.altitude, to.altitude, time), (0, $2d4d1eb6f32f02f2$export$80a8c44b8858d625).lerp(from.azimuth, to.azimuth, time), false);
        this._core.config.fov = (0, $2d4d1eb6f32f02f2$export$80a8c44b8858d625).lerp(from.fov, to.fov, time);
    }
    update(elapsedTime) {
        super.update(elapsedTime);
        if (this._core.config.isDebugVisible) {
            const altitude = (0, $a49c65c28e06311e$export$210d3b2db589eb5c).radiansToDegrees(this.altitude);
            const azimuth = (0, $a49c65c28e06311e$export$210d3b2db589eb5c).radiansToDegrees(this.azimuth);
            this._core.debugText.addLine(`cam alt ${altitude < 0 ? "" : " "}${altitude.toFixed(1)}`);
            this._core.debugText.addLine(`cam azi ${azimuth < 0 ? "" : " "}${azimuth.toFixed(1)}`);
        }
    }
    get altitude() {
        (0, $31054a6c69637582$exports).transformQuat(this._up, (0, $d4d7bd6cc65a5081$export$a002182e51710d39).VECTOR3_UNITY, this._combinedRotation);
        (0, $31054a6c69637582$exports).transformQuat(this._right, (0, $d4d7bd6cc65a5081$export$a002182e51710d39).VECTOR3_UNITX, this._combinedRotation);
        return -(0, $a49c65c28e06311e$export$210d3b2db589eb5c).signedAngleBetweenVectors((0, $d4d7bd6cc65a5081$export$a002182e51710d39).VECTOR3_UNITY, this._up, this._right);
    }
    get azimuth() {
        (0, $31054a6c69637582$exports).transformQuat(this._up, (0, $d4d7bd6cc65a5081$export$a002182e51710d39).VECTOR3_UNITY, this._combinedRotation);
        (0, $31054a6c69637582$exports).transformQuat(this._right, (0, $d4d7bd6cc65a5081$export$a002182e51710d39).VECTOR3_UNITX, this._combinedRotation);
        return -(0, $a49c65c28e06311e$export$210d3b2db589eb5c).signedAngleBetweenVectors((0, $d4d7bd6cc65a5081$export$a002182e51710d39).VECTOR3_UNITX, this._right, this._up);
    }
    setAltAzimuth(altitude, azimuth, isSmooth) {
        (0, $39ece26d1239bb77$exports).setAxisAngle(this._quat, (0, $d4d7bd6cc65a5081$export$a002182e51710d39).VECTOR3_UNITX, altitude);
        (0, $39ece26d1239bb77$exports).multiply(this._orbitRotation, this._quat, (0, $d4d7bd6cc65a5081$export$a002182e51710d39).QUAT_IDENTITY);
        (0, $39ece26d1239bb77$exports).setAxisAngle(this._quat, (0, $d4d7bd6cc65a5081$export$a002182e51710d39).VECTOR3_UNITY, azimuth);
        (0, $39ece26d1239bb77$exports).multiply(this._orbitRotation, this._orbitRotation, this._quat);
        if (!isSmooth) this.syncSmooth();
    }
    rotate(translationDelta) {
        const length = Math.min(this.width, this.height);
        let angle = translationDelta[1] * (0, $d4d7bd6cc65a5081$export$a002182e51710d39).PI / length;
        (0, $39ece26d1239bb77$exports).setAxisAngle(this._quat, (0, $d4d7bd6cc65a5081$export$a002182e51710d39).VECTOR3_UNITX, angle);
        (0, $39ece26d1239bb77$exports).multiply(this._orbitRotation, this._quat, this._orbitRotation);
        angle = translationDelta[0] * (0, $d4d7bd6cc65a5081$export$a002182e51710d39).PI / length;
        (0, $39ece26d1239bb77$exports).setAxisAngle(this._quat, (0, $d4d7bd6cc65a5081$export$a002182e51710d39).VECTOR3_UNITY, angle);
        (0, $39ece26d1239bb77$exports).multiply(this._orbitRotation, this._orbitRotation, this._quat);
    }
}


/*!
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 */ 



class $3c8e74dd6c09e751$export$29cd7b75162a9425 {
    constructor(core){
        this.reset();
    }
    reset() {
        this.isDebugVisible = false;
        this.logLevel = (0, $4a6417d29706362f$export$243e62d78d3b544d).warn;
        this.shaderPath = "shaders";
        this.fontPath = "fonts";
        this.modelDistance = 0.5;
        this.modelSize = 0.25;
        this.stereoMode = (0, $4a6417d29706362f$export$ec20dfa68810b176).none;
        this.ipd = 0.06;
        this.screenDistance = 0.5;
        this.fov = (0, $a49c65c28e06311e$export$210d3b2db589eb5c).degreesToRadians(30);
        this.nearPlane = 0.01;
        this.farPlane = 100;
        this.pickWidth = 512;
        this.pickHeight = 512;
        this.pickHoldDelay = 1000;
        this.pickSelectDelay = 100;
        this.resizeMinimumDelay = 250;
        this.rotationSmoothing = 0.02;
        this.positionSmoothing = 0.02;
        this.focusSmoothing = 0.01;
        this.scaleSmoothing = 0.02;
        this.mouseWheelZoomScale = -0.002;
        this.mouseWheelRotationScale = -0.002;
        this.dragToleranceSquared = 100;
        this.manipulatorMinRelativeDistanceSquared = 100;
        this.isMultiTouchEnabled = true;
        this.isMultiTouchZoomEnabled = true;
        this.isMultiTouchTwistEnabled = true;
        this.isMultiTouchRotateEnabled = true;
        this.isMultiTouchTranslateEnabled = true;
        this.multiTouchZoomScale = 1;
        this.cameraMinDistance = 0.1;
        this.cameraMaxDistance = 10;
        this.xrControllerRayColor = (0, $31054a6c69637582$exports).fromValues(0.5, 0.5, 0.5);
        this.xrControllerProfile = "windows-mixed-reality";
        this.xrControllerHandedness = "right";
        this.paletteColor = new Uint8Array([
            0x80,
            0x80,
            0x80,
            0
        ]);
        this.textColor = (0, $31054a6c69637582$exports).create();
        this.textHoverColor = (0, $31054a6c69637582$exports).create();
        this.textBorderColor = (0, $31054a6c69637582$exports).create();
        this.textBorderWidth = 0x18 / 0xff;
        this.identityRotation = (0, $d4d7bd6cc65a5081$export$a002182e51710d39).VECTOR3_UNITY;
        this.axesTextLabelMaxGlyphs = 32;
        this.axesTextColor = (0, $31054a6c69637582$exports).create();
        this.axesTextBorderColor = (0, $31054a6c69637582$exports).create();
        this.axesTextHoverColor = (0, $31054a6c69637582$exports).create();
        this.axesTextLabelMajorSize = 0.03;
        this.axesTextLabelMinorSize = 0.02;
        this.axesTextTitleMaxGlyphs = 127;
        this.axesTextTitleSize = 0.05;
        this.axesTextHeadingMaxGlyphs = 128;
        this.axesTextHeadingSize = 0.075;
        this.axesTextTitleLineHeight = 1.5;
        this.axesTextHeadingLineHeight = 1.5;
        this.axesTextLabelLineHeight = 1.5;
        this.axesGridMajorThickness = 0.0002;
        this.axesGridMinorThickness = 0.0001;
        this.axesGridZeroThickness = 0.002;
        this.axesGridPickDivisionHeight = 0.025;
        this.axesGridBackgroundColor = (0, $31054a6c69637582$exports).create();
        this.axesGridHighlightColor = (0, $31054a6c69637582$exports).create();
        this.axesGridMinorColor = (0, $31054a6c69637582$exports).create();
        this.axesGridMajorColor = (0, $31054a6c69637582$exports).create();
        this.axesGridZeroColor = (0, $31054a6c69637582$exports).create();
        this.axesGridDefaultDivisions = 10;
        this.keyTitleMaxGlyphs = 64;
        this.keyLabelMaxGlyphs = 64;
        this.selectionColor = (0, $31054a6c69637582$exports).create();
        this.hoverColor = (0, $31054a6c69637582$exports).create();
        this.activeColor = (0, $31054a6c69637582$exports).create();
        this.highlightMode = (0, $4a6417d29706362f$export$6b731eb2fd512fe0).color;
        this.lassoThickness = 4;
        this.lassoDashWidth = 2;
        this.lassoColor = (0, $31054a6c69637582$exports).create();
        this.minCubifiedTreeMapSlice = 0.01;
        this.sdfBuffer = 0xc0;
        this.sdfBorder = 0x0;
        this.forceDirectIsEnabled = false;
        this.forceDirectAttraction = 1;
        this.forceDirectRepulsion = 1;
        this.forceDirectGravity = 1;
        this.forceDirectInterval = 0.1;
        this.forceDirectMaxDistance = 0.1;
        this.forceDirectTheta = 1;
        this.forceDirectIterationsPerLayout = 1;
        this.forceDirectEdgeWeightPower = 1;
        this.forceDirectLockX = false;
        this.forceDirectLockY = false;
        this.forceDirectLockZ = false;
        this.transitionDuration = 400;
        this.transitionStaggering = 100;
        this.transitionView = true;
        this.isTransitionPickingEnabled = false;
        this.backgroundColor = (0, $4c4ac78b213a9c07$exports).create();
        this.theme = (0, $4a6417d29706362f$export$14faa19a0f3bbeb2).light;
        this.renderMode = (0, $4a6417d29706362f$export$2386c8c1d9db2d57).color;
        this.tilesX = 1;
        this.tilesY = 1;
        this.tileOffsetX = 0;
        this.tileOffsetY = 0;
    }
    get theme() {
        return this._theme;
    }
    set theme(value) {
        if (this._theme != value) {
            this._theme = value;
            switch(value){
                case (0, $4a6417d29706362f$export$14faa19a0f3bbeb2).dark:
                    (0, $4c4ac78b213a9c07$exports).set(this.backgroundColor, 0, 0, 0, 1);
                    (0, $31054a6c69637582$exports).set(this.textColor, 0.9, 0.9, 0.9);
                    (0, $31054a6c69637582$exports).set(this.textHoverColor, 1, 1, 1);
                    (0, $31054a6c69637582$exports).set(this.textBorderColor, 0, 0, 0);
                    (0, $31054a6c69637582$exports).set(this.axesTextColor, 0.9, 0.9, 0.9);
                    (0, $31054a6c69637582$exports).set(this.axesTextBorderColor, 0, 0, 0);
                    (0, $31054a6c69637582$exports).set(this.axesTextHoverColor, 1, 1, 1);
                    (0, $31054a6c69637582$exports).set(this.axesGridBackgroundColor, 0.02, 0.02, 0.02);
                    (0, $31054a6c69637582$exports).set(this.axesGridHighlightColor, 0.04, 0.04, 0.04);
                    (0, $31054a6c69637582$exports).set(this.axesGridMinorColor, 0.05, 0.05, 0.05);
                    (0, $31054a6c69637582$exports).set(this.axesGridMajorColor, 0.1, 0.1, 0.1);
                    (0, $31054a6c69637582$exports).set(this.axesGridZeroColor, 0.05, 0.1, 0.1);
                    (0, $31054a6c69637582$exports).set(this.selectionColor, 1, 1, 0);
                    (0, $31054a6c69637582$exports).set(this.hoverColor, 1, 0, 1);
                    (0, $31054a6c69637582$exports).set(this.activeColor, 0, 1, 1);
                    (0, $31054a6c69637582$exports).set(this.lassoColor, 0.9, 0.9, 0.9);
                    break;
                case (0, $4a6417d29706362f$export$14faa19a0f3bbeb2).light:
                    (0, $4c4ac78b213a9c07$exports).set(this.backgroundColor, 1, 1, 1, 1);
                    (0, $31054a6c69637582$exports).set(this.textColor, 0, 0, 0);
                    (0, $31054a6c69637582$exports).set(this.textHoverColor, 0.1, 0.1, 0.1);
                    (0, $31054a6c69637582$exports).set(this.textBorderColor, 1, 1, 1);
                    (0, $31054a6c69637582$exports).set(this.axesTextColor, 0, 0, 0);
                    (0, $31054a6c69637582$exports).set(this.axesTextBorderColor, 1, 1, 1);
                    (0, $31054a6c69637582$exports).set(this.axesTextHoverColor, 0.1, 0.1, 0.1);
                    (0, $31054a6c69637582$exports).set(this.axesGridBackgroundColor, 1, 1, 1);
                    (0, $31054a6c69637582$exports).set(this.axesGridHighlightColor, 0.925, 0.925, 0.925);
                    (0, $31054a6c69637582$exports).set(this.axesGridMinorColor, 0.9, 0.9, 0.9);
                    (0, $31054a6c69637582$exports).set(this.axesGridMajorColor, 0.8, 0.8, 0.8);
                    (0, $31054a6c69637582$exports).set(this.axesGridZeroColor, 0.7, 0.9, 0.9);
                    (0, $31054a6c69637582$exports).set(this.selectionColor, 1, 1, 0);
                    (0, $31054a6c69637582$exports).set(this.hoverColor, 1, 0, 1);
                    (0, $31054a6c69637582$exports).set(this.activeColor, 0, 1, 1);
                    (0, $31054a6c69637582$exports).set(this.lassoColor, 0.1, 0.1, 0.1);
                    break;
            }
            if (this.themeChangedCallback) this.themeChangedCallback(this._theme);
        }
    }
}



/*!
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 */ class $eea2540484261ac0$export$3d1f12550a40f54d {
    get text() {
        return this._text;
    }
    constructor(){
        this.clear();
    }
    clear() {
        this._text = "";
    }
    addLine(value) {
        this._text += value + "\n";
    }
}


/*!
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 */ class $f25ed8c17e63c6a4$export$6e55b0a28cfdaa88 {
    get frameCounter() {
        return this._frameCounter;
    }
    get totalFrames() {
        return this._totalFrames;
    }
    constructor(core){
        this._core = core;
        this._totalFrames = 0;
        this.reset();
    }
    update(elapsedTime) {
        this._elapsedTime += elapsedTime;
        if (this._elapsedTime > 1000) {
            this._elapsedTime -= 1000;
            this._fps = this._frameCounter;
            this._frameCounter = 0;
        }
        if (this._core.config.isDebugVisible) this._core.debugText.addLine(`fps      ${this._fps}`);
    }
    render() {
        this._frameCounter++;
        this._totalFrames++;
    }
    reset() {
        this._fps = 0;
        this._frameCounter = 0;
        this._elapsedTime = 0;
    }
}



/*!
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 */ const $548ced3eab978a8c$export$8f5ef0b663dcd813 = {
    sequentialsinglehue: "sequentialsinglehue",
    sequentialmultihue: "sequentialmultihue",
    diverging: "diverging",
    qualitative: "qualitative"
};
const $548ced3eab978a8c$export$de37189af674e8e1 = {
    blues: "blues",
    greens: "greens",
    greys: "greys",
    oranges: "oranges",
    purples: "purples",
    reds: "reds",
    viridis: "viridis",
    inferno: "inferno",
    magma: "magma",
    plasma: "plasma",
    bluegreen: "bluegreen",
    bluepurple: "bluepurple",
    greenblue: "greenblue",
    orangered: "orangered",
    purpleblue: "purpleblue",
    purplebluegreen: "purplebluegreen",
    purplered: "purplered",
    redpurple: "redpurple",
    yellowgreen: "yellowgreen",
    yellowgreenblue: "yellowgreenblue",
    yelloworangebrown: "yelloworangebrown",
    yelloworangered: "yelloworangered",
    brownbluegreen: "brownbluegreen",
    pinkyellowgreen: "pinkyellowgreen",
    purplegreen: "purplegreen",
    purpleorange: "purpleorange",
    redblue: "redblue",
    redgrey: "redgrey",
    redyellowblue: "redyellowblue",
    redyellowgreen: "redyellowgreen",
    spectral: "spectral",
    accent: "accent",
    dark2: "dark2",
    paired: "paired",
    pastel1: "pastel1",
    pastel2: "pastel2",
    set1: "set1",
    set2: "set2",
    set3: "set3"
};
class $548ced3eab978a8c$export$35624e624bb61356 {
    constructor(){
        this.palettes = {
            "blues": {
                type: $548ced3eab978a8c$export$8f5ef0b663dcd813.sequentialsinglehue,
                colors: new Uint8Array([
                    247,
                    251,
                    255,
                    222,
                    235,
                    247,
                    198,
                    219,
                    239,
                    158,
                    202,
                    225,
                    107,
                    174,
                    214,
                    66,
                    146,
                    198,
                    33,
                    113,
                    181,
                    8,
                    81,
                    156,
                    8,
                    48,
                    107
                ])
            },
            "greens": {
                type: $548ced3eab978a8c$export$8f5ef0b663dcd813.sequentialsinglehue,
                colors: new Uint8Array([
                    247,
                    252,
                    245,
                    229,
                    245,
                    224,
                    199,
                    233,
                    192,
                    161,
                    217,
                    155,
                    116,
                    196,
                    118,
                    65,
                    171,
                    93,
                    35,
                    139,
                    69,
                    0,
                    109,
                    44,
                    0,
                    68,
                    27
                ])
            },
            "greys": {
                type: $548ced3eab978a8c$export$8f5ef0b663dcd813.sequentialsinglehue,
                colors: new Uint8Array([
                    255,
                    255,
                    255,
                    240,
                    240,
                    240,
                    217,
                    217,
                    217,
                    189,
                    189,
                    189,
                    150,
                    150,
                    150,
                    115,
                    115,
                    115,
                    82,
                    82,
                    82,
                    37,
                    37,
                    37,
                    0,
                    0,
                    0
                ])
            },
            "oranges": {
                type: $548ced3eab978a8c$export$8f5ef0b663dcd813.sequentialsinglehue,
                colors: new Uint8Array([
                    255,
                    245,
                    235,
                    254,
                    230,
                    206,
                    253,
                    208,
                    162,
                    253,
                    174,
                    107,
                    253,
                    141,
                    60,
                    241,
                    105,
                    19,
                    217,
                    72,
                    1,
                    166,
                    54,
                    3,
                    127,
                    39,
                    4
                ])
            },
            "purples": {
                type: $548ced3eab978a8c$export$8f5ef0b663dcd813.sequentialsinglehue,
                colors: new Uint8Array([
                    252,
                    251,
                    253,
                    239,
                    237,
                    245,
                    218,
                    218,
                    235,
                    188,
                    189,
                    220,
                    158,
                    154,
                    200,
                    128,
                    125,
                    186,
                    106,
                    81,
                    163,
                    84,
                    39,
                    143,
                    63,
                    0,
                    125
                ])
            },
            "reds": {
                type: $548ced3eab978a8c$export$8f5ef0b663dcd813.sequentialsinglehue,
                colors: new Uint8Array([
                    255,
                    245,
                    240,
                    254,
                    224,
                    210,
                    252,
                    187,
                    161,
                    252,
                    146,
                    114,
                    251,
                    106,
                    74,
                    239,
                    59,
                    44,
                    203,
                    24,
                    29,
                    165,
                    15,
                    21,
                    103,
                    0,
                    13
                ])
            },
            "viridis": {
                type: $548ced3eab978a8c$export$8f5ef0b663dcd813.sequentialmultihue,
                colors: new Uint8Array([
                    0x48,
                    0x25,
                    0x75,
                    0x41,
                    0x44,
                    0x87,
                    0x35,
                    0x60,
                    0x8d,
                    0x2a,
                    0x78,
                    0x8e,
                    0x21,
                    0x91,
                    0x8d,
                    0x22,
                    0xa8,
                    0x84,
                    0x43,
                    0xbf,
                    0x71,
                    0x7a,
                    0xd1,
                    0x51,
                    0xbc,
                    0xdf,
                    0x27
                ])
            },
            "inferno": {
                type: $548ced3eab978a8c$export$8f5ef0b663dcd813.sequentialmultihue,
                colors: new Uint8Array([
                    0x17,
                    0x0c,
                    0x3b,
                    0x42,
                    0x0a,
                    0x68,
                    0x6b,
                    0x17,
                    0x6e,
                    0x93,
                    0x26,
                    0x67,
                    0xbb,
                    0x37,
                    0x55,
                    0xdd,
                    0x51,
                    0x3a,
                    0xf3,
                    0x77,
                    0x1a,
                    0xfc,
                    0xa5,
                    0x0a,
                    0xf6,
                    0xd6,
                    0x45
                ])
            },
            "magma": {
                type: $548ced3eab978a8c$export$8f5ef0b663dcd813.sequentialmultihue,
                colors: new Uint8Array([
                    0x15,
                    0x0e,
                    0x37,
                    0x3b,
                    0x0f,
                    0x70,
                    0x65,
                    0x1a,
                    0x80,
                    0x8c,
                    0x29,
                    0x81,
                    0xb6,
                    0x37,
                    0x7a,
                    0xde,
                    0x49,
                    0x68,
                    0xf7,
                    0x6f,
                    0x5c,
                    0xfe,
                    0x9f,
                    0x6d,
                    0xfe,
                    0xce,
                    0x91
                ])
            },
            "plasma": {
                type: $548ced3eab978a8c$export$8f5ef0b663dcd813.sequentialmultihue,
                colors: new Uint8Array([
                    0x42,
                    0x03,
                    0x9d,
                    0x6a,
                    0x00,
                    0xa8,
                    0x90,
                    0x0d,
                    0xa4,
                    0xb1,
                    0x2a,
                    0x90,
                    0xcb,
                    0x47,
                    0x79,
                    0xe1,
                    0x64,
                    0x62,
                    0xf2,
                    0x83,
                    0x4c,
                    0xfc,
                    0xa6,
                    0x36,
                    0xfc,
                    0xce,
                    0x25
                ])
            },
            "bluegreen": {
                type: $548ced3eab978a8c$export$8f5ef0b663dcd813.sequentialmultihue,
                colors: new Uint8Array([
                    247,
                    252,
                    253,
                    229,
                    245,
                    249,
                    204,
                    236,
                    230,
                    153,
                    216,
                    201,
                    102,
                    194,
                    164,
                    65,
                    174,
                    118,
                    35,
                    139,
                    69,
                    0,
                    109,
                    44,
                    0,
                    68,
                    27
                ])
            },
            "bluepurple": {
                type: $548ced3eab978a8c$export$8f5ef0b663dcd813.sequentialmultihue,
                colors: new Uint8Array([
                    247,
                    252,
                    253,
                    224,
                    236,
                    244,
                    191,
                    211,
                    230,
                    158,
                    188,
                    218,
                    140,
                    150,
                    198,
                    140,
                    107,
                    177,
                    136,
                    65,
                    157,
                    129,
                    15,
                    124,
                    77,
                    0,
                    75
                ])
            },
            "greenblue": {
                type: $548ced3eab978a8c$export$8f5ef0b663dcd813.sequentialmultihue,
                colors: new Uint8Array([
                    247,
                    252,
                    240,
                    224,
                    243,
                    219,
                    204,
                    235,
                    197,
                    168,
                    221,
                    181,
                    123,
                    204,
                    196,
                    78,
                    179,
                    211,
                    43,
                    140,
                    190,
                    8,
                    104,
                    172,
                    8,
                    64,
                    129
                ])
            },
            "orangered": {
                type: $548ced3eab978a8c$export$8f5ef0b663dcd813.sequentialmultihue,
                colors: new Uint8Array([
                    255,
                    247,
                    236,
                    254,
                    232,
                    200,
                    253,
                    212,
                    158,
                    253,
                    187,
                    132,
                    252,
                    141,
                    89,
                    239,
                    101,
                    72,
                    215,
                    48,
                    31,
                    179,
                    0,
                    0,
                    127,
                    0,
                    0
                ])
            },
            "purpleblue": {
                type: $548ced3eab978a8c$export$8f5ef0b663dcd813.sequentialmultihue,
                colors: new Uint8Array([
                    255,
                    247,
                    251,
                    236,
                    231,
                    242,
                    208,
                    209,
                    230,
                    166,
                    189,
                    219,
                    116,
                    169,
                    207,
                    54,
                    144,
                    192,
                    5,
                    112,
                    176,
                    4,
                    90,
                    141,
                    2,
                    56,
                    88
                ])
            },
            "purplebluegreen": {
                type: $548ced3eab978a8c$export$8f5ef0b663dcd813.sequentialmultihue,
                colors: new Uint8Array([
                    255,
                    247,
                    251,
                    236,
                    226,
                    240,
                    208,
                    209,
                    230,
                    166,
                    189,
                    219,
                    103,
                    169,
                    207,
                    54,
                    144,
                    192,
                    2,
                    129,
                    138,
                    1,
                    108,
                    89,
                    1,
                    70,
                    54
                ])
            },
            "purplered": {
                type: $548ced3eab978a8c$export$8f5ef0b663dcd813.sequentialmultihue,
                colors: new Uint8Array([
                    247,
                    244,
                    249,
                    231,
                    225,
                    239,
                    212,
                    185,
                    218,
                    201,
                    148,
                    199,
                    223,
                    101,
                    176,
                    231,
                    41,
                    138,
                    206,
                    18,
                    86,
                    152,
                    0,
                    67,
                    103,
                    0,
                    31
                ])
            },
            "redpurple": {
                type: $548ced3eab978a8c$export$8f5ef0b663dcd813.sequentialmultihue,
                colors: new Uint8Array([
                    255,
                    247,
                    243,
                    253,
                    224,
                    221,
                    252,
                    197,
                    192,
                    250,
                    159,
                    181,
                    247,
                    104,
                    161,
                    221,
                    52,
                    151,
                    174,
                    1,
                    126,
                    122,
                    1,
                    119,
                    73,
                    0,
                    106
                ])
            },
            "yellowgreen": {
                type: $548ced3eab978a8c$export$8f5ef0b663dcd813.sequentialmultihue,
                colors: new Uint8Array([
                    255,
                    255,
                    229,
                    247,
                    252,
                    185,
                    217,
                    240,
                    163,
                    173,
                    221,
                    142,
                    120,
                    198,
                    121,
                    65,
                    171,
                    93,
                    35,
                    132,
                    67,
                    0,
                    104,
                    55,
                    0,
                    69,
                    41
                ])
            },
            "yellowgreenblue": {
                type: $548ced3eab978a8c$export$8f5ef0b663dcd813.sequentialmultihue,
                colors: new Uint8Array([
                    255,
                    255,
                    217,
                    237,
                    248,
                    177,
                    199,
                    233,
                    180,
                    127,
                    205,
                    187,
                    65,
                    182,
                    196,
                    29,
                    145,
                    192,
                    34,
                    94,
                    168,
                    37,
                    52,
                    148,
                    8,
                    29,
                    88
                ])
            },
            "yelloworangebrown": {
                type: $548ced3eab978a8c$export$8f5ef0b663dcd813.sequentialmultihue,
                colors: new Uint8Array([
                    255,
                    255,
                    229,
                    255,
                    247,
                    188,
                    254,
                    227,
                    145,
                    254,
                    196,
                    79,
                    254,
                    153,
                    41,
                    236,
                    112,
                    20,
                    204,
                    76,
                    2,
                    153,
                    52,
                    4,
                    102,
                    37,
                    6
                ])
            },
            "yelloworangered": {
                type: $548ced3eab978a8c$export$8f5ef0b663dcd813.sequentialmultihue,
                colors: new Uint8Array([
                    255,
                    255,
                    204,
                    255,
                    237,
                    160,
                    254,
                    217,
                    118,
                    254,
                    178,
                    76,
                    253,
                    141,
                    60,
                    252,
                    78,
                    42,
                    227,
                    26,
                    28,
                    189,
                    0,
                    38,
                    128,
                    0,
                    38
                ])
            },
            "brownbluegreen": {
                type: $548ced3eab978a8c$export$8f5ef0b663dcd813.diverging,
                colors: new Uint8Array([
                    84,
                    48,
                    5,
                    140,
                    81,
                    10,
                    191,
                    129,
                    45,
                    223,
                    194,
                    125,
                    246,
                    232,
                    195,
                    245,
                    245,
                    245,
                    199,
                    234,
                    229,
                    128,
                    205,
                    193,
                    53,
                    151,
                    143,
                    1,
                    102,
                    94,
                    0,
                    60,
                    48
                ])
            },
            "pinkyellowgreen": {
                type: $548ced3eab978a8c$export$8f5ef0b663dcd813.diverging,
                colors: new Uint8Array([
                    142,
                    1,
                    82,
                    197,
                    27,
                    125,
                    222,
                    119,
                    174,
                    241,
                    182,
                    218,
                    253,
                    224,
                    239,
                    247,
                    247,
                    247,
                    230,
                    245,
                    208,
                    184,
                    225,
                    134,
                    127,
                    188,
                    65,
                    77,
                    146,
                    33,
                    39,
                    100,
                    25
                ])
            },
            "purplegreen": {
                type: $548ced3eab978a8c$export$8f5ef0b663dcd813.diverging,
                colors: new Uint8Array([
                    64,
                    0,
                    75,
                    118,
                    42,
                    131,
                    153,
                    112,
                    171,
                    194,
                    165,
                    207,
                    231,
                    212,
                    232,
                    247,
                    247,
                    247,
                    217,
                    240,
                    211,
                    166,
                    219,
                    160,
                    90,
                    174,
                    97,
                    27,
                    120,
                    55,
                    0,
                    68,
                    27
                ])
            },
            "purpleorange": {
                type: $548ced3eab978a8c$export$8f5ef0b663dcd813.diverging,
                colors: new Uint8Array([
                    127,
                    59,
                    8,
                    179,
                    88,
                    6,
                    224,
                    130,
                    20,
                    253,
                    184,
                    99,
                    254,
                    224,
                    182,
                    247,
                    247,
                    247,
                    216,
                    218,
                    235,
                    178,
                    171,
                    210,
                    128,
                    115,
                    172,
                    84,
                    39,
                    136,
                    45,
                    0,
                    75
                ])
            },
            "redblue": {
                type: $548ced3eab978a8c$export$8f5ef0b663dcd813.diverging,
                colors: new Uint8Array([
                    103,
                    0,
                    31,
                    178,
                    24,
                    43,
                    214,
                    96,
                    77,
                    244,
                    165,
                    130,
                    253,
                    219,
                    199,
                    247,
                    247,
                    247,
                    209,
                    229,
                    240,
                    146,
                    197,
                    222,
                    67,
                    147,
                    195,
                    33,
                    102,
                    172,
                    5,
                    48,
                    97
                ])
            },
            "redgrey": {
                type: $548ced3eab978a8c$export$8f5ef0b663dcd813.diverging,
                colors: new Uint8Array([
                    103,
                    0,
                    31,
                    178,
                    24,
                    43,
                    214,
                    96,
                    77,
                    244,
                    165,
                    130,
                    253,
                    219,
                    199,
                    255,
                    255,
                    255,
                    224,
                    224,
                    224,
                    186,
                    186,
                    186,
                    135,
                    135,
                    135,
                    77,
                    77,
                    77,
                    26,
                    26,
                    26
                ])
            },
            "redyellowblue": {
                type: $548ced3eab978a8c$export$8f5ef0b663dcd813.diverging,
                colors: new Uint8Array([
                    165,
                    0,
                    38,
                    215,
                    48,
                    39,
                    244,
                    109,
                    67,
                    253,
                    174,
                    97,
                    254,
                    224,
                    144,
                    255,
                    255,
                    191,
                    224,
                    243,
                    248,
                    171,
                    217,
                    233,
                    116,
                    173,
                    209,
                    69,
                    117,
                    180,
                    49,
                    54,
                    149
                ])
            },
            "redyellowgreen": {
                type: $548ced3eab978a8c$export$8f5ef0b663dcd813.diverging,
                colors: new Uint8Array([
                    165,
                    0,
                    38,
                    215,
                    48,
                    39,
                    244,
                    109,
                    67,
                    253,
                    174,
                    97,
                    254,
                    224,
                    139,
                    255,
                    255,
                    191,
                    217,
                    239,
                    139,
                    166,
                    217,
                    106,
                    102,
                    189,
                    99,
                    26,
                    152,
                    80,
                    0,
                    104,
                    55
                ])
            },
            "spectral": {
                type: $548ced3eab978a8c$export$8f5ef0b663dcd813.diverging,
                colors: new Uint8Array([
                    158,
                    1,
                    66,
                    213,
                    62,
                    79,
                    244,
                    109,
                    67,
                    253,
                    174,
                    97,
                    254,
                    224,
                    139,
                    255,
                    255,
                    191,
                    230,
                    245,
                    152,
                    171,
                    221,
                    164,
                    102,
                    194,
                    165,
                    50,
                    136,
                    189,
                    94,
                    79,
                    162
                ])
            },
            "accent": {
                type: $548ced3eab978a8c$export$8f5ef0b663dcd813.qualitative,
                colors: new Uint8Array([
                    127,
                    201,
                    127,
                    190,
                    174,
                    212,
                    253,
                    192,
                    134,
                    255,
                    255,
                    153,
                    56,
                    108,
                    176,
                    240,
                    2,
                    127,
                    191,
                    91,
                    23,
                    102,
                    102,
                    102
                ])
            },
            "dark2": {
                type: $548ced3eab978a8c$export$8f5ef0b663dcd813.qualitative,
                colors: new Uint8Array([
                    27,
                    158,
                    119,
                    217,
                    95,
                    2,
                    117,
                    112,
                    179,
                    231,
                    41,
                    138,
                    102,
                    166,
                    30,
                    230,
                    171,
                    2,
                    166,
                    118,
                    29,
                    102,
                    102,
                    102
                ])
            },
            "paired": {
                type: $548ced3eab978a8c$export$8f5ef0b663dcd813.qualitative,
                colors: new Uint8Array([
                    166,
                    206,
                    227,
                    31,
                    120,
                    180,
                    178,
                    223,
                    138,
                    51,
                    160,
                    44,
                    251,
                    154,
                    153,
                    227,
                    26,
                    28,
                    253,
                    191,
                    111,
                    255,
                    127,
                    0,
                    202,
                    178,
                    214,
                    106,
                    61,
                    154,
                    255,
                    255,
                    153,
                    177,
                    89,
                    40
                ])
            },
            "pastel1": {
                type: $548ced3eab978a8c$export$8f5ef0b663dcd813.qualitative,
                colors: new Uint8Array([
                    251,
                    180,
                    174,
                    179,
                    205,
                    227,
                    204,
                    235,
                    197,
                    222,
                    203,
                    228,
                    254,
                    217,
                    166,
                    255,
                    255,
                    204,
                    229,
                    216,
                    189,
                    253,
                    218,
                    236,
                    242,
                    242,
                    242
                ])
            },
            "pastel2": {
                type: $548ced3eab978a8c$export$8f5ef0b663dcd813.qualitative,
                colors: new Uint8Array([
                    179,
                    226,
                    205,
                    253,
                    205,
                    172,
                    203,
                    213,
                    232,
                    244,
                    202,
                    228,
                    230,
                    245,
                    201,
                    255,
                    242,
                    174,
                    241,
                    226,
                    204,
                    204,
                    204,
                    204
                ])
            },
            "set1": {
                type: $548ced3eab978a8c$export$8f5ef0b663dcd813.qualitative,
                colors: new Uint8Array([
                    228,
                    26,
                    28,
                    55,
                    126,
                    184,
                    77,
                    175,
                    74,
                    152,
                    78,
                    163,
                    255,
                    127,
                    0,
                    255,
                    255,
                    51,
                    166,
                    86,
                    40,
                    247,
                    129,
                    191,
                    153,
                    153,
                    153
                ])
            },
            "set2": {
                type: $548ced3eab978a8c$export$8f5ef0b663dcd813.qualitative,
                colors: new Uint8Array([
                    102,
                    194,
                    165,
                    252,
                    141,
                    98,
                    141,
                    160,
                    203,
                    231,
                    138,
                    195,
                    166,
                    216,
                    84,
                    255,
                    217,
                    47,
                    229,
                    196,
                    148,
                    179,
                    179,
                    179
                ])
            },
            "set3": {
                type: $548ced3eab978a8c$export$8f5ef0b663dcd813.qualitative,
                colors: new Uint8Array([
                    141,
                    211,
                    199,
                    255,
                    255,
                    179,
                    190,
                    186,
                    218,
                    251,
                    128,
                    114,
                    128,
                    177,
                    211,
                    253,
                    180,
                    98,
                    179,
                    222,
                    105,
                    252,
                    205,
                    229,
                    217,
                    217,
                    217,
                    188,
                    128,
                    189,
                    204,
                    235,
                    197,
                    255,
                    237,
                    111
                ])
            }
        };
    }
}
class $548ced3eab978a8c$export$f05ab453e1597580 {
    get colors() {
        return this._colors;
    }
    set colors(value) {
        if (this._colors != value) {
            this._colors = value;
            this._changed = true;
        }
    }
    constructor(){
        this._colors = null;
    }
    copyFrom(palette) {
        if (palette.colors) this.colors = new Uint8Array(palette.colors);
        else this.colors = null;
    }
    update() {}
}
class $548ced3eab978a8c$export$e2fbaa661ec19dbf extends $548ced3eab978a8c$export$f05ab453e1597580 {
}


/*!
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 */ 
/*!
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 */ 

/*!
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 */ 
class $0a0587bd8b0d58e8$export$5b33f080c7f6c861 {
    static getPosition(buffer, index, value) {
        const offset = index * $0a0587bd8b0d58e8$export$5b33f080c7f6c861.SIZE;
        (0, $31054a6c69637582$exports).set(value, buffer[offset], buffer[offset + 1], buffer[offset + 2]);
    }
    static setPosition(buffer, index, value) {
        const offset = index * $0a0587bd8b0d58e8$export$5b33f080c7f6c861.SIZE;
        buffer[offset] = value[0];
        buffer[offset + 1] = value[1];
        buffer[offset + 2] = value[2];
    }
}
$0a0587bd8b0d58e8$export$5b33f080c7f6c861.SIZE = 3;
$0a0587bd8b0d58e8$export$5b33f080c7f6c861.SIZE_BYTES = 12;
class $0a0587bd8b0d58e8$export$6597d9a580deb707 {
    static getPosition(bufferView, index, value) {
        const offset = $0a0587bd8b0d58e8$export$6597d9a580deb707.SIZE_BYTES * index + this.POSITION_OFFSET_BYTES;
        (0, $31054a6c69637582$exports).set(value, bufferView.getFloat32(offset, true), bufferView.getFloat32(offset + 4, true), bufferView.getFloat32(offset + 8, true));
    }
    static setPosition(bufferView, index, value) {
        const offset = $0a0587bd8b0d58e8$export$6597d9a580deb707.SIZE_BYTES * index + this.POSITION_OFFSET_BYTES;
        bufferView.setFloat32(offset, value[0], true);
        bufferView.setFloat32(offset + 4, value[1], true);
        bufferView.setFloat32(offset + 8, value[2], true);
    }
    static getColor(bufferView, index, value) {
        const offset = $0a0587bd8b0d58e8$export$6597d9a580deb707.SIZE_BYTES * index + this.COLOR_OFFSET_BYTES;
        (0, $31054a6c69637582$exports).set(value, bufferView.getUint8(offset) / 0xFF, bufferView.getUint8(offset + 1) / 0xFF, bufferView.getUint8(offset + 2) / 0xFF);
    }
    static setColor(bufferView, index, value) {
        const offset = $0a0587bd8b0d58e8$export$6597d9a580deb707.SIZE_BYTES * index + this.COLOR_OFFSET_BYTES;
        bufferView.setUint8(offset, value[0] * 0xFF);
        bufferView.setUint8(offset + 1, value[1] * 0xFF);
        bufferView.setUint8(offset + 2, value[2] * 0xFF);
    }
}
$0a0587bd8b0d58e8$export$6597d9a580deb707.SIZE_BYTES = 16;
$0a0587bd8b0d58e8$export$6597d9a580deb707.POSITION_OFFSET_BYTES = 0;
$0a0587bd8b0d58e8$export$6597d9a580deb707.COLOR_OFFSET_BYTES = 12;
class $0a0587bd8b0d58e8$export$538532535e0e8594 {
    static getPosition(bufferView, index, value) {
        const offset = $0a0587bd8b0d58e8$export$6597d9a580deb707.SIZE_BYTES * index + this.POSITION_OFFSET_BYTES;
        (0, $31054a6c69637582$exports).set(value, bufferView.getFloat32(offset, true), bufferView.getFloat32(offset + 4, true), bufferView.getFloat32(offset + 8, true));
    }
    static setPosition(bufferView, index, value) {
        const offset = $0a0587bd8b0d58e8$export$6597d9a580deb707.SIZE_BYTES * index + this.POSITION_OFFSET_BYTES;
        bufferView.setFloat32(offset, value[0], true);
        bufferView.setFloat32(offset + 4, value[1], true);
        bufferView.setFloat32(offset + 8, value[2], true);
    }
    static getTexCoord(bufferView, index, value) {
        const offset = $0a0587bd8b0d58e8$export$6597d9a580deb707.SIZE_BYTES * index + this.TEX_COORD_OFFSET_BYTES;
        (0, $91b0cc4981465964$exports).set(value, bufferView.getUint16(offset, true) / 0xFFFF, bufferView.getUint16(offset + 2, true) / 0xFFFF);
    }
    static setTexCoord(bufferView, index, value) {
        const offset = $0a0587bd8b0d58e8$export$6597d9a580deb707.SIZE_BYTES * index + this.TEX_COORD_OFFSET_BYTES;
        bufferView.setUint16(offset, value[0] * 0xFFFF, true);
        bufferView.setUint16(offset + 2, value[1] * 0xFFFF, true);
    }
}
$0a0587bd8b0d58e8$export$538532535e0e8594.SIZE_BYTES = 16;
$0a0587bd8b0d58e8$export$538532535e0e8594.POSITION_OFFSET_BYTES = 0;
$0a0587bd8b0d58e8$export$538532535e0e8594.TEX_COORD_OFFSET_BYTES = 12;
class $0a0587bd8b0d58e8$export$74c3c25430a16442 {
    static getPosition(bufferView, index, value) {
        const offset = $0a0587bd8b0d58e8$export$74c3c25430a16442.SIZE_BYTES * index + this.POSITION_OFFSET_BYTES;
        (0, $31054a6c69637582$exports).set(value, bufferView.getFloat32(offset, true), bufferView.getFloat32(offset + 4, true), bufferView.getFloat32(offset + 8, true));
    }
    static setPosition(bufferView, index, value) {
        const offset = $0a0587bd8b0d58e8$export$74c3c25430a16442.SIZE_BYTES * index + this.POSITION_OFFSET_BYTES;
        bufferView.setFloat32(offset, value[0], true);
        bufferView.setFloat32(offset + 4, value[1], true);
        bufferView.setFloat32(offset + 8, value[2], true);
    }
    static getTexCoord(bufferView, index, value) {
        const offset = $0a0587bd8b0d58e8$export$74c3c25430a16442.SIZE_BYTES * index + this.TEX_COORD_OFFSET_BYTES;
        (0, $91b0cc4981465964$exports).set(value, bufferView.getUint16(offset, true) / 0xFFFF, bufferView.getUint16(offset + 2, true) / 0xFFFF);
    }
    static setTexCoord(bufferView, index, value) {
        const offset = $0a0587bd8b0d58e8$export$74c3c25430a16442.SIZE_BYTES * index + this.TEX_COORD_OFFSET_BYTES;
        bufferView.setUint16(offset, value[0] * 0xFFFF, true);
        bufferView.setUint16(offset + 2, value[1] * 0xFFFF, true);
    }
    static getIdColor(bufferView, index, value) {
        const offset = $0a0587bd8b0d58e8$export$74c3c25430a16442.SIZE_BYTES * index + this.ID_COLOR_OFFSET_BYTES;
        (0, $4c4ac78b213a9c07$exports).set(value, bufferView.getUint8(offset) / 0xFF, bufferView.getUint8(offset + 1) / 0xFF, bufferView.getUint8(offset + 2) / 0xFF, bufferView.getUint8(offset + 3) / 0xFF);
    }
    static setIdColor(bufferView, index, value) {
        const offset = $0a0587bd8b0d58e8$export$74c3c25430a16442.SIZE_BYTES * index + this.ID_COLOR_OFFSET_BYTES;
        bufferView.setUint8(offset, value[0] * 0xFF);
        bufferView.setUint8(offset + 1, value[1] * 0xFF);
        bufferView.setUint8(offset + 2, value[2] * 0xFF);
        bufferView.setUint8(offset + 3, value[3] * 0xFF);
    }
}
$0a0587bd8b0d58e8$export$74c3c25430a16442.SIZE_BYTES = 20;
$0a0587bd8b0d58e8$export$74c3c25430a16442.ID_COLOR_OFFSET_BYTES = 0;
$0a0587bd8b0d58e8$export$74c3c25430a16442.POSITION_OFFSET_BYTES = 4;
$0a0587bd8b0d58e8$export$74c3c25430a16442.TEX_COORD_OFFSET_BYTES = 16;
class $0a0587bd8b0d58e8$export$7060026f20f731a4 {
    static getPosition(bufferView, index, value) {
        const offset = $0a0587bd8b0d58e8$export$7060026f20f731a4.SIZE_BYTES * index + this.POSITION_OFFSET_BYTES;
        (0, $31054a6c69637582$exports).set(value, bufferView.getFloat32(offset, true), bufferView.getFloat32(offset + 4, true), bufferView.getFloat32(offset + 8, true));
    }
    static setPosition(bufferView, index, value) {
        const offset = $0a0587bd8b0d58e8$export$7060026f20f731a4.SIZE_BYTES * index + this.POSITION_OFFSET_BYTES;
        bufferView.setFloat32(offset, value[0], true);
        bufferView.setFloat32(offset + 4, value[1], true);
        bufferView.setFloat32(offset + 8, value[2], true);
    }
    static getNormal(bufferView, index, value) {
        const offset = $0a0587bd8b0d58e8$export$7060026f20f731a4.SIZE_BYTES * index + this.NORMAL_OFFSET_BYTES;
        (0, $31054a6c69637582$exports).set(value, bufferView.getInt8(offset) / 0x7F, bufferView.getInt8(offset + 1) / 0x7F, bufferView.getInt8(offset + 2) / 0x7F);
    }
    static setNormal(bufferView, index, value) {
        const offset = $0a0587bd8b0d58e8$export$7060026f20f731a4.SIZE_BYTES * index + this.NORMAL_OFFSET_BYTES;
        bufferView.setInt8(offset, value[0] * 0x7F);
        bufferView.setInt8(offset + 1, value[1] * 0x7F);
        bufferView.setInt8(offset + 2, value[2] * 0x7F);
    }
}
$0a0587bd8b0d58e8$export$7060026f20f731a4.SIZE_BYTES = 16;
$0a0587bd8b0d58e8$export$7060026f20f731a4.POSITION_OFFSET_BYTES = 0;
$0a0587bd8b0d58e8$export$7060026f20f731a4.NORMAL_OFFSET_BYTES = 12;
class $0a0587bd8b0d58e8$export$15bf2991269f4a0e {
    static getPosition(bufferView, index, value) {
        const offset = $0a0587bd8b0d58e8$export$15bf2991269f4a0e.SIZE_BYTES * index + this.POSITION_OFFSET_BYTES;
        (0, $31054a6c69637582$exports).set(value, bufferView.getFloat32(offset, true), bufferView.getFloat32(offset + 4, true), bufferView.getFloat32(offset + 8, true));
    }
    static setPosition(bufferView, index, value) {
        const offset = $0a0587bd8b0d58e8$export$15bf2991269f4a0e.SIZE_BYTES * index + this.POSITION_OFFSET_BYTES;
        bufferView.setFloat32(offset, value[0], true);
        bufferView.setFloat32(offset + 4, value[1], true);
        bufferView.setFloat32(offset + 8, value[2], true);
    }
    static getNormal(bufferView, index, value) {
        const offset = $0a0587bd8b0d58e8$export$15bf2991269f4a0e.SIZE_BYTES * index + this.NORMAL_OFFSET_BYTES;
        (0, $31054a6c69637582$exports).set(value, bufferView.getInt8(offset) / 0x7F, bufferView.getInt8(offset + 1) / 0x7F, bufferView.getInt8(offset + 2) / 0x7F);
    }
    static setNormal(bufferView, index, value) {
        const offset = $0a0587bd8b0d58e8$export$15bf2991269f4a0e.SIZE_BYTES * index + this.NORMAL_OFFSET_BYTES;
        bufferView.setInt8(offset, value[0] * 0x7F);
        bufferView.setInt8(offset + 1, value[1] * 0x7F);
        bufferView.setInt8(offset + 2, value[2] * 0x7F);
    }
    static getColor(bufferView, index, value) {
        const offset = $0a0587bd8b0d58e8$export$15bf2991269f4a0e.SIZE_BYTES * index + this.COLOR_OFFSET_BYTES;
        (0, $31054a6c69637582$exports).set(value, bufferView.getUint8(offset) / 0xFF, bufferView.getUint8(offset + 1) / 0xFF, bufferView.getUint8(offset + 2) / 0xFF);
    }
    static setColor(bufferView, index, value) {
        const offset = $0a0587bd8b0d58e8$export$15bf2991269f4a0e.SIZE_BYTES * index + this.COLOR_OFFSET_BYTES;
        bufferView.setUint8(offset, value[0] * 0xFF);
        bufferView.setUint8(offset + 1, value[1] * 0xFF);
        bufferView.setUint8(offset + 2, value[2] * 0xFF);
    }
}
$0a0587bd8b0d58e8$export$15bf2991269f4a0e.SIZE_BYTES = 20;
$0a0587bd8b0d58e8$export$15bf2991269f4a0e.POSITION_OFFSET_BYTES = 0;
$0a0587bd8b0d58e8$export$15bf2991269f4a0e.NORMAL_OFFSET_BYTES = 12;
$0a0587bd8b0d58e8$export$15bf2991269f4a0e.COLOR_OFFSET_BYTES = 16;
class $0a0587bd8b0d58e8$export$e40add16394b9bff {
    static getPosition(bufferView, index, value) {
        const offset = $0a0587bd8b0d58e8$export$e40add16394b9bff.SIZE_BYTES * index + this.POSITION_OFFSET_BYTES;
        (0, $31054a6c69637582$exports).set(value, bufferView.getFloat32(offset, true), bufferView.getFloat32(offset + 4, true), bufferView.getFloat32(offset + 8, true));
    }
    static setPosition(bufferView, index, value) {
        const offset = $0a0587bd8b0d58e8$export$e40add16394b9bff.SIZE_BYTES * index + this.POSITION_OFFSET_BYTES;
        bufferView.setFloat32(offset, value[0], true);
        bufferView.setFloat32(offset + 4, value[1], true);
        bufferView.setFloat32(offset + 8, value[2], true);
    }
    static getNormal(bufferView, index, value) {
        const offset = $0a0587bd8b0d58e8$export$e40add16394b9bff.SIZE_BYTES * index + this.NORMAL_OFFSET_BYTES;
        (0, $31054a6c69637582$exports).set(value, bufferView.getInt8(offset) / 0x7F, bufferView.getInt8(offset + 1) / 0x7F, bufferView.getInt8(offset + 2) / 0x7F);
    }
    static setNormal(bufferView, index, value) {
        const offset = $0a0587bd8b0d58e8$export$e40add16394b9bff.SIZE_BYTES * index + this.NORMAL_OFFSET_BYTES;
        bufferView.setInt8(offset, value[0] * 0x7F);
        bufferView.setInt8(offset + 1, value[1] * 0x7F);
        bufferView.setInt8(offset + 2, value[2] * 0x7F);
    }
    static getTexCoord(bufferView, index, value) {
        const offset = $0a0587bd8b0d58e8$export$e40add16394b9bff.SIZE_BYTES * index + this.TEX_COORD_OFFSET_BYTES;
        (0, $91b0cc4981465964$exports).set(value, bufferView.getUint16(offset, true) / 0xFFFF, bufferView.getUint16(offset + 2, true) / 0xFFFF);
    }
    static setTexCoord(bufferView, index, value) {
        const offset = $0a0587bd8b0d58e8$export$e40add16394b9bff.SIZE_BYTES * index + this.TEX_COORD_OFFSET_BYTES;
        bufferView.setUint16(offset, value[0] * 0xFFFF, true);
        bufferView.setUint16(offset + 2, value[1] * 0xFFFF, true);
    }
}
$0a0587bd8b0d58e8$export$e40add16394b9bff.SIZE_BYTES = 20;
$0a0587bd8b0d58e8$export$e40add16394b9bff.POSITION_OFFSET_BYTES = 0;
$0a0587bd8b0d58e8$export$e40add16394b9bff.NORMAL_OFFSET_BYTES = 12;
$0a0587bd8b0d58e8$export$e40add16394b9bff.TEX_COORD_OFFSET_BYTES = 16;
class $0a0587bd8b0d58e8$export$df352805a955aca5 {
    static getTranslation(bufferView, index, value) {
        const offset = $0a0587bd8b0d58e8$export$df352805a955aca5.SIZE_BYTES * index + this.TRANSLATION_OFFSET_BYTES;
        (0, $31054a6c69637582$exports).set(value, bufferView.getFloat32(offset, true), bufferView.getFloat32(offset + 4, true), bufferView.getFloat32(offset + 8, true));
    }
    static setTranslation(bufferView, index, value) {
        const offset = $0a0587bd8b0d58e8$export$df352805a955aca5.SIZE_BYTES * index + this.TRANSLATION_OFFSET_BYTES;
        bufferView.setFloat32(offset, value[0], true);
        bufferView.setFloat32(offset + 4, value[1], true);
        bufferView.setFloat32(offset + 8, value[2], true);
    }
    static getNormal(bufferView, index, value) {
        const offset = $0a0587bd8b0d58e8$export$df352805a955aca5.SIZE_BYTES * index + this.NORMAL_OFFSET_BYTES;
        (0, $31054a6c69637582$exports).set(value, bufferView.getInt8(offset) / 0x7F, bufferView.getInt8(offset + 1) / 0x7F, bufferView.getInt8(offset + 2) / 0x7F);
    }
    static setNormal(bufferView, index, value) {
        const offset = $0a0587bd8b0d58e8$export$df352805a955aca5.SIZE_BYTES * index + this.NORMAL_OFFSET_BYTES;
        bufferView.setInt8(offset, value[0] * 0x7F);
        bufferView.setInt8(offset + 1, value[1] * 0x7F);
        bufferView.setInt8(offset + 2, value[2] * 0x7F);
    }
    static getIdColor(bufferView, index, value) {
        const offset = $0a0587bd8b0d58e8$export$df352805a955aca5.SIZE_BYTES * index + this.ID_COLOR_OFFSET_BYTES;
        (0, $4c4ac78b213a9c07$exports).set(value, bufferView.getUint8(offset) / 0xFF, bufferView.getUint8(offset + 1) / 0xFF, bufferView.getUint8(offset + 2) / 0xFF, bufferView.getUint8(offset + 3) / 0xFF);
    }
    static setIdColor(bufferView, index, value) {
        const offset = $0a0587bd8b0d58e8$export$df352805a955aca5.SIZE_BYTES * index + this.ID_COLOR_OFFSET_BYTES;
        bufferView.setUint8(offset, value[0] * 0xFF);
        bufferView.setUint8(offset + 1, value[1] * 0xFF);
        bufferView.setUint8(offset + 2, value[2] * 0xFF);
        bufferView.setUint8(offset + 3, value[3] * 0xFF);
    }
    static getTexCoord(bufferView, index, value) {
        const offset = $0a0587bd8b0d58e8$export$df352805a955aca5.SIZE_BYTES * index + this.TEX_COORD_OFFSET_BYTES;
        (0, $91b0cc4981465964$exports).set(value, bufferView.getUint16(offset, true) / 0xFFFF, bufferView.getUint16(offset + 2, true) / 0xFFFF);
    }
    static setTexCoord(bufferView, index, value) {
        const offset = $0a0587bd8b0d58e8$export$df352805a955aca5.SIZE_BYTES * index + this.TEX_COORD_OFFSET_BYTES;
        bufferView.setUint16(offset, value[0] * 0xFFFF, true);
        bufferView.setUint16(offset + 2, value[1] * 0xFFFF, true);
    }
    static getBounds(bufferView, index, value) {
        const offset = $0a0587bd8b0d58e8$export$df352805a955aca5.SIZE_BYTES * index + this.BOUNDS_OFFSET_BYTES;
        (0, $4c4ac78b213a9c07$exports).set(value, bufferView.getUint16(offset, true) / 0xFFFF, bufferView.getUint16(offset + 2, true) / 0xFFFF, bufferView.getUint16(offset + 4, true) / 0xFFFF, bufferView.getUint16(offset + 6, true) / 0xFFFF);
    }
    static setBounds(bufferView, index, value) {
        const offset = $0a0587bd8b0d58e8$export$df352805a955aca5.SIZE_BYTES * index + this.BOUNDS_OFFSET_BYTES;
        bufferView.setUint16(offset, value[0] * 0xFFFF, true);
        bufferView.setUint16(offset + 2, value[1] * 0xFFFF, true);
        bufferView.setUint16(offset + 4, value[2] * 0xFFFF, true);
        bufferView.setUint16(offset + 6, value[3] * 0xFFFF, true);
    }
}
$0a0587bd8b0d58e8$export$df352805a955aca5.SIZE_BYTES = 32;
$0a0587bd8b0d58e8$export$df352805a955aca5.TRANSLATION_OFFSET_BYTES = 0;
$0a0587bd8b0d58e8$export$df352805a955aca5.NORMAL_OFFSET_BYTES = 12;
$0a0587bd8b0d58e8$export$df352805a955aca5.ID_COLOR_OFFSET_BYTES = 16;
$0a0587bd8b0d58e8$export$df352805a955aca5.TEX_COORD_OFFSET_BYTES = 20;
$0a0587bd8b0d58e8$export$df352805a955aca5.BOUNDS_OFFSET_BYTES = 24;
class $0a0587bd8b0d58e8$export$849e31d725692576 {
    static getIdHover(bufferView, index) {
        return bufferView.getFloat32($0a0587bd8b0d58e8$export$849e31d725692576.SIZE_BYTES * index + this.ID_HOVER_OFFSET_BYTES, true);
    }
    static setIdHover(bufferView, index, value) {
        bufferView.setFloat32($0a0587bd8b0d58e8$export$849e31d725692576.SIZE_BYTES * index + this.ID_HOVER_OFFSET_BYTES, value, true);
    }
    static copyIdHover(fromBufferView, fromIndex, toBufferView, toIndex) {
        toBufferView.setFloat32($0a0587bd8b0d58e8$export$849e31d725692576.SIZE_BYTES * toIndex + this.ID_HOVER_OFFSET_BYTES, fromBufferView.getFloat32($0a0587bd8b0d58e8$export$849e31d725692576.SIZE_BYTES * fromIndex + this.ID_HOVER_OFFSET_BYTES, true), true);
    }
    static getTranslation(bufferView, index, value) {
        const offset = $0a0587bd8b0d58e8$export$849e31d725692576.SIZE_BYTES * index + this.TRANSLATION_OFFSET_BYTES;
        (0, $31054a6c69637582$exports).set(value, bufferView.getFloat32(offset, true), bufferView.getFloat32(offset + 4, true), bufferView.getFloat32(offset + 8, true));
    }
    static setTranslation(bufferView, index, value) {
        const offset = $0a0587bd8b0d58e8$export$849e31d725692576.SIZE_BYTES * index + this.TRANSLATION_OFFSET_BYTES;
        bufferView.setFloat32(offset, value[0], true);
        bufferView.setFloat32(offset + 4, value[1], true);
        bufferView.setFloat32(offset + 8, value[2], true);
    }
    static copyTranslation(fromBufferView, fromIndex, toBufferView, toIndex) {
        const fromOffset = $0a0587bd8b0d58e8$export$849e31d725692576.SIZE_BYTES * fromIndex + this.TRANSLATION_OFFSET_BYTES;
        const toOffset = $0a0587bd8b0d58e8$export$849e31d725692576.SIZE_BYTES * toIndex + this.TRANSLATION_OFFSET_BYTES;
        toBufferView.setFloat32(toOffset, fromBufferView.getFloat32(fromOffset, true), true);
        toBufferView.setFloat32(toOffset + 4, fromBufferView.getFloat32(fromOffset + 4, true), true);
        toBufferView.setFloat32(toOffset + 8, fromBufferView.getFloat32(fromOffset + 8, true), true);
    }
    static getColor(bufferView, index, value) {
        const offset = $0a0587bd8b0d58e8$export$849e31d725692576.SIZE_BYTES * index + this.COLOR_OFFSET_BYTES;
        (0, $91b0cc4981465964$exports).set(value, bufferView.getUint8(offset) / 0xFF, bufferView.getUint8(offset + 1) / 0xFF);
    }
    static setColor(bufferView, index, value) {
        const offset = $0a0587bd8b0d58e8$export$849e31d725692576.SIZE_BYTES * index + this.COLOR_OFFSET_BYTES;
        bufferView.setUint8(offset, value[0] * 0xFF);
        bufferView.setUint8(offset + 1, value[1] * 0xFF);
    }
    static copyColor(fromBufferView, fromIndex, toBufferView, toIndex) {
        const fromOffset = $0a0587bd8b0d58e8$export$849e31d725692576.SIZE_BYTES * fromIndex + this.COLOR_OFFSET_BYTES;
        const toOffset = $0a0587bd8b0d58e8$export$849e31d725692576.SIZE_BYTES * toIndex + this.COLOR_OFFSET_BYTES;
        toBufferView.setUint8(toOffset, fromBufferView.getUint8(fromOffset));
        toBufferView.setUint8(toOffset + 1, fromBufferView.getUint8(fromOffset + 1));
    }
    static getOrder(bufferView, index, value) {
        const offset = $0a0587bd8b0d58e8$export$849e31d725692576.SIZE_BYTES * index + this.ORDER_OFFSET_BYTES;
        (0, $91b0cc4981465964$exports).set(value, bufferView.getFloat32(offset, true), bufferView.getFloat32(offset + 4, true));
    }
    static setOrder(bufferView, index, value) {
        const offset = $0a0587bd8b0d58e8$export$849e31d725692576.SIZE_BYTES * index + this.ORDER_OFFSET_BYTES;
        bufferView.setFloat32(offset, value[0], true);
        bufferView.setFloat32(offset + 4, value[1], true);
    }
    static copyOrder(fromBufferView, fromIndex, toBufferView, toIndex) {
        const fromOffset = $0a0587bd8b0d58e8$export$849e31d725692576.SIZE_BYTES * fromIndex + this.ORDER_OFFSET_BYTES;
        const toOffset = $0a0587bd8b0d58e8$export$849e31d725692576.SIZE_BYTES * toIndex + this.ORDER_OFFSET_BYTES;
        toBufferView.setFloat32(toOffset, fromBufferView.getFloat32(fromOffset, true), true);
        toBufferView.setFloat32(toOffset + 4, fromBufferView.getFloat32(fromOffset + 4, true), true);
    }
    static getScale(bufferView, index, value) {
        const offset = $0a0587bd8b0d58e8$export$849e31d725692576.SIZE_BYTES * index + this.SCALE_OFFSET_BYTES;
        (0, $31054a6c69637582$exports).set(value, bufferView.getFloat32(offset, true), bufferView.getFloat32(offset + 4, true), bufferView.getFloat32(offset + 8, true));
    }
    static setScale(bufferView, index, value) {
        const offset = $0a0587bd8b0d58e8$export$849e31d725692576.SIZE_BYTES * index + this.SCALE_OFFSET_BYTES;
        bufferView.setFloat32(offset, value[0], true);
        bufferView.setFloat32(offset + 4, value[1], true);
        bufferView.setFloat32(offset + 8, value[2], true);
    }
    static copyScale(fromBufferView, fromIndex, toBufferView, toIndex) {
        const fromOffset = $0a0587bd8b0d58e8$export$849e31d725692576.SIZE_BYTES * fromIndex + this.SCALE_OFFSET_BYTES;
        const toOffset = $0a0587bd8b0d58e8$export$849e31d725692576.SIZE_BYTES * toIndex + this.SCALE_OFFSET_BYTES;
        toBufferView.setFloat32(toOffset, fromBufferView.getFloat32(fromOffset, true), true);
        toBufferView.setFloat32(toOffset + 4, fromBufferView.getFloat32(fromOffset + 4, true), true);
        toBufferView.setFloat32(toOffset + 8, fromBufferView.getFloat32(fromOffset + 8, true), true);
    }
    static getRotation(bufferView, index, value) {
        const offset = $0a0587bd8b0d58e8$export$849e31d725692576.SIZE_BYTES * index + this.ROTATION_OFFSET_BYTES;
        (0, $39ece26d1239bb77$exports).set(value, bufferView.getFloat32(offset, true), bufferView.getFloat32(offset + 4, true), bufferView.getFloat32(offset + 8, true), bufferView.getFloat32(offset + 12, true));
    }
    static setRotation(bufferView, index, value) {
        const offset = $0a0587bd8b0d58e8$export$849e31d725692576.SIZE_BYTES * index + this.ROTATION_OFFSET_BYTES;
        bufferView.setFloat32(offset, value[0], true);
        bufferView.setFloat32(offset + 4, value[1], true);
        bufferView.setFloat32(offset + 8, value[2], true);
        bufferView.setFloat32(offset + 12, value[3], true);
    }
    static copyRotation(fromBufferView, fromIndex, toBufferView, toIndex) {
        const fromOffset = $0a0587bd8b0d58e8$export$849e31d725692576.SIZE_BYTES * fromIndex + this.ROTATION_OFFSET_BYTES;
        const toOffset = $0a0587bd8b0d58e8$export$849e31d725692576.SIZE_BYTES * toIndex + this.ROTATION_OFFSET_BYTES;
        toBufferView.setFloat32(toOffset, fromBufferView.getFloat32(fromOffset, true), true);
        toBufferView.setFloat32(toOffset + 4, fromBufferView.getFloat32(fromOffset + 4, true), true);
        toBufferView.setFloat32(toOffset + 8, fromBufferView.getFloat32(fromOffset + 8, true), true);
        toBufferView.setFloat32(toOffset + 12, fromBufferView.getFloat32(fromOffset + 12, true), true);
    }
    static getTexCoord(bufferView, index, value) {
        const offset = $0a0587bd8b0d58e8$export$849e31d725692576.SIZE_BYTES * index + this.TEXCOORD_OFFSET_BYTES;
        (0, $39ece26d1239bb77$exports).set(value, bufferView.getFloat32(offset, true), bufferView.getFloat32(offset + 4, true), bufferView.getFloat32(offset + 8, true), bufferView.getFloat32(offset + 12, true));
    }
    static setTexCoord(bufferView, index, value) {
        const offset = $0a0587bd8b0d58e8$export$849e31d725692576.SIZE_BYTES * index + this.TEXCOORD_OFFSET_BYTES;
        bufferView.setFloat32(offset, value[0], true);
        bufferView.setFloat32(offset + 4, value[1], true);
        bufferView.setFloat32(offset + 8, value[2], true);
        bufferView.setFloat32(offset + 12, value[3], true);
    }
    static copyTexCoord(fromBufferView, fromIndex, toBufferView, toIndex) {
        const fromOffset = $0a0587bd8b0d58e8$export$849e31d725692576.SIZE_BYTES * fromIndex + this.TEXCOORD_OFFSET_BYTES;
        const toOffset = $0a0587bd8b0d58e8$export$849e31d725692576.SIZE_BYTES * toIndex + this.TEXCOORD_OFFSET_BYTES;
        toBufferView.setFloat32(toOffset, fromBufferView.getFloat32(fromOffset, true), true);
        toBufferView.setFloat32(toOffset + 4, fromBufferView.getFloat32(fromOffset + 4, true), true);
        toBufferView.setFloat32(toOffset + 8, fromBufferView.getFloat32(fromOffset + 8, true), true);
        toBufferView.setFloat32(toOffset + 12, fromBufferView.getFloat32(fromOffset + 12, true), true);
    }
    static getIdColor(bufferView, index, value) {
        const offset = $0a0587bd8b0d58e8$export$849e31d725692576.SIZE_BYTES * index + this.ID_COLOR_OFFSET_BYTES;
        (0, $4c4ac78b213a9c07$exports).set(value, bufferView.getUint8(offset) / 0xFF, bufferView.getUint8(offset + 1) / 0xFF, bufferView.getUint8(offset + 2) / 0xFF, bufferView.getUint8(offset + 3) / 0xFF);
    }
    static setIdColor(bufferView, index, value) {
        const offset = $0a0587bd8b0d58e8$export$849e31d725692576.SIZE_BYTES * index + this.ID_COLOR_OFFSET_BYTES;
        bufferView.setUint8(offset, value[0] * 0xFF);
        bufferView.setUint8(offset + 1, value[1] * 0xFF);
        bufferView.setUint8(offset + 2, value[2] * 0xFF);
        bufferView.setUint8(offset + 3, value[3] * 0xFF);
    }
    static getSelected(bufferView, index) {
        return bufferView.getInt8($0a0587bd8b0d58e8$export$849e31d725692576.SIZE_BYTES * index + this.SELECTED_OFFSET_BYTES) / 0x7F;
    }
    static setSelected(bufferView, index, value) {
        bufferView.setInt8($0a0587bd8b0d58e8$export$849e31d725692576.SIZE_BYTES * index + this.SELECTED_OFFSET_BYTES, value * 0x7F);
    }
    static copySelected(fromBufferView, fromIndex, toBufferView, toIndex) {
        toBufferView.setInt8($0a0587bd8b0d58e8$export$849e31d725692576.SIZE_BYTES * toIndex + this.SELECTED_OFFSET_BYTES, fromBufferView.getInt8($0a0587bd8b0d58e8$export$849e31d725692576.SIZE_BYTES * fromIndex + this.SELECTED_OFFSET_BYTES));
    }
    static getRounding(bufferView, index) {
        return bufferView.getFloat32($0a0587bd8b0d58e8$export$849e31d725692576.SIZE_BYTES * index + this.ROUNDING_OFFSET_BYTES, true);
    }
    static setRounding(bufferView, index, value) {
        bufferView.setFloat32($0a0587bd8b0d58e8$export$849e31d725692576.SIZE_BYTES * index + this.ROUNDING_OFFSET_BYTES, value, true);
    }
    static copyRounding(fromBufferView, fromIndex, toBufferView, toIndex) {
        toBufferView.setFloat32($0a0587bd8b0d58e8$export$849e31d725692576.SIZE_BYTES * toIndex + this.ROUNDING_OFFSET_BYTES, fromBufferView.getFloat32($0a0587bd8b0d58e8$export$849e31d725692576.SIZE_BYTES * fromIndex + this.ROUNDING_OFFSET_BYTES, true), true);
    }
    static getParameter1(bufferView, index) {
        return bufferView.getFloat32($0a0587bd8b0d58e8$export$849e31d725692576.SIZE_BYTES * index + this.PARAMETER_1_OFFSET_BYTES, true);
    }
    static setParameter1(bufferView, index, value) {
        bufferView.setFloat32($0a0587bd8b0d58e8$export$849e31d725692576.SIZE_BYTES * index + this.PARAMETER_1_OFFSET_BYTES, value, true);
    }
    static copyParameter1(fromBufferView, fromIndex, toBufferView, toIndex) {
        toBufferView.setFloat32($0a0587bd8b0d58e8$export$849e31d725692576.SIZE_BYTES * toIndex + this.PARAMETER_1_OFFSET_BYTES, fromBufferView.getFloat32($0a0587bd8b0d58e8$export$849e31d725692576.SIZE_BYTES * fromIndex + this.PARAMETER_1_OFFSET_BYTES, true), true);
    }
    static getParameter2(bufferView, index) {
        return bufferView.getFloat32($0a0587bd8b0d58e8$export$849e31d725692576.SIZE_BYTES * index + this.PARAMETER_2_OFFSET_BYTES, true);
    }
    static setParameter2(bufferView, index, value) {
        bufferView.setFloat32($0a0587bd8b0d58e8$export$849e31d725692576.SIZE_BYTES * index + this.PARAMETER_2_OFFSET_BYTES, value, true);
    }
    static copyParameter2(fromBufferView, fromIndex, toBufferView, toIndex) {
        toBufferView.setFloat32($0a0587bd8b0d58e8$export$849e31d725692576.SIZE_BYTES * toIndex + this.PARAMETER_2_OFFSET_BYTES, fromBufferView.getFloat32($0a0587bd8b0d58e8$export$849e31d725692576.SIZE_BYTES * fromIndex + this.PARAMETER_2_OFFSET_BYTES, true), true);
    }
    static getMaterial(bufferView, index) {
        return bufferView.getUint16($0a0587bd8b0d58e8$export$849e31d725692576.SIZE_BYTES * index + this.MATERIAL_OFFSET_BYTES);
    }
    static setMaterial(bufferView, index, value) {
        bufferView.setUint16($0a0587bd8b0d58e8$export$849e31d725692576.SIZE_BYTES * index + this.MATERIAL_OFFSET_BYTES, value);
    }
    static copyMaterial(fromBufferView, fromIndex, toBufferView, toIndex) {
        toBufferView.setUint16($0a0587bd8b0d58e8$export$849e31d725692576.SIZE_BYTES * toIndex + this.MATERIAL_OFFSET_BYTES, fromBufferView.getUint16($0a0587bd8b0d58e8$export$849e31d725692576.SIZE_BYTES * fromIndex + this.MATERIAL_OFFSET_BYTES, true), true);
    }
    static getTexture(bufferView, index) {
        return bufferView.getUint8($0a0587bd8b0d58e8$export$849e31d725692576.SIZE_BYTES * index + this.TEXTURE_OFFSET_BYTES);
    }
    static setTexture(bufferView, index, value) {
        bufferView.setUint8($0a0587bd8b0d58e8$export$849e31d725692576.SIZE_BYTES * index + this.TEXTURE_OFFSET_BYTES, value);
    }
    static copyTexture(fromBufferView, fromIndex, toBufferView, toIndex) {
        toBufferView.setUint8($0a0587bd8b0d58e8$export$849e31d725692576.SIZE_BYTES * toIndex + this.TEXTURE_OFFSET_BYTES, fromBufferView.getUint8($0a0587bd8b0d58e8$export$849e31d725692576.SIZE_BYTES * fromIndex + this.TEXTURE_OFFSET_BYTES));
    }
    static getSdfBuffer(bufferView, index) {
        return bufferView.getUint8($0a0587bd8b0d58e8$export$849e31d725692576.SIZE_BYTES * index + this.SDF_BUFFER_OFFSET_BYTES);
    }
    static setSdfBuffer(bufferView, index, value) {
        bufferView.setUint8($0a0587bd8b0d58e8$export$849e31d725692576.SIZE_BYTES * index + this.SDF_BUFFER_OFFSET_BYTES, value);
    }
    static copySdfBuffer(fromBufferView, fromIndex, toBufferView, toIndex) {
        toBufferView.setUint8($0a0587bd8b0d58e8$export$849e31d725692576.SIZE_BYTES * toIndex + this.SDF_BUFFER_OFFSET_BYTES, fromBufferView.getUint8($0a0587bd8b0d58e8$export$849e31d725692576.SIZE_BYTES * fromIndex + this.SDF_BUFFER_OFFSET_BYTES));
    }
    static getSdfBorder(bufferView, index) {
        return bufferView.getUint8($0a0587bd8b0d58e8$export$849e31d725692576.SIZE_BYTES * index + this.SDF_BORDER_OFFSET_BYTES);
    }
    static setSdfBorder(bufferView, index, value) {
        bufferView.setUint8($0a0587bd8b0d58e8$export$849e31d725692576.SIZE_BYTES * index + this.SDF_BORDER_OFFSET_BYTES, value);
    }
    static copySdfBorder(fromBufferView, fromIndex, toBufferView, toIndex) {
        toBufferView.setUint8($0a0587bd8b0d58e8$export$849e31d725692576.SIZE_BYTES * toIndex + this.SDF_BORDER_OFFSET_BYTES, fromBufferView.getUint8($0a0587bd8b0d58e8$export$849e31d725692576.SIZE_BYTES * fromIndex + this.SDF_BORDER_OFFSET_BYTES));
    }
}
$0a0587bd8b0d58e8$export$849e31d725692576.SIZE_BYTES = 92;
$0a0587bd8b0d58e8$export$849e31d725692576.ID_HOVER_OFFSET_BYTES = 0;
$0a0587bd8b0d58e8$export$849e31d725692576.ID_COLOR_OFFSET_BYTES = 4;
$0a0587bd8b0d58e8$export$849e31d725692576.ORDER_OFFSET_BYTES = 8;
$0a0587bd8b0d58e8$export$849e31d725692576.STAGGER_ORDER_OFFSET_BYTES = 12;
$0a0587bd8b0d58e8$export$849e31d725692576.SELECTED_OFFSET_BYTES = 80;
$0a0587bd8b0d58e8$export$849e31d725692576.TRANSLATION_OFFSET_BYTES = 16;
$0a0587bd8b0d58e8$export$849e31d725692576.COLOR_OFFSET_BYTES = 28;
$0a0587bd8b0d58e8$export$849e31d725692576.MATERIAL_OFFSET_BYTES = 30;
$0a0587bd8b0d58e8$export$849e31d725692576.SCALE_OFFSET_BYTES = 32;
$0a0587bd8b0d58e8$export$849e31d725692576.ROUNDING_OFFSET_BYTES = 44;
$0a0587bd8b0d58e8$export$849e31d725692576.ROTATION_OFFSET_BYTES = 48;
$0a0587bd8b0d58e8$export$849e31d725692576.TEXCOORD_OFFSET_BYTES = 64;
$0a0587bd8b0d58e8$export$849e31d725692576.TEXTURE_OFFSET_BYTES = 81;
$0a0587bd8b0d58e8$export$849e31d725692576.SDF_BUFFER_OFFSET_BYTES = 82;
$0a0587bd8b0d58e8$export$849e31d725692576.SDF_BORDER_OFFSET_BYTES = 83;
$0a0587bd8b0d58e8$export$849e31d725692576.PARAMETER_1_OFFSET_BYTES = 84;
$0a0587bd8b0d58e8$export$849e31d725692576.PARAMETER_2_OFFSET_BYTES = 88;


class $636d0ad960a10a23$export$fac54d16266765a9 {
}
class $636d0ad960a10a23$export$bfc5db82fb7164f0 {
    constructor(core){
        this._core = core;
    }
    read(data) {
        const start = window.performance.now();
        const indices = [];
        const positions = [];
        const normals = [];
        const texCoords = [];
        const meshes = [];
        const indexOffsets = [];
        const indexCounts = [];
        const faceLookup = {};
        const lines = data.split("\n");
        let faceCount = 0;
        for(let i = 0; i < lines.length; i++){
            const parts = lines[i].trim().split(" ");
            if (parts.length > 0) switch(parts[0]){
                case "o":
                    meshes.push(parts[1]);
                    indexOffsets.push(indices.length);
                    break;
                case "v":
                    positions.push(parseFloat(parts[1]));
                    positions.push(parseFloat(parts[2]));
                    positions.push(parseFloat(parts[3]));
                    break;
                case "vt":
                    texCoords.push(parseFloat(parts[1]));
                    texCoords.push(parseFloat(parts[2]));
                    break;
                case "vn":
                    normals.push(parseFloat(parts[1]));
                    normals.push(parseFloat(parts[2]));
                    normals.push(parseFloat(parts[3]));
                    break;
                case "f":
                    for(let i = 0; i < parts.length - 1; i++){
                        const part = parts[i + 1];
                        if (faceLookup[part] == undefined) faceLookup[part] = faceCount++;
                        indices.push(faceLookup[part]);
                    }
                    break;
                case "usemtl":
                case "mtllib":
                default:
                    break;
            }
        }
        for(let i = 0; i < meshes.length - 1; i++)indexCounts.push(indexOffsets[i + 1] - indexOffsets[i]);
        indexCounts.push(indices.length - indexOffsets[meshes.length - 1]);
        const vertices = new ArrayBuffer((0, $0a0587bd8b0d58e8$export$e40add16394b9bff).SIZE_BYTES * Object.keys(faceLookup).length);
        const dataView = new DataView(vertices);
        let minX = Number.MAX_VALUE;
        let minY = Number.MAX_VALUE;
        let minZ = Number.MAX_VALUE;
        let maxX = -Number.MAX_VALUE;
        let maxY = -Number.MAX_VALUE;
        let maxZ = -Number.MAX_VALUE;
        const faces = Object.keys(faceLookup);
        const _vec2 = (0, $91b0cc4981465964$exports).create();
        const _vec3 = (0, $31054a6c69637582$exports).create();
        let hasTexCoords, hasNormals;
        if (faces.length > 0) {
            const faceParts = faces[0].split("/");
            hasTexCoords = faceParts.length > 1 && !isNaN(parseInt(faceParts[1]));
            hasNormals = faceParts.length > 2 && !isNaN(parseInt(faceParts[2]));
        }
        for(let i = 0; i < faces.length; i++){
            const faceParts = faces[i].split("/");
            let index = (parseInt(faceParts[0]) - 1) * 3;
            const x = positions[index];
            const y = positions[index + 1];
            const z = positions[index + 2];
            (0, $31054a6c69637582$exports).set(_vec3, x, y, z);
            (0, $0a0587bd8b0d58e8$export$e40add16394b9bff).setPosition(dataView, i, _vec3);
            minX = Math.min(x, minX);
            minY = Math.min(y, minY);
            minZ = Math.min(z, minZ);
            maxX = Math.max(x, maxX);
            maxY = Math.max(y, maxY);
            maxZ = Math.max(z, maxZ);
            if (hasNormals) {
                index = (parseInt(faceParts[2]) - 1) * 3;
                (0, $31054a6c69637582$exports).set(_vec3, normals[index], normals[index + 1], normals[index + 2]);
                (0, $0a0587bd8b0d58e8$export$e40add16394b9bff).setNormal(dataView, i, _vec3);
            }
            if (hasTexCoords) {
                index = (parseInt(faceParts[1]) - 1) * 2;
                (0, $91b0cc4981465964$exports).set(_vec2, texCoords[index], texCoords[index + 1]);
                (0, $0a0587bd8b0d58e8$export$e40add16394b9bff).setTexCoord(dataView, i, _vec2);
            }
        }
        const originX = (minX + maxX) / 2;
        const originY = (minY + maxY) / 2;
        const originZ = (minZ + maxZ) / 2;
        const objMesh = new $636d0ad960a10a23$export$fac54d16266765a9();
        objMesh.vertices = vertices;
        objMesh.indices = new Uint16Array(indices);
        objMesh.meshes = meshes;
        objMesh.indexOffsets = indexOffsets;
        objMesh.indexCounts = indexCounts;
        objMesh.indexCount = indices.length;
        objMesh.minX = minX;
        objMesh.minY = minY;
        objMesh.minZ = minZ;
        objMesh.maxX = maxX;
        objMesh.maxY = maxY;
        objMesh.maxZ = maxZ;
        objMesh.originX = originX;
        objMesh.originY = originY;
        objMesh.originZ = originZ;
        this._core.log.write((0, $4a6417d29706362f$export$243e62d78d3b544d).info, `obj loaded ${Math.round(window.performance.now() - start)}ms`);
        return objMesh;
    }
}



/*!
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 */ 

class $c2c30e4dcf8004c5$export$a15f0a83a652dd40 {
}
$c2c30e4dcf8004c5$export$a15f0a83a652dd40.POSITIONS = new Float32Array([
    -0.5,
    0.5,
    0.5,
    0.5,
    0.5,
    0.5,
    0.5,
    -0.5,
    0.5,
    -0.5,
    -0.5,
    0.5,
    -0.5,
    0.5,
    -0.5,
    0.5,
    0.5,
    -0.5,
    0.5,
    -0.5,
    -0.5,
    -0.5,
    -0.5,
    -0.5
]);
$c2c30e4dcf8004c5$export$a15f0a83a652dd40.INDICES = new Uint16Array([
    5,
    4,
    1,
    0,
    3,
    4,
    7,
    5,
    6,
    1,
    2,
    3,
    6,
    7
]);
$c2c30e4dcf8004c5$export$a15f0a83a652dd40.CUBE_MAP_INDICES = new Uint16Array([
    2,
    3,
    1,
    0,
    4,
    3,
    7,
    2,
    6,
    1,
    5,
    4,
    6,
    7
]);
$c2c30e4dcf8004c5$export$a15f0a83a652dd40.FACE_NORMALS = [
    (0, $31054a6c69637582$exports).fromValues(0, 1, 0),
    (0, $31054a6c69637582$exports).fromValues(1, 0, 0),
    (0, $31054a6c69637582$exports).fromValues(0, -1, 0),
    (0, $31054a6c69637582$exports).fromValues(-1, 0, 0),
    (0, $31054a6c69637582$exports).fromValues(0, 0, 1),
    (0, $31054a6c69637582$exports).fromValues(0, 0, -1)
];
$c2c30e4dcf8004c5$export$a15f0a83a652dd40.FACE_POSITIONS = [
    (0, $31054a6c69637582$exports).fromValues(0.0, 0.5, 0.0),
    (0, $31054a6c69637582$exports).fromValues(0.5, 0.0, 0.0),
    (0, $31054a6c69637582$exports).fromValues(0.0, -0.5, 0.0),
    (0, $31054a6c69637582$exports).fromValues(-0.5, 0.0, 0.0),
    (0, $31054a6c69637582$exports).fromValues(0.0, 0.0, 0.5),
    (0, $31054a6c69637582$exports).fromValues(0.0, 0.0, -0.5)
];
$c2c30e4dcf8004c5$export$a15f0a83a652dd40.FACE_ROTATIONS = [
    (0, $ba3ca37806a2b6fa$exports).fromValues(1, 0, 0, 0, 0, -1, 0, 1, 0),
    (0, $ba3ca37806a2b6fa$exports).fromValues(0, 0, -1, 0, 1, 0, 1, 0, 0),
    (0, $ba3ca37806a2b6fa$exports).fromValues(1, 0, 0, 0, 0, 1, 0, -1, 0),
    (0, $ba3ca37806a2b6fa$exports).fromValues(0, 0, 1, 0, 1, 0, -1, 0, 0),
    (0, $ba3ca37806a2b6fa$exports).fromValues(1, 0, 0, 0, 1, 0, 0, 0, 1),
    (0, $ba3ca37806a2b6fa$exports).fromValues(1, 0, 0, 0, -1, 0, 0, 0, -1)
];
$c2c30e4dcf8004c5$export$a15f0a83a652dd40.EDGE_POSITIONS = [
    (0, $31054a6c69637582$exports).fromValues(0, 0.5, 0.5),
    (0, $31054a6c69637582$exports).fromValues(0.5, 0.5, 0),
    (0, $31054a6c69637582$exports).fromValues(0, 0.5, -0.5),
    (0, $31054a6c69637582$exports).fromValues(-0.5, 0.5, 0),
    (0, $31054a6c69637582$exports).fromValues(0, -0.5, 0.5),
    (0, $31054a6c69637582$exports).fromValues(0.5, -0.5, 0),
    (0, $31054a6c69637582$exports).fromValues(0, -0.5, -0.5),
    (0, $31054a6c69637582$exports).fromValues(-0.5, -0.5, 0),
    (0, $31054a6c69637582$exports).fromValues(0.5, 0, 0.5),
    (0, $31054a6c69637582$exports).fromValues(0.5, 0, -0.5),
    (0, $31054a6c69637582$exports).fromValues(-0.5, 0, -0.5),
    (0, $31054a6c69637582$exports).fromValues(-0.5, 0, 0.5)
];
$c2c30e4dcf8004c5$export$a15f0a83a652dd40.EDGE_NORMALS = [
    (0, $31054a6c69637582$exports).fromValues(0, (0, $d4d7bd6cc65a5081$export$a002182e51710d39).ROOT_TWO_OVER_TWO, (0, $d4d7bd6cc65a5081$export$a002182e51710d39).ROOT_TWO_OVER_TWO),
    (0, $31054a6c69637582$exports).fromValues((0, $d4d7bd6cc65a5081$export$a002182e51710d39).ROOT_TWO_OVER_TWO, (0, $d4d7bd6cc65a5081$export$a002182e51710d39).ROOT_TWO_OVER_TWO, 0),
    (0, $31054a6c69637582$exports).fromValues(0, (0, $d4d7bd6cc65a5081$export$a002182e51710d39).ROOT_TWO_OVER_TWO, -(0, $d4d7bd6cc65a5081$export$a002182e51710d39).ROOT_TWO_OVER_TWO),
    (0, $31054a6c69637582$exports).fromValues(-(0, $d4d7bd6cc65a5081$export$a002182e51710d39).ROOT_TWO_OVER_TWO, (0, $d4d7bd6cc65a5081$export$a002182e51710d39).ROOT_TWO_OVER_TWO, 0),
    (0, $31054a6c69637582$exports).fromValues(0, -(0, $d4d7bd6cc65a5081$export$a002182e51710d39).ROOT_TWO_OVER_TWO, (0, $d4d7bd6cc65a5081$export$a002182e51710d39).ROOT_TWO_OVER_TWO),
    (0, $31054a6c69637582$exports).fromValues((0, $d4d7bd6cc65a5081$export$a002182e51710d39).ROOT_TWO_OVER_TWO, -(0, $d4d7bd6cc65a5081$export$a002182e51710d39).ROOT_TWO_OVER_TWO, 0),
    (0, $31054a6c69637582$exports).fromValues(0, -(0, $d4d7bd6cc65a5081$export$a002182e51710d39).ROOT_TWO_OVER_TWO, -(0, $d4d7bd6cc65a5081$export$a002182e51710d39).ROOT_TWO_OVER_TWO),
    (0, $31054a6c69637582$exports).fromValues(-(0, $d4d7bd6cc65a5081$export$a002182e51710d39).ROOT_TWO_OVER_TWO, -(0, $d4d7bd6cc65a5081$export$a002182e51710d39).ROOT_TWO_OVER_TWO, 0),
    (0, $31054a6c69637582$exports).fromValues((0, $d4d7bd6cc65a5081$export$a002182e51710d39).ROOT_TWO_OVER_TWO, 0, (0, $d4d7bd6cc65a5081$export$a002182e51710d39).ROOT_TWO_OVER_TWO),
    (0, $31054a6c69637582$exports).fromValues((0, $d4d7bd6cc65a5081$export$a002182e51710d39).ROOT_TWO_OVER_TWO, 0, -(0, $d4d7bd6cc65a5081$export$a002182e51710d39).ROOT_TWO_OVER_TWO),
    (0, $31054a6c69637582$exports).fromValues(-(0, $d4d7bd6cc65a5081$export$a002182e51710d39).ROOT_TWO_OVER_TWO, 0, -(0, $d4d7bd6cc65a5081$export$a002182e51710d39).ROOT_TWO_OVER_TWO),
    (0, $31054a6c69637582$exports).fromValues(-(0, $d4d7bd6cc65a5081$export$a002182e51710d39).ROOT_TWO_OVER_TWO, 0, (0, $d4d7bd6cc65a5081$export$a002182e51710d39).ROOT_TWO_OVER_TWO)
];
$c2c30e4dcf8004c5$export$a15f0a83a652dd40.EDGE_CORNERS = [
    [
        0,
        1
    ],
    [
        1,
        5
    ],
    [
        4,
        5
    ],
    [
        0,
        4
    ],
    [
        2,
        3
    ],
    [
        2,
        6
    ],
    [
        6,
        7
    ],
    [
        3,
        7
    ],
    [
        1,
        2
    ],
    [
        5,
        6
    ],
    [
        4,
        7
    ],
    [
        0,
        3
    ]
];
$c2c30e4dcf8004c5$export$a15f0a83a652dd40.EDGE_FACES = [
    [
        0,
        4
    ],
    [
        0,
        1
    ],
    [
        0,
        5
    ],
    [
        0,
        3
    ],
    [
        2,
        4
    ],
    [
        2,
        1
    ],
    [
        2,
        5
    ],
    [
        2,
        3
    ],
    [
        1,
        4
    ],
    [
        1,
        5
    ],
    [
        3,
        5
    ],
    [
        3,
        4
    ]
];
$c2c30e4dcf8004c5$export$a15f0a83a652dd40.EDGE_AXIS = [
    0,
    2,
    0,
    2,
    0,
    2,
    0,
    2,
    1,
    1,
    1,
    1
];
$c2c30e4dcf8004c5$export$a15f0a83a652dd40.AXIS_EDGES = [
    [
        0,
        2,
        4,
        6
    ],
    [
        8,
        9,
        10,
        11
    ],
    [
        1,
        3,
        5,
        7
    ]
];
$c2c30e4dcf8004c5$export$a15f0a83a652dd40.AXIS_FACES = [
    [
        1,
        3
    ],
    [
        0,
        2
    ],
    [
        4,
        5
    ]
];
$c2c30e4dcf8004c5$export$a15f0a83a652dd40.OPPOSITE_FACES = [
    2,
    3,
    0,
    1,
    5,
    4
];
$c2c30e4dcf8004c5$export$a15f0a83a652dd40.EDGE_POSITIVES = [
    (0, $31054a6c69637582$exports).fromValues(1, 0, 0),
    (0, $31054a6c69637582$exports).fromValues(0, 0, 1),
    (0, $31054a6c69637582$exports).fromValues(1, 0, 0),
    (0, $31054a6c69637582$exports).fromValues(0, 0, 1),
    (0, $31054a6c69637582$exports).fromValues(1, 0, 0),
    (0, $31054a6c69637582$exports).fromValues(0, 0, 1),
    (0, $31054a6c69637582$exports).fromValues(1, 0, 0),
    (0, $31054a6c69637582$exports).fromValues(0, 0, 1),
    (0, $31054a6c69637582$exports).fromValues(0, 1, 0),
    (0, $31054a6c69637582$exports).fromValues(0, 1, 0),
    (0, $31054a6c69637582$exports).fromValues(0, 1, 0),
    (0, $31054a6c69637582$exports).fromValues(0, 1, 0)
];
$c2c30e4dcf8004c5$export$a15f0a83a652dd40.EDGE_FORWARDS = [
    (0, $31054a6c69637582$exports).fromValues(0, (0, $d4d7bd6cc65a5081$export$a002182e51710d39).ROOT_TWO_OVER_TWO, -(0, $d4d7bd6cc65a5081$export$a002182e51710d39).ROOT_TWO_OVER_TWO),
    (0, $31054a6c69637582$exports).fromValues((0, $d4d7bd6cc65a5081$export$a002182e51710d39).ROOT_TWO_OVER_TWO, -(0, $d4d7bd6cc65a5081$export$a002182e51710d39).ROOT_TWO_OVER_TWO, 0),
    (0, $31054a6c69637582$exports).fromValues(0, -(0, $d4d7bd6cc65a5081$export$a002182e51710d39).ROOT_TWO_OVER_TWO, -(0, $d4d7bd6cc65a5081$export$a002182e51710d39).ROOT_TWO_OVER_TWO),
    (0, $31054a6c69637582$exports).fromValues((0, $d4d7bd6cc65a5081$export$a002182e51710d39).ROOT_TWO_OVER_TWO, (0, $d4d7bd6cc65a5081$export$a002182e51710d39).ROOT_TWO_OVER_TWO, 0),
    (0, $31054a6c69637582$exports).fromValues(0, (0, $d4d7bd6cc65a5081$export$a002182e51710d39).ROOT_TWO_OVER_TWO, (0, $d4d7bd6cc65a5081$export$a002182e51710d39).ROOT_TWO_OVER_TWO),
    (0, $31054a6c69637582$exports).fromValues(-(0, $d4d7bd6cc65a5081$export$a002182e51710d39).ROOT_TWO_OVER_TWO, -(0, $d4d7bd6cc65a5081$export$a002182e51710d39).ROOT_TWO_OVER_TWO, 0),
    (0, $31054a6c69637582$exports).fromValues(0, -(0, $d4d7bd6cc65a5081$export$a002182e51710d39).ROOT_TWO_OVER_TWO, (0, $d4d7bd6cc65a5081$export$a002182e51710d39).ROOT_TWO_OVER_TWO),
    (0, $31054a6c69637582$exports).fromValues(-(0, $d4d7bd6cc65a5081$export$a002182e51710d39).ROOT_TWO_OVER_TWO, (0, $d4d7bd6cc65a5081$export$a002182e51710d39).ROOT_TWO_OVER_TWO, 0),
    (0, $31054a6c69637582$exports).fromValues(-(0, $d4d7bd6cc65a5081$export$a002182e51710d39).ROOT_TWO_OVER_TWO, 0, (0, $d4d7bd6cc65a5081$export$a002182e51710d39).ROOT_TWO_OVER_TWO),
    (0, $31054a6c69637582$exports).fromValues((0, $d4d7bd6cc65a5081$export$a002182e51710d39).ROOT_TWO_OVER_TWO, 0, (0, $d4d7bd6cc65a5081$export$a002182e51710d39).ROOT_TWO_OVER_TWO),
    (0, $31054a6c69637582$exports).fromValues((0, $d4d7bd6cc65a5081$export$a002182e51710d39).ROOT_TWO_OVER_TWO, 0, -(0, $d4d7bd6cc65a5081$export$a002182e51710d39).ROOT_TWO_OVER_TWO),
    (0, $31054a6c69637582$exports).fromValues(-(0, $d4d7bd6cc65a5081$export$a002182e51710d39).ROOT_TWO_OVER_TWO, 0, -(0, $d4d7bd6cc65a5081$export$a002182e51710d39).ROOT_TWO_OVER_TWO)
];



class $6c3dd367ac3ca617$export$c6e88a9dc8138322 {
    render(elapsedTime, xrFrame) {}
    update(elapsedTime) {}
    constructor(controller){
        this.controller = controller;
    }
}
class $6c3dd367ac3ca617$export$bd0bf19f25da8474 {
    get isInitialized() {
        return this._isInitialized;
    }
    get mMatrix() {
        return this._mMatrix;
    }
    get indexCount() {
        return this._indexCount;
    }
    get vertices() {
        return this._vertices;
    }
    get indices() {
        return this._indices;
    }
    get texture() {
        return this._texture;
    }
    get rayMMatrix() {
        return this._rayMMatrix;
    }
    get rayIndexCount() {
        return this._rayIndexCount;
    }
    get rayVertices() {
        return this._rayVertices;
    }
    get rayIndices() {
        return this._rayIndices;
    }
    constructor(core, options){
        this._cubeObj = `o Cube
v 1.000000 -1.000000 -1.000000
v 1.000000 -1.000000 1.000000
v -1.000000 -1.000000 1.000000
v -1.000000 -1.000000 -1.000000
v 1.000000 1.000000 -0.999999
v 0.999999 1.000000 1.000001
v -1.000000 1.000000 1.000000
v -1.000000 1.000000 -1.000000
vt 1.000000 0.333333
vt 1.000000 0.666667
vt 0.666667 0.666667
vt 0.666667 0.333333
vt 0.666667 0.000000
vt 0.000000 0.333333
vt 0.000000 0.000000
vt 0.333333 0.000000
vt 0.333333 1.000000
vt 0.000000 1.000000
vt 0.000000 0.666667
vt 0.333333 0.333333
vt 0.333333 0.666667
vt 1.000000 0.000000
vn 0.000000 -1.000000 0.000000
vn 0.000000 1.000000 0.000000
vn 1.000000 0.000000 0.000000
vn -0.000000 0.000000 1.000000
vn -1.000000 -0.000000 -0.000000
vn 0.000000 0.000000 -1.000000
s off
f 2/1/1 3/2/1 4/3/1
f 8/1/2 7/4/2 6/5/2
f 5/6/3 6/7/3 2/8/3
f 6/8/4 7/5/4 3/4/4
f 3/9/5 7/10/5 8/11/5
f 1/12/6 4/13/6 8/11/6
f 1/4/1 2/1/1 4/3/1
f 5/14/2 8/1/2 6/5/2
f 1/12/3 5/6/3 2/8/3
f 2/12/4 6/8/4 3/4/4
f 4/13/5 3/9/5 8/11/5
f 5/6/6 1/12/6 8/11/6`;
        this._core = core;
        this._obj = options.obj;
        this._texture = options.texture || new ImageData(new Uint8ClampedArray([
            0,
            0,
            0,
            255
        ]), 1, 1);
    }
    initialize() {
        const _vec3 = (0, $31054a6c69637582$exports).create();
        this._mMatrix = (0, $1ac1b59392edf35b$exports).create();
        const objMesh = new (0, $636d0ad960a10a23$export$bfc5db82fb7164f0)(this._core).read(this._obj || this._cubeObj);
        if (!this._obj) {
            this.useRayPose = true;
            const modelThickness = 0.02;
            const modelLength = 0.1;
            (0, $31054a6c69637582$exports).set(_vec3, modelThickness, modelThickness, modelLength);
            (0, $1ac1b59392edf35b$exports).fromScaling(this._mMatrix, _vec3);
            (0, $31054a6c69637582$exports).set(_vec3, 0, 0, 1);
            (0, $1ac1b59392edf35b$exports).translate(this._mMatrix, this._mMatrix, _vec3);
        }
        this._vertices = objMesh.vertices;
        this._indices = objMesh.indices;
        this._indexCount = objMesh.indexCount;
        this._rayMMatrix = (0, $1ac1b59392edf35b$exports).create();
        const rayVertices = (0, $c2c30e4dcf8004c5$export$a15f0a83a652dd40).POSITIONS;
        this._rayVertices = new ArrayBuffer((0, $0a0587bd8b0d58e8$export$6597d9a580deb707).SIZE_BYTES * rayVertices.length / (0, $0a0587bd8b0d58e8$export$5b33f080c7f6c861).SIZE);
        const rayVerticesView = new DataView(this._rayVertices);
        const rayIndices = (0, $c2c30e4dcf8004c5$export$a15f0a83a652dd40).INDICES;
        this._rayIndices = new Uint16Array(rayIndices);
        const rayVertexCount = rayVertices.length / (0, $0a0587bd8b0d58e8$export$5b33f080c7f6c861).SIZE;
        this._rayIndexCount = rayIndices.length;
        for(let i = 0; i < rayVertexCount; i++){
            (0, $31054a6c69637582$exports).set(_vec3, rayVertices[i * (0, $0a0587bd8b0d58e8$export$5b33f080c7f6c861).SIZE], rayVertices[i * (0, $0a0587bd8b0d58e8$export$5b33f080c7f6c861).SIZE + 1], rayVertices[i * (0, $0a0587bd8b0d58e8$export$5b33f080c7f6c861).SIZE + 2]);
            (0, $0a0587bd8b0d58e8$export$6597d9a580deb707).setPosition(rayVerticesView, i, _vec3);
            (0, $0a0587bd8b0d58e8$export$6597d9a580deb707).setColor(rayVerticesView, i, this._core.config.xrControllerRayColor);
        }
        const rayThickness = 0.0025;
        const rayLength = 10;
        (0, $31054a6c69637582$exports).set(_vec3, rayThickness, rayThickness, rayLength);
        (0, $1ac1b59392edf35b$exports).fromScaling(this._rayMMatrix, _vec3);
        (0, $31054a6c69637582$exports).set(_vec3, 0, 0, -0.5);
        (0, $1ac1b59392edf35b$exports).translate(this._rayMMatrix, this._rayMMatrix, _vec3);
        this._isInitialized = true;
        this._core.log.write((0, $4a6417d29706362f$export$243e62d78d3b544d).info, "controller initialized");
    }
    update(elapsedTime) {}
}


/*!
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 */ class $b920b5b69884770f$export$34bcf93e378e8ddd {
    static fieldOfViewFromProjectionMatrix(p) {
        return 2 * Math.atan(1 / p[5]);
    }
}


/*!
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 */ 


/*!
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 */ 
class $2e2b6f93796e9c8a$export$e784925068633981 {
    render(elapsedTime, xrFrame) {}
    update(elapsedTime) {}
    constructor(axes){
        this.axes = axes;
    }
}
class $2e2b6f93796e9c8a$export$a0569bcde4468e7f {
    get isInitialized() {
        return this._isInitialized;
    }
    set vMatrix(value) {
        this._vMatrix = value;
    }
    pickGrid(id) {
        const offset = id * 3;
        return {
            divisionX: this._pickGrid[offset] - 1,
            divisionY: this._pickGrid[offset + 1] - 1,
            divisionZ: this._pickGrid[offset + 2] - 1
        };
    }
    pickTitle(id) {
        return {
            axis: this._pickTitle[id]
        };
    }
    pickLabel(id) {
        const offset = id * 2;
        return {
            axis: this._pickLabel[offset],
            label: this._pickLabel[offset + 1]
        };
    }
    pickHeading(id) {
        return {
            axis: this._pickHeading[id]
        };
    }
    getFromValues(index) {
        return this._fromValues[index];
    }
    setFromValues(index, value) {
        if (this._fromValues[index] != value) {
            this._fromValues[index] = value;
            this._hasChanged = true;
        }
    }
    getToValues(index) {
        return this._toValues[index];
    }
    setToValues(index, value) {
        if (this._toValues[index] != value) {
            this._toValues[index] = value;
            this._hasChanged = true;
        }
    }
    get font() {
        return this._font;
    }
    set font(value) {
        if (this._font != value) {
            this._font = value;
            this._hasChanged = true;
        }
    }
    get gridPickDivisionHeight() {
        return this._gridPickDivisionHeight;
    }
    set gridPickDivisionHeight(value) {
        if (this._gridPickDivisionHeight != value) {
            this._gridPickDivisionHeight = value;
            this._hasChanged = true;
        }
    }
    constructor(core){
        this._core = core;
        this._mMatrix = (0, $1ac1b59392edf35b$exports).create();
        this._mvMatrix = (0, $1ac1b59392edf35b$exports).create();
        this._textMetric = {
            maxTop: 0,
            width: 0,
            maxHeight: 0
        };
        this._gridPickDivisionHeight = core.config.axesGridPickDivisionHeight;
        this.textBorderWidth = core.config.textBorderWidth;
        this.gamma = 0;
        this.gridMajorThickness = core.config.axesGridMajorThickness;
        this.gridMinorThickness = core.config.axesGridMinorThickness;
        this.gridZeroThickness = core.config.axesGridZeroThickness;
        this._font = core.font;
        this.isGridPickingEnabled = false;
    }
    update(elapsedTime) {}
}


/*!
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 */ 


class $3ce6ee188e300946$export$7005c9eb6671414d {
    static positions(transform) {
        const positions = new Float32Array(12);
        const position = (0, $31054a6c69637582$exports).create();
        for(let i = 0; i < 4; i++){
            (0, $31054a6c69637582$exports).set(position, this.POSITIONS[i * 3], this.POSITIONS[i * 3 + 1], this.POSITIONS[i * 3 + 2]);
            (0, $31054a6c69637582$exports).transformMat4(position, position, transform);
            positions[i * 3] = position[0];
            positions[i * 3 + 1] = position[1];
            positions[i * 3 + 2] = position[2];
        }
        return positions;
    }
    static textured(transform, texTransform = (0, $d4d7bd6cc65a5081$export$a002182e51710d39).MAT4_IDENTITY) {
        const positions = this.positions(transform);
        const texCoords = this.TEX_COORDS;
        const vertices = new ArrayBuffer((0, $0a0587bd8b0d58e8$export$538532535e0e8594).SIZE_BYTES * positions.length / 3);
        const verticesView = new DataView(vertices);
        const position = (0, $31054a6c69637582$exports).create();
        const texCoord = (0, $91b0cc4981465964$exports).create();
        for(let i = 0; i < positions.length / (0, $0a0587bd8b0d58e8$export$5b33f080c7f6c861).SIZE; i++){
            (0, $31054a6c69637582$exports).set(position, positions[i * (0, $0a0587bd8b0d58e8$export$5b33f080c7f6c861).SIZE], positions[i * (0, $0a0587bd8b0d58e8$export$5b33f080c7f6c861).SIZE + 1], positions[i * (0, $0a0587bd8b0d58e8$export$5b33f080c7f6c861).SIZE + 2]);
            (0, $91b0cc4981465964$exports).set(texCoord, texCoords[i * 2], texCoords[i * 2 + 1]);
            (0, $91b0cc4981465964$exports).transformMat4(texCoord, texCoord, texTransform);
            (0, $0a0587bd8b0d58e8$export$538532535e0e8594).setPosition(verticesView, i, position);
            (0, $0a0587bd8b0d58e8$export$538532535e0e8594).setTexCoord(verticesView, i, texCoord);
        }
        return verticesView;
    }
    static normalTextured(transform, texTransform = (0, $d4d7bd6cc65a5081$export$a002182e51710d39).MAT4_IDENTITY) {
        const positions = this.positions(transform);
        const texCoords = this.TEX_COORDS;
        const vertices = new ArrayBuffer((0, $0a0587bd8b0d58e8$export$e40add16394b9bff).SIZE_BYTES * positions.length / 3);
        const verticesView = new DataView(vertices);
        const position = (0, $31054a6c69637582$exports).create();
        const texCoord = (0, $91b0cc4981465964$exports).create();
        const normal3 = (0, $31054a6c69637582$exports).create();
        const normal4 = (0, $4c4ac78b213a9c07$exports).create();
        for(let i = 0; i < positions.length / (0, $0a0587bd8b0d58e8$export$5b33f080c7f6c861).SIZE; i++){
            (0, $31054a6c69637582$exports).set(position, positions[i * (0, $0a0587bd8b0d58e8$export$5b33f080c7f6c861).SIZE], positions[i * (0, $0a0587bd8b0d58e8$export$5b33f080c7f6c861).SIZE + 1], positions[i * (0, $0a0587bd8b0d58e8$export$5b33f080c7f6c861).SIZE + 2]);
            (0, $91b0cc4981465964$exports).set(texCoord, texCoords[i * 2], texCoords[i * 2 + 1]);
            (0, $91b0cc4981465964$exports).transformMat4(texCoord, texCoord, texTransform);
            (0, $0a0587bd8b0d58e8$export$e40add16394b9bff).setPosition(verticesView, i, position);
            (0, $4c4ac78b213a9c07$exports).set(normal4, 0.0, 0.0, 1.0, 0.0);
            (0, $4c4ac78b213a9c07$exports).transformMat4(normal4, normal4, transform);
            (0, $31054a6c69637582$exports).set(normal3, normal4[0], normal4[1], normal4[2]);
            (0, $31054a6c69637582$exports).normalize(normal3, normal3);
            (0, $0a0587bd8b0d58e8$export$e40add16394b9bff).setNormal(verticesView, i, normal3);
            (0, $0a0587bd8b0d58e8$export$e40add16394b9bff).setTexCoord(verticesView, i, texCoord);
        }
        return verticesView;
    }
}
$3ce6ee188e300946$export$7005c9eb6671414d.FACE_NORMALS = [
    (0, $31054a6c69637582$exports).fromValues(0, 0, 1),
    (0, $31054a6c69637582$exports).fromValues(0, 0, -1)
];
$3ce6ee188e300946$export$7005c9eb6671414d.FACE_ROTATIONS = [
    (0, $ba3ca37806a2b6fa$exports).fromValues(1, 0, 0, 0, 1, 0, 0, 0, 1),
    (0, $ba3ca37806a2b6fa$exports).fromValues(1, 0, 0, 0, -1, 0, 0, 0, -1)
];
$3ce6ee188e300946$export$7005c9eb6671414d.EDGE_POSITIONS = [
    (0, $31054a6c69637582$exports).fromValues(0, 0.5, 0),
    (0, $31054a6c69637582$exports).fromValues(0.5, 0, 0),
    (0, $31054a6c69637582$exports).fromValues(0, -0.5, 0),
    (0, $31054a6c69637582$exports).fromValues(-0.5, 0, 0)
];
$3ce6ee188e300946$export$7005c9eb6671414d.EDGE_NORMALS = [
    (0, $31054a6c69637582$exports).fromValues(0, 1, 0),
    (0, $31054a6c69637582$exports).fromValues(1, 0, 0),
    (0, $31054a6c69637582$exports).fromValues(0, -1, 0),
    (0, $31054a6c69637582$exports).fromValues(-1, 0, 0)
];
$3ce6ee188e300946$export$7005c9eb6671414d.EDGE_POSITIVES = [
    (0, $31054a6c69637582$exports).fromValues(1, 0, 0),
    (0, $31054a6c69637582$exports).fromValues(0, 1, 0),
    (0, $31054a6c69637582$exports).fromValues(1, 0, 0),
    (0, $31054a6c69637582$exports).fromValues(0, 1, 0)
];
$3ce6ee188e300946$export$7005c9eb6671414d.EDGE_FORWARDS = [
    (0, $31054a6c69637582$exports).fromValues(0, 0, -1),
    (0, $31054a6c69637582$exports).fromValues(0, 0, 1),
    (0, $31054a6c69637582$exports).fromValues(0, 0, 1),
    (0, $31054a6c69637582$exports).fromValues(0, 0, -1)
];
$3ce6ee188e300946$export$7005c9eb6671414d.AXIS_EDGES = [
    [
        0,
        2
    ],
    [
        1,
        3
    ]
];
$3ce6ee188e300946$export$7005c9eb6671414d.POSITIONS = new Float32Array([
    -0.5,
    0.5,
    0,
    0.5,
    0.5,
    0,
    -0.5,
    -0.5,
    0,
    0.5,
    -0.5,
    0
]);
$3ce6ee188e300946$export$7005c9eb6671414d.INDICES = new Uint16Array([
    0,
    2,
    1,
    1,
    2,
    3
]);
$3ce6ee188e300946$export$7005c9eb6671414d.TEX_COORDS = new Float32Array([
    0,
    1,
    1,
    1,
    0,
    0,
    1,
    0
]);
class $3ce6ee188e300946$export$ef2184bd89960b14 {
    static positions(cols, rows, transform) {
        const vertices = new Float32Array((cols + 1) * (rows + 1) * (0, $0a0587bd8b0d58e8$export$5b33f080c7f6c861).SIZE);
        const position = (0, $31054a6c69637582$exports).create();
        let index = 0;
        for(let row = 0; row <= rows; row++)for(let col = 0; col <= cols; col++){
            (0, $31054a6c69637582$exports).set(position, col / cols - 0.5, 0.5 - row / rows, 0);
            (0, $31054a6c69637582$exports).transformMat4(position, position, transform);
            (0, $0a0587bd8b0d58e8$export$5b33f080c7f6c861).setPosition(vertices, index++, position);
        }
        return vertices;
    }
    static indices(cols, rows) {
        const indices = new Uint16Array(cols * rows * 6);
        let index = 0;
        for(let row = 0; row < rows; row++)for(let col = 0; col < cols; col++){
            indices[index++] = col + row * (cols + 1);
            indices[index++] = col + (row + 1) * (cols + 1);
            indices[index++] = col + row * (cols + 1) + 1;
            indices[index++] = col + row * (cols + 1) + 1;
            indices[index++] = col + (row + 1) * (cols + 1);
            indices[index++] = col + (row + 1) * (cols + 1) + 1;
        }
        return indices;
    }
    static textured(cols, rows, transform, texTransform = (0, $d4d7bd6cc65a5081$export$a002182e51710d39).MAT4_IDENTITY) {
        const positions = this.positions(cols, rows, transform);
        const texCoords = this._texCoords(cols, rows, texTransform);
        const vertices = new ArrayBuffer((0, $0a0587bd8b0d58e8$export$538532535e0e8594).SIZE_BYTES * positions.length / 3);
        const verticesView = new DataView(vertices);
        const position = (0, $31054a6c69637582$exports).create();
        const texCoord = (0, $91b0cc4981465964$exports).create();
        let index = 0;
        for(let i = 0; i < positions.length / (0, $0a0587bd8b0d58e8$export$5b33f080c7f6c861).SIZE; i++){
            (0, $31054a6c69637582$exports).set(position, positions[i * (0, $0a0587bd8b0d58e8$export$5b33f080c7f6c861).SIZE], positions[i * (0, $0a0587bd8b0d58e8$export$5b33f080c7f6c861).SIZE + 1], positions[i * (0, $0a0587bd8b0d58e8$export$5b33f080c7f6c861).SIZE + 2]);
            (0, $91b0cc4981465964$exports).set(texCoord, texCoords[i * 2], texCoords[i * 2 + 1]);
            (0, $0a0587bd8b0d58e8$export$538532535e0e8594).setPosition(verticesView, index, position);
            (0, $0a0587bd8b0d58e8$export$538532535e0e8594).setTexCoord(verticesView, index++, texCoord);
        }
        return verticesView;
    }
    static normalTextured(cols, rows, transform, texTransform = (0, $d4d7bd6cc65a5081$export$a002182e51710d39).MAT4_IDENTITY) {
        const positions = this.positions(cols, rows, transform);
        const texCoords = this._texCoords(cols, rows, texTransform);
        const vertices = new ArrayBuffer((0, $0a0587bd8b0d58e8$export$e40add16394b9bff).SIZE_BYTES * positions.length / 3);
        const verticesView = new DataView(vertices);
        const position = (0, $31054a6c69637582$exports).create();
        const texCoord = (0, $91b0cc4981465964$exports).create();
        let index = 0;
        for(let i = 0; i < positions.length / (0, $0a0587bd8b0d58e8$export$5b33f080c7f6c861).SIZE; i++){
            (0, $31054a6c69637582$exports).set(position, positions[i * (0, $0a0587bd8b0d58e8$export$5b33f080c7f6c861).SIZE], positions[i * (0, $0a0587bd8b0d58e8$export$5b33f080c7f6c861).SIZE + 1], positions[i * (0, $0a0587bd8b0d58e8$export$5b33f080c7f6c861).SIZE + 2]);
            (0, $91b0cc4981465964$exports).set(texCoord, texCoords[i * 2], texCoords[i * 2 + 1]);
            (0, $0a0587bd8b0d58e8$export$e40add16394b9bff).setPosition(verticesView, index, position);
            (0, $0a0587bd8b0d58e8$export$e40add16394b9bff).setNormal(verticesView, index, (0, $d4d7bd6cc65a5081$export$a002182e51710d39).VECTOR3_UNITZ);
            (0, $0a0587bd8b0d58e8$export$e40add16394b9bff).setTexCoord(verticesView, index++, texCoord);
        }
        return verticesView;
    }
    static _texCoords(cols, rows, transform) {
        const texCoords = new Float32Array((cols + 1) * (rows + 1) * 2);
        const texCoord = (0, $91b0cc4981465964$exports).create();
        let index = 0;
        for(let row = 0; row <= rows; row++)for(let col = 0; col <= cols; col++){
            (0, $91b0cc4981465964$exports).set(texCoord, col / cols, 1 - row / rows);
            (0, $91b0cc4981465964$exports).transformMat4(texCoord, texCoord, transform);
            texCoords[index++] = texCoord[0];
            texCoords[index++] = texCoord[1];
        }
        return texCoords;
    }
}




/*!
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 */ class $92acb7820f38feec$export$46c1eaab6b8d1e23 {
    static continuous(options) {
        const labels = [];
        const positions = [];
        const fromValues = [];
        const toValues = [];
        const label = options.label || ((value)=>{
            return value.toString();
        });
        for(let i = 0; i <= options.divisions; i++){
            positions.push(options.divisions == 0 ? 0.5 : i / options.divisions);
            const value = options.divisions == 0 ? (options.min + options.max) / 2 : options.min + i * (options.max - options.min) / options.divisions;
            labels.push(label(value));
            if (i == 0) fromValues.push(options.min);
            else if (i < options.divisions) {
                toValues.push(value);
                fromValues.push(value);
            }
        }
        toValues.push(options.max);
        return {
            labels: labels,
            positions: positions,
            fromValues: fromValues,
            toValues: toValues
        };
    }
    static discrete(options) {
        const divisions = options.maxDivisions !== undefined ? Math.min(options.divisions, options.maxDivisions) : options.divisions;
        const divisionStep = 1 / options.divisions;
        const labelStep = 1 / divisions;
        const valueStep = (options.max - options.min + 1) / options.divisions;
        let nextDivision, toValue, nextPosition;
        const labels = [];
        const labelPositions = [];
        const tickPositions = [];
        const fromValues = [];
        const toValues = [];
        const label = options.label || ((value)=>{
            return value.toString();
        });
        const fromToLabel = options.fromToLabel || ((fromValue, toValue)=>{
            return `${label(fromValue)}-${label(toValue)}`;
        });
        for(let i = 0; i < divisions; i++){
            const division = Math.round(i * labelStep / divisionStep);
            const tickPosition = division / options.divisions;
            const fromValue = options.min + Math.ceil(division * valueStep);
            if (i == divisions - 1) {
                nextDivision = divisions;
                nextPosition = 1;
                toValue = options.max;
            } else {
                nextDivision = Math.round((i + 1) * labelStep / divisionStep);
                nextPosition = nextDivision / options.divisions;
                toValue = options.min + Math.ceil(nextDivision * valueStep) - 1;
            }
            labelPositions.push((tickPosition + nextPosition) / 2);
            labels.push(fromValue == toValue ? label(fromValue) : fromToLabel(fromValue, toValue));
            fromValues.push(fromValue);
            toValues.push(toValue);
            tickPositions.push(tickPosition);
        }
        tickPositions.push(1);
        return {
            labels: labels,
            labelPositions: labelPositions,
            tickPositions: tickPositions,
            fromValues: fromValues,
            toValues: toValues
        };
    }
}


/*!
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 */ 


class $ee14aeb68f9f83d5$export$f080f423ca93034f {
    static truncate(text, length) {
        return text.length > length ? `${text.substr(0, length - 1)}\u{2026}` : text;
    }
    static measure(font, text, size) {
        size.width = 0;
        let maxDescent = 0;
        for (const char of text){
            let glyph = font.glyphs[char];
            if (!glyph) {
                font.addGlyph(char);
                glyph = font.glyphs[char];
            }
            size.width += glyph.advance;
            size.maxTop = Math.max(glyph.top, size.maxTop);
            maxDescent = Math.max(glyph.height - glyph.top, maxDescent);
        }
        size.maxHeight = size.maxTop + maxDescent;
    }
    static wrap(font, text, maxWidth) {
        const lines = [];
        let width = 0;
        let start = 0;
        let lastBreakingChar = -1;
        let widthAfterLastBreakingChar = 0;
        for(let i = 0; i < text.length; i++){
            let char = text.charAt(i);
            let glyph = font.glyphs[char];
            if (!glyph) {
                font.addGlyph(char);
                glyph = font.glyphs[char];
            }
            width += glyph.advance;
            if (char == " " || char == "-") {
                widthAfterLastBreakingChar = width;
                lastBreakingChar = i;
            }
            if (width > maxWidth) {
                if (lastBreakingChar == -1) {
                    lines.push(text.substring(start, i));
                    start = i;
                    width += glyph.advance;
                } else {
                    lines.push(text.substring(start, lastBreakingChar));
                    start = lastBreakingChar + 1;
                    width -= widthAfterLastBreakingChar;
                    widthAfterLastBreakingChar = 0;
                    lastBreakingChar = -1;
                }
            }
        }
        lines.push(text.substring(start, text.length));
        return lines;
    }
    static addString(font, text, vertices, indices, index, position, scale, offset, rotation, idColor) {
        for (const char of text)this.addGlyph(font, char, vertices, indices, index++, position, scale, offset, rotation, idColor);
    }
    static addGlyph(font, char, vertices, indices, index, position, scale, offset, rotation, idColor) {
        let glyph = font.glyphs[char];
        if (!glyph) {
            font.addGlyph(char);
            glyph = font.glyphs[char];
        }
        const vertexOffset = index * 4;
        const width = glyph.width * scale;
        const height = glyph.height * scale;
        const top = glyph.top * scale;
        const border = font.border * scale;
        const x0 = offset[0] - border;
        const x1 = offset[0] + width + border;
        const y0 = offset[1] + top + border;
        const y1 = offset[1] + top - height - border;
        const z0 = offset[2];
        (0, $31054a6c69637582$exports).set(this._topLeft, x0, y0, z0);
        (0, $31054a6c69637582$exports).set(this._topRight, x1, y0, z0);
        (0, $31054a6c69637582$exports).set(this._bottomLeft, x0, y1, z0);
        (0, $31054a6c69637582$exports).set(this._bottomRight, x1, y1, z0);
        if (rotation) {
            (0, $31054a6c69637582$exports).transformQuat(this._topLeft, this._topLeft, rotation);
            (0, $31054a6c69637582$exports).transformQuat(this._topRight, this._topRight, rotation);
            (0, $31054a6c69637582$exports).transformQuat(this._bottomLeft, this._bottomLeft, rotation);
            (0, $31054a6c69637582$exports).transformQuat(this._bottomRight, this._bottomRight, rotation);
        }
        (0, $31054a6c69637582$exports).add(this._vec3, this._topLeft, position);
        (0, $0a0587bd8b0d58e8$export$74c3c25430a16442).setPosition(vertices, vertexOffset, this._vec3);
        (0, $31054a6c69637582$exports).add(this._vec3, this._topRight, position);
        (0, $0a0587bd8b0d58e8$export$74c3c25430a16442).setPosition(vertices, vertexOffset + 1, this._vec3);
        (0, $31054a6c69637582$exports).add(this._vec3, this._bottomLeft, position);
        (0, $0a0587bd8b0d58e8$export$74c3c25430a16442).setPosition(vertices, vertexOffset + 2, this._vec3);
        (0, $31054a6c69637582$exports).add(this._vec3, this._bottomRight, position);
        (0, $0a0587bd8b0d58e8$export$74c3c25430a16442).setPosition(vertices, vertexOffset + 3, this._vec3);
        (0, $91b0cc4981465964$exports).set(this._vec2, glyph.u0, glyph.v0);
        (0, $0a0587bd8b0d58e8$export$74c3c25430a16442).setTexCoord(vertices, vertexOffset, this._vec2);
        (0, $91b0cc4981465964$exports).set(this._vec2, glyph.u1, glyph.v0);
        (0, $0a0587bd8b0d58e8$export$74c3c25430a16442).setTexCoord(vertices, vertexOffset + 1, this._vec2);
        (0, $91b0cc4981465964$exports).set(this._vec2, glyph.u0, glyph.v1);
        (0, $0a0587bd8b0d58e8$export$74c3c25430a16442).setTexCoord(vertices, vertexOffset + 2, this._vec2);
        (0, $91b0cc4981465964$exports).set(this._vec2, glyph.u1, glyph.v1);
        (0, $0a0587bd8b0d58e8$export$74c3c25430a16442).setTexCoord(vertices, vertexOffset + 3, this._vec2);
        (0, $0a0587bd8b0d58e8$export$74c3c25430a16442).setIdColor(vertices, vertexOffset, idColor);
        (0, $0a0587bd8b0d58e8$export$74c3c25430a16442).setIdColor(vertices, vertexOffset + 1, idColor);
        (0, $0a0587bd8b0d58e8$export$74c3c25430a16442).setIdColor(vertices, vertexOffset + 2, idColor);
        (0, $0a0587bd8b0d58e8$export$74c3c25430a16442).setIdColor(vertices, vertexOffset + 3, idColor);
        offset[0] += glyph.advance * scale;
        const indexTemplate = (0, $3ce6ee188e300946$export$7005c9eb6671414d).INDICES;
        const indexOffset = index * 6;
        for(let i = 0; i < 6; i++)indices[indexOffset + i] = indexTemplate[i] + vertexOffset;
    }
}
$ee14aeb68f9f83d5$export$f080f423ca93034f._vec2 = (0, $91b0cc4981465964$exports).create();
$ee14aeb68f9f83d5$export$f080f423ca93034f._vec3 = (0, $31054a6c69637582$exports).create();
$ee14aeb68f9f83d5$export$f080f423ca93034f._topLeft = (0, $31054a6c69637582$exports).create();
$ee14aeb68f9f83d5$export$f080f423ca93034f._topRight = (0, $31054a6c69637582$exports).create();
$ee14aeb68f9f83d5$export$f080f423ca93034f._bottomLeft = (0, $31054a6c69637582$exports).create();
$ee14aeb68f9f83d5$export$f080f423ca93034f._bottomRight = (0, $31054a6c69637582$exports).create();


/*!
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 */ class $a60d0d861ccf87e8$export$aadd933e49c67c12 {
    static nextPickId() {
        return this._pickId++;
    }
    static encodeNumber(number, type, color) {
        const encoded = number | $a60d0d861ccf87e8$export$aadd933e49c67c12.encodeType(type);
        $a60d0d861ccf87e8$export$aadd933e49c67c12.float32ToVec4(encoded, color);
    }
    static decodeNumber(color) {
        return color[0] + (color[1] << 8) + (color[2] << 16);
    }
    static encodeVec3(vec3, type, color) {
        const encoded = vec3[0] | vec3[1] << 8 | vec3[2] << 16 | $a60d0d861ccf87e8$export$aadd933e49c67c12.encodeType(type);
        $a60d0d861ccf87e8$export$aadd933e49c67c12.float32ToVec4(encoded, color);
    }
    static decodeVec3(color, axes) {
        axes[0] = color[0];
        axes[1] = color[1];
        axes[2] = color[2];
    }
    static encodeType(type) {
        return type << 24;
    }
    static decodeType(color) {
        return color[3];
    }
    static float32ToVec4(number, color) {
        color[0] = ((number & 0xFF) >>> 0) / 0xFF;
        color[1] = ((number & 0xFF00) >>> 8) / 0xFF;
        color[2] = ((number & 0xFF0000) >>> 16) / 0xFF;
        color[3] = ((number & 0xFF000000) >>> 24) / 0xFF;
    }
    static uint8ArrayToNumber(color) {
        return color[0] + (color[1] << 8) + (color[2] << 16) + (color[3] << 24);
    }
}
$a60d0d861ccf87e8$export$aadd933e49c67c12._pickId = 1;


class $4cd1e156df302e7a$export$a623f6a4669f174c {
    static create(core, options) {
        const cartesian3dAxes = new $4cd1e156df302e7a$export$b1b08d445768978(core);
        const minBoundsX = options.minBoundsX === undefined ? 0 : options.minBoundsX;
        const minBoundsY = options.minBoundsY === undefined ? 0 : options.minBoundsY;
        const minBoundsZ = options.minBoundsZ === undefined ? 0 : options.minBoundsZ;
        const maxBoundsX = options.maxBoundsX === undefined ? 1 : options.maxBoundsX;
        const maxBoundsY = options.maxBoundsY === undefined ? 1 : options.maxBoundsY;
        const maxBoundsZ = options.maxBoundsZ === undefined ? 1 : options.maxBoundsZ;
        const minValueX = options.minValueX === undefined ? 0 : options.minValueX;
        const minValueY = options.minValueY === undefined ? 0 : options.minValueY;
        const minValueZ = options.minValueZ === undefined ? 0 : options.minValueZ;
        const maxValueX = options.maxValueX === undefined ? 1 : options.maxValueX;
        const maxValueY = options.maxValueY === undefined ? 1 : options.maxValueY;
        const maxValueZ = options.maxValueZ === undefined ? 1 : options.maxValueZ;
        const scaling = options.scaling === undefined ? 1 : options.scaling;
        cartesian3dAxes.minBoundsX = minBoundsX;
        cartesian3dAxes.minBoundsY = minBoundsY;
        cartesian3dAxes.minBoundsZ = minBoundsZ;
        cartesian3dAxes.maxBoundsX = maxBoundsX;
        cartesian3dAxes.maxBoundsY = maxBoundsY;
        cartesian3dAxes.maxBoundsZ = maxBoundsZ;
        cartesian3dAxes.scalingX = scaling;
        cartesian3dAxes.scalingY = scaling;
        cartesian3dAxes.scalingZ = scaling;
        const maxLength = Math.max(maxBoundsX - minBoundsX, Math.max(maxBoundsY - minBoundsY, maxBoundsZ - minBoundsZ));
        const requestedDivisions = [
            options.divisionsX == undefined ? Math.max(Math.floor(core.config.axesGridDefaultDivisions * (maxBoundsX - minBoundsX) / maxLength), 1) : options.divisionsX,
            options.divisionsY == undefined ? Math.max(Math.floor(core.config.axesGridDefaultDivisions * (maxBoundsY - minBoundsY) / maxLength), 1) : options.divisionsY,
            options.divisionsZ == undefined ? Math.max(Math.floor(core.config.axesGridDefaultDivisions * (maxBoundsZ - minBoundsZ) / maxLength), 1) : options.divisionsZ
        ];
        const minorGridlines = [
            options.minorGridlinesX == undefined ? 2 : options.minorGridlinesX,
            options.minorGridlinesY == undefined ? 2 : options.minorGridlinesY,
            options.minorGridlinesZ == undefined ? 2 : options.minorGridlinesZ
        ];
        const labelMajorSizes = [
            options.labelMajorSizeX === undefined ? core.config.axesTextLabelMajorSize : options.labelMajorSizeX,
            options.labelMajorSizeY === undefined ? core.config.axesTextLabelMajorSize : options.labelMajorSizeY,
            options.labelMajorSizeZ === undefined ? core.config.axesTextLabelMajorSize : options.labelMajorSizeZ
        ];
        const labelMinorSizes = [
            options.labelMinorSizeX === undefined ? core.config.axesTextLabelMinorSize : options.labelMinorSizeX,
            options.labelMinorSizeY === undefined ? core.config.axesTextLabelMinorSize : options.labelMinorSizeY,
            options.labelMinorSizeZ === undefined ? core.config.axesTextLabelMinorSize : options.labelMinorSizeZ
        ];
        cartesian3dAxes.isDiscreteX = options.isDiscreteX;
        cartesian3dAxes.isDiscreteY = options.isDiscreteY;
        cartesian3dAxes.isDiscreteZ = options.isDiscreteZ;
        cartesian3dAxes.isGridPickingEnabled = options.isGridPickingEnabled;
        const isDivisionPickingEnabledArray = [
            options.isDivisionPickingEnabledX,
            options.isDivisionPickingEnabledY,
            options.isDivisionPickingEnabledZ
        ];
        const isLabelPickingEnabledArray = [
            options.isLabelPickingEnabledX,
            options.isLabelPickingEnabledY,
            options.isLabelPickingEnabledZ
        ];
        const isAxisReversed = [
            options.reverseX,
            options.reverseY,
            options.reverseZ
        ];
        const labelsArray = [
            options.labelsX,
            options.labelsY,
            options.labelsZ
        ];
        const labelOrientationsArray = [
            options.labelOrientationX,
            options.labelOrientationY,
            options.labelOrientationZ
        ];
        const labelOrientationDefaultArray = [
            (0, $4a6417d29706362f$export$d2304d1f23cf3ace).parallel,
            (0, $4a6417d29706362f$export$d2304d1f23cf3ace).perpendicular,
            (0, $4a6417d29706362f$export$d2304d1f23cf3ace).parallel
        ];
        const areTicksVisibleArray = [
            options.arePickDivisionsVisibleX,
            options.arePickDivisionsVisibleY,
            options.arePickDivisionsVisibleZ
        ];
        const minValueArray = [
            minValueX,
            minValueY,
            minValueZ
        ];
        const maxValueArray = [
            maxValueX,
            maxValueY,
            maxValueZ
        ];
        const isDiscreteArray = [
            options.isDiscreteX,
            options.isDiscreteY,
            options.isDiscreteZ
        ];
        const titleArray = [
            options.titleX,
            options.titleY,
            options.titleZ
        ];
        const titleSizeArray = [
            options.titleSizeX,
            options.titleSizeY,
            options.titleSizeZ
        ];
        const headingArray = [
            options.headingX,
            options.headingY,
            options.headingZ
        ];
        const headingSizeArray = [
            options.headingSizeX,
            options.headingSizeY,
            options.headingSizeZ
        ];
        for(let axisId = 0; axisId < 3; axisId++){
            const label = labelsArray[axisId];
            const minValue = minValueArray[axisId];
            const maxValue = maxValueArray[axisId];
            const discrete = isDiscreteArray[axisId];
            if (discrete) {
                const divisions = maxValue - minValue + 1;
                const maxDivisions = Math.min(requestedDivisions[axisId], divisions);
                const discreteAxisOptions = {
                    min: minValue,
                    max: maxValue,
                    divisions: divisions,
                    maxDivisions: maxDivisions,
                    label: label
                };
                const discreteAxis = (0, $92acb7820f38feec$export$46c1eaab6b8d1e23).discrete(discreteAxisOptions);
                cartesian3dAxes.setTickPositions(axisId, discreteAxis.tickPositions);
                cartesian3dAxes.setLabelPositions(axisId, discreteAxis.labelPositions);
                cartesian3dAxes.setLabels(axisId, discreteAxis.labels);
                cartesian3dAxes.setFromValues(axisId, discreteAxis.fromValues);
                cartesian3dAxes.setToValues(axisId, discreteAxis.toValues);
                cartesian3dAxes.setLabelSizes(axisId, Array(discreteAxis.labels.length).fill(labelMajorSizes[axisId]));
                cartesian3dAxes.minorGridlines[axisId] = 1;
            } else {
                const divisions = requestedDivisions[axisId];
                const continuousAxisOptions = {
                    min: minValue,
                    max: maxValue,
                    divisions: divisions,
                    label: label
                };
                const continuousAxis = (0, $92acb7820f38feec$export$46c1eaab6b8d1e23).continuous(continuousAxisOptions);
                cartesian3dAxes.setTickPositions(axisId, continuousAxis.positions);
                cartesian3dAxes.setLabelPositions(axisId, continuousAxis.positions);
                cartesian3dAxes.setLabels(axisId, continuousAxis.labels);
                cartesian3dAxes.setFromValues(axisId, continuousAxis.fromValues);
                cartesian3dAxes.setToValues(axisId, continuousAxis.toValues);
                const labelSizes = [];
                for(let i = 0; i < continuousAxis.labels.length; i++)labelSizes.push(i == 0 || i == divisions ? labelMajorSizes[axisId] : labelMinorSizes[axisId]);
                cartesian3dAxes.setLabelSizes(axisId, labelSizes);
                cartesian3dAxes.minorGridlines[axisId] = minorGridlines[axisId];
            }
            cartesian3dAxes.setLabelOrientation(axisId, labelOrientationsArray[axisId] === undefined ? labelOrientationDefaultArray[axisId] : labelOrientationsArray[axisId]);
            cartesian3dAxes.setTitle(axisId, titleArray[axisId]);
            cartesian3dAxes.setTitleSize(axisId, titleSizeArray[axisId] === undefined ? core.config.axesTextTitleSize : titleSizeArray[axisId]);
            cartesian3dAxes.setHeading(axisId, headingArray[axisId]);
            cartesian3dAxes.setHeadingSize(axisId, headingSizeArray[axisId] === undefined ? core.config.axesTextHeadingSize : headingSizeArray[axisId]);
            cartesian3dAxes.arePickDivisionsVisible[axisId] = areTicksVisibleArray[axisId] === undefined ? true : areTicksVisibleArray[axisId];
            cartesian3dAxes.isDivisionPickingEnabled[axisId] = isDivisionPickingEnabledArray[axisId];
            cartesian3dAxes.isLabelPickingEnabled[axisId] = isLabelPickingEnabledArray[axisId];
            cartesian3dAxes.isAxisReversed[axisId] = isAxisReversed[axisId];
            if (minValue <= 0 && maxValue >= 0 && minValue != maxValue) cartesian3dAxes.zero[axisId] = -minValue / (maxValue - minValue);
            else cartesian3dAxes.zero[axisId] = -Number.MAX_VALUE;
        }
        return cartesian3dAxes;
    }
}
class $4cd1e156df302e7a$export$b1b08d445768978 extends (0, $2e2b6f93796e9c8a$export$a0569bcde4468e7f) {
    get size() {
        return this._size;
    }
    get isDiscreteX() {
        return this._isDiscrete[0];
    }
    set isDiscreteX(value) {
        if (value != this._isDiscrete[0]) {
            this._isDiscrete[0] = value;
            this._hasChanged = true;
        }
    }
    get isDiscreteY() {
        return this._isDiscrete[1];
    }
    set isDiscreteY(value) {
        if (value != this._isDiscrete[1]) {
            this._isDiscrete[1] = value;
            this._hasChanged = true;
        }
    }
    get isDiscreteZ() {
        return this._isDiscrete[2];
    }
    set isDiscreteZ(value) {
        if (value != this._isDiscrete[2]) {
            this._isDiscrete[2] = value;
            this._hasChanged = true;
        }
    }
    get minBoundsX() {
        return this._minBoundsX;
    }
    set minBoundsX(value) {
        if (value != this._minBoundsX) {
            this._minBoundsX = value;
            this._hasChanged = true;
        }
    }
    get maxBoundsX() {
        return this._maxBoundsX;
    }
    set maxBoundsX(value) {
        if (value != this._minBoundsX) {
            this._maxBoundsX = value;
            this._hasChanged = true;
        }
    }
    get minBoundsY() {
        return this._minBoundsY;
    }
    set minBoundsY(value) {
        if (value != this._minBoundsY) {
            this._minBoundsY = value;
            this._hasChanged = true;
        }
    }
    get maxBoundsY() {
        return this._maxBoundsY;
    }
    set maxBoundsY(value) {
        if (value != this._minBoundsY) {
            this._maxBoundsY = value;
            this._hasChanged = true;
        }
    }
    get minBoundsZ() {
        return this._minBoundsZ;
    }
    set minBoundsZ(value) {
        if (value != this._minBoundsZ) {
            this._minBoundsZ = value;
            this._hasChanged = true;
        }
    }
    get maxBoundsZ() {
        return this._maxBoundsZ;
    }
    set maxBoundsZ(value) {
        if (value != this._minBoundsZ) {
            this._maxBoundsZ = value;
            this._hasChanged = true;
        }
    }
    getIsOutsideEdge(index) {
        return this._isOutsideEdge[index];
    }
    getIsForwardFace(index) {
        return this._isForwardFace[index];
    }
    get textVertices() {
        return this._textVertices;
    }
    get textIndices() {
        return this._textIndices;
    }
    getLabelMMatrix(index) {
        return this._labelMMatrices[index];
    }
    setLabelPositions(index, value) {
        if (this._labelPositions[index] != value) {
            this._labelPositions[index] = value;
            this._hasChanged = true;
        }
    }
    setLabels(index, value) {
        if (this._labels[index] != value) {
            this._labels[index] = value;
            this._hasChanged = true;
        }
    }
    setLabelSizes(index, value) {
        if (this._labelSizes[index] != value) {
            this._labelSizes[index] = value;
            this._hasChanged = true;
        }
    }
    getLabelOrientation(index) {
        return this._orientations[index];
    }
    setLabelOrientation(index, orientation) {
        if (this._orientations[index] != orientation) {
            this._orientations[index] = orientation;
            this._hasChanged = true;
        }
    }
    getTitleIndexCount(index) {
        return this._titleIndexCounts[index];
    }
    getTitleIndexOffset(index) {
        return this._titleIndexOffsets[index];
    }
    getTitleMMatrix(index) {
        return this._titleMMatrices[index];
    }
    setTitle(index, value) {
        if (this._titles[index] != value) {
            this._titles[index] = value;
            this._hasChanged = true;
        }
    }
    setTitleSize(index, value) {
        if (this._titleSizes[index] != value) {
            this._titleSizes[index] = value;
            this._hasChanged = true;
        }
    }
    getHeadingIndexCount(index) {
        return this._headingIndexCounts[index];
    }
    getHeadingIndexOffset(index) {
        return this._headingIndexOffsets[index];
    }
    getHeadingMMatrix(index) {
        return this._headingMMatrices[index];
    }
    setHeading(index, value) {
        if (this._headings[index] != value) {
            this._headings[index] = value;
            this._hasChanged = true;
        }
    }
    setHeadingSize(index, value) {
        if (this._headingSizes[index] != value) {
            this._headingSizes[index] = value;
            this._hasChanged = true;
        }
    }
    getIsLeftToRightHorizontal(index) {
        return this._isLeftToRightHorizontal[index];
    }
    getIsLeftToRightVertical(index) {
        return this._isLeftToRightVertical[index];
    }
    getAxesLeftToRightIndexCount(index) {
        return this._axesLeftToRightIndexCounts[index];
    }
    getAxesRightToLeftIndexCount(index) {
        return this._axesRightToLeftIndexCounts[index];
    }
    getAxesLeftToRightIndexOffset(index) {
        return this._axesLeftToRightIndexOffsets[index];
    }
    getAxesRightToLeftIndexOffset(index) {
        return this._axesRightToLeftIndexOffsets[index];
    }
    get gridVertices() {
        return this._gridVertices;
    }
    get gridIndices() {
        return this._gridIndices;
    }
    getGridTicksIndexCount(index) {
        return this._gridTicksIndexCounts[index];
    }
    getGridTicksIndexOffset(index) {
        return this._gridTicksIndexOffsets[index];
    }
    getGridFaceIndexCount(index) {
        return this._gridFaceIndexCounts[index];
    }
    getGridFaceIndexOffset(index) {
        return this._gridFaceIndexOffsets[index];
    }
    getGridTicksMMatrix(index) {
        return this._gridTicksMMatrices[index];
    }
    getGridFaceMMatrix(index) {
        return this._gridFaceMMatrices[index];
    }
    getGridTicksScale(index) {
        return this._gridTicksScales[index];
    }
    getGridFaceZero(index) {
        return this._gridFaceZeros[index];
    }
    getGridTicksZero(index) {
        return this._gridTicksZeros[index];
    }
    getGridFaceMinorGridlines(index) {
        return this._gridFaceMinorGridlines[index];
    }
    getGridTicksMinorGridlines(index) {
        return this._gridTicksMinorGridlines[index];
    }
    setTickPositions(index, value) {
        if (this._gridTicksPositions[index] != value) {
            this._gridTicksPositions[index] = value;
            this._hasChanged = true;
        }
    }
    get scalingX() {
        return this._scalingX;
    }
    set scalingX(value) {
        if (value != this._scalingX) {
            this._scalingX = value;
            this._hasChanged = true;
        }
    }
    get scalingY() {
        return this._scalingY;
    }
    set scalingY(value) {
        if (value != this._scalingY) {
            this._scalingY = value;
            this._hasChanged = true;
        }
    }
    get scalingZ() {
        return this._scalingZ;
    }
    set scalingZ(value) {
        if (value != this._scalingZ) {
            this._scalingZ = value;
            this._hasChanged = true;
        }
    }
    get offsetX() {
        return this._offset[12];
    }
    set offsetX(value) {
        if (value != this._offset[12]) this._offset[12] = value;
    }
    get offsetY() {
        return this._offset[13];
    }
    set offsetY(value) {
        if (value != this._offset[13]) this._offset[13] = value;
    }
    get offsetZ() {
        return this._offset[14];
    }
    set offsetZ(value) {
        if (value != this._offset[14]) this._offset[14] = value;
    }
    constructor(core){
        super(core);
        this._size = (0, $31054a6c69637582$exports).create();
        this._translation = (0, $31054a6c69637582$exports).create();
        this._normal = (0, $31054a6c69637582$exports).create();
        this._forward = (0, $31054a6c69637582$exports).create();
        this._right = (0, $31054a6c69637582$exports).create();
        this._up = (0, $31054a6c69637582$exports).create();
        this._texCoord = (0, $91b0cc4981465964$exports).create();
        this._bounds = (0, $4c4ac78b213a9c07$exports).create();
        this._vec3 = (0, $31054a6c69637582$exports).create();
        this._vec4 = (0, $4c4ac78b213a9c07$exports).create();
        this._mat3 = (0, $ba3ca37806a2b6fa$exports).create();
        this._isDiscrete = [
            false,
            false,
            false
        ];
        this._minBoundsX = 0;
        this._minBoundsY = 0;
        this._minBoundsZ = 0;
        this._maxBoundsX = 0;
        this._maxBoundsY = 0;
        this._maxBoundsZ = 0;
        this._isForwardFace = [];
        this._isForwardEdge = [];
        this._isOutsideEdge = [];
        for(let i = 0; i < 6; i++)this._isForwardFace.push(false);
        for(let i = 0; i < 12; i++){
            this._isForwardEdge.push(false);
            this._isOutsideEdge.push(false);
        }
        this._textOffset = (0, $31054a6c69637582$exports).create();
        this._textPosition = (0, $31054a6c69637582$exports).create();
        this._distances = [];
        for(let i = 0; i < 12; i++)this._distances.push(0);
        this._labelPositions = [];
        this._labels = [];
        this._labelSizes = [];
        this._maxLabelSize = [];
        this._axesLeftToRightIndexCounts = [];
        this._axesRightToLeftIndexCounts = [];
        this._axesLeftToRightIndexOffsets = [];
        this._axesRightToLeftIndexOffsets = [];
        this._labelMMatrices = [];
        this._orientations = [];
        for(let i = 0; i < 3; i++){
            this._maxLabelSize.push((0, $91b0cc4981465964$exports).create());
            this._orientations.push((0, $4a6417d29706362f$export$d2304d1f23cf3ace).parallel);
            this._axesLeftToRightIndexCounts.push(0);
            this._axesRightToLeftIndexCounts.push(0);
            this._axesLeftToRightIndexOffsets.push(0);
            this._axesRightToLeftIndexOffsets.push(0);
        }
        for(let i = 0; i < 12; i++)this._labelMMatrices.push((0, $1ac1b59392edf35b$exports).create());
        this._titles = [];
        this._titleSizes = [];
        this._titleIndexCounts = [];
        this._titleIndexOffsets = [];
        this._titleMMatrices = [];
        for(let i = 0; i < 3; i++){
            this._titles.push(null);
            this._titleSizes.push(core.config.axesTextTitleSize);
            this._titleIndexCounts.push(0);
            this._titleIndexOffsets.push(0);
        }
        for(let i = 0; i < 12; i++)this._titleMMatrices.push((0, $1ac1b59392edf35b$exports).create());
        this._headings = [];
        this._headingSizes = [];
        this._headingIndexCounts = [];
        this._headingIndexOffsets = [];
        this._headingMMatrices = [];
        this.isHeadingVisible = [];
        for(let i = 0; i < 3; i++){
            this._headings.push(null);
            this._headingSizes.push(core.config.axesTextHeadingSize);
            this._headingIndexCounts.push(0);
            this._headingIndexOffsets.push(0);
        }
        for(let i = 0; i < 12; i++){
            this._headingMMatrices.push((0, $1ac1b59392edf35b$exports).create());
            this.isHeadingVisible.push(true);
        }
        this.isEdgeVisible = [];
        this._edgePosition = (0, $31054a6c69637582$exports).create();
        this._edgePositive = (0, $31054a6c69637582$exports).create();
        this._edgeNormal = (0, $31054a6c69637582$exports).create();
        this._edgeNormalTemp = (0, $31054a6c69637582$exports).create();
        this._edgePositiveTemp = (0, $31054a6c69637582$exports).create();
        this._isLeftToRightHorizontal = [];
        this._isLeftToRightVertical = [];
        this._edgeHorizontalRight = [];
        this._edgeHorizontalUp = [];
        this._edgeHorizontalForward = [];
        this._edgeVerticalRight = [];
        this._edgeVerticalUp = [];
        this._edgeVerticalForward = [];
        for(let i = 0; i < 12; i++){
            this.isEdgeVisible.push(true);
            this._isLeftToRightHorizontal.push(false);
            this._isLeftToRightVertical.push(false);
            this._edgeHorizontalRight.push((0, $31054a6c69637582$exports).create());
            this._edgeHorizontalUp.push((0, $31054a6c69637582$exports).create());
            this._edgeHorizontalForward.push((0, $31054a6c69637582$exports).create());
            this._edgeVerticalRight.push((0, $31054a6c69637582$exports).create());
            this._edgeVerticalUp.push((0, $31054a6c69637582$exports).create());
            this._edgeVerticalForward.push((0, $31054a6c69637582$exports).create());
        }
        this.isFaceVisible = [];
        for(let i = 0; i < 6; i++)this.isFaceVisible.push(true);
        this.arePickDivisionsVisible = [];
        this.areFacesVisible = [];
        this._indexTemplate = (0, $3ce6ee188e300946$export$7005c9eb6671414d).INDICES;
        this.zero = (0, $31054a6c69637582$exports).create();
        this._gridTicksZeros = [];
        this._gridFaceZeros = [];
        this.minorGridlines = (0, $31054a6c69637582$exports).fromValues(1, 1, 1);
        this._gridTicksMinorGridlines = [];
        this._gridFaceMinorGridlines = [];
        this._gridTicksPositions = [];
        this._gridTicksScales = [];
        this._gridTicksIndexCounts = [];
        this._gridTicksIndexOffsets = [];
        this._gridFaceScale = (0, $31054a6c69637582$exports).create();
        this._gridFaceIndexCounts = [];
        this._gridFaceIndexOffsets = [];
        this._gridFaceMMatrices = [];
        this._gridTicksMMatrices = [];
        this._gridTicksRotations = [];
        for(let i = 0; i < 3; i++){
            this.arePickDivisionsVisible.push(true);
            this.areFacesVisible.push(true);
            this._gridTicksZeros.push((0, $91b0cc4981465964$exports).create());
            this._gridFaceZeros.push((0, $91b0cc4981465964$exports).create());
            this._gridTicksMinorGridlines.push((0, $91b0cc4981465964$exports).create());
            this._gridFaceMinorGridlines.push((0, $91b0cc4981465964$exports).create());
            this._gridTicksScales.push((0, $31054a6c69637582$exports).create());
            this._gridTicksIndexCounts.push(0);
            this._gridTicksIndexOffsets.push(0);
        }
        for(let i = 0; i < 6; i++){
            this._gridFaceIndexCounts.push(0);
            this._gridFaceIndexOffsets.push(0);
            this._gridFaceMMatrices.push((0, $1ac1b59392edf35b$exports).create());
        }
        for(let i = 0; i < 12; i++){
            this._gridTicksMMatrices.push((0, $1ac1b59392edf35b$exports).create());
            this._gridTicksRotations.push((0, $1ac1b59392edf35b$exports).create());
            const _mat4 = this._gridTicksRotations[i];
            _mat4[0] = (0, $c2c30e4dcf8004c5$export$a15f0a83a652dd40).EDGE_POSITIVES[i][0];
            _mat4[1] = (0, $c2c30e4dcf8004c5$export$a15f0a83a652dd40).EDGE_POSITIVES[i][1];
            _mat4[2] = (0, $c2c30e4dcf8004c5$export$a15f0a83a652dd40).EDGE_POSITIVES[i][2];
            _mat4[4] = (0, $c2c30e4dcf8004c5$export$a15f0a83a652dd40).EDGE_NORMALS[i][0];
            _mat4[5] = (0, $c2c30e4dcf8004c5$export$a15f0a83a652dd40).EDGE_NORMALS[i][1];
            _mat4[6] = (0, $c2c30e4dcf8004c5$export$a15f0a83a652dd40).EDGE_NORMALS[i][2];
            (0, $31054a6c69637582$exports).cross(this._vec3, (0, $c2c30e4dcf8004c5$export$a15f0a83a652dd40).EDGE_POSITIVES[i], (0, $c2c30e4dcf8004c5$export$a15f0a83a652dd40).EDGE_NORMALS[i]);
            _mat4[8] = this._vec3[0];
            _mat4[9] = this._vec3[1];
            _mat4[10] = this._vec3[2];
        }
        this._fromValues = [
            null,
            null,
            null
        ];
        this._toValues = [
            null,
            null,
            null
        ];
        this.isDivisionPickingEnabled = [
            false,
            false,
            false
        ];
        this.isLabelPickingEnabled = [
            false,
            false,
            false
        ];
        this.isTitlePickingEnabled = [
            false,
            false,
            false
        ];
        this.isHeadingPickingEnabled = [
            false,
            false,
            false
        ];
        this.isAxisReversed = [
            false,
            false,
            false
        ];
        this._scalingX = 1;
        this._scalingY = 1;
        this._scalingZ = 1;
        this._offset = (0, $1ac1b59392edf35b$exports).create();
    }
    initialize() {
        this._isInitialized = true;
    }
    update(elapsedTime) {
        if (this.isInitialized) {
            if (this._hasChanged) {
                const start = window.performance.now();
                this._hasChanged = false;
                (0, $31054a6c69637582$exports).set(this._size, this._maxBoundsX - this._minBoundsX, this._maxBoundsY - this._minBoundsY, this._maxBoundsZ - this._minBoundsZ);
                const maxBounds = Math.max(this._size[0], Math.max(this._size[1], this._size[2]));
                this._size[0] *= this._scalingX / maxBounds;
                this._size[1] *= this._scalingY / maxBounds;
                this._size[2] *= this._scalingZ / maxBounds;
                this._updateGrids(this._size);
                this._updateText(this._size);
                if (this.hasChangedCallback) this.hasChangedCallback();
                this._core.log.write((0, $4a6417d29706362f$export$243e62d78d3b544d).info, `cartesian3d updated ${Math.round(window.performance.now() - start)}ms`);
            }
            (0, $1ac1b59392edf35b$exports).multiply(this._mMatrix, this.mMatrix, this._offset);
            this._mvMatrix = (0, $1ac1b59392edf35b$exports).create();
            (0, $1ac1b59392edf35b$exports).multiply(this._mvMatrix, this._vMatrix, this._mMatrix);
            (0, $ba3ca37806a2b6fa$exports).fromMat4(this._mat3, this._mvMatrix);
            for(let faceId = 0; faceId < 6; faceId++){
                (0, $31054a6c69637582$exports).multiply(this._vec3, (0, $c2c30e4dcf8004c5$export$a15f0a83a652dd40).FACE_POSITIONS[faceId], this._size);
                (0, $31054a6c69637582$exports).transformMat4(this._forward, this._vec3, this._mvMatrix);
                (0, $31054a6c69637582$exports).transformMat3(this._normal, (0, $c2c30e4dcf8004c5$export$a15f0a83a652dd40).FACE_NORMALS[faceId], this._mat3);
                this._isForwardFace[faceId] = (0, $31054a6c69637582$exports).dot(this._normal, this._forward) > 0;
            }
            this._forward[0] = this._mat3[2];
            this._forward[1] = this._mat3[5];
            this._forward[2] = this._mat3[8];
            for(let edgeId = 0; edgeId < 12; edgeId++){
                const faceIds = (0, $c2c30e4dcf8004c5$export$a15f0a83a652dd40).EDGE_FACES[edgeId];
                const forward1 = this._isForwardFace[faceIds[0]];
                const forward2 = this._isForwardFace[faceIds[1]];
                const outsideEdge = forward1 != forward2;
                this._isOutsideEdge[edgeId] = outsideEdge;
                if (outsideEdge) this._isForwardEdge[edgeId] = (0, $31054a6c69637582$exports).dot((0, $c2c30e4dcf8004c5$export$a15f0a83a652dd40).EDGE_FORWARDS[edgeId], this._forward) < 0;
                this._distances[edgeId] = 0;
            }
            for(let axisId = 0; axisId < 3; axisId++)if (this.arePickDivisionsVisible[axisId]) {
                (0, $91b0cc4981465964$exports).set(this._gridTicksZeros[axisId], this.zero[axisId], -1);
                (0, $91b0cc4981465964$exports).set(this._gridTicksMinorGridlines[axisId], this.minorGridlines[axisId], 1);
                const gridTicksScale = this._gridTicksScales[axisId];
                for(let edge = 0; edge < 4; edge++){
                    const edgeId = (0, $c2c30e4dcf8004c5$export$a15f0a83a652dd40).AXIS_EDGES[axisId][edge];
                    if (this._isOutsideEdge[edgeId] && this.isEdgeVisible[edgeId]) {
                        let distance = this._distances[edgeId];
                        distance += this._gridPickDivisionHeight * 0.5;
                        const gridTicksMMatrix = this._gridTicksMMatrices[edgeId];
                        (0, $31054a6c69637582$exports).multiply(this._vec3, (0, $c2c30e4dcf8004c5$export$a15f0a83a652dd40).EDGE_POSITIONS[edgeId], this._size);
                        (0, $31054a6c69637582$exports).scaleAndAdd(this._vec3, this._vec3, (0, $c2c30e4dcf8004c5$export$a15f0a83a652dd40).EDGE_NORMALS[edgeId], distance);
                        (0, $1ac1b59392edf35b$exports).translate(gridTicksMMatrix, this._mMatrix, this._vec3);
                        (0, $1ac1b59392edf35b$exports).multiply(gridTicksMMatrix, gridTicksMMatrix, this._gridTicksRotations[edgeId]);
                        if (!this._isForwardEdge[edgeId]) (0, $1ac1b59392edf35b$exports).scale(gridTicksMMatrix, gridTicksMMatrix, (0, $d4d7bd6cc65a5081$export$a002182e51710d39).VECTOR3_REFLECTX);
                        (0, $1ac1b59392edf35b$exports).scale(gridTicksMMatrix, gridTicksMMatrix, gridTicksScale);
                        distance += this._gridPickDivisionHeight * 0.5;
                        this._distances[edgeId] = distance;
                    }
                }
            }
            for(let axisId = 0; axisId < 3; axisId++)if (this.areFacesVisible[axisId]) {
                const axisId2 = axisId == 0 ? 1 : 0;
                const axisId3 = axisId == 2 ? 1 : 2;
                (0, $91b0cc4981465964$exports).set(this._gridFaceZeros[axisId], this.zero[axisId2], this.zero[axisId3]);
                (0, $91b0cc4981465964$exports).set(this._gridFaceMinorGridlines[axisId], this.minorGridlines[axisId2], this.minorGridlines[axisId3]);
                for(let face = 0; face < 2; face++){
                    const faceId = (0, $c2c30e4dcf8004c5$export$a15f0a83a652dd40).AXIS_FACES[axisId][face];
                    if (this._isForwardFace[faceId]) {
                        const gridFaceMMatrix = this._gridFaceMMatrices[faceId];
                        (0, $1ac1b59392edf35b$exports).scale(gridFaceMMatrix, this._mMatrix, this._gridFaceScale);
                        if (this._size[axisId] > 0) (0, $1ac1b59392edf35b$exports).translate(gridFaceMMatrix, gridFaceMMatrix, (0, $c2c30e4dcf8004c5$export$a15f0a83a652dd40).FACE_POSITIONS[faceId]);
                    }
                }
            }
            for(let axisId = 0; axisId < 3; axisId++)for(let edge = 0; edge < 4; edge++){
                const edgeId = (0, $c2c30e4dcf8004c5$export$a15f0a83a652dd40).AXIS_EDGES[axisId][edge];
                if (this._isOutsideEdge[edgeId]) {
                    (0, $31054a6c69637582$exports).multiply(this._edgePosition, (0, $c2c30e4dcf8004c5$export$a15f0a83a652dd40).EDGE_POSITIONS[edgeId], this._size);
                    (0, $31054a6c69637582$exports).transformMat4(this._edgePosition, this._edgePosition, this._mvMatrix);
                    (0, $31054a6c69637582$exports).normalize(this._forward, this._edgePosition);
                    (0, $31054a6c69637582$exports).negate(this._forward, this._forward);
                    (0, $31054a6c69637582$exports).cross(this._right, (0, $d4d7bd6cc65a5081$export$a002182e51710d39).VECTOR3_UNITY, this._forward);
                    (0, $31054a6c69637582$exports).normalize(this._right, this._right);
                    (0, $31054a6c69637582$exports).cross(this._up, this._forward, this._right);
                    (0, $31054a6c69637582$exports).transformMat3(this._edgeNormal, (0, $c2c30e4dcf8004c5$export$a15f0a83a652dd40).EDGE_NORMALS[edgeId], this._mat3);
                    (0, $31054a6c69637582$exports).transformMat3(this._edgePositive, (0, $c2c30e4dcf8004c5$export$a15f0a83a652dd40).EDGE_POSITIVES[edgeId], this._mat3);
                    (0, $31054a6c69637582$exports).copy(this._edgeNormalTemp, this._edgeNormal);
                    (0, $31054a6c69637582$exports).copy(this._edgePositiveTemp, this._edgePositive);
                    const edgeHorizontalRight = this._edgeHorizontalRight[edgeId];
                    const edgeHorizontalUp = this._edgeHorizontalUp[edgeId];
                    const edgeHorizontalForward = this._edgeHorizontalForward[edgeId];
                    if ((0, $31054a6c69637582$exports).dot(this._edgeNormalTemp, this._up) > 0) (0, $31054a6c69637582$exports).copy(edgeHorizontalUp, (0, $c2c30e4dcf8004c5$export$a15f0a83a652dd40).EDGE_NORMALS[edgeId]);
                    else {
                        (0, $31054a6c69637582$exports).negate(edgeHorizontalUp, (0, $c2c30e4dcf8004c5$export$a15f0a83a652dd40).EDGE_NORMALS[edgeId]);
                        (0, $31054a6c69637582$exports).negate(this._edgeNormalTemp, this._edgeNormalTemp);
                    }
                    if ((0, $31054a6c69637582$exports).dot(this._edgePositiveTemp, this._right) > 0) {
                        this._isLeftToRightHorizontal[edgeId] = true;
                        (0, $31054a6c69637582$exports).copy(edgeHorizontalRight, (0, $c2c30e4dcf8004c5$export$a15f0a83a652dd40).EDGE_POSITIVES[edgeId]);
                    } else {
                        this._isLeftToRightHorizontal[edgeId] = false;
                        (0, $31054a6c69637582$exports).negate(edgeHorizontalRight, (0, $c2c30e4dcf8004c5$export$a15f0a83a652dd40).EDGE_POSITIVES[edgeId]);
                        (0, $31054a6c69637582$exports).negate(this._edgePositiveTemp, this._edgePositiveTemp);
                    }
                    (0, $31054a6c69637582$exports).cross(edgeHorizontalForward, this._edgePositiveTemp, this._edgeNormalTemp);
                    if ((0, $31054a6c69637582$exports).dot(edgeHorizontalForward, this._forward) < 0) {
                        this._isLeftToRightHorizontal[edgeId] = !this._isLeftToRightHorizontal[edgeId];
                        (0, $31054a6c69637582$exports).negate(edgeHorizontalRight, edgeHorizontalRight);
                    }
                    (0, $31054a6c69637582$exports).cross(edgeHorizontalForward, edgeHorizontalRight, edgeHorizontalUp);
                    const edgeVerticalRight = this._edgeVerticalRight[edgeId];
                    const edgeVerticalUp = this._edgeVerticalUp[edgeId];
                    const edgeVerticalForward = this._edgeVerticalForward[edgeId];
                    if ((0, $31054a6c69637582$exports).dot(this._edgeNormal, this._right) < 0) (0, $31054a6c69637582$exports).copy(edgeVerticalUp, (0, $c2c30e4dcf8004c5$export$a15f0a83a652dd40).EDGE_NORMALS[edgeId]);
                    else {
                        (0, $31054a6c69637582$exports).negate(edgeVerticalUp, (0, $c2c30e4dcf8004c5$export$a15f0a83a652dd40).EDGE_NORMALS[edgeId]);
                        (0, $31054a6c69637582$exports).negate(this._edgeNormal, this._edgeNormal);
                    }
                    if ((0, $31054a6c69637582$exports).dot(this._edgePositive, this._up) < 0) {
                        this._isLeftToRightVertical[edgeId] = true;
                        (0, $31054a6c69637582$exports).copy(edgeVerticalRight, (0, $c2c30e4dcf8004c5$export$a15f0a83a652dd40).EDGE_POSITIVES[edgeId]);
                    } else {
                        this._isLeftToRightVertical[edgeId] = false;
                        (0, $31054a6c69637582$exports).negate(edgeVerticalRight, (0, $c2c30e4dcf8004c5$export$a15f0a83a652dd40).EDGE_POSITIVES[edgeId]);
                        (0, $31054a6c69637582$exports).negate(this._edgePositive, this._edgePositive);
                    }
                    (0, $31054a6c69637582$exports).cross(edgeVerticalForward, this._edgePositive, this._edgeNormal);
                    if ((0, $31054a6c69637582$exports).dot(edgeVerticalForward, this._forward) < 0) {
                        this._isLeftToRightVertical[edgeId] = !this._isLeftToRightVertical[edgeId];
                        (0, $31054a6c69637582$exports).negate(edgeVerticalRight, edgeVerticalRight);
                    }
                    (0, $31054a6c69637582$exports).cross(edgeVerticalForward, edgeVerticalRight, edgeVerticalUp);
                    if (this.isEdgeVisible[edgeId]) {
                        if (this._labels[axisId]) this._updateLabels(axisId, edgeId);
                        if (this._titles[axisId]) this._updateTitle(axisId, edgeId);
                    }
                    if (this.isHeadingVisible[edgeId]) this._updateHeading(axisId, edgeId);
                }
            }
        }
    }
    _updateLabels(axisId, edgeId) {
        const orientation = this._orientations[axisId];
        let distance = this._distances[edgeId];
        let maxLabelSize = this._maxLabelSize[axisId][1];
        if (orientation == (0, $4a6417d29706362f$export$d2304d1f23cf3ace).parallel) maxLabelSize *= this._core.config.axesTextLabelLineHeight;
        distance += maxLabelSize * 0.5;
        (0, $31054a6c69637582$exports).multiply(this._vec3, (0, $c2c30e4dcf8004c5$export$a15f0a83a652dd40).EDGE_POSITIONS[edgeId], this._size);
        (0, $31054a6c69637582$exports).scaleAndAdd(this._vec3, this._vec3, (0, $c2c30e4dcf8004c5$export$a15f0a83a652dd40).EDGE_NORMALS[edgeId], distance);
        const labelMMatrix = this._labelMMatrices[edgeId];
        labelMMatrix[12] = this._vec3[0];
        labelMMatrix[13] = this._vec3[1];
        labelMMatrix[14] = this._vec3[2];
        if (orientation == (0, $4a6417d29706362f$export$d2304d1f23cf3ace).parallel) {
            const right = this._edgeHorizontalRight[edgeId];
            const up = this._edgeHorizontalUp[edgeId];
            const forward = this._edgeHorizontalForward[edgeId];
            labelMMatrix[0] = right[0];
            labelMMatrix[1] = right[1];
            labelMMatrix[2] = right[2];
            labelMMatrix[4] = up[0];
            labelMMatrix[5] = up[1];
            labelMMatrix[6] = up[2];
            labelMMatrix[8] = forward[0];
            labelMMatrix[9] = forward[1];
            labelMMatrix[10] = forward[2];
        } else {
            const right = this._edgeVerticalRight[edgeId];
            const up = this._edgeVerticalUp[edgeId];
            const forward = this._edgeVerticalForward[edgeId];
            labelMMatrix[0] = right[0];
            labelMMatrix[1] = right[1];
            labelMMatrix[2] = right[2];
            labelMMatrix[4] = up[0];
            labelMMatrix[5] = up[1];
            labelMMatrix[6] = up[2];
            labelMMatrix[8] = forward[0];
            labelMMatrix[9] = forward[1];
            labelMMatrix[10] = forward[2];
        }
        (0, $1ac1b59392edf35b$exports).multiply(labelMMatrix, this._mMatrix, labelMMatrix);
        if (orientation == (0, $4a6417d29706362f$export$d2304d1f23cf3ace).perpendicular) (0, $1ac1b59392edf35b$exports).multiply(labelMMatrix, labelMMatrix, (0, $d4d7bd6cc65a5081$export$a002182e51710d39).MAT4_ROTATION_MINUS_90);
        distance += maxLabelSize * 0.5;
        this._distances[edgeId] = distance;
    }
    _updateTitle(axisId, edgeId) {
        let distance = this._distances[edgeId];
        const titleTextSize = this._titleSizes[axisId] * this._core.config.axesTextTitleLineHeight;
        distance += titleTextSize * 0.5;
        (0, $31054a6c69637582$exports).multiply(this._vec3, (0, $c2c30e4dcf8004c5$export$a15f0a83a652dd40).EDGE_POSITIONS[edgeId], this._size);
        (0, $31054a6c69637582$exports).scaleAndAdd(this._vec3, this._vec3, (0, $c2c30e4dcf8004c5$export$a15f0a83a652dd40).EDGE_NORMALS[edgeId], distance);
        const titleMMatrix = this._titleMMatrices[edgeId];
        titleMMatrix[12] = this._vec3[0];
        titleMMatrix[13] = this._vec3[1];
        titleMMatrix[14] = this._vec3[2];
        const right = this._edgeHorizontalRight[edgeId];
        const up = this._edgeHorizontalUp[edgeId];
        const forward = this._edgeHorizontalForward[edgeId];
        titleMMatrix[0] = right[0];
        titleMMatrix[1] = right[1];
        titleMMatrix[2] = right[2];
        titleMMatrix[4] = up[0];
        titleMMatrix[5] = up[1];
        titleMMatrix[6] = up[2];
        titleMMatrix[8] = forward[0];
        titleMMatrix[9] = forward[1];
        titleMMatrix[10] = forward[2];
        (0, $1ac1b59392edf35b$exports).multiply(titleMMatrix, this._mMatrix, titleMMatrix);
        distance += titleTextSize * 0.5;
        this._distances[edgeId] = distance;
    }
    _updateHeading(axisId, edgeId) {
        let distance = this._distances[edgeId];
        const headingTextSize = this._headingSizes[axisId] * this._core.config.axesTextHeadingLineHeight;
        distance += headingTextSize * 0.5;
        (0, $31054a6c69637582$exports).multiply(this._vec3, (0, $c2c30e4dcf8004c5$export$a15f0a83a652dd40).EDGE_POSITIONS[edgeId], this._size);
        (0, $31054a6c69637582$exports).scaleAndAdd(this._vec3, this._vec3, (0, $c2c30e4dcf8004c5$export$a15f0a83a652dd40).EDGE_NORMALS[edgeId], distance);
        const headingMMatrix = this._headingMMatrices[edgeId];
        headingMMatrix[12] = this._vec3[0];
        headingMMatrix[13] = this._vec3[1];
        headingMMatrix[14] = this._vec3[2];
        const right = this._edgeHorizontalRight[edgeId];
        const up = this._edgeHorizontalUp[edgeId];
        const forward = this._edgeHorizontalForward[edgeId];
        headingMMatrix[0] = right[0];
        headingMMatrix[1] = right[1];
        headingMMatrix[2] = right[2];
        headingMMatrix[4] = up[0];
        headingMMatrix[5] = up[1];
        headingMMatrix[6] = up[2];
        headingMMatrix[8] = forward[0];
        headingMMatrix[9] = forward[1];
        headingMMatrix[10] = forward[2];
        (0, $1ac1b59392edf35b$exports).multiply(headingMMatrix, this._mMatrix, headingMMatrix);
        distance += headingTextSize * 0.5;
        this._distances[edgeId] = distance;
    }
    _updateGrids(size) {
        let offset = 0;
        this.pickGridLookup = {};
        this._pickGrid = [];
        const xDivisions = this._gridTicksPositions[0] ? this._gridTicksPositions[0].length - 1 : 0;
        const yDivisions = this._gridTicksPositions[1] ? this._gridTicksPositions[1].length - 1 : 0;
        const zDivisions = this._gridTicksPositions[2] ? this._gridTicksPositions[2].length - 1 : 0;
        const count = 2 * (xDivisions * yDivisions) + 2 * (xDivisions * zDivisions) + 2 * (yDivisions * zDivisions) + xDivisions + yDivisions + zDivisions;
        const byteLength = (0, $0a0587bd8b0d58e8$export$df352805a955aca5).SIZE_BYTES * count * 4;
        if (!this._gridVertices || this._gridVertices.byteLength < byteLength) {
            this._gridVertices = new ArrayBuffer(byteLength);
            this._gridVerticesView = new DataView(this._gridVertices);
            this._gridIndices = new Uint16Array(count * 6);
        }
        for(let axisId = 0; axisId < 3; axisId++){
            const width = size[axisId];
            (0, $31054a6c69637582$exports).set(this._gridTicksScales[axisId], width, this._gridPickDivisionHeight, 1);
            offset = this._updateGridTicks(axisId, this._gridVerticesView, this._gridIndices, offset);
            for(let face = 0; face < 2; face++){
                const faceId = (0, $c2c30e4dcf8004c5$export$a15f0a83a652dd40).AXIS_FACES[axisId][face];
                offset = this._updateGridFace(axisId, faceId, this._gridVerticesView, this._gridIndices, offset);
            }
            this._gridFaceScale[axisId] = size[axisId] == 0 ? 1 : size[axisId];
        }
    }
    _updateText(size) {
        let glyphOffset = 0;
        let count = 0;
        for(let axisId = 0; axisId < 3; axisId++){
            const labels = this._labels[axisId];
            if (labels) for(let i = 0; i < labels.length; i++)count += 2 * Math.min(labels[i].length, this._core.config.axesTextLabelMaxGlyphs);
            const title = this._titles[axisId];
            if (title) count += Math.min(title.length, this._core.config.axesTextTitleMaxGlyphs);
            const heading = this._headings[axisId];
            if (heading) count += Math.min(heading.length, this._core.config.axesTextHeadingMaxGlyphs);
        }
        const byteLength = (0, $0a0587bd8b0d58e8$export$74c3c25430a16442).SIZE_BYTES * count * 4;
        if (!this._textVertices || this._textVertices.byteLength < byteLength) {
            this._textVertices = new ArrayBuffer(byteLength);
            this._textVerticesView = new DataView(this._textVertices);
            this._textIndices = new Uint16Array(count * 6);
        }
        this.pickLabelLookup = {};
        this._pickLabel = [];
        for(let axisId = 0; axisId < 3; axisId++)if (this._labels[axisId]) {
            const width = size[axisId];
            const maxLabelSize = this._maxLabelSize[axisId];
            const orientation = this._orientations[axisId];
            (0, $91b0cc4981465964$exports).set(maxLabelSize, 0, 0);
            this._axesLeftToRightIndexOffsets[axisId] = glyphOffset * 6;
            glyphOffset = this._updateLeftToRightAxisLabels(axisId, width, maxLabelSize, glyphOffset, orientation, this._labels[axisId], this._labelPositions[axisId], this._labelSizes[axisId]);
            this._axesLeftToRightIndexCounts[axisId] = glyphOffset * 6 - this._axesLeftToRightIndexOffsets[axisId];
            this._axesRightToLeftIndexOffsets[axisId] = glyphOffset * 6;
            glyphOffset = this._updateRightToLeftAxisLabels(axisId, width, maxLabelSize, glyphOffset, orientation, this._labels[axisId], this._labelPositions[axisId], this._labelSizes[axisId]);
            this._axesRightToLeftIndexCounts[axisId] = glyphOffset * 6 - this._axesRightToLeftIndexOffsets[axisId];
        } else {
            this._axesLeftToRightIndexOffsets[axisId] = glyphOffset * 6;
            this._axesRightToLeftIndexOffsets[axisId] = glyphOffset * 6;
            this._axesLeftToRightIndexCounts[axisId] = 0;
            this._axesRightToLeftIndexCounts[axisId] = 0;
            this._maxLabelSize[axisId][0] = 0;
            this._maxLabelSize[axisId][1] = 0;
        }
        this.pickTitleLookup = {};
        this._pickTitle = [];
        for(let axisId = 0; axisId < 3; axisId++)if (this._titles[axisId]) {
            (0, $31054a6c69637582$exports).set(this._textPosition, 0, 0, 0);
            (0, $31054a6c69637582$exports).set(this._textOffset, 0, 0, 0);
            this._titleIndexOffsets[axisId] = glyphOffset * 6;
            const text = (0, $ee14aeb68f9f83d5$export$f080f423ca93034f).truncate(this._titles[axisId], this._core.config.axesTextTitleMaxGlyphs);
            const scale = this._titleSizes[axisId] / this._font.size;
            (0, $ee14aeb68f9f83d5$export$f080f423ca93034f).measure(this._font, text, this._textMetric);
            const width = this._textMetric.width * scale;
            const maxGlyphTop = this._textMetric.maxTop * scale;
            const lineHeight = this._font.size * scale;
            this._textOffset[0] -= width / 2;
            this._textOffset[1] -= (lineHeight - maxGlyphTop) / 2;
            const pickId = (0, $a60d0d861ccf87e8$export$aadd933e49c67c12).nextPickId();
            (0, $a60d0d861ccf87e8$export$aadd933e49c67c12).encodeNumber(pickId, (0, $4a6417d29706362f$export$6fc3f4da94ff0be0).axesTitle, this._vec4);
            this.pickTitleLookup[pickId] = this._pickTitle.length;
            this._pickTitle.push(axisId);
            (0, $ee14aeb68f9f83d5$export$f080f423ca93034f).addString(this._font, text, this._textVerticesView, this._textIndices, glyphOffset, this._textPosition, scale, this._textOffset, null, this._vec4);
            glyphOffset += text.length;
            this._titleIndexCounts[axisId] = glyphOffset * 6 - this._titleIndexOffsets[axisId];
        } else {
            this._titleIndexOffsets[axisId] = glyphOffset * 6;
            this._titleIndexCounts[axisId] = 0;
        }
        this.pickHeadingLookup = {};
        this._pickHeading = [];
        for(let axisId = 0; axisId < 3; axisId++)if (this._headings[axisId]) {
            (0, $31054a6c69637582$exports).set(this._textPosition, 0, 0, 0);
            (0, $31054a6c69637582$exports).set(this._textOffset, 0, 0, 0);
            this._headingIndexOffsets[axisId] = glyphOffset * 6;
            const text = (0, $ee14aeb68f9f83d5$export$f080f423ca93034f).truncate(this._headings[axisId], this._core.config.axesTextHeadingMaxGlyphs);
            const scale = this._headingSizes[axisId] / this._font.size;
            (0, $ee14aeb68f9f83d5$export$f080f423ca93034f).measure(this._font, text, this._textMetric);
            const width = this._textMetric.width * scale;
            const maxGlyphTop = this._textMetric.maxTop * scale;
            const lineHeight = this._font.size * scale;
            this._textOffset[0] -= width / 2;
            this._textOffset[1] -= (lineHeight - maxGlyphTop) / 2;
            const pickId = (0, $a60d0d861ccf87e8$export$aadd933e49c67c12).nextPickId();
            (0, $a60d0d861ccf87e8$export$aadd933e49c67c12).encodeNumber(pickId, (0, $4a6417d29706362f$export$6fc3f4da94ff0be0).axesHeading, this._vec4);
            this.pickHeadingLookup[pickId] = this._pickHeading.length;
            this._pickHeading.push(axisId);
            (0, $ee14aeb68f9f83d5$export$f080f423ca93034f).addString(this._font, text, this._textVerticesView, this._textIndices, glyphOffset, this._textPosition, scale, this._textOffset, null, this._vec4);
            glyphOffset += text.length;
            this._headingIndexCounts[axisId] = glyphOffset * 6 - this._headingIndexOffsets[axisId];
        } else {
            this._headingIndexOffsets[axisId] = glyphOffset * 6;
            this._headingIndexCounts[axisId] = 0;
        }
    }
    _updateLeftToRightAxisLabels(axisId, size, maxSize, glyphOffset, orientation, labels, positions, scales) {
        const isAxisReversed = this.isAxisReversed[axisId];
        for(let label = 0; label < labels.length; label++){
            const text = (0, $ee14aeb68f9f83d5$export$f080f423ca93034f).truncate(labels[label], this._core.config.axesTextLabelMaxGlyphs);
            const lineHeight = scales[label];
            const scale = lineHeight / this._font.size;
            (0, $ee14aeb68f9f83d5$export$f080f423ca93034f).measure(this._font, text, this._textMetric);
            const width = this._textMetric.width * scale;
            const maxGlyphTop = this._textMetric.maxTop * scale;
            const position = isAxisReversed ? 1 - positions[label] : positions[label];
            switch(orientation){
                case (0, $4a6417d29706362f$export$d2304d1f23cf3ace).parallel:
                    (0, $31054a6c69637582$exports).set(this._textPosition, (position - 0.5) * size, 0, 0);
                    if (this._isDiscrete[axisId]) this._textOffset[0] = -width / 2;
                    else this._textOffset[0] = position == 0 ? 0 : position == 1 ? -width : -width / 2;
                    this._textOffset[1] = (maxGlyphTop - lineHeight) / 2;
                    maxSize[0] = Math.max(width, maxSize[0]);
                    maxSize[1] = Math.max(lineHeight, maxSize[1]);
                    break;
                case (0, $4a6417d29706362f$export$d2304d1f23cf3ace).perpendicular:
                    (0, $31054a6c69637582$exports).set(this._textPosition, 0, (position - 0.5) * size, 0);
                    this._textOffset[0] = -width / 2;
                    if (this._isDiscrete[axisId]) this._textOffset[1] = -maxGlyphTop / 2;
                    else this._textOffset[1] = position == 0 ? 0 : position == 1 ? -maxGlyphTop : -maxGlyphTop / 2;
                    maxSize[0] = Math.max(lineHeight, maxSize[0]);
                    maxSize[1] = Math.max(width, maxSize[1]);
                    break;
            }
            const pickId = (0, $a60d0d861ccf87e8$export$aadd933e49c67c12).nextPickId();
            (0, $a60d0d861ccf87e8$export$aadd933e49c67c12).encodeNumber(pickId, (0, $4a6417d29706362f$export$6fc3f4da94ff0be0).axesLabel, this._vec4);
            this.pickLabelLookup[pickId] = this._pickLabel.length / 2;
            this._pickLabel.push(axisId);
            this._pickLabel.push(label);
            (0, $ee14aeb68f9f83d5$export$f080f423ca93034f).addString(this._font, text, this._textVerticesView, this._textIndices, glyphOffset, this._textPosition, scale, this._textOffset, null, this._vec4);
            glyphOffset += text.length;
        }
        return glyphOffset;
    }
    _updateRightToLeftAxisLabels(axisId, size, maxSize, glyphOffset, orientation, labels, positions, scales) {
        const isAxisReversed = this.isAxisReversed[axisId];
        for(let label = 0; label < labels.length; label++){
            const text = (0, $ee14aeb68f9f83d5$export$f080f423ca93034f).truncate(labels[label], this._core.config.axesTextLabelMaxGlyphs);
            const lineHeight = scales[label];
            const scale = lineHeight / this._font.size;
            (0, $ee14aeb68f9f83d5$export$f080f423ca93034f).measure(this._font, text, this._textMetric);
            const width = this._textMetric.width * scale;
            const maxGlyphTop = this._textMetric.maxTop * scale;
            const position = isAxisReversed ? 1 - positions[label] : positions[label];
            switch(orientation){
                case (0, $4a6417d29706362f$export$d2304d1f23cf3ace).parallel:
                    (0, $31054a6c69637582$exports).set(this._textPosition, (0.5 - position) * size, 0, 0);
                    if (this._isDiscrete[axisId]) this._textOffset[0] = -width / 2;
                    else this._textOffset[0] = label == 0 ? -width : label == labels.length - 1 ? 0 : -width / 2;
                    this._textOffset[1] = (maxGlyphTop - lineHeight) / 2;
                    break;
                case (0, $4a6417d29706362f$export$d2304d1f23cf3ace).perpendicular:
                    (0, $31054a6c69637582$exports).set(this._textPosition, 0, (0.5 - position) * size, 0);
                    this._textOffset[0] = -width / 2;
                    if (this._isDiscrete[axisId]) this._textOffset[1] = -maxGlyphTop / 2;
                    else this._textOffset[1] = label == 0 ? -maxGlyphTop : label == labels.length - 1 ? 0 : -maxGlyphTop / 2;
                    break;
            }
            const pickId = (0, $a60d0d861ccf87e8$export$aadd933e49c67c12).nextPickId();
            (0, $a60d0d861ccf87e8$export$aadd933e49c67c12).encodeNumber(pickId, (0, $4a6417d29706362f$export$6fc3f4da94ff0be0).axesLabel, this._vec4);
            this.pickLabelLookup[pickId] = this._pickLabel.length / 2;
            this._pickLabel.push(axisId);
            this._pickLabel.push(label);
            (0, $ee14aeb68f9f83d5$export$f080f423ca93034f).addString(this._font, text, this._textVerticesView, this._textIndices, glyphOffset, this._textPosition, scale, this._textOffset, null, this._vec4);
            glyphOffset += text.length;
        }
        return glyphOffset;
    }
    _updateGridTicks(axisId, dataView, indices, offset) {
        this._gridTicksIndexOffsets[axisId] = offset * 6;
        if (this._gridTicksPositions[axisId]) {
            const axes = (0, $31054a6c69637582$exports).create();
            const positions = this._gridTicksPositions[axisId];
            const isAxisReversed = this.isAxisReversed[axisId];
            let vertexOffset = offset * 4;
            for(let position = 0; position < positions.length - 1; position++){
                const left = isAxisReversed ? 1 - positions[position + 1] - 0.5 : positions[position] - 0.5;
                const right = isAxisReversed ? 1 - positions[position] - 0.5 : positions[position + 1] - 0.5;
                axes[axisId] = position + 1;
                const pickId = (0, $a60d0d861ccf87e8$export$aadd933e49c67c12).nextPickId();
                (0, $a60d0d861ccf87e8$export$aadd933e49c67c12).encodeNumber(pickId, (0, $4a6417d29706362f$export$6fc3f4da94ff0be0).axesDivision, this._vec4);
                this.pickGridLookup[pickId] = this._pickGrid.length / 3;
                this._pickGrid.push(axes[0]);
                this._pickGrid.push(axes[1]);
                this._pickGrid.push(axes[2]);
                let indexOffset = offset * 6;
                for(let j = 0; j < this._indexTemplate.length; j++)indices[indexOffset++] = this._indexTemplate[j] + vertexOffset;
                (0, $4c4ac78b213a9c07$exports).set(this._bounds, left + 0.5, 0, right + 0.5, 1);
                this._translation[0] = left;
                this._translation[1] = 0.5;
                this._translation[2] = 0;
                this._texCoord[0] = left + 0.5;
                this._texCoord[1] = 1;
                (0, $0a0587bd8b0d58e8$export$df352805a955aca5).setTranslation(dataView, vertexOffset, this._translation);
                (0, $0a0587bd8b0d58e8$export$df352805a955aca5).setNormal(dataView, vertexOffset, (0, $d4d7bd6cc65a5081$export$a002182e51710d39).VECTOR3_UNITZ);
                (0, $0a0587bd8b0d58e8$export$df352805a955aca5).setIdColor(dataView, vertexOffset, this._vec4);
                (0, $0a0587bd8b0d58e8$export$df352805a955aca5).setTexCoord(dataView, vertexOffset, this._texCoord);
                (0, $0a0587bd8b0d58e8$export$df352805a955aca5).setBounds(dataView, vertexOffset, this._bounds);
                vertexOffset++;
                this._translation[0] = right;
                this._texCoord[0] = right + 0.5;
                (0, $0a0587bd8b0d58e8$export$df352805a955aca5).setTranslation(dataView, vertexOffset, this._translation);
                (0, $0a0587bd8b0d58e8$export$df352805a955aca5).setNormal(dataView, vertexOffset, (0, $d4d7bd6cc65a5081$export$a002182e51710d39).VECTOR3_UNITZ);
                (0, $0a0587bd8b0d58e8$export$df352805a955aca5).setIdColor(dataView, vertexOffset, this._vec4);
                (0, $0a0587bd8b0d58e8$export$df352805a955aca5).setTexCoord(dataView, vertexOffset, this._texCoord);
                (0, $0a0587bd8b0d58e8$export$df352805a955aca5).setBounds(dataView, vertexOffset, this._bounds);
                vertexOffset++;
                this._translation[0] = left;
                this._translation[1] = -0.5;
                this._texCoord[0] = left + 0.5;
                this._texCoord[1] = 0;
                (0, $0a0587bd8b0d58e8$export$df352805a955aca5).setTranslation(dataView, vertexOffset, this._translation);
                (0, $0a0587bd8b0d58e8$export$df352805a955aca5).setNormal(dataView, vertexOffset, (0, $d4d7bd6cc65a5081$export$a002182e51710d39).VECTOR3_UNITZ);
                (0, $0a0587bd8b0d58e8$export$df352805a955aca5).setIdColor(dataView, vertexOffset, this._vec4);
                (0, $0a0587bd8b0d58e8$export$df352805a955aca5).setTexCoord(dataView, vertexOffset, this._texCoord);
                (0, $0a0587bd8b0d58e8$export$df352805a955aca5).setBounds(dataView, vertexOffset, this._bounds);
                vertexOffset++;
                this._translation[0] = right;
                this._texCoord[0] = right + 0.5;
                (0, $0a0587bd8b0d58e8$export$df352805a955aca5).setTranslation(dataView, vertexOffset, this._translation);
                (0, $0a0587bd8b0d58e8$export$df352805a955aca5).setNormal(dataView, vertexOffset, (0, $d4d7bd6cc65a5081$export$a002182e51710d39).VECTOR3_UNITZ);
                (0, $0a0587bd8b0d58e8$export$df352805a955aca5).setIdColor(dataView, vertexOffset, this._vec4);
                (0, $0a0587bd8b0d58e8$export$df352805a955aca5).setTexCoord(dataView, vertexOffset, this._texCoord);
                (0, $0a0587bd8b0d58e8$export$df352805a955aca5).setBounds(dataView, vertexOffset, this._bounds);
                vertexOffset++;
                offset++;
            }
        }
        this._gridTicksIndexCounts[axisId] = offset * 6 - this._gridTicksIndexOffsets[axisId];
        return offset;
    }
    _updateGridFace(axisId, faceId, dataView, indices, offset) {
        (0, $31054a6c69637582$exports).set(this._translation, 0, 0, 0);
        this._gridFaceIndexOffsets[faceId] = offset * 6;
        const axisId2 = axisId == 0 ? 1 : 0;
        const axisId3 = axisId == 2 ? 1 : 2;
        if (this._gridTicksPositions[axisId2] && this._gridTicksPositions[axisId3]) {
            const axes = (0, $31054a6c69637582$exports).create();
            (0, $31054a6c69637582$exports).negate(this._normal, (0, $c2c30e4dcf8004c5$export$a15f0a83a652dd40).FACE_NORMALS[faceId]);
            const positions2 = this._gridTicksPositions[axisId2];
            const positions3 = this._gridTicksPositions[axisId3];
            const isAxisReversed2 = this.isAxisReversed[axisId2];
            const isAxisReversed3 = this.isAxisReversed[axisId3];
            for(let position2 = 0; position2 < positions2.length - 1; position2++){
                const min2 = isAxisReversed2 ? 1 - positions2[position2 + 1] - 0.5 : positions2[position2] - 0.5;
                const max2 = isAxisReversed2 ? 1 - positions2[position2] - 0.5 : positions2[position2 + 1] - 0.5;
                axes[axisId2] = position2 + 1;
                let vertexOffset = offset * 4;
                for(let position3 = 0; position3 < positions3.length - 1; position3++){
                    const min3 = isAxisReversed3 ? 1 - positions3[position3 + 1] - 0.5 : positions3[position3] - 0.5;
                    const max3 = isAxisReversed3 ? 1 - positions3[position3] - 0.5 : positions3[position3 + 1] - 0.5;
                    axes[axisId3] = position3 + 1;
                    const pickId = (0, $a60d0d861ccf87e8$export$aadd933e49c67c12).nextPickId();
                    (0, $a60d0d861ccf87e8$export$aadd933e49c67c12).encodeNumber(pickId, (0, $4a6417d29706362f$export$6fc3f4da94ff0be0).axesDivision, this._vec4);
                    this.pickGridLookup[pickId] = this._pickGrid.length / 3;
                    this._pickGrid.push(axes[0]);
                    this._pickGrid.push(axes[1]);
                    this._pickGrid.push(axes[2]);
                    let indexOffset = offset * 6;
                    for(let i = 0; i < this._indexTemplate.length; i++)indices[indexOffset++] = this._indexTemplate[i] + vertexOffset;
                    (0, $4c4ac78b213a9c07$exports).set(this._bounds, min2 + 0.5, min3 + 0.5, max2 + 0.5, max3 + 0.5);
                    this._translation[axisId2] = min2;
                    this._translation[axisId3] = max3;
                    this._texCoord[0] = min2 + 0.5;
                    this._texCoord[1] = max3 + 0.5;
                    (0, $0a0587bd8b0d58e8$export$df352805a955aca5).setTranslation(dataView, vertexOffset, this._translation);
                    (0, $0a0587bd8b0d58e8$export$df352805a955aca5).setNormal(dataView, vertexOffset, this._normal);
                    (0, $0a0587bd8b0d58e8$export$df352805a955aca5).setIdColor(dataView, vertexOffset, this._vec4);
                    (0, $0a0587bd8b0d58e8$export$df352805a955aca5).setTexCoord(dataView, vertexOffset, this._texCoord);
                    (0, $0a0587bd8b0d58e8$export$df352805a955aca5).setBounds(dataView, vertexOffset, this._bounds);
                    vertexOffset++;
                    this._translation[axisId2] = max2;
                    this._texCoord[0] = max2 + 0.5;
                    (0, $0a0587bd8b0d58e8$export$df352805a955aca5).setTranslation(dataView, vertexOffset, this._translation);
                    (0, $0a0587bd8b0d58e8$export$df352805a955aca5).setNormal(dataView, vertexOffset, this._normal);
                    (0, $0a0587bd8b0d58e8$export$df352805a955aca5).setIdColor(dataView, vertexOffset, this._vec4);
                    (0, $0a0587bd8b0d58e8$export$df352805a955aca5).setTexCoord(dataView, vertexOffset, this._texCoord);
                    (0, $0a0587bd8b0d58e8$export$df352805a955aca5).setBounds(dataView, vertexOffset, this._bounds);
                    vertexOffset++;
                    this._translation[axisId2] = min2;
                    this._translation[axisId3] = min3;
                    this._texCoord[0] = min2 + 0.5;
                    this._texCoord[1] = min3 + 0.5;
                    (0, $0a0587bd8b0d58e8$export$df352805a955aca5).setTranslation(dataView, vertexOffset, this._translation);
                    (0, $0a0587bd8b0d58e8$export$df352805a955aca5).setNormal(dataView, vertexOffset, this._normal);
                    (0, $0a0587bd8b0d58e8$export$df352805a955aca5).setIdColor(dataView, vertexOffset, this._vec4);
                    (0, $0a0587bd8b0d58e8$export$df352805a955aca5).setTexCoord(dataView, vertexOffset, this._texCoord);
                    (0, $0a0587bd8b0d58e8$export$df352805a955aca5).setBounds(dataView, vertexOffset, this._bounds);
                    vertexOffset++;
                    this._translation[axisId2] = max2;
                    this._texCoord[0] = max2 + 0.5;
                    (0, $0a0587bd8b0d58e8$export$df352805a955aca5).setTranslation(dataView, vertexOffset, this._translation);
                    (0, $0a0587bd8b0d58e8$export$df352805a955aca5).setNormal(dataView, vertexOffset, this._normal);
                    (0, $0a0587bd8b0d58e8$export$df352805a955aca5).setIdColor(dataView, vertexOffset, this._vec4);
                    (0, $0a0587bd8b0d58e8$export$df352805a955aca5).setTexCoord(dataView, vertexOffset, this._texCoord);
                    (0, $0a0587bd8b0d58e8$export$df352805a955aca5).setBounds(dataView, vertexOffset, this._bounds);
                    vertexOffset++;
                    offset++;
                }
            }
        }
        this._gridFaceIndexCounts[faceId] = offset * 6 - this._gridFaceIndexOffsets[faceId];
        return offset;
    }
}


/*!
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 */ 








class $28691cf6913948f8$export$133913079d003c31 {
    static create(core, options) {
        const cartesian2dAxes = new $28691cf6913948f8$export$e3e79a454e5f8e5a(core);
        const minBoundsX = options.minBoundsX === undefined ? 0 : options.minBoundsX;
        const minBoundsY = options.minBoundsY === undefined ? 0 : options.minBoundsY;
        const maxBoundsX = options.maxBoundsX === undefined ? 1 : options.maxBoundsX;
        const maxBoundsY = options.maxBoundsY === undefined ? 1 : options.maxBoundsY;
        const minValueX = options.minValueX === undefined ? 0 : options.minValueX;
        const minValueY = options.minValueY === undefined ? 0 : options.minValueY;
        const maxValueX = options.maxValueX === undefined ? 1 : options.maxValueX;
        const maxValueY = options.maxValueY === undefined ? 1 : options.maxValueY;
        const scaling = options.scaling === undefined ? 1 : options.scaling;
        cartesian2dAxes.minBoundsX = minBoundsX;
        cartesian2dAxes.minBoundsY = minBoundsY;
        cartesian2dAxes.maxBoundsX = maxBoundsX;
        cartesian2dAxes.maxBoundsY = maxBoundsY;
        cartesian2dAxes.scalingX = scaling;
        cartesian2dAxes.scalingY = scaling;
        const maxLength = Math.max(maxBoundsX - minBoundsX, maxBoundsY - minBoundsY);
        const requestedDivisions = [
            options.divisionsX == undefined ? Math.max(Math.floor(core.config.axesGridDefaultDivisions * (maxBoundsX - minBoundsX) / maxLength), 1) : options.divisionsX,
            options.divisionsY == undefined ? Math.max(Math.floor(core.config.axesGridDefaultDivisions * (maxBoundsY - minBoundsY) / maxLength), 1) : options.divisionsY
        ];
        const minorGridlines = [
            options.minorGridlinesX == undefined ? 2 : options.minorGridlinesX,
            options.minorGridlinesY == undefined ? 2 : options.minorGridlinesY
        ];
        const labelMajorSizes = [
            options.labelMajorSizeX === undefined ? core.config.axesTextLabelMajorSize : options.labelMajorSizeX,
            options.labelMajorSizeY === undefined ? core.config.axesTextLabelMajorSize : options.labelMajorSizeY
        ];
        const labelMinorSizes = [
            options.labelMinorSizeX === undefined ? core.config.axesTextLabelMinorSize : options.labelMinorSizeX,
            options.labelMinorSizeY === undefined ? core.config.axesTextLabelMinorSize : options.labelMinorSizeY
        ];
        cartesian2dAxes.isDiscreteX = options.isDiscreteX;
        cartesian2dAxes.isDiscreteY = options.isDiscreteY;
        cartesian2dAxes.isGridPickingEnabled = options.isGridPickingEnabled;
        const isDivisionPickingEnabledArray = [
            options.isDivisionPickingEnabledX,
            options.isDivisionPickingEnabledY
        ];
        const isLabelPickingEnabled = [
            options.isLabelPickingEnabledX,
            options.isLabelPickingEnabledY
        ];
        const isAxisReversed = [
            options.reverseX,
            options.reverseY
        ];
        const labelsArray = [
            options.labelsX,
            options.labelsY
        ];
        const labelOrientationsArray = [
            options.labelOrientationX,
            options.labelOrientationY
        ];
        const labelOrientationDefaultArray = [
            (0, $4a6417d29706362f$export$d2304d1f23cf3ace).parallel,
            (0, $4a6417d29706362f$export$d2304d1f23cf3ace).perpendicular,
            (0, $4a6417d29706362f$export$d2304d1f23cf3ace).parallel
        ];
        const arePickDivisionsVisibleArray = [
            options.arePickDivisionsVisibleX,
            options.arePickDivisionsVisibleY
        ];
        const minValueArray = [
            minValueX,
            minValueY
        ];
        const maxValueArray = [
            maxValueX,
            maxValueY
        ];
        const isDiscreteArray = [
            options.isDiscreteX,
            options.isDiscreteY
        ];
        const titleArray = [
            options.titleX,
            options.titleY
        ];
        const titleSizeArray = [
            options.titleSizeX,
            options.titleSizeY
        ];
        const headingArray = [
            options.headingX,
            options.headingY
        ];
        const headingSizeArray = [
            options.headingSizeX,
            options.headingSizeY
        ];
        for(let axisId = 0; axisId < 2; axisId++){
            const label = labelsArray[axisId];
            const minValue = minValueArray[axisId];
            const maxValue = maxValueArray[axisId];
            const discrete = isDiscreteArray[axisId];
            if (discrete) {
                const divisions = maxValue - minValue + 1;
                const maxDivisions = Math.min(requestedDivisions[axisId], divisions);
                const discreteAxisOptions = {
                    min: minValue,
                    max: maxValue,
                    divisions: divisions,
                    maxDivisions: maxDivisions,
                    label: label
                };
                const discreteAxis = (0, $92acb7820f38feec$export$46c1eaab6b8d1e23).discrete(discreteAxisOptions);
                cartesian2dAxes.setTickPositions(axisId, discreteAxis.tickPositions);
                cartesian2dAxes.setLabelPositions(axisId, discreteAxis.labelPositions);
                cartesian2dAxes.setLabels(axisId, discreteAxis.labels);
                cartesian2dAxes.setFromValues(axisId, discreteAxis.fromValues);
                cartesian2dAxes.setToValues(axisId, discreteAxis.toValues);
                cartesian2dAxes.setLabelSizes(axisId, Array(discreteAxis.labels.length).fill(labelMajorSizes[axisId]));
                cartesian2dAxes.minorGridlines[axisId] = 1;
            } else {
                const divisions = requestedDivisions[axisId];
                const continuousAxisOptions = {
                    min: minValue,
                    max: maxValue,
                    divisions: divisions,
                    label: label
                };
                const continuousAxis = (0, $92acb7820f38feec$export$46c1eaab6b8d1e23).continuous(continuousAxisOptions);
                cartesian2dAxes.setTickPositions(axisId, continuousAxis.positions);
                cartesian2dAxes.setLabelPositions(axisId, continuousAxis.positions);
                cartesian2dAxes.setLabels(axisId, continuousAxis.labels);
                cartesian2dAxes.setFromValues(axisId, continuousAxis.fromValues);
                cartesian2dAxes.setToValues(axisId, continuousAxis.toValues);
                const labelSizes = [];
                for(let i = 0; i < continuousAxis.labels.length; i++)labelSizes.push(i == 0 || i == divisions ? labelMajorSizes[axisId] : labelMinorSizes[axisId]);
                cartesian2dAxes.setLabelSizes(axisId, labelSizes);
                cartesian2dAxes.minorGridlines[axisId] = minorGridlines[axisId];
            }
            cartesian2dAxes.setLabelOrientation(axisId, labelOrientationsArray[axisId] === undefined ? labelOrientationDefaultArray[axisId] : labelOrientationsArray[axisId]);
            cartesian2dAxes.setTitle(axisId, titleArray[axisId]);
            cartesian2dAxes.setTitleSize(axisId, titleSizeArray[axisId] === undefined ? core.config.axesTextTitleSize : titleSizeArray[axisId]);
            cartesian2dAxes.setHeading(axisId, headingArray[axisId]);
            cartesian2dAxes.setHeadingSize(axisId, headingSizeArray[axisId] === undefined ? core.config.axesTextHeadingSize : headingSizeArray[axisId]);
            cartesian2dAxes.arePickDivisionsVisible[axisId] = arePickDivisionsVisibleArray[axisId] === undefined ? true : arePickDivisionsVisibleArray[axisId];
            cartesian2dAxes.isDivisionPickingEnabled[axisId] = isDivisionPickingEnabledArray[axisId];
            cartesian2dAxes.isLabelPickingEnabled[axisId] = isLabelPickingEnabled[axisId];
            cartesian2dAxes.isAxisReversed[axisId] = isAxisReversed[axisId];
            if (minValue <= 0 && maxValue >= 0 && minValue != maxValue) cartesian2dAxes.zero[axisId] = -minValue / (maxValue - minValue);
            else cartesian2dAxes.zero[axisId] = -Number.MAX_VALUE;
        }
        return cartesian2dAxes;
    }
}
class $28691cf6913948f8$export$e3e79a454e5f8e5a extends (0, $2e2b6f93796e9c8a$export$a0569bcde4468e7f) {
    get size() {
        return this._size;
    }
    get isDiscreteX() {
        return this._isDiscrete[0];
    }
    set isDiscreteX(value) {
        if (value != this._isDiscrete[0]) {
            this._isDiscrete[0] = value;
            this._hasChanged = true;
        }
    }
    get isDiscreteY() {
        return this._isDiscrete[1];
    }
    set isDiscreteY(value) {
        if (value != this._isDiscrete[1]) {
            this._isDiscrete[1] = value;
            this._hasChanged = true;
        }
    }
    get minBoundsX() {
        return this._minBoundsX;
    }
    set minBoundsX(value) {
        if (value != this._minBoundsX) {
            this._minBoundsX = value;
            this._hasChanged = true;
        }
    }
    get maxBoundsX() {
        return this._maxBoundsX;
    }
    set maxBoundsX(value) {
        if (value != this._minBoundsX) {
            this._maxBoundsX = value;
            this._hasChanged = true;
        }
    }
    get minBoundsY() {
        return this._minBoundsY;
    }
    set minBoundsY(value) {
        if (value != this._minBoundsY) {
            this._minBoundsY = value;
            this._hasChanged = true;
        }
    }
    get maxBoundsY() {
        return this._maxBoundsY;
    }
    set maxBoundsY(value) {
        if (value != this._minBoundsY) {
            this._maxBoundsY = value;
            this._hasChanged = true;
        }
    }
    getIsOutsideEdge(index) {
        return this._isOutsideEdge[index];
    }
    getIsForwardFace(index) {
        return this._isForwardFace[index];
    }
    get textVertices() {
        return this._textVertices;
    }
    get textIndices() {
        return this._textIndices;
    }
    getLabelMMatrix(index) {
        return this._labelMMatrices[index];
    }
    setLabelPositions(index, value) {
        if (this._labelPositions[index] != value) {
            this._labelPositions[index] = value;
            this._hasChanged = true;
        }
    }
    setLabels(index, value) {
        if (this._labels[index] != value) {
            this._labels[index] = value;
            this._hasChanged = true;
        }
    }
    setLabelSizes(index, value) {
        if (this._labelSizes[index] != value) {
            this._labelSizes[index] = value;
            this._hasChanged = true;
        }
    }
    getLabelOrientation(index) {
        return this._orientations[index];
    }
    setLabelOrientation(index, orientation) {
        if (this._orientations[index] != orientation) {
            this._orientations[index] = orientation;
            this._hasChanged = true;
        }
    }
    getTitleIndexCount(index) {
        return this._titleIndexCounts[index];
    }
    getTitleIndexOffset(index) {
        return this._titleIndexOffsets[index];
    }
    getTitleMMatrix(index) {
        return this._titleMMatrices[index];
    }
    setTitle(index, value) {
        if (this._titles[index] != value) {
            this._titles[index] = value;
            this._hasChanged = true;
        }
    }
    setTitleSize(index, value) {
        if (this._titleSizes[index] != value) {
            this._titleSizes[index] = value;
            this._hasChanged = true;
        }
    }
    getHeadingIndexCount(index) {
        return this._headingIndexCounts[index];
    }
    getHeadingIndexOffset(index) {
        return this._headingIndexOffsets[index];
    }
    getHeadingMMatrix(index) {
        return this._headingMMatrices[index];
    }
    setHeading(index, value) {
        if (this._headings[index] != value) {
            this._headings[index] = value;
            this._hasChanged = true;
        }
    }
    setHeadingSize(index, value) {
        if (this._headingSizes[index] != value) {
            this._headingSizes[index] = value;
            this._hasChanged = true;
        }
    }
    getIsLeftToRightHorizontal(index) {
        return this._isLeftToRightHorizontal[index];
    }
    getIsLeftToRightVertical(index) {
        return this._isLeftToRightVertical[index];
    }
    getAxesLeftToRightIndexCount(index) {
        return this._axesLeftToRightIndexCounts[index];
    }
    getAxesRightToLeftIndexCount(index) {
        return this._axesRightToLeftIndexCounts[index];
    }
    getAxesLeftToRightIndexOffset(index) {
        return this._axesLeftToRightIndexOffsets[index];
    }
    getAxesRightToLeftIndexOffset(index) {
        return this._axesRightToLeftIndexOffsets[index];
    }
    get gridVertices() {
        return this._gridVertices;
    }
    get gridIndices() {
        return this._gridIndices;
    }
    getGridTicksIndexCount(index) {
        return this._gridTicksIndexCounts[index];
    }
    getGridTicksIndexOffset(index) {
        return this._gridTicksIndexOffsets[index];
    }
    getGridFaceIndexCount(index) {
        return this._gridFaceIndexCounts[index];
    }
    getGridFaceIndexOffset(index) {
        return this._gridFaceIndexOffsets[index];
    }
    getGridTicksMMatrix(index) {
        return this._gridTicksMMatrices[index];
    }
    getGridFaceMMatrix(index) {
        return this._gridFaceMMatrices[index];
    }
    getGridTicksScale(index) {
        return this._gridTicksScales[index];
    }
    getGridTicksZero(index) {
        return this._gridTicksZeros[index];
    }
    get gridFaceZero() {
        return this._gridFaceZeros;
    }
    get gridFaceMinorGridlines() {
        return this._gridFaceMinorGridlines;
    }
    getGridTicksMinorGridlines(index) {
        return this._gridTicksMinorGridlines[index];
    }
    setTickPositions(index, value) {
        if (this._gridTicksPositions[index] != value) {
            this._gridTicksPositions[index] = value;
            this._hasChanged = true;
        }
    }
    get scalingX() {
        return this._scalingX;
    }
    set scalingX(value) {
        if (value != this._scalingX) {
            this._scalingX = value;
            this._hasChanged = true;
        }
    }
    get scalingY() {
        return this._scalingY;
    }
    set scalingY(value) {
        if (value != this._scalingY) {
            this._scalingY = value;
            this._hasChanged = true;
        }
    }
    get offsetX() {
        return this._offset[12];
    }
    set offsetX(value) {
        if (value != this._offset[12]) this._offset[12] = value;
    }
    get offsetY() {
        return this._offset[13];
    }
    set offsetY(value) {
        if (value != this._offset[13]) this._offset[13] = value;
    }
    set rotation(value) {
        if (this._rotation != value) {
            this._rotation = value;
            this._rMatrix = (0, $1ac1b59392edf35b$exports).create();
            (0, $1ac1b59392edf35b$exports).fromQuat(this._rMatrix, value);
        }
    }
    constructor(core){
        super(core);
        this._size = (0, $31054a6c69637582$exports).create();
        this._translation = (0, $31054a6c69637582$exports).create();
        this._normal = (0, $31054a6c69637582$exports).create();
        this._forward = (0, $31054a6c69637582$exports).create();
        this._right = (0, $31054a6c69637582$exports).create();
        this._up = (0, $31054a6c69637582$exports).create();
        this._texCoord = (0, $91b0cc4981465964$exports).create();
        this._bounds = (0, $4c4ac78b213a9c07$exports).create();
        this._vec3 = (0, $31054a6c69637582$exports).create();
        this._vec4 = (0, $4c4ac78b213a9c07$exports).create();
        this._mat3 = (0, $ba3ca37806a2b6fa$exports).create();
        this._isDiscrete = [
            false,
            false
        ];
        this._minBoundsX = 0;
        this._minBoundsY = 0;
        this._maxBoundsX = 0;
        this._maxBoundsY = 0;
        this._isForwardFace = [];
        this._isForwardEdge = [];
        this._isOutsideEdge = [];
        for(let i = 0; i < 2; i++)this._isForwardFace.push(false);
        for(let i = 0; i < 4; i++){
            this._isForwardEdge.push(false);
            this._isOutsideEdge.push(false);
        }
        this._textOffset = (0, $31054a6c69637582$exports).create();
        this._textPosition = (0, $31054a6c69637582$exports).create();
        this._distances = [];
        for(let i = 0; i < 4; i++)this._distances.push(0);
        this._labelPositions = [];
        this._labels = [];
        this._labelSizes = [];
        this._maxLabelSize = [];
        this._axesLeftToRightIndexCounts = [];
        this._axesRightToLeftIndexCounts = [];
        this._axesLeftToRightIndexOffsets = [];
        this._axesRightToLeftIndexOffsets = [];
        this._labelMMatrices = [];
        this._orientations = [];
        for(let i = 0; i < 2; i++){
            this._maxLabelSize.push((0, $91b0cc4981465964$exports).create());
            this._orientations.push((0, $4a6417d29706362f$export$d2304d1f23cf3ace).parallel);
            this._axesLeftToRightIndexCounts.push(0);
            this._axesRightToLeftIndexCounts.push(0);
            this._axesLeftToRightIndexOffsets.push(0);
            this._axesRightToLeftIndexOffsets.push(0);
        }
        for(let i = 0; i < 4; i++)this._labelMMatrices.push((0, $1ac1b59392edf35b$exports).create());
        this._titles = [];
        this._titleSizes = [];
        this._titleIndexCounts = [];
        this._titleIndexOffsets = [];
        this._titleMMatrices = [];
        for(let i = 0; i < 2; i++){
            this._titles.push(null);
            this._titleSizes.push(core.config.axesTextTitleSize);
            this._titleIndexCounts.push(0);
            this._titleIndexOffsets.push(0);
        }
        for(let i = 0; i < 4; i++)this._titleMMatrices.push((0, $1ac1b59392edf35b$exports).create());
        this._headings = [];
        this._headingSizes = [];
        this._headingIndexCounts = [];
        this._headingIndexOffsets = [];
        this._headingMMatrices = [];
        this.isHeadingVisible = [];
        for(let i = 0; i < 2; i++){
            this._headings.push(null);
            this._headingSizes.push(core.config.axesTextHeadingSize);
            this._headingIndexCounts.push(0);
            this._headingIndexOffsets.push(0);
        }
        for(let i = 0; i < 4; i++){
            this._headingMMatrices.push((0, $1ac1b59392edf35b$exports).create());
            this.isHeadingVisible.push(true);
        }
        this.isEdgeVisible = [];
        this._edgePosition = (0, $31054a6c69637582$exports).create();
        this._edgePositive = (0, $31054a6c69637582$exports).create();
        this._edgeNormal = (0, $31054a6c69637582$exports).create();
        this._edgeNormalTemp = (0, $31054a6c69637582$exports).create();
        this._edgePositiveTemp = (0, $31054a6c69637582$exports).create();
        this._isLeftToRightHorizontal = [];
        this._isLeftToRightVertical = [];
        this._edgeHorizontalRight = [];
        this._edgeHorizontalUp = [];
        this._edgeHorizontalForward = [];
        this._edgeVerticalRight = [];
        this._edgeVerticalUp = [];
        this._edgeVerticalForward = [];
        for(let i = 0; i < 4; i++){
            this.isEdgeVisible.push(true);
            this._isLeftToRightHorizontal.push(false);
            this._isLeftToRightVertical.push(false);
            this._edgeHorizontalRight.push((0, $31054a6c69637582$exports).create());
            this._edgeHorizontalUp.push((0, $31054a6c69637582$exports).create());
            this._edgeHorizontalForward.push((0, $31054a6c69637582$exports).create());
            this._edgeVerticalRight.push((0, $31054a6c69637582$exports).create());
            this._edgeVerticalUp.push((0, $31054a6c69637582$exports).create());
            this._edgeVerticalForward.push((0, $31054a6c69637582$exports).create());
        }
        this.isFaceVisible = [];
        for(let i = 0; i < 2; i++)this.isFaceVisible.push(true);
        this.arePickDivisionsVisible = [];
        this.areFacesVisible = [];
        this._indexTemplate = (0, $3ce6ee188e300946$export$7005c9eb6671414d).INDICES;
        this.zero = (0, $31054a6c69637582$exports).create();
        this._gridTicksZeros = [];
        this._gridFaceZeros = (0, $91b0cc4981465964$exports).create();
        this.minorGridlines = (0, $31054a6c69637582$exports).fromValues(1, 1, 1);
        this._gridTicksMinorGridlines = [];
        this._gridFaceMinorGridlines = (0, $91b0cc4981465964$exports).create();
        this._gridTicksPositions = [];
        this._gridTicksScales = [];
        this._gridTicksIndexCounts = [];
        this._gridTicksIndexOffsets = [];
        this._gridFaceScale = (0, $31054a6c69637582$exports).create();
        this._gridFaceIndexCounts = [];
        this._gridFaceIndexOffsets = [];
        this._gridFaceMMatrices = [];
        this._gridTicksMMatrices = [];
        this._gridTicksRotations = [];
        for(let i = 0; i < 2; i++){
            this.arePickDivisionsVisible.push(true);
            this.areFacesVisible.push(true);
            this._gridTicksZeros.push((0, $91b0cc4981465964$exports).create());
            this._gridTicksMinorGridlines.push((0, $91b0cc4981465964$exports).create());
            this._gridTicksScales.push((0, $31054a6c69637582$exports).create());
            this._gridTicksIndexCounts.push(0);
            this._gridTicksIndexOffsets.push(0);
            this._gridFaceIndexCounts.push(0);
            this._gridFaceIndexOffsets.push(0);
            this._gridFaceMMatrices.push((0, $1ac1b59392edf35b$exports).create());
        }
        for(let i = 0; i < 4; i++){
            this._gridTicksMMatrices.push((0, $1ac1b59392edf35b$exports).create());
            this._gridTicksRotations.push((0, $1ac1b59392edf35b$exports).create());
            const _mat4 = this._gridTicksRotations[i];
            _mat4[0] = (0, $3ce6ee188e300946$export$7005c9eb6671414d).EDGE_POSITIVES[i][0];
            _mat4[1] = (0, $3ce6ee188e300946$export$7005c9eb6671414d).EDGE_POSITIVES[i][1];
            _mat4[2] = (0, $3ce6ee188e300946$export$7005c9eb6671414d).EDGE_POSITIVES[i][2];
            _mat4[4] = (0, $3ce6ee188e300946$export$7005c9eb6671414d).EDGE_NORMALS[i][0];
            _mat4[5] = (0, $3ce6ee188e300946$export$7005c9eb6671414d).EDGE_NORMALS[i][1];
            _mat4[6] = (0, $3ce6ee188e300946$export$7005c9eb6671414d).EDGE_NORMALS[i][2];
            (0, $31054a6c69637582$exports).cross(this._vec3, (0, $3ce6ee188e300946$export$7005c9eb6671414d).EDGE_POSITIVES[i], (0, $3ce6ee188e300946$export$7005c9eb6671414d).EDGE_NORMALS[i]);
            _mat4[8] = this._vec3[0];
            _mat4[9] = this._vec3[1];
            _mat4[10] = this._vec3[2];
        }
        this._fromValues = [
            null,
            null
        ];
        this._toValues = [
            null,
            null
        ];
        this.isDivisionPickingEnabled = [
            false,
            false
        ];
        this.isLabelPickingEnabled = [
            false,
            false
        ];
        this.isTitlePickingEnabled = [
            false,
            false
        ];
        this.isHeadingPickingEnabled = [
            false,
            false
        ];
        this.isAxisReversed = [
            false,
            false
        ];
        this._scalingX = 1;
        this._scalingY = 1;
        this._offset = (0, $1ac1b59392edf35b$exports).create();
    }
    initialize() {
        this._isInitialized = true;
    }
    update(elapsedTime) {
        if (this.isInitialized) {
            if (this._hasChanged) {
                const start = window.performance.now();
                this._hasChanged = false;
                (0, $31054a6c69637582$exports).set(this._size, this._maxBoundsX - this._minBoundsX, this._maxBoundsY - this._minBoundsY, 0);
                const maxBounds = Math.max(this._size[0], this._size[1]);
                this._size[0] *= this._scalingX / maxBounds;
                this._size[1] *= this._scalingY / maxBounds;
                this._updateGrids(this._size);
                this._updateText(this._size);
                if (this.hasChangedCallback) this.hasChangedCallback();
                this._core.log.write((0, $4a6417d29706362f$export$243e62d78d3b544d).info, `cartesian2d updated ${Math.round(window.performance.now() - start)}ms`);
            }
            if (this._rMatrix) {
                (0, $1ac1b59392edf35b$exports).mul(this._mMatrix, this.mMatrix, this._rMatrix);
                (0, $1ac1b59392edf35b$exports).mul(this._mMatrix, this._mMatrix, this._offset);
            } else (0, $1ac1b59392edf35b$exports).multiply(this._mMatrix, this.mMatrix, this._offset);
            this._mvMatrix = (0, $1ac1b59392edf35b$exports).create();
            (0, $1ac1b59392edf35b$exports).multiply(this._mvMatrix, this._vMatrix, this._mMatrix);
            (0, $ba3ca37806a2b6fa$exports).fromMat4(this._mat3, this._mvMatrix);
            for(let faceId = 0; faceId < 2; faceId++){
                (0, $31054a6c69637582$exports).transformMat4(this._forward, (0, $d4d7bd6cc65a5081$export$a002182e51710d39).VECTOR3_ZERO, this._mvMatrix);
                (0, $31054a6c69637582$exports).transformMat3(this._normal, (0, $3ce6ee188e300946$export$7005c9eb6671414d).FACE_NORMALS[faceId], this._mat3);
                this._isForwardFace[faceId] = (0, $31054a6c69637582$exports).dot(this._normal, this._forward) > 0;
            }
            this._forward[0] = this._mat3[2];
            this._forward[1] = this._mat3[5];
            this._forward[2] = this._mat3[8];
            for(let edgeId = 0; edgeId < 4; edgeId++){
                this._isForwardEdge[edgeId] = (0, $31054a6c69637582$exports).dot((0, $3ce6ee188e300946$export$7005c9eb6671414d).EDGE_FORWARDS[edgeId], this._forward) < 0;
                this._distances[edgeId] = 0;
            }
            for(let axisId = 0; axisId < 2; axisId++)if (this.arePickDivisionsVisible[axisId]) {
                (0, $91b0cc4981465964$exports).set(this._gridTicksZeros[axisId], this.zero[axisId], -1);
                (0, $91b0cc4981465964$exports).set(this._gridTicksMinorGridlines[axisId], this.minorGridlines[axisId], 1);
                const gridTicksScale = this._gridTicksScales[axisId];
                for(let edge = 0; edge < 2; edge++){
                    const edgeId = (0, $3ce6ee188e300946$export$7005c9eb6671414d).AXIS_EDGES[axisId][edge];
                    if (this.isEdgeVisible[edgeId]) {
                        let distance = this._distances[edgeId];
                        distance += this._gridPickDivisionHeight * 0.5;
                        const gridTicksMMatrix = this._gridTicksMMatrices[edgeId];
                        (0, $31054a6c69637582$exports).multiply(this._vec3, (0, $3ce6ee188e300946$export$7005c9eb6671414d).EDGE_POSITIONS[edgeId], this._size);
                        (0, $31054a6c69637582$exports).scaleAndAdd(this._vec3, this._vec3, (0, $3ce6ee188e300946$export$7005c9eb6671414d).EDGE_NORMALS[edgeId], distance);
                        (0, $1ac1b59392edf35b$exports).translate(gridTicksMMatrix, this._mMatrix, this._vec3);
                        (0, $1ac1b59392edf35b$exports).multiply(gridTicksMMatrix, gridTicksMMatrix, this._gridTicksRotations[edgeId]);
                        if (!this._isForwardEdge[edgeId]) (0, $1ac1b59392edf35b$exports).scale(gridTicksMMatrix, gridTicksMMatrix, (0, $d4d7bd6cc65a5081$export$a002182e51710d39).VECTOR3_REFLECTX);
                        (0, $1ac1b59392edf35b$exports).scale(gridTicksMMatrix, gridTicksMMatrix, gridTicksScale);
                        distance += this._gridPickDivisionHeight * 0.5;
                        this._distances[edgeId] = distance;
                    }
                }
            }
            (0, $91b0cc4981465964$exports).set(this._gridFaceZeros, this.zero[0], this.zero[1]);
            (0, $91b0cc4981465964$exports).set(this._gridFaceMinorGridlines, this.minorGridlines[0], this.minorGridlines[1]);
            for(let faceId = 0; faceId < 2; faceId++)if (this._isForwardFace[faceId]) {
                const gridFaceMMatrix = this._gridFaceMMatrices[faceId];
                (0, $1ac1b59392edf35b$exports).scale(gridFaceMMatrix, this._mMatrix, this._gridFaceScale);
            }
            for(let axisId = 0; axisId < 2; axisId++)for(let edge = 0; edge < 2; edge++){
                const edgeId = (0, $3ce6ee188e300946$export$7005c9eb6671414d).AXIS_EDGES[axisId][edge];
                (0, $31054a6c69637582$exports).multiply(this._edgePosition, (0, $3ce6ee188e300946$export$7005c9eb6671414d).EDGE_POSITIONS[edgeId], this._size);
                (0, $31054a6c69637582$exports).transformMat4(this._edgePosition, this._edgePosition, this._mvMatrix);
                (0, $31054a6c69637582$exports).normalize(this._forward, this._edgePosition);
                (0, $31054a6c69637582$exports).negate(this._forward, this._forward);
                (0, $31054a6c69637582$exports).cross(this._right, (0, $d4d7bd6cc65a5081$export$a002182e51710d39).VECTOR3_UNITY, this._forward);
                (0, $31054a6c69637582$exports).normalize(this._right, this._right);
                (0, $31054a6c69637582$exports).cross(this._up, this._forward, this._right);
                (0, $31054a6c69637582$exports).transformMat3(this._edgeNormal, (0, $3ce6ee188e300946$export$7005c9eb6671414d).EDGE_NORMALS[edgeId], this._mat3);
                (0, $31054a6c69637582$exports).transformMat3(this._edgePositive, (0, $3ce6ee188e300946$export$7005c9eb6671414d).EDGE_POSITIVES[edgeId], this._mat3);
                (0, $31054a6c69637582$exports).copy(this._edgeNormalTemp, this._edgeNormal);
                (0, $31054a6c69637582$exports).copy(this._edgePositiveTemp, this._edgePositive);
                const edgeHorizontalRight = this._edgeHorizontalRight[edgeId];
                const edgeHorizontalUp = this._edgeHorizontalUp[edgeId];
                const edgeHorizontalForward = this._edgeHorizontalForward[edgeId];
                if ((0, $31054a6c69637582$exports).dot(this._edgeNormalTemp, this._up) > 0) (0, $31054a6c69637582$exports).copy(edgeHorizontalUp, (0, $3ce6ee188e300946$export$7005c9eb6671414d).EDGE_NORMALS[edgeId]);
                else {
                    (0, $31054a6c69637582$exports).negate(edgeHorizontalUp, (0, $3ce6ee188e300946$export$7005c9eb6671414d).EDGE_NORMALS[edgeId]);
                    (0, $31054a6c69637582$exports).negate(this._edgeNormalTemp, this._edgeNormalTemp);
                }
                if ((0, $31054a6c69637582$exports).dot(this._edgePositiveTemp, this._right) > 0) {
                    this._isLeftToRightHorizontal[edgeId] = true;
                    (0, $31054a6c69637582$exports).copy(edgeHorizontalRight, (0, $3ce6ee188e300946$export$7005c9eb6671414d).EDGE_POSITIVES[edgeId]);
                } else {
                    this._isLeftToRightHorizontal[edgeId] = false;
                    (0, $31054a6c69637582$exports).negate(edgeHorizontalRight, (0, $3ce6ee188e300946$export$7005c9eb6671414d).EDGE_POSITIVES[edgeId]);
                    (0, $31054a6c69637582$exports).negate(this._edgePositiveTemp, this._edgePositiveTemp);
                }
                (0, $31054a6c69637582$exports).cross(edgeHorizontalForward, this._edgePositiveTemp, this._edgeNormalTemp);
                if ((0, $31054a6c69637582$exports).dot(edgeHorizontalForward, this._forward) < 0) {
                    this._isLeftToRightHorizontal[edgeId] = !this._isLeftToRightHorizontal[edgeId];
                    (0, $31054a6c69637582$exports).negate(edgeHorizontalRight, edgeHorizontalRight);
                }
                (0, $31054a6c69637582$exports).cross(edgeHorizontalForward, edgeHorizontalRight, edgeHorizontalUp);
                const edgeVerticalRight = this._edgeVerticalRight[edgeId];
                const edgeVerticalUp = this._edgeVerticalUp[edgeId];
                const edgeVerticalForward = this._edgeVerticalForward[edgeId];
                if ((0, $31054a6c69637582$exports).dot(this._edgeNormal, this._right) < 0) (0, $31054a6c69637582$exports).copy(edgeVerticalUp, (0, $3ce6ee188e300946$export$7005c9eb6671414d).EDGE_NORMALS[edgeId]);
                else {
                    (0, $31054a6c69637582$exports).negate(edgeVerticalUp, (0, $3ce6ee188e300946$export$7005c9eb6671414d).EDGE_NORMALS[edgeId]);
                    (0, $31054a6c69637582$exports).negate(this._edgeNormal, this._edgeNormal);
                }
                if ((0, $31054a6c69637582$exports).dot(this._edgePositive, this._up) < 0) {
                    this._isLeftToRightVertical[edgeId] = true;
                    (0, $31054a6c69637582$exports).copy(edgeVerticalRight, (0, $3ce6ee188e300946$export$7005c9eb6671414d).EDGE_POSITIVES[edgeId]);
                } else {
                    this._isLeftToRightVertical[edgeId] = false;
                    (0, $31054a6c69637582$exports).negate(edgeVerticalRight, (0, $3ce6ee188e300946$export$7005c9eb6671414d).EDGE_POSITIVES[edgeId]);
                    (0, $31054a6c69637582$exports).negate(this._edgePositive, this._edgePositive);
                }
                (0, $31054a6c69637582$exports).cross(edgeVerticalForward, this._edgePositive, this._edgeNormal);
                if ((0, $31054a6c69637582$exports).dot(edgeVerticalForward, this._forward) < 0) {
                    this._isLeftToRightVertical[edgeId] = !this._isLeftToRightVertical[edgeId];
                    (0, $31054a6c69637582$exports).negate(edgeVerticalRight, edgeVerticalRight);
                }
                (0, $31054a6c69637582$exports).cross(edgeVerticalForward, edgeVerticalRight, edgeVerticalUp);
                if (this.isEdgeVisible[edgeId]) {
                    if (this._labels[axisId]) this._updateLabels(axisId, edgeId);
                    if (this._titles[axisId]) this._updateTitle(axisId, edgeId);
                }
                if (this.isHeadingVisible[edgeId]) this._updateHeading(axisId, edgeId);
            }
        }
    }
    _updateLabels(axisId, edgeId) {
        const orientation = this._orientations[axisId];
        let distance = this._distances[edgeId];
        let maxLabelSize = this._maxLabelSize[axisId][1];
        if (orientation == (0, $4a6417d29706362f$export$d2304d1f23cf3ace).parallel) maxLabelSize *= this._core.config.axesTextLabelLineHeight;
        distance += maxLabelSize * 0.5;
        (0, $31054a6c69637582$exports).multiply(this._vec3, (0, $3ce6ee188e300946$export$7005c9eb6671414d).EDGE_POSITIONS[edgeId], this._size);
        (0, $31054a6c69637582$exports).scaleAndAdd(this._vec3, this._vec3, (0, $3ce6ee188e300946$export$7005c9eb6671414d).EDGE_NORMALS[edgeId], distance);
        const labelMMatrix = this._labelMMatrices[edgeId];
        labelMMatrix[12] = this._vec3[0];
        labelMMatrix[13] = this._vec3[1];
        labelMMatrix[14] = this._vec3[2];
        if (orientation == (0, $4a6417d29706362f$export$d2304d1f23cf3ace).parallel) {
            const right = this._edgeHorizontalRight[edgeId];
            const up = this._edgeHorizontalUp[edgeId];
            const forward = this._edgeHorizontalForward[edgeId];
            labelMMatrix[0] = right[0];
            labelMMatrix[1] = right[1];
            labelMMatrix[2] = right[2];
            labelMMatrix[4] = up[0];
            labelMMatrix[5] = up[1];
            labelMMatrix[6] = up[2];
            labelMMatrix[8] = forward[0];
            labelMMatrix[9] = forward[1];
            labelMMatrix[10] = forward[2];
        } else {
            const right = this._edgeVerticalRight[edgeId];
            const up = this._edgeVerticalUp[edgeId];
            const forward = this._edgeVerticalForward[edgeId];
            labelMMatrix[0] = right[0];
            labelMMatrix[1] = right[1];
            labelMMatrix[2] = right[2];
            labelMMatrix[4] = up[0];
            labelMMatrix[5] = up[1];
            labelMMatrix[6] = up[2];
            labelMMatrix[8] = forward[0];
            labelMMatrix[9] = forward[1];
            labelMMatrix[10] = forward[2];
        }
        (0, $1ac1b59392edf35b$exports).multiply(labelMMatrix, this._mMatrix, labelMMatrix);
        if (orientation == (0, $4a6417d29706362f$export$d2304d1f23cf3ace).perpendicular) (0, $1ac1b59392edf35b$exports).multiply(labelMMatrix, labelMMatrix, (0, $d4d7bd6cc65a5081$export$a002182e51710d39).MAT4_ROTATION_MINUS_90);
        distance += maxLabelSize * 0.5;
        this._distances[edgeId] = distance;
    }
    _updateTitle(axisId, edgeId) {
        let distance = this._distances[edgeId];
        const titleTextSize = this._titleSizes[axisId] * this._core.config.axesTextTitleLineHeight;
        distance += titleTextSize * 0.5;
        (0, $31054a6c69637582$exports).multiply(this._vec3, (0, $3ce6ee188e300946$export$7005c9eb6671414d).EDGE_POSITIONS[edgeId], this._size);
        (0, $31054a6c69637582$exports).scaleAndAdd(this._vec3, this._vec3, (0, $3ce6ee188e300946$export$7005c9eb6671414d).EDGE_NORMALS[edgeId], distance);
        const titleMMatrix = this._titleMMatrices[edgeId];
        titleMMatrix[12] = this._vec3[0];
        titleMMatrix[13] = this._vec3[1];
        titleMMatrix[14] = this._vec3[2];
        const right = this._edgeHorizontalRight[edgeId];
        const up = this._edgeHorizontalUp[edgeId];
        const forward = this._edgeHorizontalForward[edgeId];
        titleMMatrix[0] = right[0];
        titleMMatrix[1] = right[1];
        titleMMatrix[2] = right[2];
        titleMMatrix[4] = up[0];
        titleMMatrix[5] = up[1];
        titleMMatrix[6] = up[2];
        titleMMatrix[8] = forward[0];
        titleMMatrix[9] = forward[1];
        titleMMatrix[10] = forward[2];
        (0, $1ac1b59392edf35b$exports).multiply(titleMMatrix, this._mMatrix, titleMMatrix);
        distance += titleTextSize * 0.5;
        this._distances[edgeId] = distance;
    }
    _updateHeading(axisId, edgeId) {
        let distance = this._distances[edgeId];
        const headingTextSize = this._headingSizes[axisId] * this._core.config.axesTextHeadingLineHeight;
        distance += headingTextSize * 0.5;
        (0, $31054a6c69637582$exports).multiply(this._vec3, (0, $3ce6ee188e300946$export$7005c9eb6671414d).EDGE_POSITIONS[edgeId], this._size);
        (0, $31054a6c69637582$exports).scaleAndAdd(this._vec3, this._vec3, (0, $3ce6ee188e300946$export$7005c9eb6671414d).EDGE_NORMALS[edgeId], distance);
        const headingMMatrix = this._headingMMatrices[edgeId];
        headingMMatrix[12] = this._vec3[0];
        headingMMatrix[13] = this._vec3[1];
        headingMMatrix[14] = this._vec3[2];
        const right = this._edgeHorizontalRight[edgeId];
        const up = this._edgeHorizontalUp[edgeId];
        const forward = this._edgeHorizontalForward[edgeId];
        headingMMatrix[0] = right[0];
        headingMMatrix[1] = right[1];
        headingMMatrix[2] = right[2];
        headingMMatrix[4] = up[0];
        headingMMatrix[5] = up[1];
        headingMMatrix[6] = up[2];
        headingMMatrix[8] = forward[0];
        headingMMatrix[9] = forward[1];
        headingMMatrix[10] = forward[2];
        (0, $1ac1b59392edf35b$exports).multiply(headingMMatrix, this._mMatrix, headingMMatrix);
        distance += headingTextSize * 0.5;
        this._distances[edgeId] = distance;
    }
    _updateGrids(size) {
        let offset = 0;
        this.pickGridLookup = {};
        this._pickGrid = [];
        const xDivisions = this._gridTicksPositions[0] ? this._gridTicksPositions[0].length - 1 : 0;
        const yDivisions = this._gridTicksPositions[1] ? this._gridTicksPositions[1].length - 1 : 0;
        const count = 2 * (xDivisions * yDivisions) + xDivisions + yDivisions;
        const byteLength = (0, $0a0587bd8b0d58e8$export$df352805a955aca5).SIZE_BYTES * count * 4;
        if (!this._gridVertices || this._gridVertices.byteLength < byteLength) {
            this._gridVertices = new ArrayBuffer(byteLength);
            this._gridVerticesView = new DataView(this._gridVertices);
            this._gridIndices = new Uint16Array(count * 6);
        }
        for(let axisId = 0; axisId < 2; axisId++){
            const width = size[axisId];
            (0, $31054a6c69637582$exports).set(this._gridTicksScales[axisId], width, this._gridPickDivisionHeight, 1);
            offset = this._updateGridTicks(axisId, this._gridVerticesView, this._gridIndices, offset);
            this._gridFaceScale[axisId] = size[axisId] == 0 ? 1 : size[axisId];
        }
        const axisId = 2;
        this._gridFaceScale[axisId] = 1;
        for(let faceId = 0; faceId < 2; faceId++)offset = this._updateGridFace(axisId, faceId, this._gridVerticesView, this._gridIndices, offset);
    }
    _updateText(size) {
        let glyphOffset = 0;
        let count = 0;
        for(let axisId = 0; axisId < 2; axisId++){
            const labels = this._labels[axisId];
            if (labels) for(let i = 0; i < labels.length; i++)count += 2 * Math.min(labels[i].length, this._core.config.axesTextLabelMaxGlyphs);
            const title = this._titles[axisId];
            if (title) count += Math.min(title.length, this._core.config.axesTextTitleMaxGlyphs);
            const heading = this._headings[axisId];
            if (heading) count += Math.min(heading.length, this._core.config.axesTextHeadingMaxGlyphs);
        }
        const byteLength = (0, $0a0587bd8b0d58e8$export$74c3c25430a16442).SIZE_BYTES * count * 4;
        if (!this._textVertices || this._textVertices.byteLength < byteLength) {
            this._textVertices = new ArrayBuffer(byteLength);
            this._textVerticesView = new DataView(this._textVertices);
            this._textIndices = new Uint16Array(count * 6);
        }
        this.pickLabelLookup = {};
        this._pickLabel = [];
        for(let axisId = 0; axisId < 2; axisId++)if (this._labels[axisId]) {
            const width = size[axisId];
            const maxLabelSize = this._maxLabelSize[axisId];
            const orientation = this._orientations[axisId];
            (0, $91b0cc4981465964$exports).set(maxLabelSize, 0, 0);
            this._axesLeftToRightIndexOffsets[axisId] = glyphOffset * 6;
            glyphOffset = this._updateLeftToRightAxisLabels(axisId, width, maxLabelSize, glyphOffset, orientation, this._labels[axisId], this._labelPositions[axisId], this._labelSizes[axisId]);
            this._axesLeftToRightIndexCounts[axisId] = glyphOffset * 6 - this._axesLeftToRightIndexOffsets[axisId];
            this._axesRightToLeftIndexOffsets[axisId] = glyphOffset * 6;
            glyphOffset = this._updateRightToLeftAxisLabels(axisId, width, maxLabelSize, glyphOffset, orientation, this._labels[axisId], this._labelPositions[axisId], this._labelSizes[axisId]);
            this._axesRightToLeftIndexCounts[axisId] = glyphOffset * 6 - this._axesRightToLeftIndexOffsets[axisId];
        } else {
            this._axesLeftToRightIndexOffsets[axisId] = glyphOffset * 6;
            this._axesRightToLeftIndexOffsets[axisId] = glyphOffset * 6;
            this._axesLeftToRightIndexCounts[axisId] = 0;
            this._axesRightToLeftIndexCounts[axisId] = 0;
            this._maxLabelSize[axisId][0] = 0;
            this._maxLabelSize[axisId][1] = 0;
        }
        this.pickTitleLookup = {};
        this._pickTitle = [];
        for(let axisId = 0; axisId < 2; axisId++)if (this._titles[axisId]) {
            (0, $31054a6c69637582$exports).set(this._textPosition, 0, 0, 0);
            (0, $31054a6c69637582$exports).set(this._textOffset, 0, 0, 0);
            this._titleIndexOffsets[axisId] = glyphOffset * 6;
            const text = (0, $ee14aeb68f9f83d5$export$f080f423ca93034f).truncate(this._titles[axisId], this._core.config.axesTextTitleMaxGlyphs);
            const scale = this._titleSizes[axisId] / this._font.size;
            (0, $ee14aeb68f9f83d5$export$f080f423ca93034f).measure(this._font, text, this._textMetric);
            const width = this._textMetric.width * scale;
            const maxGlyphTop = this._textMetric.maxTop * scale;
            const lineHeight = this._font.size * scale;
            this._textOffset[0] -= width / 2;
            this._textOffset[1] -= (lineHeight - maxGlyphTop) / 2;
            const pickId = (0, $a60d0d861ccf87e8$export$aadd933e49c67c12).nextPickId();
            (0, $a60d0d861ccf87e8$export$aadd933e49c67c12).encodeNumber(pickId, (0, $4a6417d29706362f$export$6fc3f4da94ff0be0).axesTitle, this._vec4);
            this.pickTitleLookup[pickId] = this._pickTitle.length;
            this._pickTitle.push(axisId);
            (0, $ee14aeb68f9f83d5$export$f080f423ca93034f).addString(this._font, text, this._textVerticesView, this._textIndices, glyphOffset, this._textPosition, scale, this._textOffset, null, this._vec4);
            glyphOffset += text.length;
            this._titleIndexCounts[axisId] = glyphOffset * 6 - this._titleIndexOffsets[axisId];
        } else {
            this._titleIndexOffsets[axisId] = glyphOffset * 6;
            this._titleIndexCounts[axisId] = 0;
        }
        this.pickHeadingLookup = {};
        this._pickHeading = [];
        for(let axisId = 0; axisId < 2; axisId++)if (this._headings[axisId]) {
            (0, $31054a6c69637582$exports).set(this._textPosition, 0, 0, 0);
            (0, $31054a6c69637582$exports).set(this._textOffset, 0, 0, 0);
            this._headingIndexOffsets[axisId] = glyphOffset * 6;
            const text = (0, $ee14aeb68f9f83d5$export$f080f423ca93034f).truncate(this._headings[axisId], this._core.config.axesTextHeadingMaxGlyphs);
            const scale = this._headingSizes[axisId] / this._font.size;
            (0, $ee14aeb68f9f83d5$export$f080f423ca93034f).measure(this._font, text, this._textMetric);
            const width = this._textMetric.width * scale;
            const maxGlyphTop = this._textMetric.maxTop * scale;
            const lineHeight = this._font.size * scale;
            this._textOffset[0] -= width / 2;
            this._textOffset[1] -= (lineHeight - maxGlyphTop) / 2;
            const pickId = (0, $a60d0d861ccf87e8$export$aadd933e49c67c12).nextPickId();
            (0, $a60d0d861ccf87e8$export$aadd933e49c67c12).encodeNumber(pickId, (0, $4a6417d29706362f$export$6fc3f4da94ff0be0).axesHeading, this._vec4);
            this.pickHeadingLookup[pickId] = this._pickHeading.length;
            this._pickHeading.push(axisId);
            (0, $ee14aeb68f9f83d5$export$f080f423ca93034f).addString(this._font, text, this._textVerticesView, this._textIndices, glyphOffset, this._textPosition, scale, this._textOffset, null, this._vec4);
            glyphOffset += text.length;
            this._headingIndexCounts[axisId] = glyphOffset * 6 - this._headingIndexOffsets[axisId];
        } else {
            this._headingIndexOffsets[axisId] = glyphOffset * 6;
            this._headingIndexCounts[axisId] = 0;
        }
    }
    _updateLeftToRightAxisLabels(axisId, size, maxSize, glyphOffset, orientation, labels, positions, scales) {
        const isAxisReversed = this.isAxisReversed[axisId];
        for(let label = 0; label < labels.length; label++){
            const text = (0, $ee14aeb68f9f83d5$export$f080f423ca93034f).truncate(labels[label], this._core.config.axesTextLabelMaxGlyphs);
            const lineHeight = scales[label];
            const scale = lineHeight / this._font.size;
            (0, $ee14aeb68f9f83d5$export$f080f423ca93034f).measure(this._font, text, this._textMetric);
            const width = this._textMetric.width * scale;
            const maxGlyphTop = this._textMetric.maxTop * scale;
            const position = isAxisReversed ? 1 - positions[label] : positions[label];
            switch(orientation){
                case (0, $4a6417d29706362f$export$d2304d1f23cf3ace).parallel:
                    (0, $31054a6c69637582$exports).set(this._textPosition, (position - 0.5) * size, 0, 0);
                    if (this._isDiscrete[axisId]) this._textOffset[0] = -width / 2;
                    else this._textOffset[0] = position == 0 ? 0 : position == 1 ? -width : -width / 2;
                    this._textOffset[1] = (maxGlyphTop - lineHeight) / 2;
                    maxSize[0] = Math.max(width, maxSize[0]);
                    maxSize[1] = Math.max(lineHeight, maxSize[1]);
                    break;
                case (0, $4a6417d29706362f$export$d2304d1f23cf3ace).perpendicular:
                    (0, $31054a6c69637582$exports).set(this._textPosition, 0, (position - 0.5) * size, 0);
                    this._textOffset[0] = -width / 2;
                    if (this._isDiscrete[axisId]) this._textOffset[1] = -maxGlyphTop / 2;
                    else this._textOffset[1] = position == 0 ? 0 : position == 1 ? -maxGlyphTop : -maxGlyphTop / 2;
                    maxSize[0] = Math.max(lineHeight, maxSize[0]);
                    maxSize[1] = Math.max(width, maxSize[1]);
                    break;
            }
            const pickId = (0, $a60d0d861ccf87e8$export$aadd933e49c67c12).nextPickId();
            (0, $a60d0d861ccf87e8$export$aadd933e49c67c12).encodeNumber(pickId, (0, $4a6417d29706362f$export$6fc3f4da94ff0be0).axesLabel, this._vec4);
            this.pickLabelLookup[pickId] = this._pickLabel.length / 2;
            this._pickLabel.push(axisId);
            this._pickLabel.push(label);
            (0, $ee14aeb68f9f83d5$export$f080f423ca93034f).addString(this._font, text, this._textVerticesView, this._textIndices, glyphOffset, this._textPosition, scale, this._textOffset, null, this._vec4);
            glyphOffset += text.length;
        }
        return glyphOffset;
    }
    _updateRightToLeftAxisLabels(axisId, size, maxSize, glyphOffset, orientation, labels, positions, scales) {
        const isAxisReversed = this.isAxisReversed[axisId];
        for(let label = 0; label < labels.length; label++){
            const text = (0, $ee14aeb68f9f83d5$export$f080f423ca93034f).truncate(labels[label], this._core.config.axesTextLabelMaxGlyphs);
            const lineHeight = scales[label];
            const scale = lineHeight / this._font.size;
            (0, $ee14aeb68f9f83d5$export$f080f423ca93034f).measure(this._font, text, this._textMetric);
            const width = this._textMetric.width * scale;
            const maxGlyphTop = this._textMetric.maxTop * scale;
            const position = isAxisReversed ? 1 - positions[label] : positions[label];
            switch(orientation){
                case (0, $4a6417d29706362f$export$d2304d1f23cf3ace).parallel:
                    (0, $31054a6c69637582$exports).set(this._textPosition, (0.5 - position) * size, 0, 0);
                    if (this._isDiscrete[axisId]) this._textOffset[0] = -width / 2;
                    else this._textOffset[0] = label == 0 ? -width : label == labels.length - 1 ? 0 : -width / 2;
                    this._textOffset[1] = (maxGlyphTop - lineHeight) / 2;
                    break;
                case (0, $4a6417d29706362f$export$d2304d1f23cf3ace).perpendicular:
                    (0, $31054a6c69637582$exports).set(this._textPosition, 0, (0.5 - position) * size, 0);
                    this._textOffset[0] = -width / 2;
                    if (this._isDiscrete[axisId]) this._textOffset[1] = -maxGlyphTop / 2;
                    else this._textOffset[1] = label == 0 ? -maxGlyphTop : label == labels.length - 1 ? 0 : -maxGlyphTop / 2;
                    break;
            }
            const pickId = (0, $a60d0d861ccf87e8$export$aadd933e49c67c12).nextPickId();
            (0, $a60d0d861ccf87e8$export$aadd933e49c67c12).encodeNumber(pickId, (0, $4a6417d29706362f$export$6fc3f4da94ff0be0).axesLabel, this._vec4);
            this.pickLabelLookup[pickId] = this._pickLabel.length / 2;
            this._pickLabel.push(axisId);
            this._pickLabel.push(label);
            (0, $ee14aeb68f9f83d5$export$f080f423ca93034f).addString(this._font, text, this._textVerticesView, this._textIndices, glyphOffset, this._textPosition, scale, this._textOffset, null, this._vec4);
            glyphOffset += text.length;
        }
        return glyphOffset;
    }
    _updateGridTicks(axisId, dataView, indices, offset) {
        this._gridTicksIndexOffsets[axisId] = offset * 6;
        if (this._gridTicksPositions[axisId]) {
            const axes = (0, $31054a6c69637582$exports).create();
            const positions = this._gridTicksPositions[axisId];
            const isAxisReversed = this.isAxisReversed[axisId];
            let vertexOffset = offset * 4;
            for(let position = 0; position < positions.length - 1; position++){
                const left = isAxisReversed ? 1 - positions[position + 1] - 0.5 : positions[position] - 0.5;
                const right = isAxisReversed ? 1 - positions[position] - 0.5 : positions[position + 1] - 0.5;
                axes[axisId] = position + 1;
                const pickId = (0, $a60d0d861ccf87e8$export$aadd933e49c67c12).nextPickId();
                (0, $a60d0d861ccf87e8$export$aadd933e49c67c12).encodeNumber(pickId, (0, $4a6417d29706362f$export$6fc3f4da94ff0be0).axesDivision, this._vec4);
                this.pickGridLookup[pickId] = this._pickGrid.length / 3;
                this._pickGrid.push(axes[0]);
                this._pickGrid.push(axes[1]);
                this._pickGrid.push(axes[2]);
                let indexOffset = offset * 6;
                for(let j = 0; j < this._indexTemplate.length; j++)indices[indexOffset++] = this._indexTemplate[j] + vertexOffset;
                (0, $4c4ac78b213a9c07$exports).set(this._bounds, left + 0.5, 0, right + 0.5, 1);
                this._translation[0] = left;
                this._translation[1] = 0.5;
                this._translation[2] = 0;
                this._texCoord[0] = left + 0.5;
                this._texCoord[1] = 1;
                (0, $0a0587bd8b0d58e8$export$df352805a955aca5).setTranslation(dataView, vertexOffset, this._translation);
                (0, $0a0587bd8b0d58e8$export$df352805a955aca5).setNormal(dataView, vertexOffset, (0, $d4d7bd6cc65a5081$export$a002182e51710d39).VECTOR3_UNITZ);
                (0, $0a0587bd8b0d58e8$export$df352805a955aca5).setIdColor(dataView, vertexOffset, this._vec4);
                (0, $0a0587bd8b0d58e8$export$df352805a955aca5).setTexCoord(dataView, vertexOffset, this._texCoord);
                (0, $0a0587bd8b0d58e8$export$df352805a955aca5).setBounds(dataView, vertexOffset, this._bounds);
                vertexOffset++;
                this._translation[0] = right;
                this._texCoord[0] = right + 0.5;
                (0, $0a0587bd8b0d58e8$export$df352805a955aca5).setTranslation(dataView, vertexOffset, this._translation);
                (0, $0a0587bd8b0d58e8$export$df352805a955aca5).setNormal(dataView, vertexOffset, (0, $d4d7bd6cc65a5081$export$a002182e51710d39).VECTOR3_UNITZ);
                (0, $0a0587bd8b0d58e8$export$df352805a955aca5).setIdColor(dataView, vertexOffset, this._vec4);
                (0, $0a0587bd8b0d58e8$export$df352805a955aca5).setTexCoord(dataView, vertexOffset, this._texCoord);
                (0, $0a0587bd8b0d58e8$export$df352805a955aca5).setBounds(dataView, vertexOffset, this._bounds);
                vertexOffset++;
                this._translation[0] = left;
                this._translation[1] = -0.5;
                this._texCoord[0] = left + 0.5;
                this._texCoord[1] = 0;
                (0, $0a0587bd8b0d58e8$export$df352805a955aca5).setTranslation(dataView, vertexOffset, this._translation);
                (0, $0a0587bd8b0d58e8$export$df352805a955aca5).setNormal(dataView, vertexOffset, (0, $d4d7bd6cc65a5081$export$a002182e51710d39).VECTOR3_UNITZ);
                (0, $0a0587bd8b0d58e8$export$df352805a955aca5).setIdColor(dataView, vertexOffset, this._vec4);
                (0, $0a0587bd8b0d58e8$export$df352805a955aca5).setTexCoord(dataView, vertexOffset, this._texCoord);
                (0, $0a0587bd8b0d58e8$export$df352805a955aca5).setBounds(dataView, vertexOffset, this._bounds);
                vertexOffset++;
                this._translation[0] = right;
                this._texCoord[0] = right + 0.5;
                (0, $0a0587bd8b0d58e8$export$df352805a955aca5).setTranslation(dataView, vertexOffset, this._translation);
                (0, $0a0587bd8b0d58e8$export$df352805a955aca5).setNormal(dataView, vertexOffset, (0, $d4d7bd6cc65a5081$export$a002182e51710d39).VECTOR3_UNITZ);
                (0, $0a0587bd8b0d58e8$export$df352805a955aca5).setIdColor(dataView, vertexOffset, this._vec4);
                (0, $0a0587bd8b0d58e8$export$df352805a955aca5).setTexCoord(dataView, vertexOffset, this._texCoord);
                (0, $0a0587bd8b0d58e8$export$df352805a955aca5).setBounds(dataView, vertexOffset, this._bounds);
                vertexOffset++;
                offset++;
            }
        }
        this._gridTicksIndexCounts[axisId] = offset * 6 - this._gridTicksIndexOffsets[axisId];
        return offset;
    }
    _updateGridFace(axisId, faceId, dataView, indices, offset) {
        (0, $31054a6c69637582$exports).set(this._translation, 0, 0, 0);
        this._gridFaceIndexOffsets[faceId] = offset * 6;
        const axisId2 = axisId == 0 ? 1 : 0;
        const axisId3 = axisId == 2 ? 1 : 2;
        if (this._gridTicksPositions[axisId2] && this._gridTicksPositions[axisId3]) {
            const axes = (0, $31054a6c69637582$exports).create();
            (0, $31054a6c69637582$exports).negate(this._normal, (0, $3ce6ee188e300946$export$7005c9eb6671414d).FACE_NORMALS[faceId]);
            const positions2 = this._gridTicksPositions[axisId2];
            const positions3 = this._gridTicksPositions[axisId3];
            const isAxisReversed2 = this.isAxisReversed[axisId2];
            const isAxisReversed3 = this.isAxisReversed[axisId3];
            for(let position2 = 0; position2 < positions2.length - 1; position2++){
                const min2 = isAxisReversed2 ? 1 - positions2[position2 + 1] - 0.5 : positions2[position2] - 0.5;
                const max2 = isAxisReversed2 ? 1 - positions2[position2] - 0.5 : positions2[position2 + 1] - 0.5;
                axes[axisId2] = position2 + 1;
                let vertexOffset = offset * 4;
                for(let position3 = 0; position3 < positions3.length - 1; position3++){
                    const min3 = isAxisReversed3 ? 1 - positions3[position3 + 1] - 0.5 : positions3[position3] - 0.5;
                    const max3 = isAxisReversed3 ? 1 - positions3[position3] - 0.5 : positions3[position3 + 1] - 0.5;
                    axes[axisId3] = position3 + 1;
                    const pickId = (0, $a60d0d861ccf87e8$export$aadd933e49c67c12).nextPickId();
                    (0, $a60d0d861ccf87e8$export$aadd933e49c67c12).encodeNumber(pickId, (0, $4a6417d29706362f$export$6fc3f4da94ff0be0).axesDivision, this._vec4);
                    this.pickGridLookup[pickId] = this._pickGrid.length / 3;
                    this._pickGrid.push(axes[0]);
                    this._pickGrid.push(axes[1]);
                    this._pickGrid.push(axes[2]);
                    let indexOffset = offset * 6;
                    for(let i = 0; i < this._indexTemplate.length; i++)indices[indexOffset++] = this._indexTemplate[i] + vertexOffset;
                    (0, $4c4ac78b213a9c07$exports).set(this._bounds, min2 + 0.5, min3 + 0.5, max2 + 0.5, max3 + 0.5);
                    this._translation[axisId2] = min2;
                    this._translation[axisId3] = max3;
                    this._texCoord[0] = min2 + 0.5;
                    this._texCoord[1] = max3 + 0.5;
                    (0, $0a0587bd8b0d58e8$export$df352805a955aca5).setTranslation(dataView, vertexOffset, this._translation);
                    (0, $0a0587bd8b0d58e8$export$df352805a955aca5).setNormal(dataView, vertexOffset, this._normal);
                    (0, $0a0587bd8b0d58e8$export$df352805a955aca5).setIdColor(dataView, vertexOffset, this._vec4);
                    (0, $0a0587bd8b0d58e8$export$df352805a955aca5).setTexCoord(dataView, vertexOffset, this._texCoord);
                    (0, $0a0587bd8b0d58e8$export$df352805a955aca5).setBounds(dataView, vertexOffset, this._bounds);
                    vertexOffset++;
                    this._translation[axisId2] = max2;
                    this._texCoord[0] = max2 + 0.5;
                    (0, $0a0587bd8b0d58e8$export$df352805a955aca5).setTranslation(dataView, vertexOffset, this._translation);
                    (0, $0a0587bd8b0d58e8$export$df352805a955aca5).setNormal(dataView, vertexOffset, this._normal);
                    (0, $0a0587bd8b0d58e8$export$df352805a955aca5).setIdColor(dataView, vertexOffset, this._vec4);
                    (0, $0a0587bd8b0d58e8$export$df352805a955aca5).setTexCoord(dataView, vertexOffset, this._texCoord);
                    (0, $0a0587bd8b0d58e8$export$df352805a955aca5).setBounds(dataView, vertexOffset, this._bounds);
                    vertexOffset++;
                    this._translation[axisId2] = min2;
                    this._translation[axisId3] = min3;
                    this._texCoord[0] = min2 + 0.5;
                    this._texCoord[1] = min3 + 0.5;
                    (0, $0a0587bd8b0d58e8$export$df352805a955aca5).setTranslation(dataView, vertexOffset, this._translation);
                    (0, $0a0587bd8b0d58e8$export$df352805a955aca5).setNormal(dataView, vertexOffset, this._normal);
                    (0, $0a0587bd8b0d58e8$export$df352805a955aca5).setIdColor(dataView, vertexOffset, this._vec4);
                    (0, $0a0587bd8b0d58e8$export$df352805a955aca5).setTexCoord(dataView, vertexOffset, this._texCoord);
                    (0, $0a0587bd8b0d58e8$export$df352805a955aca5).setBounds(dataView, vertexOffset, this._bounds);
                    vertexOffset++;
                    this._translation[axisId2] = max2;
                    this._texCoord[0] = max2 + 0.5;
                    (0, $0a0587bd8b0d58e8$export$df352805a955aca5).setTranslation(dataView, vertexOffset, this._translation);
                    (0, $0a0587bd8b0d58e8$export$df352805a955aca5).setNormal(dataView, vertexOffset, this._normal);
                    (0, $0a0587bd8b0d58e8$export$df352805a955aca5).setIdColor(dataView, vertexOffset, this._vec4);
                    (0, $0a0587bd8b0d58e8$export$df352805a955aca5).setTexCoord(dataView, vertexOffset, this._texCoord);
                    (0, $0a0587bd8b0d58e8$export$df352805a955aca5).setBounds(dataView, vertexOffset, this._bounds);
                    vertexOffset++;
                    offset++;
                }
            }
        }
        this._gridFaceIndexCounts[faceId] = offset * 6 - this._gridFaceIndexOffsets[faceId];
        return offset;
    }
}


/*!
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 */ 
class $f690fa88528736e9$export$408bb2acbb28390c {
    toJSON() {
        return {
            key: this.key,
            char: this.char,
            width: this.width,
            height: this.height,
            top: this.top,
            left: this.left,
            advance: this.advance,
            u0: this.u0,
            v0: this.v0,
            u1: this.u1,
            v1: this.v1
        };
    }
}
class $f690fa88528736e9$export$e784a6eab4d2d700 {
    update() {}
    constructor(font){
        this.font = font;
    }
}
class $f690fa88528736e9$export$89abf52a030e56ee {
    get atlas() {
        return this._rasterizer.fontAtlas;
    }
    get count() {
        return this._chars.size;
    }
    constructor(core, rasterizer){
        this._core = core;
        this._rasterizer = rasterizer;
        this._chars = new Set();
        this._previousSize = 0;
        this.glyphs = {};
    }
    addGlyph(char) {
        if (!this._chars.has(char)) {
            this._chars.add(char);
            this._rasterizer.draw(char);
            this._hasChanged = true;
        }
    }
    update() {
        if (this._hasChanged) {
            this._hasChanged = false;
            this._core.log.write((0, $4a6417d29706362f$export$243e62d78d3b544d).info, `${this.name} added ${this._chars.size - this._previousSize} new glyphs`);
            this._previousSize = this._chars.size;
            if (this.hasChangedCallback) this.hasChangedCallback();
        }
    }
    toJSON() {
        const glyphs = [];
        for(let key in this.glyphs){
            const glyph = this.glyphs[key];
            glyphs.push(glyph.toJSON());
        }
        return {
            name: this.name,
            size: this.size,
            border: this.border,
            glyphs: glyphs,
            edgeValue: this.edgeValue
        };
    }
}
class $f690fa88528736e9$export$834e93b4abb19d0a {
    constructor(width, height){
        const canvas = document.createElement("canvas");
        canvas.width = width;
        canvas.height = height;
        const context = canvas.getContext("2d");
        context.clearRect(0, 0, width, height);
        this.imageData = context.getImageData(0, 0, width, height);
        this.x = 0;
        this.top = new Uint16Array(width);
    }
}
class $f690fa88528736e9$export$9cdd7c9f8d056e99 {
    get font() {
        return this._font;
    }
    get fontAtlas() {
        return this._fontAtlas;
    }
    constructor(core, options){
        let start = performance.now();
        this._core = core;
        this._fontAtlas = options.fontAtlas;
        this._fontSize = options.fontSize;
        this._border = options.border;
        this._fontFamily = options.fontFamily;
        this._fontWeight = options.fontWeight;
        this._fontStyle = options.fontStyle;
        this._baseline = options.baseline;
        this._maxDistance = options.maxDistance;
        this._edgeValue = options.edgeValue;
        this._font = new $f690fa88528736e9$export$89abf52a030e56ee(core, this);
        this._font.name = `${this._fontFamily}${this._fontSize}${this._fontWeight == "normal" ? "" : this._fontWeight}${this._fontStyle == "normal" ? "" : this._fontStyle}`.replace(/[^a-z0-9,]/ig, "").toLowerCase();
        this._font.size = this._fontSize;
        this._font.border = this._border;
        this._font.edgeValue = this._edgeValue;
        const glyphRasterizerOptions = {
            baseline: this._baseline,
            border: this._border,
            edgeValue: this._edgeValue,
            fontFamily: this._fontFamily,
            fontSize: this._fontSize,
            fontStyle: this._fontStyle,
            fontWeight: this._fontWeight,
            maxDistance: this._maxDistance
        };
        this._glyphRasterizer = new $f690fa88528736e9$export$8109d828920592df(core, glyphRasterizerOptions);
        this._core.log.write((0, $4a6417d29706362f$export$243e62d78d3b544d).info, `font rasterizer ${Math.round(window.performance.now() - start)}ms`);
    }
    draw(char) {
        const glyph = this._glyphRasterizer.draw(char);
        const texWidth = glyph.width + 2 * this._border;
        const texHeight = glyph.height + 2 * this._border;
        const width = this._fontAtlas.imageData.width;
        const height = this._fontAtlas.imageData.height;
        if (this._fontAtlas.x + texWidth > width) this._fontAtlas.x = 0;
        let y = 0;
        for(let x = this._fontAtlas.x; x < this._fontAtlas.x + texWidth; x++)y = Math.max(y, this._fontAtlas.top[x]);
        if (y + texHeight > height) this._core.log.write((0, $4a6417d29706362f$export$243e62d78d3b544d).warn, `${this._font.name} height overflow`);
        for(let x = this._fontAtlas.x; x < this._fontAtlas.x + texWidth; x++)this._fontAtlas.top[x] = y + texHeight;
        glyph.u0 = this._fontAtlas.x / width;
        glyph.v0 = y / height;
        glyph.u1 = (this._fontAtlas.x + texWidth) / width;
        glyph.v1 = (y + texHeight) / height;
        this._font.glyphs[char] = glyph;
        for(let i = 0; i < glyph.distances.length; i++){
            const distance = glyph.distances[i];
            const dataX = i % texWidth;
            const dataY = Math.floor(i / texWidth);
            const offset = (this._fontAtlas.x + dataX + (y + dataY) * width) * 4;
            this._fontAtlas.imageData.data[offset + 0] = distance;
            this._fontAtlas.imageData.data[offset + 1] = distance;
            this._fontAtlas.imageData.data[offset + 2] = distance;
            this._fontAtlas.imageData.data[offset + 3] = 0xff;
        }
        this._fontAtlas.x += texWidth;
    }
}
class $f690fa88528736e9$export$8109d828920592df {
    constructor(core, options){
        let start = performance.now();
        this._core = core;
        this._fontSize = options.fontSize;
        this._border = options.border;
        this._fontFamily = options.fontFamily;
        this._fontWeight = options.fontWeight;
        this._fontStyle = options.fontStyle;
        this._baseline = options.baseline;
        this._maxDistance = options.maxDistance;
        this._edgeValue = options.edgeValue;
        this._size = this._fontSize + this._border * 2;
        this._size += this._border * 2;
        this._gridOuter = new Float64Array(this._size * this._size);
        this._gridInner = new Float64Array(this._size * this._size);
        this._f = new Float64Array(this._size);
        this._z = new Float64Array(this._size + 1);
        this._v = new Uint16Array(this._size);
        const canvas = document.createElement("canvas");
        canvas.width = canvas.height = this._size;
        this._context = canvas.getContext("2d", {
            willReadFrequently: true
        });
        this._context.font = `${this._fontStyle} ${this._fontWeight} ${this._fontSize}px ${this._fontFamily} `;
        this._context.textBaseline = this._baseline;
        this._context.textAlign = "left";
        this._context.fillStyle = "black";
        this._core.log.write((0, $4a6417d29706362f$export$243e62d78d3b544d).info, `glyph rasterizer ${Math.round(window.performance.now() - start)}ms`);
    }
    draw(char) {
        const textMetrics = this._context.measureText(char);
        const glyphLeft = 0;
        const glyphTop = Math.floor(textMetrics.actualBoundingBoxAscent);
        let glyphWidth = Math.ceil(textMetrics.actualBoundingBoxRight);
        let glyphHeight = Math.ceil(textMetrics.actualBoundingBoxAscent) + Math.ceil(textMetrics.actualBoundingBoxDescent);
        glyphWidth = Math.min(this._size - this._border, glyphWidth);
        glyphHeight = Math.min(this._size - this._border, glyphHeight);
        const width = glyphWidth + 2 * this._border;
        const height = glyphHeight + 2 * this._border;
        const length = width * height;
        const distances = new Uint8ClampedArray(length);
        const gradientsX = new Uint8ClampedArray(length);
        const gradientsY = new Uint8ClampedArray(length);
        const pixels = new Uint8ClampedArray(length);
        const glyph = new $f690fa88528736e9$export$408bb2acbb28390c();
        glyph.char = char;
        glyph.key = char.codePointAt(0);
        glyph.distances = distances;
        glyph.gradientsX = gradientsX;
        glyph.gradientsY = gradientsY;
        glyph.pixels = pixels;
        glyph.width = glyphWidth;
        glyph.height = glyphHeight;
        glyph.top = glyphTop;
        glyph.left = glyphLeft;
        glyph.advance = textMetrics.width;
        if (glyphWidth == 0 || glyphHeight == 0) return glyph;
        this._context.clearRect(this._border, this._border, glyphWidth, glyphHeight);
        this._context.fillText(char, this._border, this._border + glyphTop);
        const imgData = this._context.getImageData(this._border, this._border, glyphWidth, glyphHeight);
        for(let i = 0; i < length; i++){
            this._gridOuter[i] = Number.MAX_VALUE;
            this._gridInner[i] = 0;
        }
        for(let y = 0; y < glyphHeight; y++)for(let x = 0; x < glyphWidth; x++){
            const a = imgData.data[4 * (y * glyphWidth + x) + 3] / 0xff;
            if (a > 0) {
                const j = (y + this._border) * width + x + this._border;
                if (a == 1) {
                    this._gridOuter[j] = 0;
                    this._gridInner[j] = Number.MAX_VALUE;
                } else {
                    const d = 0.5 - a;
                    this._gridOuter[j] = d > 0 ? d * d : 0;
                    this._gridInner[j] = d < 0 ? d * d : 0;
                    pixels[j] = 0xff;
                }
            }
        }
        this._edt(this._gridOuter, 0, 0, width, height, width, this._f, this._v, this._z);
        this._edt(this._gridInner, this._border, this._border, glyphWidth, glyphHeight, width, this._f, this._v, this._z);
        const distances2 = new Float32Array(length);
        for(let i = 0; i < length; i++){
            const distance = Math.sqrt(this._gridOuter[i]) - Math.sqrt(this._gridInner[i]);
            distances[i] = Math.round(this._edgeValue - distance * 0xff / this._maxDistance);
            distances2[i] = distance;
        }
        for(let i = 0; i < length; i++){
            const x = i % width;
            const y = Math.floor(i / width);
            const d = distances2[i];
            const sign = d < 0 ? -1 : 1;
            const x0 = x > 0 ? distances2[i - 1] : Number.MAX_VALUE;
            const x1 = x < width - 1 ? distances2[i + 1] : Number.MAX_VALUE;
            const y0 = y > 0 ? distances2[i - width] : Number.MAX_VALUE;
            const y1 = y < height - 1 ? distances2[i + width] : Number.MAX_VALUE;
            let gradientX = sign * x0 < sign * x1 ? d - x0 : x1 - d;
            let gradientY = sign * y0 < sign * y1 ? y0 - d : d - y1;
            gradientsX[i] = Math.round((gradientX * 0.5 + 0.5) * 0xff);
            gradientsY[i] = Math.round((gradientY * 0.5 + 0.5) * 0xff);
        }
        return glyph;
    }
    _edt(data, x0, y0, width, height, gridSize, f, v, z) {
        for(let x = x0; x < x0 + width; x++)this._edt1d(data, y0 * gridSize + x, gridSize, height, f, v, z);
        for(let y = y0; y < y0 + height; y++)this._edt1d(data, y * gridSize + x0, 1, width, f, v, z);
    }
    _edt1d(grid, offset, stride, n, f, v, z) {
        v[0] = 0;
        z[0] = -Number.MAX_VALUE;
        z[1] = Number.MAX_VALUE;
        f[0] = grid[offset];
        for(let q = 1, k = 0, s = 0; q < n; q++){
            f[q] = grid[offset + q * stride];
            const q2 = q * q;
            do {
                const r = v[k];
                s = (f[q] - f[r] + q2 - r * r) / (q - r) / 2;
            }while (s <= z[k] && --k > -1);
            k++;
            v[k] = q;
            z[k] = s;
            z[k + 1] = Number.MAX_VALUE;
        }
        for(let q = 0, k = 0; q < n; q++){
            while(z[k + 1] < q)k++;
            const r = v[k];
            const qr = q - r;
            grid[offset + q * stride] = f[r] + qr * qr;
        }
    }
}



/*!
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 */ 

/*!
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 */ 


class $fe2e3fed887771f8$export$a1bb24b21e5c8dba {
    get manipulators() {
        return this._manipulators;
    }
    get count() {
        return this._count;
    }
    get isDragging() {
        return this._isDragging;
    }
    constructor(core){
        this._core = core;
        this._count = 0;
        this._centroid = (0, $31054a6c69637582$exports).create();
        this._previousCentroid = (0, $31054a6c69637582$exports).create();
        this._relativePositionToCentroid = (0, $31054a6c69637582$exports).create();
        this._directionToCentroid = (0, $31054a6c69637582$exports).create();
        this._previousDirectionToCentroid = (0, $31054a6c69637582$exports).create();
        this._manipulators = {};
        this._removedManipulators = [];
        this.cumulativeTranslation = (0, $31054a6c69637582$exports).create();
        this.translationDelta = (0, $31054a6c69637582$exports).create();
        this.centroid = (0, $31054a6c69637582$exports).create();
        this.maxScale = Number.MAX_VALUE;
        this.twistAxis = (0, $31054a6c69637582$exports).fromValues(0, 0, 1);
        this.initialize();
    }
    update(elapsedTime, manipulators) {
        for(const key in this._manipulators){
            const manipulator = this._manipulators[key];
            if (!manipulators[manipulator.id]) {
                if (this.removeManipulator) this.removeManipulator(manipulator);
                this._removedManipulators.push(manipulator.id);
            }
        }
        if (this._removedManipulators.length > 0) {
            for(let i = 0; i < this._removedManipulators.length; i++){
                delete this._manipulators[this._removedManipulators[i]];
                this._count--;
            }
            this._removedManipulators = [];
        }
        for(const key in manipulators){
            const manipulator = manipulators[key];
            if (!this._manipulators[manipulator.id]) {
                if (!this.addManipulator || this.addManipulator(manipulator)) {
                    (0, $31054a6c69637582$exports).copy(manipulator.initialPosition, manipulator.position);
                    this._manipulators[manipulator.id] = manipulator;
                    this._count++;
                }
            }
        }
        (0, $31054a6c69637582$exports).set(this.translationDelta, 0, 0, 0);
        this.scaleDelta = 0;
        this.twistDelta = 0;
        if (this._count > 0) {
            if (this._previousCount > 0) {
                if (this.prepareManipulation) this.prepareManipulation();
                this._process();
                if (this.processManipulation) this.processManipulation(elapsedTime);
            } else {
                this.initialize();
                if (this.beginManipulation) this.beginManipulation();
            }
        } else {
            if (this._previousCount > 0) {
                if (this.endManipulation) this.endManipulation();
            }
        }
        this._isDragging = this._count == 1 && (0, $31054a6c69637582$exports).squaredLength(this.cumulativeTranslation) > this._core.config.dragToleranceSquared || this._count > 1;
        this._previousCount = this._count;
    }
    initialize() {
        (0, $31054a6c69637582$exports).set(this.centroid, 0, 0, 0);
        (0, $31054a6c69637582$exports).set(this.cumulativeTranslation, 0, 0, 0);
        this.cumulativeScale = 1;
        this.cumulativeTwist = 0;
    }
    _process() {
        if (this._previousCount > 0) {
            let persisted = 0;
            for(const key in this._manipulators){
                const manipulator = this._manipulators[key];
                if (manipulator.isPersisted) persisted++;
            }
            const removed = this._previousCount - persisted;
            if (persisted > 0) {
                if (removed > 0) (0, $31054a6c69637582$exports).copy(this._centroid, this._previousCentroid);
                else {
                    (0, $31054a6c69637582$exports).set(this._centroid, 0, 0, 0);
                    for(const key in this._manipulators){
                        const manipulator = this._manipulators[key];
                        if (manipulator.isPersisted) (0, $31054a6c69637582$exports).add(this._centroid, this._centroid, manipulator.position);
                    }
                    (0, $31054a6c69637582$exports).scale(this._centroid, this._centroid, 1 / persisted);
                }
                for(const key in this._manipulators){
                    const manipulator = this._manipulators[key];
                    if (manipulator.isPersisted) {
                        manipulator.maxTranslationSquared = Math.max(manipulator.maxTranslationSquared, (0, $31054a6c69637582$exports).squaredDistance(manipulator.position, manipulator.initialPosition));
                        (0, $31054a6c69637582$exports).add(this.translationDelta, this.translationDelta, manipulator.position);
                        (0, $31054a6c69637582$exports).subtract(this.translationDelta, this.translationDelta, manipulator.previousPosition);
                        (0, $31054a6c69637582$exports).subtract(this._relativePositionToCentroid, manipulator.position, this._centroid);
                        const distanceToCentroidSquared = (0, $31054a6c69637582$exports).squaredLength(this._relativePositionToCentroid);
                        if (distanceToCentroidSquared < this._core.config.manipulatorMinRelativeDistanceSquared) this.scaleDelta += 1;
                        else {
                            const distanceToCentroid = Math.sqrt(distanceToCentroidSquared);
                            const previousDistanceToCentroidSquared = (0, $31054a6c69637582$exports).squaredLength(manipulator.previousPositionRelativeToCentroid);
                            const previousDistanceToCentroid = Math.sqrt(previousDistanceToCentroidSquared);
                            this.scaleDelta += distanceToCentroid / previousDistanceToCentroid;
                            (0, $31054a6c69637582$exports).scale(this._directionToCentroid, this._relativePositionToCentroid, 1 / distanceToCentroid);
                            (0, $31054a6c69637582$exports).scale(this._previousDirectionToCentroid, manipulator.previousPositionRelativeToCentroid, 1 / previousDistanceToCentroid);
                            this.twistDelta += (0, $a49c65c28e06311e$export$210d3b2db589eb5c).signedAngleBetweenVectors(this._previousDirectionToCentroid, this._directionToCentroid, this.twistAxis);
                        }
                    }
                }
                (0, $31054a6c69637582$exports).scale(this.translationDelta, this.translationDelta, 1 / persisted);
                (0, $31054a6c69637582$exports).add(this.cumulativeTranslation, this.cumulativeTranslation, this.translationDelta);
                this.scaleDelta /= persisted;
                this.cumulativeScale = (0, $2d4d1eb6f32f02f2$export$80a8c44b8858d625).clamp(this.cumulativeScale * this.scaleDelta, this.minScale, this.maxScale);
                this.scaleDelta -= 1;
                this.twistDelta /= persisted;
                this.cumulativeTwist += this.twistDelta;
            }
        }
        (0, $31054a6c69637582$exports).set(this.centroid, 0, 0, 0);
        for(const key in this._manipulators){
            const manipulator = this._manipulators[key];
            (0, $31054a6c69637582$exports).add(this.centroid, this.centroid, manipulator.position);
        }
        (0, $31054a6c69637582$exports).scale(this.centroid, this.centroid, 1 / this._count);
        for(const key in this._manipulators){
            const manipulator = this._manipulators[key];
            (0, $31054a6c69637582$exports).subtract(manipulator.positionRelativeToCentroid, manipulator.position, this.centroid);
        }
        (0, $31054a6c69637582$exports).copy(this._previousCentroid, this.centroid);
        for(const key in this._manipulators){
            const manipulator = this._manipulators[key];
            manipulator.isPersisted = true;
            (0, $31054a6c69637582$exports).copy(manipulator.previousPosition, manipulator.position);
            (0, $31054a6c69637582$exports).copy(manipulator.previousRotationAxis, manipulator.rotationAxis);
            (0, $31054a6c69637582$exports).copy(manipulator.previousPositionRelativeToCentroid, manipulator.positionRelativeToCentroid);
        }
    }
}


/*!
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 */ class $70fcce5652cf6320$export$25eea374d13151b1 {
    constructor(core){
        this._core = core;
        this._previousTotal = 0;
        this.total = 0;
    }
    initialize(element) {
        element.addEventListener("wheel", (e)=>{
            e.preventDefault();
            const wheelEvent = e;
            this.total += wheelEvent.deltaY;
        }, {
            passive: false
        });
    }
    update(elapsedTime) {
        const total = this.total;
        this.delta = total - this._previousTotal;
        this._previousTotal = total;
        if (this._core.config.isDebugVisible) this._core.debugText.addLine(`mse whl ${this.total < 0 ? "" : " "}${Math.round(this.total)}`);
    }
}


/*!
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 */ /*!
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 */ 
class $c2c210fed9a5e919$export$7a218bb03b109350 {
    constructor(){
        this.pickedIndex = 0;
        this.maxTranslationSquared = 0;
        this.initialPosition = (0, $31054a6c69637582$exports).create();
        this.position = (0, $31054a6c69637582$exports).create();
        this.previousPosition = (0, $31054a6c69637582$exports).create();
        this.holdOrigin = (0, $31054a6c69637582$exports).create();
        this.positionRelativeToCentroid = (0, $31054a6c69637582$exports).create();
        this.previousPositionRelativeToCentroid = (0, $31054a6c69637582$exports).create();
        this.rotationAxis = (0, $31054a6c69637582$exports).create();
        this.previousRotationAxis = (0, $31054a6c69637582$exports).create();
    }
}


class $0cfca151d38bf5a7$export$6412482d5070c3e5 {
    get hoverX() {
        return this._hoverX;
    }
    get hoverY() {
        return this._hoverY;
    }
    get hoverId() {
        return this._hoverId;
    }
    constructor(core, manipulators){
        this._core = core;
        this._manipulators = manipulators;
    }
    initialize(element) {
        this._element = element;
        element.addEventListener("pointerdown", (e)=>this._handlePointerDown(e), {
            passive: true
        });
        element.addEventListener("pointermove", (e)=>this._handlePointerMove(e), {
            passive: true
        });
        element.addEventListener("pointerup", (e)=>this._handlePointerUp(e), {
            passive: true
        });
        element.addEventListener("pointercancel", (e)=>this._handlePointerCancel(e), {
            passive: true
        });
        element.addEventListener("pointerleave", (e)=>this._handlePointerLeave(e), {
            passive: true
        });
        element.addEventListener("pointerout", (e)=>this._handlePointerOut(e), {
            passive: true
        });
    }
    update(elapsedTime) {
        if (this._core.config.isDebugVisible) {
            this._core.debugText.addLine(`pen rot  ${(this._tiltX | 0).toFixed(3)},${(this._tiltY | 0).toFixed(3)},${(this._twist | 0).toFixed(3)}`);
            this._core.debugText.addLine(`hov pos  ${this.hoverX ? `${this.hoverX.toFixed(3)},${this.hoverY.toFixed(3)}px` : ""}`);
        }
    }
    _handlePointerDown(e) {
        this._element.focus();
        const devicePixelRatio = this._core.renderer.devicePixelRatio;
        const manipulator = new (0, $c2c210fed9a5e919$export$7a218bb03b109350)();
        const id = e.pointerId;
        const x = e.offsetX * devicePixelRatio;
        const y = e.offsetY * devicePixelRatio;
        manipulator.id = id;
        manipulator.position[0] = x;
        manipulator.position[1] = y;
        manipulator.type = e.pointerType;
        manipulator.button = e.button;
        manipulator.shiftKey = e.shiftKey;
        manipulator.ctrlKey = e.ctrlKey;
        manipulator.altKey = e.altKey;
        manipulator.event = e;
        this._manipulators[id] = manipulator;
        this._hoverId = id;
        this._hoverX = x;
        this._hoverY = y;
    }
    _handlePointerMove(e) {
        const devicePixelRatio = this._core.renderer.devicePixelRatio;
        const x = e.offsetX * devicePixelRatio;
        const y = e.offsetY * devicePixelRatio;
        const id = e.pointerId;
        const manipulator = this._manipulators[id];
        if (manipulator) {
            manipulator.position[0] = x;
            manipulator.position[1] = y;
            manipulator.event = e;
        }
        switch(e.pointerType){
            case "mouse":
                this._hoverId = id;
                this._hoverX = x;
                this._hoverY = y;
                break;
            case "pen":
                this._hoverId = id;
                this._hoverX = x;
                this._hoverY = y;
                this._tiltX = e.tiltX;
                this._tiltY = e.tiltY;
                this._twist = e.twist;
                break;
        }
    }
    _handlePointerUp(e) {
        const manipulator = this._manipulators[e.pointerId];
        if (manipulator) manipulator.event = e;
        this._remove(e.pointerId);
    }
    _handlePointerCancel(e) {
        this._remove(e.pointerId);
    }
    _handlePointerLeave(e) {
        this._resetHover();
        this._remove(e.pointerId);
    }
    _handlePointerOut(e) {
        this._resetHover();
        this._remove(e.pointerId);
    }
    _resetHover() {
        this._hoverId = null;
        this._hoverX = null;
        this._hoverY = null;
    }
    _remove(pointerId) {
        const manipulator = this._manipulators[pointerId];
        if (manipulator) delete this._manipulators[pointerId];
    }
}


/*!
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 */ 
class $cc0e5bcb75088eeb$export$f1c8488f7ae08606 {
    static smoothStep(value) {
        return value * value * (3 - 2 * value);
    }
    static damp(value, target, threshold, dampening) {
        if (Math.abs(target) < threshold) return (0, $2d4d1eb6f32f02f2$export$80a8c44b8858d625).lerp(value, 0, dampening);
        else return (0, $2d4d1eb6f32f02f2$export$80a8c44b8858d625).lerp(value, target, dampening);
    }
}



/*!
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 */ class $1db11aa593bd11cd$export$16e4d70cc375e707 {
    constructor(core){
        this._core = core;
        this._pressedKeys = new Set();
        this._previousPressedKeys = new Set();
    }
    initialize(element) {
        element.addEventListener("keydown", (e)=>{
            this._handleKeyDown(e);
        }, false);
        element.addEventListener("keyup", (e)=>{
            this._handleKeyUp(e);
        }, false);
    }
    update(elapsedTime) {
        if (this._core.config.isDebugVisible) this._core.debugText.addLine(`key tot  ${this._pressedKeys.size}`);
    }
    isKeyDown(key) {
        return this._pressedKeys.has(key);
    }
    wasKeyReleased(key) {
        if (this._pressedKeys.has(key)) {
            if (!this._previousPressedKeys.has(key)) {
                this._previousPressedKeys.add(key);
                return true;
            }
        } else this._previousPressedKeys.delete(key);
        return false;
    }
    _handleKeyDown(e) {
        const keyboardEvent = e;
        const key = keyboardEvent.key;
        if (!this._pressedKeys.has(key)) this._pressedKeys.add(key);
    }
    _handleKeyUp(e) {
        const keyboardEvent = e;
        const key = keyboardEvent.key;
        if (this._pressedKeys.has(key)) this._pressedKeys.delete(key);
    }
}


class $942e14c8121accda$export$d0d38e7dec7a1a61 {
    constructor(core){
        this._manipulators = {};
        this._core = core;
        this._vec3 = (0, $31054a6c69637582$exports).create();
        this._manipulationProcessor = new (0, $fe2e3fed887771f8$export$a1bb24b21e5c8dba)(core);
        this._manipulators = {};
        this._pointers = new (0, $0cfca151d38bf5a7$export$6412482d5070c3e5)(core, this._manipulators);
        this._pointers.initialize(core.container);
        this._mouseWheel = new (0, $70fcce5652cf6320$export$25eea374d13151b1)(core);
        this._mouseWheel.initialize(core.container);
        this._keyboard = new (0, $1db11aa593bd11cd$export$16e4d70cc375e707)(core);
        this._keyboard.initialize(core.container);
        this.isPickingEnabled = true;
        this.mouseWheelZoomScale = this._core.config.mouseWheelZoomScale;
        this.mouseWheelRotationScale = this._core.config.mouseWheelRotationScale;
        this.multiTouchZoomScale = this._core.config.multiTouchZoomScale;
        this.pickHoldDelay = this._core.config.pickHoldDelay;
        this.pickSelectDelay = this._core.config.pickSelectDelay;
        const rightButton = 2;
        this.singleTouchAction = (manipulator)=>{
            if (manipulator.type == "mouse" && manipulator.button == rightButton || manipulator.shiftKey || manipulator.ctrlKey) return (0, $4a6417d29706362f$export$226dc1249c607930).translate;
            else if (manipulator.altKey || manipulator.type == "pen" && manipulator.button == rightButton) return (0, $4a6417d29706362f$export$226dc1249c607930).lasso;
            else return (0, $4a6417d29706362f$export$226dc1249c607930).rotate;
        };
        this.mouseWheelAction = (keyboard)=>{
            if (this._keyboard.isKeyDown("Control")) return (0, $4a6417d29706362f$export$335c7d069643eb6d).rotateY;
            else return (0, $4a6417d29706362f$export$335c7d069643eb6d).zoom;
        };
        this.lassoPickType = (0, $4a6417d29706362f$export$6fc3f4da94ff0be0).data;
        this._thumbstickX = 0;
        this._previousControllerButtonPressed = [
            false,
            false,
            false,
            false
        ];
        this._quat0 = (0, $39ece26d1239bb77$exports).create();
        this._quat1 = (0, $39ece26d1239bb77$exports).create();
    }
    update(elapsedTime, xrFrame) {
        if (xrFrame) {
            const inputSources = this._core.webXRSession.inputSources;
            if (inputSources.length > 0 && this._core.renderer.controllers.length > 0) {
                const inputSource = inputSources[0];
                const controllerVisual = this._core.renderer.controllers[0];
                if (inputSource.gripSpace && inputSource.targetRayMode == "tracked-pointer") {
                    const gripPose = xrFrame.getPose(inputSource.gripSpace, this._core.renderer.webXRReferenceSpace);
                    if (gripPose) controllerVisual.mMatrix = gripPose.transform.matrix;
                    const gamepad = inputSource.gamepad;
                    this._core.renderer.isPickingEnabled = false;
                    const rayPose = xrFrame.getPose(inputSource.targetRaySpace, this._core.renderer.webXRReferenceSpace);
                    if (rayPose) {
                        controllerVisual.rayMMatrix = rayPose.transform.matrix;
                        if (gamepad.buttons[0].value > 0 && this.isPickingEnabled) {
                            this._core.renderer.pickVMatrix = rayPose.transform.inverse.matrix;
                            this._core.renderer.isPickingEnabled = true;
                        }
                    }
                    const threshold = 0.2;
                    const dampening = Math.min(0.015 * elapsedTime, 1);
                    this._thumbstickX = (0, $cc0e5bcb75088eeb$export$f1c8488f7ae08606).damp(this._thumbstickX, gamepad.axes[2], threshold, dampening);
                    if (this._thumbstickX != 0) {
                        (0, $39ece26d1239bb77$exports).setAxisAngle(this._quat0, (0, $d4d7bd6cc65a5081$export$a002182e51710d39).VECTOR3_UNITY, 0.01 * this._thumbstickX * elapsedTime);
                        this._core.getModelRotation(this._quat1);
                        (0, $39ece26d1239bb77$exports).multiply(this._quat1, this._quat0, this._quat1);
                        this._core.setModelRotation(this._quat1, true);
                    }
                    if (gamepad.buttons[2].pressed) {
                        if (!this._previousControllerButtonPressed[2]) {
                            this._previousControllerButtonPressed[2] = true;
                            if (this.controllerButtonPressedCallback) this.controllerButtonPressedCallback(2);
                        }
                    } else this._previousControllerButtonPressed[2] = false;
                }
            }
        } else {
            const camera = this._core.camera;
            this._manipulationProcessor.update(elapsedTime, this._manipulators);
            this._pointers.update(elapsedTime);
            this._mouseWheel.update(elapsedTime);
            this._keyboard.update(elapsedTime);
            if (this._mouseWheel.delta != 0) switch(this.mouseWheelAction(this._keyboard)){
                case (0, $4a6417d29706362f$export$335c7d069643eb6d).zoom:
                    if (this._pointers.hoverX, this._pointers.hoverY) camera.zoom(this._mouseWheel.delta * this.mouseWheelZoomScale, this._pointers.hoverX, this._pointers.hoverY);
                    break;
                case (0, $4a6417d29706362f$export$335c7d069643eb6d).rotateY:
                    (0, $39ece26d1239bb77$exports).setAxisAngle(this._quat0, (0, $d4d7bd6cc65a5081$export$a002182e51710d39).VECTOR3_UNITY, this._mouseWheel.delta * this.mouseWheelRotationScale);
                    camera.getOrbit(this._quat1);
                    (0, $39ece26d1239bb77$exports).multiply(this._quat1, this._quat1, this._quat0);
                    camera.setOrbit(this._quat1, true);
                    break;
            }
            const count = this._manipulationProcessor.count;
            if (count == 0) {
                if (this._isLassoPicking) {
                    this._isLassoPicking = false;
                    this._core.renderer.isLassoPicking = false;
                    const x0 = Math.min(this._lassoX0, this._lassoX1);
                    const y0 = Math.min(this._lassoY0, this._lassoY1);
                    const x1 = Math.max(this._lassoX0, this._lassoX1);
                    const y1 = Math.max(this._lassoY0, this._lassoY1);
                    if (x1 - x0 > 0 && y1 - y0 > 0) {
                        const sets = this._core.pickLasso(x0, y0, x1, y1, this.lassoPickType);
                        const result = {
                            x0: x0,
                            y0: y0,
                            x1: x1,
                            y1: y1,
                            pickType: this.lassoPickType,
                            ids: sets,
                            manipulator: this._manipulator
                        };
                        this.pickLassoCallback(result);
                    }
                }
            } else if (count == 1) {
                const translationDelta = this._manipulationProcessor.translationDelta;
                if (translationDelta[0] != 0 || translationDelta[1] != 0) {
                    const manipulators = this._manipulationProcessor.manipulators;
                    for(const key in manipulators){
                        const manipulator = manipulators[key];
                        switch(this.singleTouchAction(manipulator)){
                            case (0, $4a6417d29706362f$export$226dc1249c607930).rotate:
                                camera.rotate(translationDelta);
                                break;
                            case (0, $4a6417d29706362f$export$226dc1249c607930).translate:
                                camera.translate(translationDelta);
                                break;
                            case (0, $4a6417d29706362f$export$226dc1249c607930).lasso:
                                if (this.pickLassoCallback) {
                                    if (!this._isLassoPicking) {
                                        this._isLassoPicking = true;
                                        this._core.renderer.isLassoPicking = true;
                                        this._lassoX0 = manipulator.position[0];
                                        this._lassoY0 = manipulator.position[1];
                                    }
                                    this._lassoX1 = manipulator.position[0];
                                    this._lassoY1 = manipulator.position[1];
                                    this._core.renderer.lassoX0 = Math.min(this._lassoX0, this._lassoX1);
                                    this._core.renderer.lassoY0 = Math.min(this._lassoY0, this._lassoY1);
                                    this._core.renderer.lassoX1 = Math.max(this._lassoX0, this._lassoX1);
                                    this._core.renderer.lassoY1 = Math.max(this._lassoY0, this._lassoY1);
                                }
                                break;
                        }
                        break;
                    }
                }
            } else {
                const translationDelta = this._manipulationProcessor.translationDelta;
                const camera = this._core.camera;
                if (translationDelta[0] != 0 || translationDelta[1] != 0) camera.translate(translationDelta);
                if (this._manipulationProcessor.scaleDelta != 0) {
                    const distance = this._manipulationProcessor.scaleDelta * this.multiTouchZoomScale;
                    camera.zoom(distance, this._manipulationProcessor.centroid[0], this._manipulationProcessor.centroid[1]);
                }
                if (this._manipulationProcessor.twistDelta != 0) camera.twist(this._manipulationProcessor.twistDelta, this._manipulationProcessor.centroid[0], this._manipulationProcessor.centroid[1]);
            }
            if (this.isPickingEnabled && !this._manipulationProcessor.isDragging && !this._isLassoPicking) {
                const camera = this._core.camera;
                const renderer = this._core.renderer;
                if (renderer.isCapturingPickImage) {
                    camera.updatePickVMatrix(renderer.width / 2, renderer.height / 2);
                    renderer.pickVMatrix = camera.pickVMatrix;
                    renderer.isPickingEnabled = true;
                    this._pickedTime = 0;
                } else if (this._pointers.hoverId > -1) {
                    const pickingX = this._pointers.hoverX;
                    const pickingY = this._pointers.hoverY;
                    camera.updatePickVMatrix(pickingX, pickingY);
                    renderer.pickVMatrix = camera.pickVMatrix;
                    renderer.isPickingEnabled = true;
                    if (this._pickedId != renderer.pickedId) {
                        this._pickedId = renderer.pickedId;
                        this._pickedTime = 0;
                    } else if (this._manipulationProcessor.count == 1) {
                        this._pickedTime += elapsedTime;
                        for(const key in this._manipulators){
                            this._manipulator = this._manipulators[key];
                            break;
                        }
                    }
                    if (this._pickedTime > 0) switch(renderer.pickedType){
                        case (0, $4a6417d29706362f$export$6fc3f4da94ff0be0).data:
                            if (this._pickedTime > this.pickHoldDelay) {
                                renderer.getVertexPosition(this._vec3, this._pickedId);
                                this._core.setModelManipulationOrigin(this._vec3);
                                this._pickedTime = 0;
                            } else if (this._manipulationProcessor.count == 0) {
                                if (this._pickedTime > this.pickSelectDelay) for(let i = 0; i < renderer.transitionBuffers.length; i++){
                                    const transitionBuffer = renderer.transitionBuffers[i];
                                    const id = transitionBuffer.pickIdLookup[this._pickedId];
                                    if (id > -1) {
                                        const result = {
                                            transitionBuffer: i,
                                            id: id,
                                            manipulator: this._manipulator
                                        };
                                        this._core.log.write((0, $4a6417d29706362f$export$243e62d78d3b544d).info, `picked id ${result.id}, transition buffer ${i}`);
                                        if (this.pickItemCallback) this.pickItemCallback(result);
                                        break;
                                    }
                                }
                                this._pickedTime = 0;
                            }
                            break;
                        case (0, $4a6417d29706362f$export$6fc3f4da94ff0be0).label:
                            if (this._manipulationProcessor.count == 0) {
                                if (this._pickedTime > this.pickSelectDelay) for(let i = 0; i < renderer.labelSets.length; i++){
                                    const labelSet = renderer.labelSets[i].label;
                                    const id = labelSet.pickIdLookup[this._pickedId];
                                    if (id > -1) {
                                        const result = {
                                            label: id,
                                            set: i,
                                            manipulator: this._manipulator
                                        };
                                        this._core.log.write((0, $4a6417d29706362f$export$243e62d78d3b544d).info, `picked label ${result.label}, set ${result.set}`);
                                        if (this.pickLabelSetCallback) this.pickLabelSetCallback(result);
                                        break;
                                    }
                                }
                                this._pickedTime = 0;
                            }
                            break;
                        case (0, $4a6417d29706362f$export$6fc3f4da94ff0be0).axesDivision:
                            if (this._manipulationProcessor.count == 0) {
                                if (this._pickedTime > this.pickSelectDelay) for(let i = 0; i < renderer.currentAxes.length; i++){
                                    const axes = renderer.currentAxes[i].axes;
                                    const id = axes.pickGridLookup[this._pickedId];
                                    if (id > -1) {
                                        const result = axes.pickGrid(id);
                                        result.axes = i;
                                        result.manipulator = this._manipulator;
                                        this._core.log.write((0, $4a6417d29706362f$export$243e62d78d3b544d).info, `picked division (${result.divisionX}, ${result.divisionY}, ${result.divisionZ}), axes ${result.axes}`);
                                        if (this.pickAxesGridCallback) this.pickAxesGridCallback(result);
                                        break;
                                    }
                                }
                                this._pickedTime = 0;
                            }
                            break;
                        case (0, $4a6417d29706362f$export$6fc3f4da94ff0be0).axesTitle:
                            if (this._manipulationProcessor.count == 0) {
                                if (this._pickedTime > this.pickSelectDelay) for(let i = 0; i < renderer.currentAxes.length; i++){
                                    const axes = renderer.currentAxes[i].axes;
                                    const id = axes.pickTitleLookup[this._pickedId];
                                    if (id > -1) {
                                        const result = axes.pickTitle(id);
                                        result.axes = i;
                                        result.manipulator = this._manipulator;
                                        this._core.log.write((0, $4a6417d29706362f$export$243e62d78d3b544d).info, `picked title ${result.axis}, axes ${result.axes}`);
                                        if (this.pickAxesTitleCallback) this.pickAxesTitleCallback(result);
                                        break;
                                    }
                                }
                                this._pickedTime = 0;
                            }
                            break;
                        case (0, $4a6417d29706362f$export$6fc3f4da94ff0be0).axesLabel:
                            if (this._manipulationProcessor.count == 0) {
                                if (this._pickedTime > this.pickSelectDelay) for(let i = 0; i < renderer.currentAxes.length; i++){
                                    const axes = renderer.currentAxes[i].axes;
                                    const id = axes.pickLabelLookup[this._pickedId];
                                    if (id > -1) {
                                        const result = axes.pickLabel(id);
                                        result.axes = i;
                                        result.manipulator = this._manipulator;
                                        this._core.log.write((0, $4a6417d29706362f$export$243e62d78d3b544d).info, `picked label ${result.label}, axis ${result.axis}, axes ${result.axes}`);
                                        if (this.pickAxesLabelCallback) this.pickAxesLabelCallback(result);
                                        break;
                                    }
                                }
                                this._pickedTime = 0;
                            }
                            break;
                        case (0, $4a6417d29706362f$export$6fc3f4da94ff0be0).axesHeading:
                            if (this._manipulationProcessor.count == 0) {
                                if (this._pickedTime > this.pickSelectDelay) for(let i = 0; i < renderer.currentAxes.length; i++){
                                    const axes = renderer.currentAxes[i].axes;
                                    const id = axes.pickHeadingLookup[this._pickedId];
                                    if (id > -1) {
                                        const result = axes.pickHeading(id);
                                        result.axes = i;
                                        result.manipulator = this._manipulator;
                                        this._core.log.write((0, $4a6417d29706362f$export$243e62d78d3b544d).info, `picked heading ${result.axis}, axes ${result.axes}`);
                                        if (this.pickAxesHeadingCallback) this.pickAxesHeadingCallback(result);
                                        break;
                                    }
                                }
                                this._pickedTime = 0;
                            }
                            break;
                    }
                } else {
                    renderer.isPickingEnabled = false;
                    this._pickedTime = 0;
                }
            } else {
                this._core.renderer.isPickingEnabled = false;
                this._pickedTime = 0;
            }
        }
        if (this._core.config.isDebugVisible) {
            this._core.debugText.addLine(`man tot  ${this._manipulationProcessor.count}`);
            this._core.debugText.addLine(`pck key  ${this._core.renderer.pickedId}`);
        }
    }
}


/*!
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 */ 
class $470791aaa8c4f15b$export$ce30dbb46644d06c {
    constructor(core){
        this._core = core;
    }
    write(level, value) {
        if (level >= this._core.config.logLevel) switch(level){
            case (0, $4a6417d29706362f$export$243e62d78d3b544d).trace:
                console.trace(value);
                break;
            case (0, $4a6417d29706362f$export$243e62d78d3b544d).debug:
                console.debug(value);
                break;
            case (0, $4a6417d29706362f$export$243e62d78d3b544d).info:
                console.info(value);
                break;
            case (0, $4a6417d29706362f$export$243e62d78d3b544d).warn:
                console.warn(value);
                break;
            case (0, $4a6417d29706362f$export$243e62d78d3b544d).error:
                console.error(value);
                break;
        }
    }
}



var $4a6417d29706362f$var$__awaiter = undefined && undefined.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
            resolve(value);
        });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
            try {
                step(generator.next(value));
            } catch (e) {
                reject(e);
            }
        }
        function rejected(value) {
            try {
                step(generator["throw"](value));
            } catch (e) {
                reject(e);
            }
        }
        function step(result) {
            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
class $4a6417d29706362f$export$9ebbd251760e4895 {
    constructor(core){
        this.position = (0, $31054a6c69637582$exports).create();
        this.manipulationOrigin = (0, $31054a6c69637582$exports).create();
        this.rotation = (0, $39ece26d1239bb77$exports).create();
        (0, $31054a6c69637582$exports).set(this.position, 0, 0, -core.config.modelDistance);
        this.scale = core.config.modelSize;
    }
}
class $4a6417d29706362f$export$4143ab5b91744744 {
    get container() {
        return this._container;
    }
    get started() {
        return this._started;
    }
    get debugText() {
        return this._debugText;
    }
    get log() {
        return this._log;
    }
    get totalFrames() {
        return this._fps.totalFrames;
    }
    get camera() {
        return this._camera;
    }
    set camera(value) {
        this._camera = value;
    }
    getModelRotation(value) {
        (0, $39ece26d1239bb77$exports).copy(value, this._modelRotation);
    }
    setModelRotation(value, isSmooth) {
        (0, $39ece26d1239bb77$exports).copy(this._modelRotation, value);
        if (!isSmooth) (0, $39ece26d1239bb77$exports).copy(this._smoothedModelRotation, this._modelRotation);
    }
    getModelScale() {
        return this._modelScale[0];
    }
    setModelScale(value, isSmooth) {
        (0, $31054a6c69637582$exports).set(this._modelScale, value, value, value);
        if (!isSmooth) (0, $31054a6c69637582$exports).copy(this._smoothedModelScale, this._modelScale);
    }
    getModelManipulationOrigin(value) {
        (0, $31054a6c69637582$exports).copy(value, this._modelManipulationOrigin);
    }
    setModelManipulationOrigin(value) {
        this._updateManipulationOrigin(value);
    }
    getModelPosition(value) {
        (0, $31054a6c69637582$exports).copy(value, this._modelPosition);
    }
    setModelPosition(value, isSmooth) {
        (0, $31054a6c69637582$exports).copy(this._modelPosition, value);
        if (!isSmooth) (0, $31054a6c69637582$exports).copy(this._smoothedModelPosition, this._modelPosition);
    }
    get webXRSession() {
        return this._webXRSession;
    }
    get renderer() {
        return this._renderer;
    }
    set renderer(renderer) {
        if (this._renderer == renderer) return;
        if (this._renderer) {
            this.stop();
            this._renderer.remove();
        }
        if (!renderer.isInitialized) renderer.initialize(this);
        if (this._renderer) {
            renderer.transitionTime = this._renderer.transitionTime;
            for(let i = 0; i < this._renderer.transitionBuffers.length; i++){
                const previousTransitionBuffer = this._renderer.transitionBuffers[i];
                const transitionBuffer = renderer.createTransitionBuffer(previousTransitionBuffer.currentBuffer.ids);
                transitionBuffer.copyFrom(previousTransitionBuffer);
                renderer.transitionBuffers.push(transitionBuffer);
            }
            const currentAxes = this._renderer.currentAxes;
            if (currentAxes) {
                renderer.currentAxes = [];
                for(let i = 0; i < currentAxes.length; i++){
                    const axesVisual = currentAxes[i];
                    const axes = axesVisual.axes;
                    if (axes instanceof (0, $4cd1e156df302e7a$export$b1b08d445768978)) {
                        const cartesian3dAxesVisual = renderer.createCartesian3dAxesVisual(axes);
                        renderer.currentAxes.push(cartesian3dAxesVisual);
                    } else if (axes instanceof (0, $28691cf6913948f8$export$e3e79a454e5f8e5a)) renderer.currentAxes.push(renderer.createCartesian2dAxesVisual(axes));
                }
            }
            const labelSets = this._renderer.labelSets;
            if (labelSets) {
                renderer.labelSets = [];
                for(let i = 0; i < labelSets.length; i++)renderer.labelSets.push(renderer.createLabelSetVisual(labelSets[i].label));
            }
            const images = this._renderer.images;
            if (images) {
                renderer.images = [];
                for(let i = 0; i < images.length; i++)renderer.images.push(renderer.createImageVisual(images[i].image));
            }
            const fonts = this._renderer.fonts;
            if (fonts) for(const key in fonts){
                const font = fonts[key].font;
                renderer.fonts[font.name] = renderer.createFontVisual(font);
            }
        } else renderer.fonts[this._font.name] = renderer.createFontVisual(this._font);
        if (this._renderer) this._renderer.finalize();
        this._renderer = renderer;
        this._fps.reset();
        this.start();
    }
    get font() {
        return this._font;
    }
    get paletteResources() {
        return this._paletteResources;
    }
    get config() {
        return this._config;
    }
    get inputManager() {
        return this._inputManager;
    }
    constructor(options){
        (0, $14f38b7dd89457d7$exports).setMatrixArrayType(Array);
        this._vec3 = (0, $31054a6c69637582$exports).create();
        this._quat = (0, $39ece26d1239bb77$exports).create();
        this._mat4 = (0, $1ac1b59392edf35b$exports).create();
        this._container = options && options.container ? options.container : document.body;
        this._config = new (0, $3c8e74dd6c09e751$export$29cd7b75162a9425)(this);
        this._log = new (0, $470791aaa8c4f15b$export$ce30dbb46644d06c)(this);
        this._debugText = new (0, $eea2540484261ac0$export$3d1f12550a40f54d)();
        this._inputManager = options && options.useInputManager === false ? null : new (0, $942e14c8121accda$export$d0d38e7dec7a1a61)(this);
        const fontRasterizerOptions = options && options.fontRasterizerOptions ? options.fontRasterizerOptions : {
            fontAtlas: new (0, $f690fa88528736e9$export$834e93b4abb19d0a)(256, 512),
            fontSize: 24,
            border: 3,
            fontFamily: "\"segoe ui semibold\", sans-serif",
            fontWeight: "normal",
            fontStyle: "normal",
            baseline: "alphabetic",
            maxDistance: 8,
            edgeValue: 0xc0
        };
        const fontRasterizer = new (0, $f690fa88528736e9$export$9cdd7c9f8d056e99)(this, fontRasterizerOptions);
        this._font = fontRasterizer.font;
        this._paletteResources = new (0, $548ced3eab978a8c$export$35624e624bb61356)();
        this._previousTime = 0;
        this._fps = new (0, $f25ed8c17e63c6a4$export$6e55b0a28cfdaa88)(this);
        this._modelMMatrix = (0, $1ac1b59392edf35b$exports).create();
        this._modelPosition = (0, $31054a6c69637582$exports).create();
        this._modelRotation = (0, $39ece26d1239bb77$exports).create();
        this._modelScale = (0, $31054a6c69637582$exports).create();
        this._smoothedModelPosition = (0, $31054a6c69637582$exports).create();
        this._smoothedModelRotation = (0, $39ece26d1239bb77$exports).create();
        this._smoothedModelScale = (0, $31054a6c69637582$exports).create();
        this._modelManipulationOrigin = (0, $31054a6c69637582$exports).create();
        this._camera = new (0, $242ad176fe12a941$export$cf22ae31f9260ad2)(this);
        this.resetModel(false);
    }
    getView(view) {
        this.getModelPosition(view.position);
        this.getModelRotation(view.rotation);
        view.scale = this.getModelScale();
    }
    setView(view, isSmooth) {
        this.setModelPosition(view.position, isSmooth);
        this.setModelRotation(view.rotation, isSmooth);
        this.setModelScale(view.scale, isSmooth);
    }
    lerpView(from, to, time) {
        (0, $31054a6c69637582$exports).lerp(this._vec3, from.position, to.position, time);
        this.setModelPosition(this._vec3, false);
        (0, $39ece26d1239bb77$exports).slerp(this._quat, from.rotation, to.rotation, time);
        this.setModelRotation(this._quat, false);
        this.setModelScale((0, $2d4d1eb6f32f02f2$export$80a8c44b8858d625).lerp(from.scale, to.scale, time), false);
    }
    resetModel(isSmooth) {
        (0, $31054a6c69637582$exports).set(this._modelPosition, 0, 0, -this._config.modelDistance);
        (0, $31054a6c69637582$exports).set(this._modelScale, this._config.modelSize, this._config.modelSize, this._config.modelSize);
        (0, $39ece26d1239bb77$exports).set(this._modelRotation, 0, 0, 0, 1);
        if (!isSmooth) this._syncSmooth();
    }
    resetManipulationOrigin() {
        if (!(0, $31054a6c69637582$exports).exactEquals(this._modelManipulationOrigin, (0, $d4d7bd6cc65a5081$export$a002182e51710d39).VECTOR3_ZERO)) this._updateManipulationOrigin((0, $d4d7bd6cc65a5081$export$a002182e51710d39).VECTOR3_ZERO);
    }
    reset(isSmooth) {
        this.resetModel(isSmooth);
        this.resetManipulationOrigin();
        this._camera.reset(isSmooth);
    }
    start() {
        if (!this._started && this._renderer) {
            this._windowAnimationFrame = window.requestAnimationFrame((currentTime)=>this._tick(currentTime));
            this._started = true;
            this._log.write($4a6417d29706362f$export$243e62d78d3b544d.info, "render loop started");
            if (this.startCallback) this.startCallback();
        }
    }
    stop() {
        if (this._started) {
            this._started = false;
            if (this._windowAnimationFrame != null) {
                window.cancelAnimationFrame(this._windowAnimationFrame);
                this._windowAnimationFrame = null;
                this._log.write($4a6417d29706362f$export$243e62d78d3b544d.info, "render loop stopped");
            }
            if (this.stopCallback) this.stopCallback();
        }
    }
    checkWebXRSupport() {
        const xrSystem = navigator.xr;
        if (xrSystem) xrSystem.isSessionSupported("immersive-vr").then((supported)=>{
            if (supported) {
                this._log.write($4a6417d29706362f$export$243e62d78d3b544d.info, "WebXR supported");
                if (this.webXRSupportedCallback) this.webXRSupportedCallback();
            }
        });
    }
    requestWebXRSession() {
        if (this._webXRSession) this._webXRSession.end();
        else navigator.xr.requestSession("immersive-vr").then((session)=>this._webXRSessionStarted(session));
    }
    _webXRSessionStarted(session) {
        if (this.webXRSessionStartedCallback) this.webXRSessionStartedCallback();
        this._webXRSession = session;
        session.onend = ()=>this._webXRSessionEnded();
        this._renderer.initializeWebXR(session).then(()=>{
            if (this._windowAnimationFrame) {
                window.cancelAnimationFrame(this._windowAnimationFrame);
                this._windowAnimationFrame = null;
            }
            session.requestAnimationFrame((currentTime, xrframe)=>this._tick(currentTime, xrframe));
        });
        session.oninputsourceschange = (event)=>this._webXRInputSourcesChanged(event);
    }
    _webXRSessionEnded() {
        if (this.webXRSessionEndedCallback) this.webXRSessionEndedCallback();
        this._webXRSession = null;
        this._renderer.controllers.length = 0;
        this.start();
    }
    _webXRInputSourcesChanged(event) {
        if (event.added.length > 0) {
            const added = event.added[0];
            if (added.targetRayMode == "tracked-pointer") {
                const profiles = added.profiles;
                const handedness = added.handedness;
                if (this.webXRInputSourceRequestCallback) this.webXRInputSourceRequestCallback(profiles, handedness, (response)=>{
                    const options = {
                        profiles: profiles,
                        handedness: handedness,
                        obj: response.obj,
                        texture: response.texture
                    };
                    const controller = new (0, $6c3dd367ac3ca617$export$bd0bf19f25da8474)(this, options);
                    this.renderer.controllers.push(this.renderer.createControllerVisual(controller));
                }, (e)=>{
                    this._log.write($4a6417d29706362f$export$243e62d78d3b544d.error, e);
                });
                else {
                    const options = {};
                    const controller = new (0, $6c3dd367ac3ca617$export$bd0bf19f25da8474)(this, options);
                    this.renderer.controllers.push(this.renderer.createControllerVisual(controller));
                }
            }
        }
        if (event.removed.length > 0) this.renderer.controllers.length = 0;
    }
    _tick(currentTime, xrFrame) {
        return $4a6417d29706362f$var$__awaiter(this, void 0, void 0, function*() {
            let elapsedTime = currentTime - this._previousTime;
            this._previousTime = currentTime;
            if (elapsedTime > 0) {
                this.update(elapsedTime, xrFrame);
                yield this.render(elapsedTime, xrFrame);
            }
            if (xrFrame) xrFrame.session.requestAnimationFrame((currentTime, xrframe)=>this._tick(currentTime, xrframe));
            else if (this._started) this._windowAnimationFrame = window.requestAnimationFrame((currentTime)=>this._tick(currentTime));
        });
    }
    update(elapsedTime, xrFrame) {
        this._renderer.setSize(elapsedTime);
        if (this.updateCallback) this.updateCallback(elapsedTime, xrFrame);
        if (this._config.isDebugVisible) this._debugText.clear();
        this._fps.update(elapsedTime);
        if (this._inputManager) {
            this._inputManager.isPickingEnabled = this._config.isTransitionPickingEnabled || this._renderer.transitionTime == 1;
            this._inputManager.update(elapsedTime, xrFrame);
        }
        let amount = Math.min(elapsedTime * this._config.positionSmoothing, 1);
        (0, $31054a6c69637582$exports).lerp(this._smoothedModelPosition, this._smoothedModelPosition, this._modelPosition, amount);
        amount = Math.min(elapsedTime * this._config.rotationSmoothing, 1);
        (0, $39ece26d1239bb77$exports).slerp(this._smoothedModelRotation, this._smoothedModelRotation, this._modelRotation, amount);
        amount = Math.min(elapsedTime * this._config.scaleSmoothing, 1);
        (0, $31054a6c69637582$exports).lerp(this._smoothedModelScale, this._smoothedModelScale, this._modelScale, amount);
        (0, $1ac1b59392edf35b$exports).fromRotationTranslationScaleOrigin(this._modelMMatrix, this._smoothedModelRotation, this._smoothedModelPosition, this._smoothedModelScale, this._modelManipulationOrigin);
        this._renderer.mMatrix = this._modelMMatrix;
        if (this._config.isDebugVisible) {
            this._debugText.addLine(`mod pos ${this._smoothedModelPosition[0] < 0 ? "" : " "}${this._smoothedModelPosition[0].toFixed(3)},${this._smoothedModelPosition[1] < 0 ? "" : " "}${this._smoothedModelPosition[1].toFixed(3)},${this._smoothedModelPosition[2] < 0 ? "" : " "}${this._smoothedModelPosition[2].toFixed(3)}`);
            this._debugText.addLine(`mod rot ${this._smoothedModelRotation[0] < 0 ? "" : " "}${this._smoothedModelRotation[0].toFixed(3)},${this._smoothedModelRotation[1] < 0 ? "" : " "}${this._smoothedModelRotation[1].toFixed(3)},${this._smoothedModelRotation[2] < 0 ? "" : " "}${this._smoothedModelRotation[2].toFixed(3)},${this._smoothedModelRotation[3] < 0 ? "" : " "}${this._smoothedModelRotation[3].toFixed(3)}`);
            this._debugText.addLine(`mod siz  ${this._smoothedModelScale[0].toFixed(3)}`);
            this._debugText.addLine(`man ori ${this._modelManipulationOrigin[0] < 0 ? "" : " "}${this._modelManipulationOrigin[0].toFixed(3)},${this._modelManipulationOrigin[1] < 0 ? "" : " "}${this._modelManipulationOrigin[1].toFixed(3)},${this._modelManipulationOrigin[2] < 0 ? "" : " "}${this._modelManipulationOrigin[2].toFixed(3)}`);
            this._debugText.addLine(`scr dst  ${this._config.screenDistance.toFixed(3)}`);
            this._debugText.addLine(`cam fov  ${Math.round((0, $a49c65c28e06311e$export$210d3b2db589eb5c).radiansToDegrees(this._config.fov))}`);
            this._debugText.addLine(`tbf tot  ${this._renderer.transitionBuffers.length}`);
        }
        if (!xrFrame) {
            this._camera.width = this._renderer.width;
            this._camera.height = this._renderer.height;
            this._camera.modelMMatrix = this._modelMMatrix;
            this._camera.modelPosition = this._smoothedModelPosition;
            this._camera.modelRotation = this._smoothedModelRotation;
            this._camera.modelScale = this._smoothedModelScale;
            this._camera.modelManipulationOrigin = this._modelManipulationOrigin;
            this._camera.update(elapsedTime);
            this._renderer.vMatrices = this._camera.vMatrices;
            this._renderer.mvMatrices = this._camera.mvMatrices;
            this._renderer.pMatrices = this._camera.pMatrices;
            this._renderer.inverseVMatrices = this._camera.inverseVMatrices;
            this._renderer.inversePMatrices = this._camera.inversePMatrices;
        }
        this._renderer.prepare(xrFrame);
        if (!xrFrame && this._config.stereoMode == $4a6417d29706362f$export$ec20dfa68810b176.none) this._renderer.pickPMatrix = this._camera.pMatrices[0];
        else {
            const fov = (0, $b920b5b69884770f$export$34bcf93e378e8ddd).fieldOfViewFromProjectionMatrix(this._renderer.pMatrices[0]);
            (0, $1ac1b59392edf35b$exports).perspective(this._mat4, fov, this._renderer.width / this._renderer.height, this._config.nearPlane, this._config.farPlane);
            this._renderer.pickPMatrix = this._mat4;
        }
        if (this._renderer.isInitialized) this._renderer.update(elapsedTime);
    }
    render(elapsedTime, xrFrame) {
        return $4a6417d29706362f$var$__awaiter(this, void 0, void 0, function*() {
            this._fps.render();
            if (this._renderer.isInitialized) {
                yield this._renderer.render(elapsedTime, xrFrame);
                if (this.afterRenderCallback) this.afterRenderCallback();
            }
        });
    }
    _syncSmooth() {
        (0, $31054a6c69637582$exports).copy(this._smoothedModelPosition, this._modelPosition);
        (0, $31054a6c69637582$exports).copy(this._smoothedModelScale, this._modelScale);
        (0, $39ece26d1239bb77$exports).copy(this._smoothedModelRotation, this._modelRotation);
    }
    _updateManipulationOrigin(position) {
        this._log.write($4a6417d29706362f$export$243e62d78d3b544d.info, `manipulation origin ${position[0].toFixed(3)},${position[1].toFixed(3)},${position[2].toFixed(3)}`);
        this._camera.updateModelManipulationOrigin(this._modelManipulationOrigin, position);
        (0, $31054a6c69637582$exports).copy(this._modelManipulationOrigin, position);
        (0, $31054a6c69637582$exports).transformMat4(this._vec3, this._modelManipulationOrigin, this._modelMMatrix);
        (0, $31054a6c69637582$exports).subtract(this._modelPosition, this._vec3, this._modelManipulationOrigin);
        (0, $31054a6c69637582$exports).copy(this._smoothedModelPosition, this._modelPosition);
        if (this.manipulationOriginChangedCallback) {
            const result = {
                x: position[0],
                y: position[1],
                z: position[2]
            };
            this.manipulationOriginChangedCallback(result);
        }
    }
    pickLasso(x0, y0, x1, y1, pickType) {
        const inverseMMatrix = (0, $1ac1b59392edf35b$exports).create();
        (0, $1ac1b59392edf35b$exports).invert(inverseMMatrix, this._modelMMatrix);
        const sets = [];
        const nearPositions = [
            (0, $31054a6c69637582$exports).create(),
            (0, $31054a6c69637582$exports).create(),
            (0, $31054a6c69637582$exports).create(),
            (0, $31054a6c69637582$exports).create()
        ];
        const farPositions = [
            (0, $31054a6c69637582$exports).create(),
            (0, $31054a6c69637582$exports).create(),
            (0, $31054a6c69637582$exports).create(),
            (0, $31054a6c69637582$exports).create()
        ];
        const directions = [
            (0, $31054a6c69637582$exports).create(),
            (0, $31054a6c69637582$exports).create(),
            (0, $31054a6c69637582$exports).create(),
            (0, $31054a6c69637582$exports).create()
        ];
        this._camera.unproject(nearPositions[0], x0, y1, -1);
        this._camera.unproject(farPositions[0], x0, y1, 1);
        this._camera.unproject(nearPositions[1], x1, y1, -1);
        this._camera.unproject(farPositions[1], x1, y1, 1);
        this._camera.unproject(nearPositions[2], x1, y0, -1);
        this._camera.unproject(farPositions[2], x1, y0, 1);
        this._camera.unproject(nearPositions[3], x0, y0, -1);
        this._camera.unproject(farPositions[3], x0, y0, 1);
        for(let i = 0; i < 4; i++){
            (0, $31054a6c69637582$exports).transformMat4(nearPositions[i], nearPositions[i], inverseMMatrix);
            (0, $31054a6c69637582$exports).transformMat4(farPositions[i], farPositions[i], inverseMMatrix);
            (0, $31054a6c69637582$exports).subtract(directions[i], farPositions[i], nearPositions[i]);
            (0, $31054a6c69637582$exports).normalize(directions[i], directions[i]);
        }
        const normals = [
            (0, $31054a6c69637582$exports).create(),
            (0, $31054a6c69637582$exports).create(),
            (0, $31054a6c69637582$exports).create(),
            (0, $31054a6c69637582$exports).create()
        ];
        const d = [];
        for(let i = 0; i < 4; i++){
            (0, $31054a6c69637582$exports).cross(normals[i], directions[(i + 1) % 4], directions[i]);
            (0, $31054a6c69637582$exports).normalize(normals[i], normals[i]);
            d.push(-(0, $31054a6c69637582$exports).dot(normals[i], nearPositions[i]));
        }
        if (pickType == $4a6417d29706362f$export$6fc3f4da94ff0be0.data) {
            const translation = (0, $31054a6c69637582$exports).create();
            for(let i = 0; i < this._renderer.transitionBuffers.length; i++){
                const transitionBuffer = this._renderer.transitionBuffers[i];
                const set = new Set();
                if (transitionBuffer.isVisible) {
                    const start = window.performance.now();
                    const currentBuffer = transitionBuffer.currentBuffer;
                    const lookup = currentBuffer.lookup;
                    for(let j = 0; j < currentBuffer.length; j++){
                        const id = currentBuffer.ids[j];
                        const index = lookup[id];
                        if (index != null) {
                            (0, $0a0587bd8b0d58e8$export$849e31d725692576).getTranslation(currentBuffer.dataView, index, translation);
                            let isInside = true;
                            for(let k = 0; k < 4; k++){
                                let distance = (0, $31054a6c69637582$exports).dot(normals[k], translation);
                                distance += d[k];
                                if (distance < 0) {
                                    isInside = false;
                                    break;
                                }
                            }
                            if (isInside) set.add(id);
                        }
                    }
                    if (set.size > 0) this._log.write($4a6417d29706362f$export$243e62d78d3b544d.info, `lasso transition buffer ${i} picked ${set.size} ${Math.round(window.performance.now() - start)}ms`);
                }
                sets.push(set);
            }
        }
        return sets;
    }
}
const $4a6417d29706362f$export$b9eeb0cadc4c12e4 = {
    orbit: "orbit",
    altAzimuth: "altAzimuth"
};
const $4a6417d29706362f$export$ec20dfa68810b176 = {
    none: "none",
    split: "split",
    anaglyph: "anaglyph",
    left: "left",
    right: "right"
};
const $4a6417d29706362f$export$91484609d16ec765 = {
    new: "new",
    add: "add",
    subtract: "subtract",
    intersect: "intersect"
};
const $4a6417d29706362f$export$ec1e12eead838acf = {
    isolate: "isolate",
    exclude: "exclude"
};
const $4a6417d29706362f$export$d94dcb5bec64086e = {
    left: "left",
    center: "center",
    right: "right"
};
const $4a6417d29706362f$export$c12e835f91722ef8 = {
    top: "top",
    center: "center",
    bottom: "bottom"
};
const $4a6417d29706362f$export$84b2d1b68830363f = {
    left: "left",
    center: "center",
    right: "right"
};
const $4a6417d29706362f$export$df54d73aa0ec5e82 = {
    horizontal: "horizontal",
    vertical: "vertical"
};
const $4a6417d29706362f$export$d2304d1f23cf3ace = {
    parallel: "parallel",
    perpendicular: "perpendicular"
};
const $4a6417d29706362f$export$7dbc7c2b82487e42 = {
    none: "none",
    current: "current",
    previous: "previous"
};
const $4a6417d29706362f$export$6fc3f4da94ff0be0 = {
    none: 0,
    data: 1,
    label: 2,
    axesDivision: 3,
    axesTitle: 4,
    axesLabel: 5,
    axesHeading: 6
};
const $4a6417d29706362f$export$14faa19a0f3bbeb2 = {
    dark: "dark",
    light: "light"
};
const $4a6417d29706362f$export$6b731eb2fd512fe0 = {
    luminance: "luminance",
    color: "color"
};
const $4a6417d29706362f$export$80d48287646c9e3b = {
    block: "block",
    blockSdf: "blockSdf",
    boxFrameSdf: "boxFrameSdf",
    sphere: "sphere",
    sphereSdf: "sphereSdf",
    cylinder: "cylinder",
    cylinderSdf: "cylinderSdf",
    hexPrism: "hexPrism",
    hexPrismSdf: "hexPrismSdf",
    sdf: "sdf",
    disk: "disk",
    ringSdf: "ringSdf"
};
const $4a6417d29706362f$export$226dc1249c607930 = {
    none: "none",
    translate: "translate",
    rotate: "rotate",
    lasso: "lasso"
};
const $4a6417d29706362f$export$335c7d069643eb6d = {
    none: "none",
    zoom: "zoom",
    rotateY: "rotateY"
};
const $4a6417d29706362f$export$243e62d78d3b544d = {
    trace: 0,
    debug: 1,
    info: 2,
    warn: 3,
    error: 4
};
const $4a6417d29706362f$export$1c6bed1dcbac1312 = {
    top: 0,
    right: 1,
    bottom: 2,
    left: 3
};
const $4a6417d29706362f$export$e5036cab5f304801 = {
    front: 0,
    back: 1
};
const $4a6417d29706362f$export$99dacba06f5726bd = {
    topFront: 0,
    topRight: 1,
    topBack: 2,
    topLeft: 3,
    bottomFront: 4,
    bottomRight: 5,
    bottomBack: 6,
    bottomLeft: 7,
    frontRight: 8,
    backRight: 9,
    backLeft: 10,
    frontLeft: 11
};
const $4a6417d29706362f$export$3f28760630ff8d3c = {
    top: 0,
    right: 1,
    bottom: 2,
    left: 3,
    front: 4,
    back: 5
};
const $4a6417d29706362f$export$9ac0daa892cfa13e = {
    pointyTop: "pointyTop",
    flatTop: "flatTop"
};
const $4a6417d29706362f$export$2386c8c1d9db2d57 = {
    color: "color",
    hdr: "hdr",
    depth: "depth",
    normal: "normal",
    segment: "segment",
    edge: "edge"
};





/*!
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 */ 
class $42b018e85c350e4a$export$c537fa0d021d010b {
}
$42b018e85c350e4a$export$c537fa0d021d010b.MediumVioletRed = (0, $31054a6c69637582$exports).fromValues(0xc7, 0x15, 0x85);
$42b018e85c350e4a$export$c537fa0d021d010b.DeepPink = (0, $31054a6c69637582$exports).fromValues(0xff, 0x14, 0x93);
$42b018e85c350e4a$export$c537fa0d021d010b.PaleVioletRed = (0, $31054a6c69637582$exports).fromValues(0xdb, 0x70, 0x93);
$42b018e85c350e4a$export$c537fa0d021d010b.HotPink = (0, $31054a6c69637582$exports).fromValues(0xff, 0x69, 0xb4);
$42b018e85c350e4a$export$c537fa0d021d010b.LightPink = (0, $31054a6c69637582$exports).fromValues(0xff, 0xb6, 0xc1);
$42b018e85c350e4a$export$c537fa0d021d010b.Pink = (0, $31054a6c69637582$exports).fromValues(0xff, 0xc0, 0xcb);
$42b018e85c350e4a$export$c537fa0d021d010b.DarkRed = (0, $31054a6c69637582$exports).fromValues(0x8b, 0x00, 0x00);
$42b018e85c350e4a$export$c537fa0d021d010b.Red = (0, $31054a6c69637582$exports).fromValues(0xff, 0x00, 0x00);
$42b018e85c350e4a$export$c537fa0d021d010b.Firebrick = (0, $31054a6c69637582$exports).fromValues(0xb2, 0x22, 0x22);
$42b018e85c350e4a$export$c537fa0d021d010b.Crimson = (0, $31054a6c69637582$exports).fromValues(0xdc, 0x14, 0x3c);
$42b018e85c350e4a$export$c537fa0d021d010b.IndianRed = (0, $31054a6c69637582$exports).fromValues(0xcd, 0x5c, 0x5c);
$42b018e85c350e4a$export$c537fa0d021d010b.LightCoral = (0, $31054a6c69637582$exports).fromValues(0xf0, 0x80, 0x80);
$42b018e85c350e4a$export$c537fa0d021d010b.Salmon = (0, $31054a6c69637582$exports).fromValues(0xfa, 0x80, 0x72);
$42b018e85c350e4a$export$c537fa0d021d010b.DarkSalmon = (0, $31054a6c69637582$exports).fromValues(0xe9, 0x96, 0x7a);
$42b018e85c350e4a$export$c537fa0d021d010b.LightSalmon = (0, $31054a6c69637582$exports).fromValues(0xff, 0xa0, 0x7a);
$42b018e85c350e4a$export$c537fa0d021d010b.OrangeRed = (0, $31054a6c69637582$exports).fromValues(0xff, 0x45, 0x00);
$42b018e85c350e4a$export$c537fa0d021d010b.Tomato = (0, $31054a6c69637582$exports).fromValues(0xff, 0x63, 0x47);
$42b018e85c350e4a$export$c537fa0d021d010b.DarkOrange = (0, $31054a6c69637582$exports).fromValues(0xff, 0x8c, 0x00);
$42b018e85c350e4a$export$c537fa0d021d010b.Coral = (0, $31054a6c69637582$exports).fromValues(0xff, 0x7f, 0x50);
$42b018e85c350e4a$export$c537fa0d021d010b.Orange = (0, $31054a6c69637582$exports).fromValues(0xff, 0xa5, 0x00);
$42b018e85c350e4a$export$c537fa0d021d010b.DarkKhaki = (0, $31054a6c69637582$exports).fromValues(0xbd, 0xb7, 0x6b);
$42b018e85c350e4a$export$c537fa0d021d010b.Gold = (0, $31054a6c69637582$exports).fromValues(0xff, 0xd7, 0x00);
$42b018e85c350e4a$export$c537fa0d021d010b.Khaki = (0, $31054a6c69637582$exports).fromValues(0xf0, 0xe6, 0x8c);
$42b018e85c350e4a$export$c537fa0d021d010b.PeachPuff = (0, $31054a6c69637582$exports).fromValues(0xff, 0xda, 0xb9);
$42b018e85c350e4a$export$c537fa0d021d010b.Yellow = (0, $31054a6c69637582$exports).fromValues(0xff, 0xff, 0x00);
$42b018e85c350e4a$export$c537fa0d021d010b.PaleGoldenrod = (0, $31054a6c69637582$exports).fromValues(0xee, 0xe8, 0xaa);
$42b018e85c350e4a$export$c537fa0d021d010b.Moccasin = (0, $31054a6c69637582$exports).fromValues(0xff, 0xe4, 0xb5);
$42b018e85c350e4a$export$c537fa0d021d010b.PapayaWhip = (0, $31054a6c69637582$exports).fromValues(0xff, 0xef, 0xd5);
$42b018e85c350e4a$export$c537fa0d021d010b.LightGoldenrodYellow = (0, $31054a6c69637582$exports).fromValues(0xfa, 0xfa, 0xd2);
$42b018e85c350e4a$export$c537fa0d021d010b.LemonChiffon = (0, $31054a6c69637582$exports).fromValues(0xff, 0xfa, 0xcd);
$42b018e85c350e4a$export$c537fa0d021d010b.LightYellow = (0, $31054a6c69637582$exports).fromValues(0xff, 0xff, 0xe0);
$42b018e85c350e4a$export$c537fa0d021d010b.Maroon = (0, $31054a6c69637582$exports).fromValues(0x80, 0x00, 0x00);
$42b018e85c350e4a$export$c537fa0d021d010b.Brown = (0, $31054a6c69637582$exports).fromValues(0xa5, 0x2a, 0x2a);
$42b018e85c350e4a$export$c537fa0d021d010b.SaddleBrown = (0, $31054a6c69637582$exports).fromValues(0x8b, 0x45, 0x13);
$42b018e85c350e4a$export$c537fa0d021d010b.Sienna = (0, $31054a6c69637582$exports).fromValues(0xa0, 0x52, 0x2d);
$42b018e85c350e4a$export$c537fa0d021d010b.Chocolate = (0, $31054a6c69637582$exports).fromValues(0xd2, 0x69, 0x1e);
$42b018e85c350e4a$export$c537fa0d021d010b.DarkGoldenrod = (0, $31054a6c69637582$exports).fromValues(0xb8, 0x86, 0x0b);
$42b018e85c350e4a$export$c537fa0d021d010b.Peru = (0, $31054a6c69637582$exports).fromValues(0xcd, 0x85, 0x3f);
$42b018e85c350e4a$export$c537fa0d021d010b.RosyBrown = (0, $31054a6c69637582$exports).fromValues(0xbc, 0x8f, 0x8f);
$42b018e85c350e4a$export$c537fa0d021d010b.Goldenrod = (0, $31054a6c69637582$exports).fromValues(0xda, 0xa5, 0x20);
$42b018e85c350e4a$export$c537fa0d021d010b.SandyBrown = (0, $31054a6c69637582$exports).fromValues(0xf4, 0xa4, 0x60);
$42b018e85c350e4a$export$c537fa0d021d010b.Tan = (0, $31054a6c69637582$exports).fromValues(0xd2, 0xb4, 0x8c);
$42b018e85c350e4a$export$c537fa0d021d010b.Burlywood = (0, $31054a6c69637582$exports).fromValues(0xde, 0xb8, 0x87);
$42b018e85c350e4a$export$c537fa0d021d010b.Wheat = (0, $31054a6c69637582$exports).fromValues(0xf5, 0xde, 0xb3);
$42b018e85c350e4a$export$c537fa0d021d010b.NavajoWhite = (0, $31054a6c69637582$exports).fromValues(0xff, 0xde, 0xad);
$42b018e85c350e4a$export$c537fa0d021d010b.Bisque = (0, $31054a6c69637582$exports).fromValues(0xff, 0xe4, 0xc4);
$42b018e85c350e4a$export$c537fa0d021d010b.BlanchedAlmond = (0, $31054a6c69637582$exports).fromValues(0xff, 0xeb, 0xcd);
$42b018e85c350e4a$export$c537fa0d021d010b.Cornsilk = (0, $31054a6c69637582$exports).fromValues(0xff, 0xf8, 0xdc);
$42b018e85c350e4a$export$c537fa0d021d010b.DarkGreen = (0, $31054a6c69637582$exports).fromValues(0x00, 0x64, 0x00);
$42b018e85c350e4a$export$c537fa0d021d010b.Green = (0, $31054a6c69637582$exports).fromValues(0x00, 0x80, 0x00);
$42b018e85c350e4a$export$c537fa0d021d010b.DarkOliveGreen = (0, $31054a6c69637582$exports).fromValues(0x55, 0x6b, 0x2f);
$42b018e85c350e4a$export$c537fa0d021d010b.ForestGreen = (0, $31054a6c69637582$exports).fromValues(0x22, 0x8b, 0x22);
$42b018e85c350e4a$export$c537fa0d021d010b.SeaGreen = (0, $31054a6c69637582$exports).fromValues(0x2e, 0x8b, 0x57);
$42b018e85c350e4a$export$c537fa0d021d010b.Olive = (0, $31054a6c69637582$exports).fromValues(0x80, 0x80, 0x00);
$42b018e85c350e4a$export$c537fa0d021d010b.OliveDrab = (0, $31054a6c69637582$exports).fromValues(0x6b, 0x8e, 0x23);
$42b018e85c350e4a$export$c537fa0d021d010b.MediumSeaGreen = (0, $31054a6c69637582$exports).fromValues(0x3c, 0xb3, 0x71);
$42b018e85c350e4a$export$c537fa0d021d010b.LimeGreen = (0, $31054a6c69637582$exports).fromValues(0x32, 0xcd, 0x32);
$42b018e85c350e4a$export$c537fa0d021d010b.Lime = (0, $31054a6c69637582$exports).fromValues(0x00, 0xff, 0x00);
$42b018e85c350e4a$export$c537fa0d021d010b.SpringGreen = (0, $31054a6c69637582$exports).fromValues(0x00, 0xff, 0x7f);
$42b018e85c350e4a$export$c537fa0d021d010b.MediumSpringGreen = (0, $31054a6c69637582$exports).fromValues(0x00, 0xfa, 0x9a);
$42b018e85c350e4a$export$c537fa0d021d010b.DarkSeaGreen = (0, $31054a6c69637582$exports).fromValues(0x8f, 0xbc, 0x8f);
$42b018e85c350e4a$export$c537fa0d021d010b.MediumAquamarine = (0, $31054a6c69637582$exports).fromValues(0x66, 0xcd, 0xaa);
$42b018e85c350e4a$export$c537fa0d021d010b.YellowGreen = (0, $31054a6c69637582$exports).fromValues(0x9a, 0xcd, 0x32);
$42b018e85c350e4a$export$c537fa0d021d010b.LawnGreen = (0, $31054a6c69637582$exports).fromValues(0x7c, 0xfc, 0x00);
$42b018e85c350e4a$export$c537fa0d021d010b.Chartreuse = (0, $31054a6c69637582$exports).fromValues(0x7f, 0xff, 0x00);
$42b018e85c350e4a$export$c537fa0d021d010b.LightGreen = (0, $31054a6c69637582$exports).fromValues(0x90, 0xee, 0x90);
$42b018e85c350e4a$export$c537fa0d021d010b.GreenYellow = (0, $31054a6c69637582$exports).fromValues(0xad, 0xff, 0x2f);
$42b018e85c350e4a$export$c537fa0d021d010b.PaleGreen = (0, $31054a6c69637582$exports).fromValues(0x98, 0xfb, 0x98);
$42b018e85c350e4a$export$c537fa0d021d010b.Teal = (0, $31054a6c69637582$exports).fromValues(0x00, 0x80, 0x80);
$42b018e85c350e4a$export$c537fa0d021d010b.DarkCyan = (0, $31054a6c69637582$exports).fromValues(0x00, 0x8b, 0x8b);
$42b018e85c350e4a$export$c537fa0d021d010b.LightSeaGreen = (0, $31054a6c69637582$exports).fromValues(0x20, 0xb2, 0xaa);
$42b018e85c350e4a$export$c537fa0d021d010b.CadetBlue = (0, $31054a6c69637582$exports).fromValues(0x5f, 0x9e, 0xa0);
$42b018e85c350e4a$export$c537fa0d021d010b.DarkTurquoise = (0, $31054a6c69637582$exports).fromValues(0x00, 0xce, 0xd1);
$42b018e85c350e4a$export$c537fa0d021d010b.MediumTurquoise = (0, $31054a6c69637582$exports).fromValues(0x48, 0xd1, 0xcc);
$42b018e85c350e4a$export$c537fa0d021d010b.Turquoise = (0, $31054a6c69637582$exports).fromValues(0x40, 0xe0, 0xd0);
$42b018e85c350e4a$export$c537fa0d021d010b.Aqua = (0, $31054a6c69637582$exports).fromValues(0x00, 0xff, 0xff);
$42b018e85c350e4a$export$c537fa0d021d010b.Cyan = (0, $31054a6c69637582$exports).fromValues(0x00, 0xff, 0xff);
$42b018e85c350e4a$export$c537fa0d021d010b.Aquamarine = (0, $31054a6c69637582$exports).fromValues(0x7f, 0xff, 0xd4);
$42b018e85c350e4a$export$c537fa0d021d010b.PaleTurquoise = (0, $31054a6c69637582$exports).fromValues(0xaf, 0xee, 0xee);
$42b018e85c350e4a$export$c537fa0d021d010b.LightCyan = (0, $31054a6c69637582$exports).fromValues(0xe0, 0xff, 0xff);
$42b018e85c350e4a$export$c537fa0d021d010b.Navy = (0, $31054a6c69637582$exports).fromValues(0x00, 0x00, 0x80);
$42b018e85c350e4a$export$c537fa0d021d010b.DarkBlue = (0, $31054a6c69637582$exports).fromValues(0x00, 0x00, 0x8b);
$42b018e85c350e4a$export$c537fa0d021d010b.MediumBlue = (0, $31054a6c69637582$exports).fromValues(0x00, 0x00, 0xcd);
$42b018e85c350e4a$export$c537fa0d021d010b.Blue = (0, $31054a6c69637582$exports).fromValues(0x00, 0x00, 0xff);
$42b018e85c350e4a$export$c537fa0d021d010b.MidnightBlue = (0, $31054a6c69637582$exports).fromValues(0x19, 0x19, 0x70);
$42b018e85c350e4a$export$c537fa0d021d010b.RoyalBlue = (0, $31054a6c69637582$exports).fromValues(0x41, 0x69, 0xe1);
$42b018e85c350e4a$export$c537fa0d021d010b.SteelBlue = (0, $31054a6c69637582$exports).fromValues(0x46, 0x82, 0xb4);
$42b018e85c350e4a$export$c537fa0d021d010b.DodgerBlue = (0, $31054a6c69637582$exports).fromValues(0x1e, 0x90, 0xff);
$42b018e85c350e4a$export$c537fa0d021d010b.DeepSkyBlue = (0, $31054a6c69637582$exports).fromValues(0x00, 0xbf, 0xff);
$42b018e85c350e4a$export$c537fa0d021d010b.CornflowerBlue = (0, $31054a6c69637582$exports).fromValues(0x64, 0x95, 0xed);
$42b018e85c350e4a$export$c537fa0d021d010b.SkyBlue = (0, $31054a6c69637582$exports).fromValues(0x87, 0xce, 0xeb);
$42b018e85c350e4a$export$c537fa0d021d010b.LightSkyBlue = (0, $31054a6c69637582$exports).fromValues(0x87, 0xce, 0xfa);
$42b018e85c350e4a$export$c537fa0d021d010b.LightSteelBlue = (0, $31054a6c69637582$exports).fromValues(0xb0, 0xc4, 0xde);
$42b018e85c350e4a$export$c537fa0d021d010b.LightBlue = (0, $31054a6c69637582$exports).fromValues(0xad, 0xd8, 0xe6);
$42b018e85c350e4a$export$c537fa0d021d010b.PowderBlue = (0, $31054a6c69637582$exports).fromValues(0xb0, 0xe0, 0xe6);
$42b018e85c350e4a$export$c537fa0d021d010b.Indigo = (0, $31054a6c69637582$exports).fromValues(0x4b, 0x00, 0x82);
$42b018e85c350e4a$export$c537fa0d021d010b.Purple = (0, $31054a6c69637582$exports).fromValues(0x80, 0x00, 0x80);
$42b018e85c350e4a$export$c537fa0d021d010b.DarkMagenta = (0, $31054a6c69637582$exports).fromValues(0x8b, 0x00, 0x8b);
$42b018e85c350e4a$export$c537fa0d021d010b.DarkViolet = (0, $31054a6c69637582$exports).fromValues(0x94, 0x00, 0xd3);
$42b018e85c350e4a$export$c537fa0d021d010b.DarkSlateBlue = (0, $31054a6c69637582$exports).fromValues(0x48, 0x3d, 0x8b);
$42b018e85c350e4a$export$c537fa0d021d010b.BlueViolet = (0, $31054a6c69637582$exports).fromValues(0x8a, 0x2b, 0xe2);
$42b018e85c350e4a$export$c537fa0d021d010b.DarkOrchid = (0, $31054a6c69637582$exports).fromValues(0x99, 0x32, 0xcc);
$42b018e85c350e4a$export$c537fa0d021d010b.Fuchsia = (0, $31054a6c69637582$exports).fromValues(0xff, 0x00, 0xff);
$42b018e85c350e4a$export$c537fa0d021d010b.Magenta = (0, $31054a6c69637582$exports).fromValues(0xff, 0x00, 0xff);
$42b018e85c350e4a$export$c537fa0d021d010b.SlateBlue = (0, $31054a6c69637582$exports).fromValues(0x6a, 0x5a, 0xcd);
$42b018e85c350e4a$export$c537fa0d021d010b.MediumSlateBlue = (0, $31054a6c69637582$exports).fromValues(0x7b, 0x68, 0xee);
$42b018e85c350e4a$export$c537fa0d021d010b.MediumOrchid = (0, $31054a6c69637582$exports).fromValues(0xba, 0x55, 0xd3);
$42b018e85c350e4a$export$c537fa0d021d010b.MediumPurple = (0, $31054a6c69637582$exports).fromValues(0x93, 0x70, 0xdb);
$42b018e85c350e4a$export$c537fa0d021d010b.Orchid = (0, $31054a6c69637582$exports).fromValues(0xda, 0x70, 0xd6);
$42b018e85c350e4a$export$c537fa0d021d010b.Violet = (0, $31054a6c69637582$exports).fromValues(0xee, 0x82, 0xee);
$42b018e85c350e4a$export$c537fa0d021d010b.Plum = (0, $31054a6c69637582$exports).fromValues(0xdd, 0xa0, 0xdd);
$42b018e85c350e4a$export$c537fa0d021d010b.Thistle = (0, $31054a6c69637582$exports).fromValues(0xd8, 0xbf, 0xd8);
$42b018e85c350e4a$export$c537fa0d021d010b.Lavender = (0, $31054a6c69637582$exports).fromValues(0xe6, 0xe6, 0xfa);
$42b018e85c350e4a$export$c537fa0d021d010b.MistyRose = (0, $31054a6c69637582$exports).fromValues(0xff, 0xe4, 0xe1);
$42b018e85c350e4a$export$c537fa0d021d010b.AntiqueWhite = (0, $31054a6c69637582$exports).fromValues(0xfa, 0xeb, 0xd7);
$42b018e85c350e4a$export$c537fa0d021d010b.Linen = (0, $31054a6c69637582$exports).fromValues(0xfa, 0xf0, 0xe6);
$42b018e85c350e4a$export$c537fa0d021d010b.Beige = (0, $31054a6c69637582$exports).fromValues(0xf5, 0xf5, 0xdc);
$42b018e85c350e4a$export$c537fa0d021d010b.WhiteSmoke = (0, $31054a6c69637582$exports).fromValues(0xf5, 0xf5, 0xf5);
$42b018e85c350e4a$export$c537fa0d021d010b.LavenderBlush = (0, $31054a6c69637582$exports).fromValues(0xff, 0xf0, 0xf5);
$42b018e85c350e4a$export$c537fa0d021d010b.OldLace = (0, $31054a6c69637582$exports).fromValues(0xfd, 0xf5, 0xe6);
$42b018e85c350e4a$export$c537fa0d021d010b.AliceBlue = (0, $31054a6c69637582$exports).fromValues(0xf0, 0xf8, 0xff);
$42b018e85c350e4a$export$c537fa0d021d010b.Seashell = (0, $31054a6c69637582$exports).fromValues(0xff, 0xf5, 0xee);
$42b018e85c350e4a$export$c537fa0d021d010b.GhostWhite = (0, $31054a6c69637582$exports).fromValues(0xf8, 0xf8, 0xff);
$42b018e85c350e4a$export$c537fa0d021d010b.Honeydew = (0, $31054a6c69637582$exports).fromValues(0xf0, 0xff, 0xf0);
$42b018e85c350e4a$export$c537fa0d021d010b.FloralWhite = (0, $31054a6c69637582$exports).fromValues(0xff, 0xfa, 0xf0);
$42b018e85c350e4a$export$c537fa0d021d010b.Azure = (0, $31054a6c69637582$exports).fromValues(0xf0, 0xff, 0xff);
$42b018e85c350e4a$export$c537fa0d021d010b.MintCream = (0, $31054a6c69637582$exports).fromValues(0xf5, 0xff, 0xfa);
$42b018e85c350e4a$export$c537fa0d021d010b.Snow = (0, $31054a6c69637582$exports).fromValues(0xff, 0xfa, 0xfa);
$42b018e85c350e4a$export$c537fa0d021d010b.Ivory = (0, $31054a6c69637582$exports).fromValues(0xff, 0xff, 0xf0);
$42b018e85c350e4a$export$c537fa0d021d010b.White = (0, $31054a6c69637582$exports).fromValues(0xff, 0xff, 0xff);
$42b018e85c350e4a$export$c537fa0d021d010b.Black = (0, $31054a6c69637582$exports).fromValues(0x00, 0x00, 0x00);
$42b018e85c350e4a$export$c537fa0d021d010b.DarkSlateGray = (0, $31054a6c69637582$exports).fromValues(0x2f, 0x4f, 0x4f);
$42b018e85c350e4a$export$c537fa0d021d010b.DimGray = (0, $31054a6c69637582$exports).fromValues(0x69, 0x69, 0x69);
$42b018e85c350e4a$export$c537fa0d021d010b.SlateGray = (0, $31054a6c69637582$exports).fromValues(0x70, 0x80, 0x90);
$42b018e85c350e4a$export$c537fa0d021d010b.Gray = (0, $31054a6c69637582$exports).fromValues(0x80, 0x80, 0x80);
$42b018e85c350e4a$export$c537fa0d021d010b.LightSlateGray = (0, $31054a6c69637582$exports).fromValues(0x77, 0x88, 0x99);
$42b018e85c350e4a$export$c537fa0d021d010b.DarkGray = (0, $31054a6c69637582$exports).fromValues(0xa9, 0xa9, 0xa9);
$42b018e85c350e4a$export$c537fa0d021d010b.Silver = (0, $31054a6c69637582$exports).fromValues(0xc0, 0xc0, 0xc0);
$42b018e85c350e4a$export$c537fa0d021d010b.LightGray = (0, $31054a6c69637582$exports).fromValues(0xd3, 0xd3, 0xd3);
$42b018e85c350e4a$export$c537fa0d021d010b.Gainsboro = (0, $31054a6c69637582$exports).fromValues(0xdc, 0xdc, 0xdc);
$42b018e85c350e4a$export$c537fa0d021d010b.Copper = (0, $31054a6c69637582$exports).fromValues(0xb8, 0x73, 0x33);
$42b018e85c350e4a$export$c537fa0d021d010b.Bronze = (0, $31054a6c69637582$exports).fromValues(0xcd, 0x7f, 0x32);
$42b018e85c350e4a$export$c537fa0d021d010b.Steel = (0, $31054a6c69637582$exports).fromValues(0xce, 0xd2, 0xd7);
$42b018e85c350e4a$export$c537fa0d021d010b.Platinum = (0, $31054a6c69637582$exports).fromValues(0xe5, 0xe4, 0xe2);
$42b018e85c350e4a$export$c537fa0d021d010b.Gunmetal = (0, $31054a6c69637582$exports).fromValues(0x5c, 0x5d, 0x5b);
$42b018e85c350e4a$export$c537fa0d021d010b.Titanium = (0, $31054a6c69637582$exports).fromValues(0x87, 0x86, 0x81);
$42b018e85c350e4a$export$c537fa0d021d010b.RoseGold = (0, $31054a6c69637582$exports).fromValues(0xcb, 0xa3, 0xb2);
$42b018e85c350e4a$export$c537fa0d021d010b.AquaGlass = (0, $31054a6c69637582$exports).fromValues(0xd2, 0xe8, 0xdf);
$42b018e85c350e4a$export$c537fa0d021d010b.BlueGlass = (0, $31054a6c69637582$exports).fromValues(0xc7, 0xe3, 0xe1);



/*!
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 */ /*!
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 */ 


class $9567e168ff06f2c9$export$33e818f0c514945e {
    constructor(){
        this.minLatitude = -85.05112878;
        this.maxLatitude = 85.05112878;
        this.minLongitude = -180;
        this.maxLongitude = 180;
        this.minX = -1;
        this.minY = -1;
        this.maxX = 1;
        this.maxY = 1;
    }
    project(longitude, latitude, xy) {
        const x = longitude / 180;
        latitude = (0, $2d4d1eb6f32f02f2$export$80a8c44b8858d625).clamp(latitude, this.minLatitude, this.maxLatitude);
        latitude = (0, $a49c65c28e06311e$export$210d3b2db589eb5c).degreesToRadians(latitude);
        const sinLatitude = Math.sin(latitude);
        let y = Math.log((1 + sinLatitude) / (1 - sinLatitude)) / 2;
        y = (0, $2d4d1eb6f32f02f2$export$80a8c44b8858d625).clamp(y / Math.PI, this.minY, this.maxY);
        xy[0] = x;
        xy[1] = y;
    }
    unproject(x, y, lonLat) {
        const longitude = x * 180;
        y *= Math.PI;
        let latitude = (0, $d4d7bd6cc65a5081$export$a002182e51710d39).PI_OVER_TWO - 2 * Math.atan(Math.exp(-y));
        latitude = (0, $a49c65c28e06311e$export$210d3b2db589eb5c).radiansToDegrees(latitude);
        lonLat[0] = longitude;
        lonLat[1] = latitude;
    }
}
class $9567e168ff06f2c9$export$4c4ef7713ed8a00d {
    constructor(){
        this._phi1 = 29.5;
        this._phi2 = 45.5;
        this._lat0 = 37.5;
        this._lon0 = -96;
    }
    get standardParallel1() {
        return this._phi1;
    }
    set standardParallel1(value) {
        this._phi1 = value;
    }
    get standardParallel2() {
        return this._phi2;
    }
    set standardParallel2(value) {
        this._phi2 = value;
    }
    get latitudeOfOrigin() {
        return this._lat0;
    }
    set latitudeOfOrigin(value) {
        this._lat0 = value;
    }
    get centralMeridian() {
        return this._lon0;
    }
    set centralMeridian(value) {
        this._lon0 = value;
    }
    project(lon, lat, xy) {
        const phi1 = (0, $a49c65c28e06311e$export$210d3b2db589eb5c).degreesToRadians(this._phi1);
        const phi2 = (0, $a49c65c28e06311e$export$210d3b2db589eb5c).degreesToRadians(this._phi2);
        const lat0 = (0, $a49c65c28e06311e$export$210d3b2db589eb5c).degreesToRadians(this._lat0);
        const lon0 = (0, $a49c65c28e06311e$export$210d3b2db589eb5c).degreesToRadians(this._lon0);
        lat = (0, $a49c65c28e06311e$export$210d3b2db589eb5c).degreesToRadians(lat);
        lon = (0, $a49c65c28e06311e$export$210d3b2db589eb5c).degreesToRadians(lon);
        const n = 0.5 * (Math.sin(phi1) + Math.sin(phi2));
        const c = Math.cos(phi1);
        const C = c * c + 2 * n * Math.sin(phi1);
        const p0 = Math.sqrt(C - 2 * n * Math.sin(lat0)) / n;
        const theta = n * (lon - lon0);
        const p = Math.sqrt(C - 2 * n * Math.sin(lat)) / n;
        const x = p * Math.sin(theta);
        const y = p0 - p * Math.cos(theta);
        xy[0] = x;
        xy[1] = y;
    }
    unproject(x, y, lonLat) {
        const phi1 = (0, $a49c65c28e06311e$export$210d3b2db589eb5c).degreesToRadians(this._phi1);
        const phi2 = (0, $a49c65c28e06311e$export$210d3b2db589eb5c).degreesToRadians(this._phi2);
        const lat0 = (0, $a49c65c28e06311e$export$210d3b2db589eb5c).degreesToRadians(this._lat0);
        const lon0 = (0, $a49c65c28e06311e$export$210d3b2db589eb5c).degreesToRadians(this._lon0);
        const n = 0.5 * (Math.sin(phi1) + Math.sin(phi2));
        const c = Math.cos(phi1);
        const C = c * c + 2 * n * Math.sin(phi1);
        const p0 = Math.sqrt(C - 2 * n * Math.sin(lat0)) / n;
        let theta = Math.atan(x / Math.abs(p0 - y) * Math.sign(p0 - y));
        if ((p0 - y) * n < 0) theta -= Math.PI * Math.sign(x) * Math.sign(p0 - y);
        const p = Math.sqrt(x * x + Math.pow(p0 - y, 2));
        const lon = lon0 + theta / n;
        const lat = Math.asin((C - p * p * n * n) / (2 * n));
        lonLat[0] = (0, $a49c65c28e06311e$export$210d3b2db589eb5c).radiansToDegrees(lon);
        lonLat[1] = (0, $a49c65c28e06311e$export$210d3b2db589eb5c).radiansToDegrees(lat);
    }
}
class $9567e168ff06f2c9$export$618604db0cd69e78 {
    constructor(){
        this._lonLat = [
            0,
            0
        ];
    }
    feature(geoJSON, property, key) {
        for(let i = 0; i < geoJSON.features.length; i++){
            let feature = geoJSON.features[i];
            if (feature.properties[property] == key) return feature;
        }
        return null;
    }
    bounds(geometry, clip, projection) {
        let minX = Number.MAX_VALUE;
        let maxX = -Number.MAX_VALUE;
        let minY = Number.MAX_VALUE;
        let maxY = -Number.MAX_VALUE;
        switch(geometry.type){
            case "Polygon":
                const polygon = geometry;
                const outer = polygon.coordinates[0];
                for(let k = 0; k < outer.length; k++){
                    this._lonLat[0] = outer[k][0];
                    this._lonLat[1] = outer[k][1];
                    if (this._lonLat[0] < clip.minLon || this._lonLat[0] > clip.maxLon || this._lonLat[1] < clip.minLat || this._lonLat[1] > clip.maxLat) break;
                    if (this._lonLat[0] > 0) this._lonLat[0] -= 360;
                    if (projection) projection.project(this._lonLat[0], this._lonLat[1], this._lonLat);
                    minX = Math.min(minX, this._lonLat[0]);
                    maxX = Math.max(maxX, this._lonLat[0]);
                    minY = Math.min(minY, this._lonLat[1]);
                    maxY = Math.max(maxY, this._lonLat[1]);
                }
                break;
            case "MultiPolygon":
                const multiPolygon = geometry;
                for(let j = 0; j < multiPolygon.coordinates.length; j++){
                    const polygon = multiPolygon.coordinates[j];
                    const outer = polygon[0];
                    for(let k = 0; k < outer.length; k++){
                        this._lonLat[0] = outer[k][0];
                        this._lonLat[1] = outer[k][1];
                        if (this._lonLat[0] < clip.minLon || this._lonLat[0] > clip.maxLon || this._lonLat[1] < clip.minLat || this._lonLat[1] > clip.maxLat) continue;
                        if (this._lonLat[0] > 0) this._lonLat[0] -= 360;
                        if (projection) projection.project(this._lonLat[0], this._lonLat[1], this._lonLat);
                        minX = Math.min(minX, this._lonLat[0]);
                        maxX = Math.max(maxX, this._lonLat[0]);
                        minY = Math.min(minY, this._lonLat[1]);
                        maxY = Math.max(maxY, this._lonLat[1]);
                    }
                }
                break;
        }
        if (minX == Number.MAX_VALUE) {
            minX = 0;
            maxX = 0;
            minY = 0;
            maxY = 0;
        }
        return {
            minX: minX,
            maxX: maxX,
            minY: minY,
            maxY: maxY
        };
    }
}



class $674034e16b0fa1d5$export$375c50c679feb27e {
    toJSON() {
        return {
            key: this.key,
            scale: this.scale,
            minLat: this.minLat,
            maxLat: this.maxLat,
            minLon: this.minLon,
            maxLon: this.maxLon,
            u0: this.u0,
            v0: this.v0,
            u1: this.u1,
            v1: this.v1
        };
    }
}
class $674034e16b0fa1d5$export$e09d61cfc7544ffc {
    update() {}
    constructor(map){
        this.map = map;
    }
}
class $674034e16b0fa1d5$export$a5c7b93649eaf8f8 {
    get atlas() {
        return this._rasterizer.atlas;
    }
    get count() {
        return this._keys.size;
    }
    constructor(core, rasterizer){
        this._core = core;
        this._rasterizer = rasterizer;
        this._keys = new Set();
        this._previousSize = 0;
        this.items = {};
    }
    add(key) {
        if (!this._keys.has(key)) {
            if (this._rasterizer.draw(key) !== null) {
                this._keys.add(key);
                this._hasChanged = true;
            }
        }
    }
    update() {
        if (this._hasChanged) {
            this._hasChanged = false;
            this._core.log.write((0, $4a6417d29706362f$export$243e62d78d3b544d).info, `${this.key} added ${this._keys.size - this._previousSize} new items`);
            this._previousSize = this._keys.size;
            if (this.hasChangedCallback) this.hasChangedCallback();
        }
    }
    toJSON() {
        const items = [];
        for(let key in this.items){
            const item = this.items[key];
            items.push(item.toJSON());
        }
        return {
            key: this.key,
            items: items
        };
    }
}
class $674034e16b0fa1d5$export$2f33733435e4fbde {
    constructor(width, height){
        const canvas = document.createElement("canvas");
        canvas.width = width;
        canvas.height = height;
        const context = canvas.getContext("2d");
        context.clearRect(0, 0, width, height);
        this.imageData = context.getImageData(0, 0, width, height);
        this.x = 0;
        this.top = new Uint16Array(width);
    }
}
class $674034e16b0fa1d5$export$8377de51ad4460c0 {
    get map() {
        return this._map;
    }
    get atlas() {
        return this._atlas;
    }
    get scale() {
        return this._scale;
    }
    set scale(value) {
        this._scale = value;
        this._geoJSONRasterizer.scale = value;
    }
    get geoJSON() {
        return this._geoJSON;
    }
    set geoJSON(value) {
        this._geoJSON = value;
        this._geoJSONRasterizer.geoJSON = value;
    }
    get property() {
        return this._property;
    }
    set property(value) {
        this._property = value;
        this._geoJSONRasterizer.property = value;
    }
    get mapProjection() {
        return this._mapProjection;
    }
    set mapProjection(value) {
        this._mapProjection = value;
        this._geoJSONRasterizer.mapProjection = value;
    }
    get scaleFactor() {
        return this._scaleFactor;
    }
    set scaleFactor(value) {
        this._scaleFactor = value;
        this._geoJSONRasterizer.scaleFactor = this._scaleFactor;
    }
    get minLongitude() {
        return this._minLogitude;
    }
    set minLongitude(value) {
        this._minLogitude = value;
        this._geoJSONRasterizer.minLongitude = this._minLogitude;
    }
    get maxLongitude() {
        return this._maxLongitude;
    }
    set maxLongitude(value) {
        this._maxLongitude = value;
        this._geoJSONRasterizer.maxLongitude = this._maxLongitude;
    }
    get minLatitude() {
        return this._minLatitude;
    }
    set minLatitude(value) {
        this._minLatitude = value;
        this._geoJSONRasterizer.minLatitude = this._minLatitude;
    }
    get maxLatitude() {
        return this._maxLatitude;
    }
    set maxLatitude(value) {
        this._maxLatitude = value;
        this._geoJSONRasterizer.maxLatitude = this._maxLatitude;
    }
    constructor(core, options){
        let start = performance.now();
        this._core = core;
        this._atlas = options.atlas;
        this._geoJSON = options.geoJSON;
        this._scale = options.scale;
        this._property = options.property;
        this._border = options.border;
        this._maxDistance = options.maxDistance;
        this._edgeValue = options.edgeValue;
        this._key = options.key;
        this._mapProjection = options.mapProjection;
        this._map = new $674034e16b0fa1d5$export$a5c7b93649eaf8f8(core, this);
        this._map.key = this._key;
        const geoJSONRasterizerOptions = {
            border: this._border,
            edgeValue: this._edgeValue,
            maxDistance: this._maxDistance,
            geoJSON: this._geoJSON,
            scale: this._scale,
            property: this._property,
            mapProjection: this._mapProjection
        };
        this._geoJSONRasterizer = new $674034e16b0fa1d5$export$d7e26c56770d910(core, geoJSONRasterizerOptions);
        this._core.log.write((0, $4a6417d29706362f$export$243e62d78d3b544d).info, `map rasterizer ${Math.round(window.performance.now() - start)}ms`);
    }
    draw(key) {
        const item = this._geoJSONRasterizer.draw(key);
        if (item) {
            const texWidth = item.width + 2 * this._border;
            const texHeight = item.height + 2 * this._border;
            const width = this._atlas.imageData.width;
            const height = this.atlas.imageData.height;
            if (this._atlas.x + texWidth > width - 1) this._atlas.x = 0;
            let y = 0;
            for(let x = this._atlas.x; x < this._atlas.x + texWidth; x++)y = Math.max(y, this._atlas.top[x]);
            if (y + texHeight > height - 1) this._core.log.write((0, $4a6417d29706362f$export$243e62d78d3b544d).warn, `${this._map.key} height overflow`);
            for(let x = this._atlas.x; x < this._atlas.x + texWidth; x++)this._atlas.top[x] = y + texHeight;
            const halfTexelOffsetX = 0.5 / width;
            const halfTexelOffsetY = 0.5 / height;
            item.u0 = this._atlas.x / width + halfTexelOffsetX;
            item.v0 = y / height + halfTexelOffsetY;
            item.u1 = (this._atlas.x + texWidth) / width - halfTexelOffsetX;
            item.v1 = (y + texHeight) / height - halfTexelOffsetY;
            this._map.items[key] = item;
            for(let i = 0; i < item.distances.length; i++){
                const distance = item.distances[i];
                const dataX = i % texWidth;
                const dataY = Math.floor(i / texWidth);
                const offset = (this._atlas.x + dataX + (y + dataY) * width) * 4;
                this._atlas.imageData.data[offset + 0] = distance;
                this._atlas.imageData.data[offset + 1] = distance;
                this._atlas.imageData.data[offset + 2] = distance;
                this._atlas.imageData.data[offset + 3] = 0xff;
            }
            this._atlas.x += texWidth;
        }
        return item;
    }
}
class $674034e16b0fa1d5$export$d7e26c56770d910 {
    get scale() {
        return this._scale;
    }
    set scale(value) {
        this._scale = value;
    }
    get geoJSON() {
        return this._geoJSON;
    }
    set geoJSON(value) {
        this._geoJSON = value;
    }
    get property() {
        return this._property;
    }
    set property(value) {
        this._property = value;
    }
    get mapProjection() {
        return this._mapProjection;
    }
    set mapProjection(value) {
        this._mapProjection = value;
    }
    get scaleFactor() {
        return this._scaleFactor;
    }
    set scaleFactor(value) {
        this._scaleFactor = value;
    }
    get minLongitude() {
        return this._minLongitude;
    }
    set minLongitude(value) {
        this._minLongitude = value;
    }
    get maxLongitude() {
        return this._maxLongitude;
    }
    set maxLongitude(value) {
        this._maxLongitude = value;
    }
    get minLatitude() {
        return this._minLatitude;
    }
    set minLatitude(value) {
        this._minLatitude = value;
    }
    get maxLatitude() {
        return this._maxLatitude;
    }
    set maxLatitude(value) {
        this._maxLatitude = value;
    }
    constructor(core, options){
        let start = performance.now();
        this._core = core;
        this._geoJSON = options.geoJSON;
        this._scale = options.scale;
        this._property = options.property;
        this._border = options.border;
        this._maxDistance = options.maxDistance;
        this._edgeValue = options.edgeValue;
        this._mapProjection = options.mapProjection;
        this._lonLat = [
            0,
            0
        ];
        this._geoJSONHelper = new (0, $9567e168ff06f2c9$export$618604db0cd69e78)();
        this._core.log.write((0, $4a6417d29706362f$export$243e62d78d3b544d).info, `geoJSON rasterizer ${Math.round(window.performance.now() - start)}ms`);
    }
    draw(key) {
        let feature = this._geoJSONHelper.feature(this._geoJSON, this._property, key);
        if (feature) {
            let geometry = feature.geometry;
            const clip = {
                minLon: this._minLongitude,
                maxLon: this._maxLongitude,
                minLat: this._minLatitude,
                maxLat: this._maxLatitude
            };
            const bounds = this._geoJSONHelper.bounds(geometry, clip, this._mapProjection);
            if (bounds) {
                let minX = bounds.minX;
                let maxX = bounds.maxX;
                let minY = bounds.minY;
                let maxY = bounds.maxY;
                let sizeX = bounds.maxX - bounds.minX;
                let sizeY = bounds.maxY - bounds.minY;
                if (sizeX > 0 && sizeY > 0) {
                    const scale = this._scale * this._scaleFactor;
                    sizeX = Math.ceil(sizeX * scale);
                    sizeY = Math.ceil(sizeY * scale);
                    const canvas = document.createElement("canvas");
                    const width = sizeX + 2 * this._border;
                    const height = sizeY + 2 * this._border;
                    canvas.width = width;
                    canvas.height = height;
                    const ctx = canvas.getContext("2d", {
                        willReadFrequently: true
                    });
                    let length = width * height;
                    this._gridOuter = new Float64Array(length);
                    this._gridInner = new Float64Array(length);
                    length = Math.max(width, height);
                    this._f = new Float64Array(length);
                    this._z = new Float64Array(length + 1);
                    this._v = new Uint16Array(length);
                    length = width * height;
                    const distances = new Uint8ClampedArray(length);
                    const gradientsX = new Uint8ClampedArray(length);
                    const gradientsY = new Uint8ClampedArray(length);
                    const pixels = new Uint8ClampedArray(length);
                    const item = new $674034e16b0fa1d5$export$375c50c679feb27e();
                    item.key = key;
                    item.distances = distances;
                    item.gradientsX = gradientsX;
                    item.gradientsY = gradientsY;
                    item.pixels = pixels;
                    item.width = sizeX;
                    item.height = sizeY;
                    item.minLon = minX;
                    item.maxLon = maxX;
                    item.minLat = minY;
                    item.maxLat = maxY;
                    item.scale = this._scaleFactor;
                    ctx.clearRect(this._border, this._border, sizeX, sizeY);
                    switch(geometry.type){
                        case "Polygon":
                            const polygon = geometry;
                            const outer = polygon.coordinates[0];
                            ctx.fillStyle = "black";
                            ctx.beginPath();
                            this._lonLat[0] = outer[0][0];
                            this._lonLat[1] = outer[0][1];
                            if (this._lonLat[0] < clip.minLon || this._lonLat[0] > clip.maxLon || this._lonLat[1] < clip.minLat || this._lonLat[1] > clip.maxLat) break;
                            if (this._lonLat[0] > 0) this._lonLat[0] -= 360;
                            if (this._mapProjection) this._mapProjection.project(this._lonLat[0], this._lonLat[1], this._lonLat);
                            const x = (this._lonLat[0] - minX) * scale - sizeX / 2 + width / 2;
                            const y = height / 2 - (this._lonLat[1] - minY) * scale + sizeY / 2;
                            ctx.moveTo(x, y);
                            for(let k = 1; k < outer.length; k++){
                                this._lonLat[0] = outer[k][0];
                                this._lonLat[1] = outer[k][1];
                                if (this._lonLat[0] > 0) this._lonLat[0] -= 360;
                                if (this._mapProjection) this._mapProjection.project(this._lonLat[0], this._lonLat[1], this._lonLat);
                                const x = (this._lonLat[0] - minX) * scale - sizeX / 2 + width / 2;
                                const y = height / 2 - (this._lonLat[1] - minY) * scale + sizeY / 2;
                                ctx.lineTo(x, y);
                            }
                            ctx.fill();
                            for(let k = 1; k < polygon.coordinates.length; k++){
                                const inner = polygon.coordinates[k];
                                ctx.fillStyle = "transparent";
                                ctx.beginPath();
                                this._lonLat[0] = inner[0][0];
                                this._lonLat[1] = inner[0][1];
                                if (this._lonLat[0] > 0) this._lonLat[0] -= 360;
                                if (this._mapProjection) this._mapProjection.project(this._lonLat[0], this._lonLat[1], this._lonLat);
                                const x = (this._lonLat[0] - minX) * scale - sizeX / 2 + width / 2;
                                const y = height / 2 - (this._lonLat[1] - minY) * scale + sizeY / 2;
                                ctx.moveTo(x, y);
                                for(let l = 1; l < inner.length; l++){
                                    this._lonLat[0] = inner[l][0];
                                    this._lonLat[1] = inner[l][1];
                                    if (this._lonLat[0] > 0) this._lonLat[0] -= 360;
                                    if (this._mapProjection) this._mapProjection.project(this._lonLat[0], this._lonLat[1], this._lonLat);
                                    const x = (this._lonLat[0] - minX) * scale - sizeX / 2 + width / 2;
                                    const y = height / 2 - (this._lonLat[1] - minY) * scale + sizeY / 2;
                                    ctx.lineTo(x, y);
                                }
                                ctx.fill();
                            }
                            break;
                        case "MultiPolygon":
                            const multiPolygon = geometry;
                            for(let j = 0; j < multiPolygon.coordinates.length; j++){
                                const polygon = multiPolygon.coordinates[j];
                                const outer = polygon[0];
                                ctx.fillStyle = "black";
                                ctx.beginPath();
                                this._lonLat[0] = outer[0][0];
                                this._lonLat[1] = outer[0][1];
                                if (this._lonLat[0] < clip.minLon || this._lonLat[0] > clip.maxLon || this._lonLat[1] < clip.minLat || this._lonLat[1] > clip.maxLat) continue;
                                if (this._lonLat[0] > 0) this._lonLat[0] -= 360;
                                if (this._mapProjection) this._mapProjection.project(this._lonLat[0], this._lonLat[1], this._lonLat);
                                const x = (this._lonLat[0] - minX) * scale - sizeX / 2 + width / 2;
                                const y = height / 2 - (this._lonLat[1] - minY) * scale + sizeY / 2;
                                ctx.moveTo(x, y);
                                for(let k = 1; k < outer.length; k++){
                                    this._lonLat[0] = outer[k][0];
                                    this._lonLat[1] = outer[k][1];
                                    if (this._lonLat[0] > 0) this._lonLat[0] -= 360;
                                    if (this._mapProjection) this._mapProjection.project(this._lonLat[0], this._lonLat[1], this._lonLat);
                                    const x = (this._lonLat[0] - minX) * scale - sizeX / 2 + width / 2;
                                    const y = height / 2 - (this._lonLat[1] - minY) * scale + sizeY / 2;
                                    ctx.lineTo(x, y);
                                }
                                ctx.fill();
                                for(let k = 1; k < polygon.length; k++){
                                    const inner = polygon[k];
                                    ctx.fillStyle = "transparent";
                                    ctx.beginPath();
                                    this._lonLat[0] = inner[0][0];
                                    this._lonLat[1] = inner[0][1];
                                    if (this._lonLat[0] > 0) this._lonLat[0] -= 360;
                                    if (this._mapProjection) this._mapProjection.project(this._lonLat[0], this._lonLat[1], this._lonLat);
                                    const x = (this._lonLat[0] - minX) * scale - sizeX / 2 + width / 2;
                                    const y = height / 2 - (this._lonLat[1] - minY) * scale + sizeY / 2;
                                    ctx.moveTo(x, y);
                                    for(let l = 1; l < inner.length; l++){
                                        this._lonLat[0] = inner[l][0];
                                        this._lonLat[1] = inner[l][1];
                                        if (this._lonLat[0] > 0) this._lonLat[0] -= 360;
                                        if (this._mapProjection) this._mapProjection.project(this._lonLat[0], this._lonLat[1], this._lonLat);
                                        const x = (this._lonLat[0] - minX) * scale - sizeX / 2 + width / 2;
                                        const y = height / 2 - (this._lonLat[1] - minY) * scale + sizeY / 2;
                                        ctx.lineTo(x, y);
                                    }
                                    ctx.fill();
                                }
                            }
                            break;
                    }
                    const imgData = ctx.getImageData(this._border, this._border, sizeX, sizeY);
                    for(let i = 0; i < length; i++){
                        this._gridOuter[i] = Number.MAX_VALUE;
                        this._gridInner[i] = 0;
                    }
                    for(let y = 0; y < sizeY; y++)for(let x = 0; x < sizeX; x++){
                        const a = imgData.data[4 * (y * sizeX + x) + 3] / 0xff;
                        if (a > 0) {
                            const j = (y + this._border) * width + x + this._border;
                            if (a == 1) {
                                this._gridOuter[j] = 0;
                                this._gridInner[j] = Number.MAX_VALUE;
                                pixels[j] = 0xff;
                            } else {
                                const d = 0.5 - a;
                                this._gridOuter[j] = d > 0 ? d * d : 0;
                                this._gridInner[j] = d < 0 ? d * d : 0;
                            }
                        }
                    }
                    this._edt(this._gridOuter, 0, 0, width, height, width, this._f, this._v, this._z);
                    this._edt(this._gridInner, this._border, this._border, sizeX, sizeY, width, this._f, this._v, this._z);
                    const distances2 = new Float32Array(length);
                    for(let i = 0; i < length; i++){
                        const distance = Math.sqrt(this._gridOuter[i]) - Math.sqrt(this._gridInner[i]);
                        distances[i] = Math.round(this._edgeValue - distance * 0xff / this._maxDistance);
                        distances2[i] = distance;
                    }
                    for(let i = 0; i < length; i++){
                        const x = i % width;
                        const y = Math.floor(i / width);
                        const d = distances2[i];
                        const sign = d < 0 ? -1 : 1;
                        const x0 = x > 0 ? distances2[i - 1] : Number.MAX_VALUE;
                        const x1 = x < width - 1 ? distances2[i + 1] : Number.MAX_VALUE;
                        const y0 = y > 0 ? distances2[i - width] : Number.MAX_VALUE;
                        const y1 = y < height - 1 ? distances2[i + width] : Number.MAX_VALUE;
                        let gradientX = sign * x0 < sign * x1 ? d - x0 : x1 - d;
                        let gradientY = sign * y0 < sign * y1 ? y0 - d : d - y1;
                        gradientsX[i] = Math.round((gradientX * 0.5 + 0.5) * 0xff);
                        gradientsY[i] = Math.round((gradientY * 0.5 + 0.5) * 0xff);
                    }
                    return item;
                }
            }
        }
        if (!feature) this._core.log.write((0, $4a6417d29706362f$export$243e62d78d3b544d).warn, `geoJSON rasterizer ${key} not found`);
        return null;
    }
    _edt(data, x0, y0, width, height, gridSize, f, v, z) {
        for(let x = x0; x < x0 + width; x++)this._edt1d(data, y0 * gridSize + x, gridSize, height, f, v, z);
        for(let y = y0; y < y0 + height; y++)this._edt1d(data, y * gridSize + x0, 1, width, f, v, z);
    }
    _edt1d(grid, offset, stride, n, f, v, z) {
        v[0] = 0;
        z[0] = -Number.MAX_VALUE;
        z[1] = Number.MAX_VALUE;
        f[0] = grid[offset];
        for(let q = 1, k = 0, s = 0; q < n; q++){
            f[q] = grid[offset + q * stride];
            const q2 = q * q;
            do {
                const r = v[k];
                s = (f[q] - f[r] + q2 - r * r) / (q - r) / 2;
            }while (s <= z[k] && --k > -1);
            k++;
            v[k] = q;
            z[k] = s;
            z[k + 1] = Number.MAX_VALUE;
        }
        for(let q = 0, k = 0; q < n; q++){
            while(z[k + 1] < q)k++;
            const r = v[k];
            const qr = q - r;
            grid[offset + q * stride] = f[r] + qr * qr;
        }
    }
}


/*!
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 */ 
class $e74a570f4944e4e3$export$f04a61298a47a40f {
    toJSON() {
        return {
            key: this.key,
            u0: this.u0,
            v0: this.v0,
            u1: this.u1,
            v1: this.v1
        };
    }
}
class $e74a570f4944e4e3$export$88f28934f7b397a2 {
    update() {}
    constructor(icons){
        this.icons = icons;
    }
}
class $e74a570f4944e4e3$export$4f13f83fd8bb1dac {
    get atlas() {
        return this._rasterizer.atlas;
    }
    get count() {
        return this._keys.size;
    }
    constructor(core, rasterizer){
        this._core = core;
        this._rasterizer = rasterizer;
        this._keys = new Set();
        this._previousSize = 0;
        this.items = {};
    }
    add(key, imgData) {
        if (!this._keys.has(key)) {
            this._keys.add(key);
            this._rasterizer.draw(key, imgData);
        }
    }
    update() {
        if (this._hasChanged) {
            this._hasChanged = false;
            this._core.log.write((0, $4a6417d29706362f$export$243e62d78d3b544d).info, `${this.key} added ${this._keys.size - this._previousSize} new items`);
            this._previousSize = this._keys.size;
            if (this.hasChangedCallback) this.hasChangedCallback();
        }
    }
    toJSON() {
        const items = [];
        for(let key in this.items){
            const item = this.items[key];
            items.push(item.toJSON());
        }
        return {
            key: this.key,
            items: items
        };
    }
}
class $e74a570f4944e4e3$export$6497be8c854f7ac0 {
    constructor(width, height){
        const canvas = document.createElement("canvas");
        canvas.width = width;
        canvas.height = height;
        const context = canvas.getContext("2d");
        context.clearRect(0, 0, width, height);
        this.imageData = context.getImageData(0, 0, width, height);
        this.x = 0;
        this.top = new Uint16Array(width);
    }
}
class $e74a570f4944e4e3$export$368093602d58cb0a {
    get icons() {
        return this._icons;
    }
    get atlas() {
        return this._atlas;
    }
    constructor(core, options){
        let start = performance.now();
        this._core = core;
        this._atlas = options.atlas;
        this._border = options.border;
        this._maxDistance = options.maxDistance;
        this._edgeValue = options.edgeValue;
        this._key = options.key;
        this._icons = new $e74a570f4944e4e3$export$4f13f83fd8bb1dac(core, this);
        this._icons.key = this._key;
        const iconRasterizerOptions = {
            border: this._border,
            edgeValue: this._edgeValue,
            maxDistance: this._maxDistance
        };
        this._iconRasterizer = new $e74a570f4944e4e3$export$9178c5490b70082f(core, iconRasterizerOptions);
        this._core.log.write((0, $4a6417d29706362f$export$243e62d78d3b544d).info, `icons rasterizer ${Math.round(window.performance.now() - start)}ms`);
    }
    draw(key, imgData) {
        const item = this._iconRasterizer.draw(key, imgData);
        if (item) {
            const texWidth = item.width + 2 * this._border;
            const texHeight = item.height + 2 * this._border;
            const width = this._atlas.imageData.width;
            const height = this.atlas.imageData.height;
            if (this._atlas.x + texWidth > width - 1) this._atlas.x = 0;
            let y = 0;
            for(let x = this._atlas.x; x < this._atlas.x + texWidth; x++)y = Math.max(y, this._atlas.top[x]);
            if (y + texHeight > height - 1) this._core.log.write((0, $4a6417d29706362f$export$243e62d78d3b544d).warn, `${this._icons.key} height overflow`);
            for(let x = this._atlas.x; x < this._atlas.x + texWidth; x++)this._atlas.top[x] = y + texHeight;
            const halfTexelOffsetX = 0.5 / width;
            const halfTexelOffsetY = 0.5 / height;
            item.u0 = this._atlas.x / width + halfTexelOffsetX;
            item.v0 = y / height + halfTexelOffsetY;
            item.u1 = (this._atlas.x + texWidth) / width - halfTexelOffsetX;
            item.v1 = (y + texHeight) / height - halfTexelOffsetY;
            this._icons.items[key] = item;
            for(let i = 0; i < item.distances.length; i++){
                const distance = item.distances[i];
                const dataX = i % texWidth;
                const dataY = Math.floor(i / texWidth);
                const offset = (this._atlas.x + dataX + (y + dataY) * width) * 4;
                this._atlas.imageData.data[offset + 0] = distance;
                this._atlas.imageData.data[offset + 1] = distance;
                this._atlas.imageData.data[offset + 2] = distance;
                this._atlas.imageData.data[offset + 3] = 0xff;
            }
            this._atlas.x += texWidth;
        }
    }
}
class $e74a570f4944e4e3$export$9178c5490b70082f {
    constructor(core, options){
        let start = performance.now();
        this._core = core;
        this._border = options.border;
        this._maxDistance = options.maxDistance;
        this._edgeValue = options.edgeValue;
        this._core.log.write((0, $4a6417d29706362f$export$243e62d78d3b544d).info, `icon rasterizer ${Math.round(window.performance.now() - start)}ms`);
    }
    draw(key, imgData0) {
        const sizeX = imgData0.width;
        const sizeY = imgData0.height;
        const canvas = document.createElement("canvas");
        const width = sizeX + 2 * this._border;
        const height = sizeY + 2 * this._border;
        canvas.width = width;
        canvas.height = height;
        let length = width * height;
        this._gridOuter = new Float64Array(length);
        this._gridInner = new Float64Array(length);
        length = Math.max(width, height);
        this._f = new Float64Array(length);
        this._z = new Float64Array(length + 1);
        this._v = new Uint16Array(length);
        length = width * height;
        const distances = new Uint8ClampedArray(length);
        const gradientsX = new Uint8ClampedArray(length);
        const gradientsY = new Uint8ClampedArray(length);
        const pixels = new Uint8ClampedArray(length);
        const item = new $e74a570f4944e4e3$export$f04a61298a47a40f();
        item.key = key;
        item.distances = distances;
        item.gradientsX = gradientsX;
        item.gradientsY = gradientsY;
        item.pixels = pixels;
        item.width = sizeX;
        item.height = sizeY;
        const ctx = canvas.getContext("2d", {
            willReadFrequently: true
        });
        ctx.clearRect(this._border, this._border, sizeX, sizeY);
        ctx.putImageData(imgData0, this._border, this._border);
        const imgData1 = ctx.getImageData(this._border, this._border, sizeX, sizeY);
        for(let i = 0; i < length; i++){
            this._gridOuter[i] = Number.MAX_VALUE;
            this._gridInner[i] = 0;
        }
        for(let y = 0; y < sizeY; y++)for(let x = 0; x < sizeX; x++){
            const a = imgData1.data[4 * (y * sizeX + x) + 3] / 0xff;
            if (a > 0) {
                const j = (y + this._border) * width + x + this._border;
                if (a == 1) {
                    this._gridOuter[j] = 0;
                    this._gridInner[j] = Number.MAX_VALUE;
                    pixels[j] = 0xff;
                } else {
                    const d = 0.5 - a;
                    this._gridOuter[j] = d > 0 ? d * d : 0;
                    this._gridInner[j] = d < 0 ? d * d : 0;
                }
            }
        }
        this._edt(this._gridOuter, 0, 0, width, height, width, this._f, this._v, this._z);
        this._edt(this._gridInner, this._border, this._border, sizeX, sizeY, width, this._f, this._v, this._z);
        const distances2 = new Float32Array(length);
        for(let i = 0; i < length; i++){
            const distance = Math.sqrt(this._gridOuter[i]) - Math.sqrt(this._gridInner[i]);
            distances[i] = Math.round(this._edgeValue - distance * 0xff / this._maxDistance);
            distances2[i] = distance;
        }
        for(let i = 0; i < length; i++){
            const x = i % width;
            const y = Math.floor(i / width);
            const d = distances2[i];
            const sign = d < 0 ? -1 : 1;
            const x0 = x > 0 ? distances2[i - 1] : Number.MAX_VALUE;
            const x1 = x < width - 1 ? distances2[i + 1] : Number.MAX_VALUE;
            const y0 = y > 0 ? distances2[i - width] : Number.MAX_VALUE;
            const y1 = y < height - 1 ? distances2[i + width] : Number.MAX_VALUE;
            let gradientX = sign * x0 < sign * x1 ? d - x0 : x1 - d;
            let gradientY = sign * y0 < sign * y1 ? y0 - d : d - y1;
            gradientsX[i] = Math.round((gradientX * 0.5 + 0.5) * 0xff);
            gradientsY[i] = Math.round((gradientY * 0.5 + 0.5) * 0xff);
        }
        return item;
    }
    _edt(data, x0, y0, width, height, gridSize, f, v, z) {
        for(let x = x0; x < x0 + width; x++)this._edt1d(data, y0 * gridSize + x, gridSize, height, f, v, z);
        for(let y = y0; y < y0 + height; y++)this._edt1d(data, y * gridSize + x0, 1, width, f, v, z);
    }
    _edt1d(grid, offset, stride, n, f, v, z) {
        v[0] = 0;
        z[0] = -Number.MAX_VALUE;
        z[1] = Number.MAX_VALUE;
        f[0] = grid[offset];
        for(let q = 1, k = 0, s = 0; q < n; q++){
            f[q] = grid[offset + q * stride];
            const q2 = q * q;
            do {
                const r = v[k];
                s = (f[q] - f[r] + q2 - r * r) / (q - r) / 2;
            }while (s <= z[k] && --k > -1);
            k++;
            v[k] = q;
            z[k] = s;
            z[k + 1] = Number.MAX_VALUE;
        }
        for(let q = 0, k = 0; q < n; q++){
            while(z[k + 1] < q)k++;
            const r = v[k];
            const qr = q - r;
            grid[offset + q * stride] = f[r] + qr * qr;
        }
    }
}


var $8fe9a403f3311664$exports = {};

$parcel$export($8fe9a403f3311664$exports, "Controller", () => $6c3dd367ac3ca617$export$bd0bf19f25da8474);
$parcel$export($8fe9a403f3311664$exports, "ControllerVisual", () => $6c3dd367ac3ca617$export$c6e88a9dc8138322);
$parcel$export($8fe9a403f3311664$exports, "Label", () => $715a174735ed4fbb$export$b04be29aa201d4f5);
$parcel$export($8fe9a403f3311664$exports, "LabelVisual", () => $715a174735ed4fbb$export$71c7fa1581020e2c);
$parcel$export($8fe9a403f3311664$exports, "LabelSet", () => $715a174735ed4fbb$export$f51a22c5863d0d80);
$parcel$export($8fe9a403f3311664$exports, "TransitionLabelSet", () => $715a174735ed4fbb$export$8e28e4b5a55f0bba);
$parcel$export($8fe9a403f3311664$exports, "LabelSetVisual", () => $715a174735ed4fbb$export$97e93e7019ef67b9);
$parcel$export($8fe9a403f3311664$exports, "ImageVisual", () => $f7de7bdc7bccbb25$export$6f251cd327b2ff1);
$parcel$export($8fe9a403f3311664$exports, "ImageQuad", () => $f7de7bdc7bccbb25$export$3f0bd71f9b37d8ee);
$parcel$export($8fe9a403f3311664$exports, "ImageSphere", () => $f7de7bdc7bccbb25$export$f4ca272a8ace4457);
$parcel$export($8fe9a403f3311664$exports, "NominalKey", () => $4cef0568024a2460$export$1f02ce5a460c3bdd);
/*!
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 */ 
/*!
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 */ 






class $715a174735ed4fbb$export$71c7fa1581020e2c {
    render(elapsedTime, xrFrame) {}
    update(elapsedTime) {}
    constructor(label){
        this.label = label;
    }
}
class $715a174735ed4fbb$export$97e93e7019ef67b9 {
    render(elapsedTime, xrFrame) {}
    update(elapsedTime) {}
    constructor(labelSet){
        this.label = labelSet;
    }
}
class $715a174735ed4fbb$export$31008ffe97c96a49 {
    get material() {
        return this._material;
    }
    get vertices() {
        return this._vertices;
    }
    get verticesView() {
        return this._verticesView;
    }
    get indices() {
        return this._indices;
    }
    get indexCount() {
        return this._indexCount;
    }
    get isInitialized() {
        return this._isInitialized;
    }
    get mMatrix() {
        return this._mMatrix;
    }
    get scale() {
        return this._scale;
    }
    set scale(value) {
        if (this._scale != value) {
            this._scale = value;
            this._hasChanged = true;
        }
    }
    get font() {
        return this._font;
    }
    set font(value) {
        if (this._font != value) {
            this._font = value;
            this._hasChanged = true;
        }
    }
    get rotation() {
        return this._rotation;
    }
    set rotation(value) {
        if (this._rotation != value) {
            this._rotation = value;
            this._hasChanged = true;
        }
    }
    set reverseX(value) {
        if (this._reverseX != value) {
            this._reverseX = value;
            this._hasChanged = true;
        }
    }
    set reverseY(value) {
        if (this._reverseY != value) {
            this._reverseY = value;
            this._hasChanged = true;
        }
    }
    set reverseZ(value) {
        if (this._reverseZ != value) {
            this._reverseZ = value;
            this._hasChanged = true;
        }
    }
    get horizontalAlignment() {
        return this._horizontalAlignment;
    }
    set horizontalAlignment(value) {
        if (this._horizontalAlignment != value) {
            this._horizontalAlignment = value;
            this._hasChanged = true;
        }
    }
    get verticalAlignment() {
        return this._verticalAlignment;
    }
    set verticalAlignment(value) {
        if (this._verticalAlignment != value) {
            this._verticalAlignment = value;
            this._hasChanged = true;
        }
    }
    get offsetX() {
        return this._offsetX;
    }
    set offsetX(value) {
        if (this._offsetX != value) {
            this._offsetX = value;
            this._hasChanged = true;
        }
    }
    get offsetY() {
        return this._offsetY;
    }
    set offsetY(value) {
        if (this._offsetY != value) {
            this._offsetY = value;
            this._hasChanged = true;
        }
    }
    get offsetZ() {
        return this._offsetZ;
    }
    set offsetZ(value) {
        if (this._offsetZ != value) {
            this._offsetZ = value;
            this._hasChanged = true;
        }
    }
    get maxGlyphTop() {
        return this._maxGlyphTop;
    }
    set maxGlyphTop(value) {
        if (this._maxGlyphTop != value) {
            this._maxGlyphTop = value;
            this._hasChanged = true;
        }
    }
    get maxGlyphHeight() {
        return this._maxGlyphHeight;
    }
    set maxGlyphHeight(value) {
        if (this._maxGlyphHeight != value) {
            this._maxGlyphHeight = value;
            this._hasChanged = true;
        }
    }
    constructor(core, options){
        this._core = core;
        this._offset = (0, $31054a6c69637582$exports).create();
        this._vec3 = (0, $31054a6c69637582$exports).create();
        this._vec4 = (0, $4c4ac78b213a9c07$exports).create();
        this._mMatrix = (0, $1ac1b59392edf35b$exports).create();
        this._indexCount = 0;
        this._maxGlyphs = options.maxGlyphs;
        this._textMetric = {
            width: 0,
            maxHeight: 0,
            maxTop: 0
        };
        this.scale = options.scale ? options.scale : 1;
        this.offsetX = options.offsetX ? options.offsetX : 0;
        this.offsetY = options.offsetY ? options.offsetY : 0;
        this.offsetZ = options.offsetZ ? options.offsetZ : 0;
        this.reverseX = options.reverseX;
        this.reverseY = options.reverseY;
        this.reverseZ = options.reverseZ;
        this.rotation = options.rotation;
        this.maxGlyphTop = options.maxGlyphTop;
        this.horizontalAlignment = options.horizontalAlignment === undefined ? (0, $4a6417d29706362f$export$d94dcb5bec64086e).center : options.horizontalAlignment;
        this.verticalAlignment = options.verticalAlignment === undefined ? (0, $4a6417d29706362f$export$c12e835f91722ef8).center : options.verticalAlignment;
        this._material = options.material;
        this.borderWidth = core.config.textBorderWidth;
        this.gamma = 0;
    }
    initialize() {
        this._vertices = new ArrayBuffer((0, $0a0587bd8b0d58e8$export$74c3c25430a16442).SIZE_BYTES * this._maxGlyphs * 4);
        this._verticesView = new DataView(this._vertices);
        this._indices = new Uint32Array(this._maxGlyphs * 6);
        this._isInitialized = true;
    }
    update(elapsedTime) {}
}
class $715a174735ed4fbb$export$b04be29aa201d4f5 extends $715a174735ed4fbb$export$31008ffe97c96a49 {
    get textAlignment() {
        return this._textAlignment;
    }
    set textAlignment(value) {
        if (this._textAlignment != value) {
            this._textAlignment = value;
            this._hasChanged = true;
        }
    }
    get text() {
        return this._text;
    }
    set text(value) {
        if (this._text != value) {
            this._text = value;
            this._hasChanged = true;
        }
    }
    constructor(core, options){
        super(core, options);
        this._font = options.font || core.font;
        this._text = options.text;
        this._textAlignment = options.textAlignment === undefined ? (0, $4a6417d29706362f$export$84b2d1b68830363f).left : options.textAlignment;
    }
    update(elapsedTime) {
        if (this._hasChanged && this._isInitialized) {
            this._hasChanged = false;
            if (!this._text) {
                this._indexCount = 0;
                this.width = 0;
                this.height = 0;
            } else {
                const widths = [];
                const truncated = [];
                let maxWidth = 0;
                let maxGlyphHeight = 0;
                let maxGlyphTop = 0;
                let glyphs = 0;
                for(let i = 0; i < this._text.length; i++){
                    const text = (0, $ee14aeb68f9f83d5$export$f080f423ca93034f).truncate(this._text[i], this._maxGlyphs - glyphs);
                    (0, $ee14aeb68f9f83d5$export$f080f423ca93034f).measure(this._font, text, this._textMetric);
                    widths.push(this._textMetric.width);
                    maxWidth = Math.max(this._textMetric.width, maxWidth);
                    maxGlyphHeight = Math.max(this._textMetric.maxHeight, maxGlyphHeight);
                    maxGlyphTop = Math.max(this._textMetric.maxTop, maxGlyphTop);
                    glyphs += text.length;
                    truncated.push(text);
                    if (glyphs >= this._maxGlyphs) break;
                }
                if (this._maxGlyphHeight) maxGlyphHeight = this._maxGlyphHeight;
                if (this._maxGlyphTop) maxGlyphTop = this._maxGlyphTop;
                const lineHeight = this._font.size;
                const height = truncated.length * lineHeight;
                switch(this._horizontalAlignment){
                    case (0, $4a6417d29706362f$export$d94dcb5bec64086e).left:
                        this._originX = this._offsetX + maxWidth / 2;
                        break;
                    case (0, $4a6417d29706362f$export$d94dcb5bec64086e).center:
                        this._originX = this._offsetX;
                        break;
                    case (0, $4a6417d29706362f$export$d94dcb5bec64086e).right:
                        this._originX = this._offsetX - maxWidth / 2;
                        break;
                }
                switch(this._verticalAlignment){
                    case (0, $4a6417d29706362f$export$c12e835f91722ef8).top:
                        this._originY = this._offsetY - height / 2;
                        break;
                    case (0, $4a6417d29706362f$export$c12e835f91722ef8).center:
                        this._originY = this._offsetY;
                        break;
                    case (0, $4a6417d29706362f$export$c12e835f91722ef8).bottom:
                        this._originY = this._offsetY + height / 2;
                        break;
                }
                glyphs = 0;
                for(let i = 0; i < truncated.length; i++){
                    switch(this._textAlignment){
                        case (0, $4a6417d29706362f$export$84b2d1b68830363f).left:
                            this._offset[0] = this._originX - maxWidth / 2;
                            break;
                        case (0, $4a6417d29706362f$export$84b2d1b68830363f).center:
                            this._offset[0] = this._originX - widths[i] / 2;
                            break;
                        case (0, $4a6417d29706362f$export$84b2d1b68830363f).right:
                            this._offset[0] = this._originX + maxWidth / 2 - widths[i];
                            break;
                    }
                    this._offset[1] = this._originY + height / 2 - i * lineHeight - lineHeight / 2 - maxGlyphTop / 2;
                    const pickingId = (0, $a60d0d861ccf87e8$export$aadd933e49c67c12).nextPickId();
                    (0, $a60d0d861ccf87e8$export$aadd933e49c67c12).encodeNumber(pickingId, (0, $4a6417d29706362f$export$6fc3f4da94ff0be0).label, this._vec4);
                    const text = truncated[i];
                    if (text.length > 0) {
                        (0, $ee14aeb68f9f83d5$export$f080f423ca93034f).addString(this._font, text, this._verticesView, this._indices, glyphs, (0, $d4d7bd6cc65a5081$export$a002182e51710d39).VECTOR3_ZERO, 1, this._offset, null, this._vec4);
                        glyphs += text.length;
                    }
                }
                const scaling = this._scale / this._font.size;
                this.width = maxWidth * scaling;
                this.height = height * scaling;
                this._indexCount = glyphs * 6;
                (0, $31054a6c69637582$exports).set(this._vec3, scaling, scaling, scaling);
                (0, $1ac1b59392edf35b$exports).fromScaling(this._mMatrix, this._vec3);
                if (this.hasChangedCallback) this.hasChangedCallback();
            }
        }
    }
}
class $715a174735ed4fbb$export$f51a22c5863d0d80 extends $715a174735ed4fbb$export$31008ffe97c96a49 {
    get materials() {
        return this._materials;
    }
    get minBoundsX() {
        return this._minBoundsX;
    }
    set minBoundsX(value) {
        if (this._minBoundsX != value) {
            this._minBoundsX = value;
            this._hasChanged = true;
        }
    }
    get minBoundsY() {
        return this._minBoundsY;
    }
    set minBoundsY(value) {
        if (this._minBoundsY != value) {
            this._minBoundsY = value;
            this._hasChanged = true;
        }
    }
    get minBoundsZ() {
        return this._minBoundsZ;
    }
    set minBoundsZ(value) {
        if (this._minBoundsZ != value) {
            this._minBoundsZ = value;
            this._hasChanged = true;
        }
    }
    get maxBoundsX() {
        return this._maxBoundsX;
    }
    set maxBoundsX(value) {
        if (this._maxBoundsX != value) {
            this._maxBoundsX = value;
            this._hasChanged = true;
        }
    }
    get maxBoundsY() {
        return this._maxBoundsY;
    }
    set maxBoundsY(value) {
        if (this._maxBoundsY != value) {
            this._maxBoundsY = value;
            this._hasChanged = true;
        }
    }
    get maxBoundsZ() {
        return this._maxBoundsZ;
    }
    set maxBoundsZ(value) {
        if (this._maxBoundsZ != value) {
            this._maxBoundsZ = value;
            this._hasChanged = true;
        }
    }
    get positionsX() {
        return this._positionsX;
    }
    set positionsX(value) {
        if (this._positionsX != value) {
            this._positionsX = value;
            this._hasChanged = true;
        }
    }
    get positionsY() {
        return this._positionsY;
    }
    set positionsY(value) {
        if (this._positionsY != value) {
            this._positionsY = value;
            this._hasChanged = true;
        }
    }
    get positionsZ() {
        return this._positionsZ;
    }
    set positionsZ(value) {
        if (this._positionsZ != value) {
            this._positionsZ = value;
            this._hasChanged = true;
        }
    }
    get positionScalingX() {
        return this._positionScalingX;
    }
    set positionScalingX(value) {
        if (this._positionScalingX != value) {
            this._positionScalingX = value;
            this._hasChanged = true;
        }
    }
    get positionScalingY() {
        return this._positionScalingY;
    }
    set positionScalingY(value) {
        if (this._positionScalingY != value) {
            this._positionScalingY = value;
            this._hasChanged = true;
        }
    }
    get positionScalingZ() {
        return this._positionScalingZ;
    }
    set positionScalingZ(value) {
        if (this._positionScalingZ != value) {
            this._positionScalingZ = value;
            this._hasChanged = true;
        }
    }
    get rotations() {
        return this._rotations;
    }
    set rotations(value) {
        if (this._rotations != value) {
            this._rotations = value;
            this._hasChanged = true;
        }
    }
    get offsetsX() {
        return this._offsetsX;
    }
    set offsetsX(value) {
        if (this._offsetsX != value) {
            this._offsetsX = value;
            this._hasChanged = true;
        }
    }
    get offsetsY() {
        return this._offsetsY;
    }
    set offsetsY(value) {
        if (this._offsetsY != value) {
            this._offsetsY = value;
            this._hasChanged = true;
        }
    }
    get offsetsZ() {
        return this._offsetsZ;
    }
    set offsetsZ(value) {
        if (this._offsetsZ != value) {
            this._offsetsZ = value;
            this._hasChanged = true;
        }
    }
    get offsetScalingX() {
        return this._offsetScalingX;
    }
    set offsetScalingX(value) {
        if (this._offsetScalingX != value) {
            this._offsetScalingX = value;
            this._hasChanged = true;
        }
    }
    get offsetScalingY() {
        return this._offsetScalingY;
    }
    set offsetScalingY(value) {
        if (this._offsetScalingY != value) {
            this._offsetScalingY = value;
            this._hasChanged = true;
        }
    }
    get offsetScalingZ() {
        return this._offsetScalingZ;
    }
    set offsetScalingZ(value) {
        if (this._offsetScalingZ != value) {
            this._offsetScalingZ = value;
            this._hasChanged = true;
        }
    }
    get text() {
        return this._text;
    }
    set text(value) {
        if (this._text != value) {
            this._text = value;
            this._hasChanged = true;
        }
    }
    get horizontalAlignments() {
        return this._horizontalAlignments;
    }
    set horizontalAlignments(value) {
        if (this._horizontalAlignments != value) {
            this._horizontalAlignments = value;
            this._hasChanged = true;
        }
    }
    get verticalAlignments() {
        return this._verticalAlignments;
    }
    set verticalAlignments(value) {
        if (this._verticalAlignments != value) {
            this._verticalAlignments = value;
            this._hasChanged = true;
        }
    }
    get scales() {
        return this._scales;
    }
    set scales(value) {
        if (this._scales != value) {
            this._scales = value;
            this._hasChanged = true;
        }
    }
    get scalesScaling() {
        return this._scalesScaling;
    }
    set scalesScaling(value) {
        if (this._scalesScaling != value) {
            this._scalesScaling = value;
            this._hasChanged = true;
        }
    }
    constructor(core, options){
        super(core, options);
        this._quat = (0, $39ece26d1239bb77$exports).create();
        this._materials = options.materials;
        this.minBoundsX = options.minBoundsX ? options.minBoundsX : 0;
        this.minBoundsY = options.minBoundsY ? options.minBoundsY : 0;
        this.minBoundsZ = options.minBoundsZ ? options.minBoundsZ : 0;
        this.maxBoundsX = options.maxBoundsX ? options.maxBoundsX : 1;
        this.maxBoundsY = options.maxBoundsY ? options.maxBoundsY : 1;
        this.maxBoundsZ = options.maxBoundsZ ? options.maxBoundsZ : 1;
        this._font = options.font || core.font;
        this.text = options.text;
        this.positionsX = options.positionsX;
        this.positionsY = options.positionsY;
        this.positionsZ = options.positionsZ;
        this.positionScalingX = options.positionScalingX ? options.positionScalingX : 1;
        this.positionScalingY = options.positionScalingY ? options.positionScalingY : 1;
        this.positionScalingZ = options.positionScalingZ ? options.positionScalingZ : 1;
        this.rotations = options.rotations;
        this.offsetsX = options.offsetsX;
        this.offsetsY = options.offsetsY;
        this.offsetsZ = options.offsetsZ;
        this.offsetScalingX = options.offsetScalingX ? options.offsetScalingX : 1;
        this.offsetScalingY = options.offsetScalingY ? options.offsetScalingY : 1;
        this.offsetScalingZ = options.offsetScalingZ ? options.offsetScalingZ : 1;
        if (options.horizontalAlignments) this.horizontalAlignments = options.horizontalAlignments;
        if (options.verticalAlignments) this.verticalAlignments = options.verticalAlignments;
        if (options.scales) this.scales = options.scales;
        this.scalesScaling = options.scalesScaling ? options.scalesScaling : 1;
    }
    update(elapsedTime) {
        if (this._hasChanged && this._isInitialized) {
            this._hasChanged = false;
            this.pickIdLookup = {};
            if (!this._text) this._indexCount = 0;
            else {
                const start = window.performance.now();
                const modelSizeX = this._maxBoundsX - this._minBoundsX;
                const modelSizeY = this._maxBoundsY - this._minBoundsY;
                const modelSizeZ = this._maxBoundsZ - this._minBoundsZ;
                const maxBounds = Math.max(modelSizeX, Math.max(modelSizeY, modelSizeZ));
                const boundsScaling = maxBounds == 0 ? 1 : 1 / maxBounds;
                const modelOriginX = (this._minBoundsX + this._maxBoundsX) / 2;
                const modelOriginY = (this._minBoundsY + this._maxBoundsY) / 2;
                const modelOriginZ = (this._minBoundsZ + this._maxBoundsZ) / 2;
                if (this._rotation) (0, $39ece26d1239bb77$exports).set(this._quat, this._rotation[0], this._rotation[1], this._rotation[2], this._rotation[3]);
                let glyphs = 0;
                for(let i = 0; i < this._text.length; i++){
                    const offsetX = (this._offsetsX ? this._offsetsX[i] / 2 : this._offsetX) * boundsScaling * this._offsetScalingX;
                    const offsetY = (this._offsetsY ? this._offsetsY[i] / 2 : this._offsetY) * boundsScaling * this._offsetScalingY;
                    const offsetZ = (this._offsetsZ ? this._offsetsZ[i] / 2 : this._offsetZ) * boundsScaling * this._offsetScalingZ;
                    const text = (0, $ee14aeb68f9f83d5$export$f080f423ca93034f).truncate(this._text[i], this._maxGlyphs - glyphs);
                    const scale = (this._scales ? this._scales[i] * this._scalesScaling : this._scale) * boundsScaling / this._font.size;
                    (0, $ee14aeb68f9f83d5$export$f080f423ca93034f).measure(this._font, text, this._textMetric);
                    const width = this._textMetric.width * scale;
                    const lineHeight = this._font.size * scale;
                    const maxGlyphTop = (this._maxGlyphTop ? this._maxGlyphTop : this._textMetric.maxTop) * scale;
                    const horizontalAlignment = this._horizontalAlignments ? this._horizontalAlignments[i] : this._horizontalAlignment;
                    switch(horizontalAlignment){
                        case (0, $4a6417d29706362f$export$d94dcb5bec64086e).left:
                            this._offset[0] = offsetX;
                            break;
                        case (0, $4a6417d29706362f$export$d94dcb5bec64086e).center:
                            this._offset[0] = offsetX - width / 2;
                            break;
                        case (0, $4a6417d29706362f$export$d94dcb5bec64086e).right:
                            this._offset[0] = offsetX - width;
                            break;
                    }
                    const verticalAlignment = this._verticalAlignments ? this._verticalAlignments[i] : this._verticalAlignment;
                    switch(verticalAlignment){
                        case (0, $4a6417d29706362f$export$c12e835f91722ef8).top:
                            this._offset[1] = offsetY - lineHeight / 2;
                            break;
                        case (0, $4a6417d29706362f$export$c12e835f91722ef8).center:
                            this._offset[1] = offsetY;
                            break;
                        case (0, $4a6417d29706362f$export$c12e835f91722ef8).bottom:
                            this._offset[1] = offsetY + lineHeight / 2;
                            break;
                    }
                    this._offset[1] -= maxGlyphTop / 2;
                    this._offset[2] = offsetZ;
                    let positionX = this.positionsX ? this.positionsX[i] * this.positionScalingX : 0;
                    let positionY = this.positionsY ? this.positionsY[i] * this.positionScalingY : 0;
                    let positionZ = this.positionsZ ? this.positionsZ[i] * this.positionScalingZ : 0;
                    if (this._reverseX) positionX = this.minBoundsX + this.maxBoundsX - positionX;
                    if (this._reverseY) positionY = this.minBoundsY + this.maxBoundsY - positionY;
                    if (this._reverseZ) positionZ = this.minBoundsZ + this.maxBoundsZ - positionZ;
                    (0, $31054a6c69637582$exports).set(this._vec3, (positionX - modelOriginX) * boundsScaling, (positionY - modelOriginY) * boundsScaling, (positionZ - modelOriginZ) * boundsScaling);
                    if (this._rotations) (0, $39ece26d1239bb77$exports).set(this._quat, this._rotations[i * 4], this._rotations[i * 4 + 1], this._rotations[i * 4 + 2], this._rotations[i * 4 + 3]);
                    const pickId = (0, $a60d0d861ccf87e8$export$aadd933e49c67c12).nextPickId();
                    (0, $a60d0d861ccf87e8$export$aadd933e49c67c12).encodeNumber(pickId, (0, $4a6417d29706362f$export$6fc3f4da94ff0be0).label, this._vec4);
                    this.pickIdLookup[pickId] = i;
                    (0, $ee14aeb68f9f83d5$export$f080f423ca93034f).addString(this._font, text, this._verticesView, this._indices, glyphs, this._vec3, scale, this._offset, this._rotation || this._rotations ? this._quat : null, this._vec4);
                    glyphs += text.length;
                    if (glyphs >= this._maxGlyphs) {
                        glyphs = this._maxGlyphs;
                        break;
                    }
                }
                this._indexCount = glyphs * 6;
                this._core.log.write((0, $4a6417d29706362f$export$243e62d78d3b544d).info, `label set updated ${Math.round(window.performance.now() - start)}ms`);
                if (this.hasChangedCallback) this.hasChangedCallback();
            }
        }
    }
}
class $715a174735ed4fbb$export$8e28e4b5a55f0bba {
    constructor(core){
        this._core = core;
        this._vec2 = (0, $91b0cc4981465964$exports).create();
        this._vec3 = (0, $31054a6c69637582$exports).create();
        this._vec4 = (0, $4c4ac78b213a9c07$exports).create();
        this._quat = (0, $39ece26d1239bb77$exports).create();
        this._textMetric = {
            width: 0,
            maxHeight: 0,
            maxTop: 0
        };
        this._topLeft = (0, $31054a6c69637582$exports).create();
        this._topRight = (0, $31054a6c69637582$exports).create();
        this._bottomLeft = (0, $31054a6c69637582$exports).create();
        this._bottomRight = (0, $31054a6c69637582$exports).create();
        this._offset = (0, $31054a6c69637582$exports).create();
    }
    update(buffer, labelIds, options) {
        const start = window.performance.now();
        const offset = options.offset === undefined ? 0 : options.offset;
        const count = options.count === undefined ? options.text.length : options.count;
        const dataView = buffer.dataView;
        const minBoundsX = options.minBoundsX ? options.minBoundsX : 0;
        const minBoundsY = options.minBoundsY ? options.minBoundsY : 0;
        const minBoundsZ = options.minBoundsZ ? options.minBoundsZ : 0;
        const maxBoundsX = options.maxBoundsX ? options.maxBoundsX : 1;
        const maxBoundsY = options.maxBoundsY ? options.maxBoundsY : 1;
        const maxBoundsZ = options.maxBoundsZ ? options.maxBoundsZ : 1;
        const positionScalingX = options.positionScalingX ? options.positionScalingX : 1;
        const positionScalingY = options.positionScalingY ? options.positionScalingY : 1;
        const positionScalingZ = options.positionScalingZ ? options.positionScalingZ : 1;
        const offsetX = options.offsetX ? options.offsetX : 0;
        const offsetY = options.offsetY ? options.offsetY : 0;
        const offsetZ = options.offsetZ ? options.offsetZ : 0;
        const offsetScalingX = options.offsetScalingX ? options.offsetScalingX : 1;
        const offsetScalingY = options.offsetScalingY ? options.offsetScalingY : 1;
        const offsetScalingZ = options.offsetScalingZ ? options.offsetScalingZ : 1;
        const horizontalAlignment = options.horizontalAlignment === undefined ? (0, $4a6417d29706362f$export$d94dcb5bec64086e).center : options.horizontalAlignment;
        const verticalAlignment = options.verticalAlignment === undefined ? (0, $4a6417d29706362f$export$c12e835f91722ef8).center : options.verticalAlignment;
        const scale = options.scale ? options.scale : 1;
        const scalesScaling = options.scalesScaling ? options.scalesScaling : 1;
        const font = options.font || this._core.font;
        const minOrder = options.minOrder === undefined ? 0 : options.minOrder;
        const maxOrder = options.maxOrder === undefined ? 1 : options.maxOrder;
        const orderReverse = options.orderReverse === undefined ? false : options.orderReverse;
        const minStaggerOrder = options.minStaggerOrder === undefined ? 0 : options.minStaggerOrder;
        const maxStaggerOrder = options.maxStaggerOrder === undefined ? 1 : options.maxStaggerOrder;
        const staggerOrderReverse = options.staggerOrderReverse === undefined ? false : options.staggerOrderReverse;
        const modelSizeX = maxBoundsX - minBoundsX;
        const modelSizeY = maxBoundsY - minBoundsY;
        const modelSizeZ = maxBoundsZ - minBoundsZ;
        const maxBounds = Math.max(modelSizeX, Math.max(modelSizeY, modelSizeZ));
        const boundsScaling = maxBounds == 0 ? 1 : 1 / maxBounds;
        const modelOriginX = (minBoundsX + maxBoundsX) / 2;
        const modelOriginY = (minBoundsY + maxBoundsY) / 2;
        const modelOriginZ = (minBoundsZ + maxBoundsZ) / 2;
        if (options.rotation) {
            this._quat[0] = options.rotation[0];
            this._quat[1] = options.rotation[1];
            this._quat[2] = options.rotation[2];
            this._quat[3] = options.rotation[3];
        } else (0, $39ece26d1239bb77$exports).rotationTo(this._quat, this._core.config.identityRotation, (0, $d4d7bd6cc65a5081$export$a002182e51710d39).VECTOR3_UNITY);
        this.pickIdLookup = {};
        for(let i = 0; i < count; i++){
            const labelIndex = labelIds[i + offset];
            const _offsetX = (options.offsetsX ? options.offsetsX[labelIndex] / 2 : offsetX) * boundsScaling * offsetScalingX;
            const _offsetY = (options.offsetsY ? options.offsetsY[labelIndex] / 2 : offsetY) * boundsScaling * offsetScalingY;
            const _offsetZ = (options.offsetsZ ? options.offsetsZ[labelIndex] / 2 : offsetZ) * boundsScaling * offsetScalingZ;
            const label = options.text[labelIndex];
            const _scale = (options.scales ? options.scales[labelIndex] * scalesScaling : scale) * boundsScaling / font.size;
            (0, $ee14aeb68f9f83d5$export$f080f423ca93034f).measure(font, label, this._textMetric);
            const width = this._textMetric.width * _scale;
            const lineHeight = font.size * _scale;
            const _maxGlyphTop = (options.maxGlyphTop ? options.maxGlyphTop : this._textMetric.maxTop) * _scale;
            const _horizontalAlignment = options.horizontalAlignments ? options.horizontalAlignments[labelIndex] : horizontalAlignment;
            switch(_horizontalAlignment){
                case (0, $4a6417d29706362f$export$d94dcb5bec64086e).left:
                    this._offset[0] = _offsetX;
                    break;
                case (0, $4a6417d29706362f$export$d94dcb5bec64086e).center:
                    this._offset[0] = _offsetX - width / 2;
                    break;
                case (0, $4a6417d29706362f$export$d94dcb5bec64086e).right:
                    this._offset[0] = _offsetX - width;
                    break;
            }
            const _verticalAlignment = options.verticalAlignments ? options.verticalAlignments[labelIndex] : verticalAlignment;
            switch(_verticalAlignment){
                case (0, $4a6417d29706362f$export$c12e835f91722ef8).top:
                    this._offset[1] = _offsetY - lineHeight / 2;
                    break;
                case (0, $4a6417d29706362f$export$c12e835f91722ef8).center:
                    this._offset[1] = _offsetY;
                    break;
                case (0, $4a6417d29706362f$export$c12e835f91722ef8).bottom:
                    this._offset[1] = _offsetY + lineHeight / 2;
                    break;
            }
            this._offset[1] -= _maxGlyphTop / 2;
            this._offset[2] = _offsetZ;
            let positionX = options.positionsX ? options.positionsX[labelIndex] * positionScalingX : 0;
            let positionY = options.positionsY ? options.positionsY[labelIndex] * positionScalingY : 0;
            let positionZ = options.positionsZ ? options.positionsZ[labelIndex] * positionScalingZ : 0;
            if (options.reverseX) positionX = minBoundsX + maxBoundsX - positionX;
            if (options.reverseY) positionY = minBoundsY + maxBoundsY - positionY;
            if (options.reverseZ) positionZ = minBoundsZ + maxBoundsZ - positionZ;
            positionX = (positionX - modelOriginX) * boundsScaling;
            positionY = (positionY - modelOriginY) * boundsScaling;
            positionZ = (positionZ - modelOriginZ) * boundsScaling;
            if (options.rotations) (0, $39ece26d1239bb77$exports).set(this._quat, options.rotations[labelIndex * 4], options.rotations[labelIndex * 4 + 1], options.rotations[labelIndex * 4 + 2], options.rotations[labelIndex * 4 + 3]);
            const pickId = (0, $a60d0d861ccf87e8$export$aadd933e49c67c12).nextPickId();
            (0, $a60d0d861ccf87e8$export$aadd933e49c67c12).encodeNumber(pickId, (0, $4a6417d29706362f$export$6fc3f4da94ff0be0).label, this._vec4);
            this.pickIdLookup[pickId] = labelIndex;
            if (options.order !== undefined) {
                const order = (0, $2d4d1eb6f32f02f2$export$80a8c44b8858d625).normalize(options.order[labelIndex], minOrder, maxOrder, 0, 1);
                this._vec2[0] = orderReverse ? 1 - order : order;
            } else this._vec2[0] = count == 1 ? 0 : i / (count - 1);
            if (options.staggerOrder !== undefined) this._vec2[1] = options.staggerOrder;
            else if (options.staggerOrders) {
                const stagger = (0, $2d4d1eb6f32f02f2$export$80a8c44b8858d625).normalize(options.staggerOrders[labelIndex], minStaggerOrder, maxStaggerOrder, 0, 1);
                this._vec2[1] = staggerOrderReverse ? 1 - stagger : stagger;
            } else this._vec2[1] = count == 1 ? 0 : i / (count - 1);
            let glyphIndex = options.glyphOffsets[labelIndex];
            for (const char of label){
                let glyph = font.glyphs[char];
                if (!glyph) {
                    font.addGlyph(char);
                    glyph = font.glyphs[char];
                }
                const width = glyph.width * _scale;
                const height = glyph.height * _scale;
                const top = glyph.top * _scale;
                const border = font.border * _scale;
                const x0 = this._offset[0] - border;
                const x1 = this._offset[0] + width + border;
                const y0 = this._offset[1] + top + border;
                const y1 = this._offset[1] + top - height - border;
                const z0 = this._offset[2];
                (0, $31054a6c69637582$exports).set(this._topLeft, x0, y0, z0);
                (0, $31054a6c69637582$exports).set(this._topRight, x1, y0, z0);
                (0, $31054a6c69637582$exports).set(this._bottomLeft, x0, y1, z0);
                (0, $31054a6c69637582$exports).set(this._bottomRight, x1, y1, z0);
                if (options.rotation || options.rotations) {
                    (0, $31054a6c69637582$exports).transformQuat(this._topLeft, this._topLeft, this._quat);
                    (0, $31054a6c69637582$exports).transformQuat(this._topRight, this._topRight, this._quat);
                    (0, $31054a6c69637582$exports).transformQuat(this._bottomLeft, this._bottomLeft, this._quat);
                    (0, $31054a6c69637582$exports).transformQuat(this._bottomRight, this._bottomRight, this._quat);
                }
                (0, $0a0587bd8b0d58e8$export$849e31d725692576).setRotation(dataView, glyphIndex, this._quat);
                this._vec3[0] = positionX + (this._topLeft[0] + this._bottomRight[0]) / 2;
                this._vec3[1] = positionY + (this._topLeft[1] + this._bottomRight[1]) / 2;
                this._vec3[2] = positionZ + (this._topLeft[2] + this._bottomRight[2]) / 2;
                (0, $0a0587bd8b0d58e8$export$849e31d725692576).setTranslation(dataView, glyphIndex, this._vec3);
                this._vec3[0] = Math.abs(x1 - x0);
                this._vec3[1] = Math.abs(y1 - y0);
                this._vec3[2] = 0.001;
                (0, $0a0587bd8b0d58e8$export$849e31d725692576).setScale(dataView, glyphIndex, this._vec3);
                this._vec4[0] = glyph.u0;
                this._vec4[1] = glyph.v0;
                this._vec4[2] = glyph.u1;
                this._vec4[3] = glyph.v1;
                (0, $0a0587bd8b0d58e8$export$849e31d725692576).setTexCoord(dataView, glyphIndex, this._vec4);
                (0, $0a0587bd8b0d58e8$export$849e31d725692576).setIdHover(dataView, glyphIndex, options.hover ? options.hover[labelIndex] : labelIndex);
                (0, $0a0587bd8b0d58e8$export$849e31d725692576).setOrder(dataView, glyphIndex, this._vec2);
                (0, $0a0587bd8b0d58e8$export$849e31d725692576).setMaterial(dataView, glyphIndex, options.material ? options.material : options.materials ? options.materials[labelIndex] : 0);
                (0, $0a0587bd8b0d58e8$export$849e31d725692576).setTexture(dataView, glyphIndex, 1);
                (0, $0a0587bd8b0d58e8$export$849e31d725692576).setSdfBuffer(dataView, glyphIndex, this._core.config.sdfBuffer);
                this._offset[0] += glyph.advance * _scale;
                glyphIndex++;
            }
        }
        buffer.update();
        this._core.log.write((0, $4a6417d29706362f$export$243e62d78d3b544d).info, `${this.constructor.name.toLowerCase()} update ${count} ${Math.round(window.performance.now() - start)}ms`);
    }
}


/*!
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 */ 


/*!
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 */ 



class $01ead9aa9a4bc88a$export$805e8b72413ccaba {
    constructor(core){}
    positions(slices, stacks, transform) {
        const vertices = new Float32Array((slices + 1) * (stacks + 1) * (0, $0a0587bd8b0d58e8$export$5b33f080c7f6c861).SIZE);
        const position = (0, $31054a6c69637582$exports).create();
        let index = 0;
        for(let stack = 0; stack <= stacks; stack++){
            const latitude = 90 - 180 * stack / stacks;
            for(let slice = 0; slice <= slices; slice++){
                const longitude = 360 * slice / slices - 180;
                (0, $a49c65c28e06311e$export$210d3b2db589eb5c).sphericalToCartesian(1, longitude, latitude, position);
                (0, $31054a6c69637582$exports).transformMat4(position, position, transform);
                (0, $0a0587bd8b0d58e8$export$5b33f080c7f6c861).setPosition(vertices, index++, position);
            }
        }
        return vertices;
    }
    indices(slices, stacks) {
        const indices = new Uint16Array(slices * stacks * 6);
        let index = 0;
        for(let stack = 0; stack < stacks; stack++){
            const top = stack * (slices + 1);
            const bottom = (stack + 1) * (slices + 1);
            for(let slice = 0; slice < slices; slice++){
                if (stack != 0) {
                    indices[index++] = top + slice;
                    indices[index++] = bottom + slice;
                    indices[index++] = top + slice + 1;
                }
                if (stack != stacks - 1) {
                    indices[index++] = top + slice + 1;
                    indices[index++] = bottom + slice;
                    indices[index++] = bottom + slice + 1;
                }
            }
        }
        return indices;
    }
    textured(slices, stacks, transform, texTransform = (0, $d4d7bd6cc65a5081$export$a002182e51710d39).MAT4_IDENTITY) {
        const positions = this.positions(slices, stacks, transform);
        const texCoords = this._texCoords(slices, stacks, texTransform);
        const vertices = new ArrayBuffer((0, $0a0587bd8b0d58e8$export$538532535e0e8594).SIZE_BYTES * positions.length / 3);
        const verticesView = new DataView(vertices);
        const position = (0, $31054a6c69637582$exports).create();
        const texCoord = (0, $91b0cc4981465964$exports).create();
        for(let i = 0; i < positions.length / (0, $0a0587bd8b0d58e8$export$5b33f080c7f6c861).SIZE; i++){
            (0, $31054a6c69637582$exports).set(position, positions[i * (0, $0a0587bd8b0d58e8$export$5b33f080c7f6c861).SIZE], positions[i * (0, $0a0587bd8b0d58e8$export$5b33f080c7f6c861).SIZE + 1], positions[i * (0, $0a0587bd8b0d58e8$export$5b33f080c7f6c861).SIZE + 2]);
            (0, $91b0cc4981465964$exports).set(texCoord, texCoords[i * 2], texCoords[i * 2 + 1]);
            (0, $0a0587bd8b0d58e8$export$538532535e0e8594).setPosition(verticesView, i, position);
            (0, $0a0587bd8b0d58e8$export$538532535e0e8594).setTexCoord(verticesView, i, texCoord);
        }
        return verticesView;
    }
    normalTextured(slices, stacks, transform, texTransform = (0, $d4d7bd6cc65a5081$export$a002182e51710d39).MAT4_IDENTITY) {
        const positions = this.positions(slices, stacks, transform);
        const texCoords = this._texCoords(slices, stacks, texTransform);
        const vertices = new ArrayBuffer((0, $0a0587bd8b0d58e8$export$e40add16394b9bff).SIZE_BYTES * positions.length / 3);
        const verticesView = new DataView(vertices);
        const position = (0, $31054a6c69637582$exports).create();
        const texCoord = (0, $91b0cc4981465964$exports).create();
        const normal = (0, $31054a6c69637582$exports).create();
        for(let i = 0; i < positions.length / (0, $0a0587bd8b0d58e8$export$5b33f080c7f6c861).SIZE; i++){
            (0, $31054a6c69637582$exports).set(position, positions[i * (0, $0a0587bd8b0d58e8$export$5b33f080c7f6c861).SIZE], positions[i * (0, $0a0587bd8b0d58e8$export$5b33f080c7f6c861).SIZE + 1], positions[i * (0, $0a0587bd8b0d58e8$export$5b33f080c7f6c861).SIZE + 2]);
            (0, $91b0cc4981465964$exports).set(texCoord, texCoords[i * 2], texCoords[i * 2 + 1]);
            (0, $0a0587bd8b0d58e8$export$e40add16394b9bff).setPosition(verticesView, i, position);
            (0, $0a0587bd8b0d58e8$export$e40add16394b9bff).setTexCoord(verticesView, i, texCoord);
            (0, $31054a6c69637582$exports).set(normal, position[0] - transform[12], position[1] - transform[13], position[2] - transform[14]);
            (0, $31054a6c69637582$exports).normalize(normal, normal);
            (0, $0a0587bd8b0d58e8$export$e40add16394b9bff).setNormal(verticesView, i, normal);
        }
        return verticesView;
    }
    _texCoords(slices, stacks, transform) {
        const texCoords = new Float32Array((slices + 1) * (stacks + 1) * 2);
        const texCoord = (0, $91b0cc4981465964$exports).create();
        let index = 0;
        for(let stack = 0; stack <= stacks; stack++)for(let slice = 0; slice <= slices; slice++){
            (0, $91b0cc4981465964$exports).set(texCoord, slice / slices, stack / stacks);
            (0, $91b0cc4981465964$exports).transformMat4(texCoord, texCoord, transform);
            texCoords[index++] = texCoord[0];
            texCoords[index++] = texCoord[1];
        }
        return texCoords;
    }
}



class $f7de7bdc7bccbb25$export$6f251cd327b2ff1 {
    render(elapsedTime, xrFrame) {}
    update(elapsedTime) {}
    constructor(image){
        this.image = image;
    }
}
class $f7de7bdc7bccbb25$export$a3758d3f9ac64232 {
    get material() {
        return this._material;
    }
    get vertices() {
        return this._vertices;
    }
    get indices() {
        return this._indices;
    }
    get indexCount() {
        return this._indexCount;
    }
    get isInitialized() {
        return this._isInitialized;
    }
    get mMatrix() {
        return this._mMatrix;
    }
    get imageData() {
        return this._imageData;
    }
    set imageData(value) {
        if (this._imageData != value) {
            this._imageData = value;
            this._hasChanged = true;
        }
    }
    get rotation() {
        return this._rotation;
    }
    set rotation(value) {
        if (!(0, $39ece26d1239bb77$exports).equals(this._rotation, value)) {
            (0, $39ece26d1239bb77$exports).copy(this._rotation, value);
            this._hasChanged = true;
        }
    }
    get position() {
        return this._position;
    }
    set position(value) {
        if (!(0, $31054a6c69637582$exports).equals(this._position, value)) {
            (0, $31054a6c69637582$exports).copy(this._position, value);
            this._hasChanged = true;
        }
    }
    get texCoord0() {
        return this._texCoord0;
    }
    set texCoord0(value) {
        if (!(0, $91b0cc4981465964$exports).equals(this._texCoord0, value)) {
            (0, $91b0cc4981465964$exports).copy(this._texCoord0, value);
            this._hasChanged = true;
        }
    }
    get texCoord1() {
        return this._texCoord1;
    }
    set texCoord1(value) {
        if (!(0, $91b0cc4981465964$exports).equals(this._texCoord1, value)) {
            (0, $91b0cc4981465964$exports).copy(this._texCoord1, value);
            this._hasChanged = true;
        }
    }
    get minBoundsX() {
        return this._minBoundsX;
    }
    set minBoundsX(value) {
        if (this._minBoundsX != value) {
            this._minBoundsX = value;
            this._hasChanged = true;
        }
    }
    get minBoundsY() {
        return this._minBoundsY;
    }
    set minBoundsY(value) {
        if (this._minBoundsY != value) {
            this._minBoundsY = value;
            this._hasChanged = true;
        }
    }
    get minBoundsZ() {
        return this._minBoundsZ;
    }
    set minBoundsZ(value) {
        if (this._minBoundsZ != value) {
            this._minBoundsZ = value;
            this._hasChanged = true;
        }
    }
    get maxBoundsX() {
        return this._maxBoundsX;
    }
    set maxBoundsX(value) {
        if (this._maxBoundsX != value) {
            this._maxBoundsX = value;
            this._hasChanged = true;
        }
    }
    get maxBoundsY() {
        return this._maxBoundsY;
    }
    set maxBoundsY(value) {
        if (this._maxBoundsY != value) {
            this._maxBoundsY = value;
            this._hasChanged = true;
        }
    }
    get maxBoundsZ() {
        return this._maxBoundsZ;
    }
    set maxBoundsZ(value) {
        if (this._maxBoundsZ != value) {
            this._maxBoundsZ = value;
            this._hasChanged = true;
        }
    }
    constructor(core, options){
        this._core = core;
        this._mMatrix = (0, $1ac1b59392edf35b$exports).create();
        this._origin = (0, $31054a6c69637582$exports).create();
        this._translation = (0, $31054a6c69637582$exports).create();
        this._scale = (0, $31054a6c69637582$exports).create();
        this._transform = (0, $1ac1b59392edf35b$exports).create();
        this._imageData = options.imageData;
        this._minBoundsX = options.minBoundsX === undefined ? 0 : options.minBoundsX;
        this._minBoundsY = options.minBoundsY === undefined ? 0 : options.minBoundsY;
        this._minBoundsZ = options.minBoundsZ === undefined ? 0 : options.minBoundsZ;
        this._maxBoundsX = options.maxBoundsX === undefined ? 1 : options.maxBoundsX;
        this._maxBoundsY = options.maxBoundsY === undefined ? 1 : options.maxBoundsY;
        this._maxBoundsZ = options.maxBoundsZ === undefined ? 1 : options.maxBoundsZ;
        this._position = options.position ? (0, $31054a6c69637582$exports).clone(options.position) : (0, $31054a6c69637582$exports).create();
        this._rotation = options.rotation ? (0, $39ece26d1239bb77$exports).clone(options.rotation) : (0, $39ece26d1239bb77$exports).create();
        this._texCoord0 = options.texCoord0 ? (0, $91b0cc4981465964$exports).clone(options.texCoord0) : (0, $91b0cc4981465964$exports).fromValues(0, 0);
        this._texCoord1 = options.texCoord1 ? (0, $91b0cc4981465964$exports).clone(options.texCoord1) : (0, $91b0cc4981465964$exports).fromValues(1, 1);
        this._material = options.material === undefined ? -1 : options.material;
        this._hasChanged = true;
    }
}
class $f7de7bdc7bccbb25$export$3f0bd71f9b37d8ee extends $f7de7bdc7bccbb25$export$a3758d3f9ac64232 {
    get width() {
        return this._width;
    }
    set width(value) {
        if (this._width != value) {
            this._width = value;
            this._hasChanged = true;
        }
    }
    get height() {
        return this._height;
    }
    set height(value) {
        if (this._height != value) {
            this._height = value;
            this._hasChanged = true;
        }
    }
    constructor(core, options){
        super(core, options);
        this._width = options.width === undefined ? 1 : options.width;
        this._height = options.height === undefined ? 1 : options.height;
        this._texTransform = (0, $1ac1b59392edf35b$exports).create();
        (0, $1ac1b59392edf35b$exports).translate(this._texTransform, this._texTransform, (0, $31054a6c69637582$exports).fromValues(0, 1, 0));
        (0, $1ac1b59392edf35b$exports).scale(this._texTransform, this._texTransform, (0, $31054a6c69637582$exports).fromValues(1, -1, 1));
    }
    initialize() {
        this._vertices = new ArrayBuffer((0, $0a0587bd8b0d58e8$export$e40add16394b9bff).SIZE_BYTES * 4);
        this._indices = (0, $3ce6ee188e300946$export$7005c9eb6671414d).INDICES;
        this._indexCount = this._indices.length;
        this._isInitialized = true;
    }
    update(elapsedTime) {
        if (this._hasChanged && this._isInitialized) {
            this._hasChanged = false;
            const modelSizeX = this._maxBoundsX - this._minBoundsX;
            const modelSizeY = this._maxBoundsY - this._minBoundsY;
            const modelSizeZ = this._maxBoundsZ - this._minBoundsZ;
            const maxBounds = Math.max(modelSizeX, Math.max(modelSizeY, modelSizeZ));
            const boundsScaling = maxBounds == 0 ? 1 : 1 / maxBounds;
            (0, $31054a6c69637582$exports).set(this._origin, (this._minBoundsX + this._maxBoundsX) / 2, (this._minBoundsY + this._maxBoundsY) / 2, (this._minBoundsZ + this._maxBoundsZ) / 2);
            (0, $31054a6c69637582$exports).subtract(this._translation, this._position, this._origin);
            (0, $31054a6c69637582$exports).scale(this._translation, this._translation, boundsScaling);
            (0, $31054a6c69637582$exports).set(this._scale, this._width, this._height, 1);
            (0, $31054a6c69637582$exports).scale(this._scale, this._scale, boundsScaling);
            (0, $1ac1b59392edf35b$exports).fromRotationTranslationScale(this._transform, this._rotation, this._translation, this._scale);
            this._verticesView = (0, $3ce6ee188e300946$export$7005c9eb6671414d).normalTextured(this._transform, this._texTransform);
            this._vertices = this._verticesView.buffer;
            if (this.hasChangedCallback) this.hasChangedCallback();
        }
    }
}
class $f7de7bdc7bccbb25$export$f4ca272a8ace4457 extends $f7de7bdc7bccbb25$export$a3758d3f9ac64232 {
    get radius() {
        return this._radius;
    }
    set radius(value) {
        if (this._radius != value) {
            this._radius = value;
            this._hasChanged = true;
        }
    }
    constructor(core, options){
        super(core, options);
        this._radius = options.radius === undefined ? 0.5 : options.radius;
        this._slices = options.slices === undefined ? 72 : options.slices;
        this._stacks = options.stacks === undefined ? 36 : options.stacks;
    }
    initialize() {
        this._sphere = new (0, $01ead9aa9a4bc88a$export$805e8b72413ccaba)(this._core);
        this._vertices = this._sphere.normalTextured(this._slices, this._stacks, (0, $d4d7bd6cc65a5081$export$a002182e51710d39).MAT4_IDENTITY).buffer;
        this._indices = this._sphere.indices(this._slices, this._stacks);
        this._indexCount = this._indices.length;
        this._isInitialized = true;
    }
    update(elapsedTime) {
        if (this._hasChanged && this._isInitialized) {
            this._hasChanged = false;
            const modelSizeX = this._maxBoundsX - this._minBoundsX;
            const modelSizeY = this._maxBoundsY - this._minBoundsY;
            const modelSizeZ = this._maxBoundsZ - this._minBoundsZ;
            const maxBounds = Math.max(modelSizeX, Math.max(modelSizeY, modelSizeZ));
            const boundsScaling = maxBounds == 0 ? 1 : 1 / maxBounds;
            (0, $31054a6c69637582$exports).set(this._origin, (this._minBoundsX + this._maxBoundsX) / 2, (this._minBoundsY + this._maxBoundsY) / 2, (this._minBoundsZ + this._maxBoundsZ) / 2);
            (0, $31054a6c69637582$exports).set(this._scale, this._radius, this._radius, this._radius);
            (0, $31054a6c69637582$exports).scale(this._scale, this._scale, boundsScaling);
            (0, $1ac1b59392edf35b$exports).fromRotationTranslationScaleOrigin(this._transform, this._rotation, this._position, this._scale, this._origin);
            this._verticesView = this._sphere.normalTextured(this._slices, this._stacks, this._transform);
            this._vertices = this._verticesView.buffer;
            if (this.hasChangedCallback) this.hasChangedCallback();
        }
    }
}


/*!
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 */ 


/*!
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 */ 




/*!
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 */ 

/*!
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 */ 

class $9614560ff899e49d$export$93b17801046b2267 {
    static rotateBounds(minBounds, maxBounds, rotation, rotatedMinBounds, rotatedMaxBounds, offset) {
        const sizeX = maxBounds[0] - minBounds[0];
        const sizeY = maxBounds[1] - minBounds[1];
        const sizeZ = maxBounds[2] - minBounds[2];
        const min = rotatedMinBounds;
        const max = rotatedMaxBounds;
        (0, $31054a6c69637582$exports).set(min, Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE);
        (0, $31054a6c69637582$exports).set(max, -Number.MAX_VALUE, -Number.MAX_VALUE, -Number.MAX_VALUE);
        const vertices = (0, $c2c30e4dcf8004c5$export$a15f0a83a652dd40).POSITIONS;
        const position = (0, $31054a6c69637582$exports).create();
        for(let i = 0; i < 8; i++){
            (0, $31054a6c69637582$exports).set(position, vertices[i * 3] * sizeX, vertices[i * 3 + 1] * sizeY, vertices[i * 3 + 2] * sizeZ);
            (0, $31054a6c69637582$exports).add(position, position, offset);
            (0, $31054a6c69637582$exports).transformQuat(position, position, rotation);
            (0, $31054a6c69637582$exports).subtract(position, position, offset);
            (0, $31054a6c69637582$exports).min(min, min, position);
            (0, $31054a6c69637582$exports).max(max, max, position);
        }
        (0, $31054a6c69637582$exports).add(position, minBounds, maxBounds);
        (0, $31054a6c69637582$exports).scale(position, position, 0.5);
        (0, $31054a6c69637582$exports).add(min, min, position);
        (0, $31054a6c69637582$exports).add(max, max, position);
    }
    static cylinder(pa, pb, radius, minBounds, maxBounds) {
        const a = (0, $31054a6c69637582$exports).create();
        (0, $31054a6c69637582$exports).subtract(a, pb, pa);
        const aa = (0, $31054a6c69637582$exports).dot(a, a);
        const ex = radius * Math.sqrt(1 - a[0] * a[0] / aa);
        const ey = radius * Math.sqrt(1 - a[1] * a[1] / aa);
        const ez = radius * Math.sqrt(1 - a[2] * a[2] / aa);
        minBounds[0] = Math.min(pa[0] - ex, pb[0] - ex);
        minBounds[1] = Math.min(pa[1] - ey, pb[1] - ey);
        minBounds[2] = Math.min(pa[2] - ez, pb[2] - ez);
        maxBounds[0] = Math.max(pa[0] + ex, pb[0] + ex);
        maxBounds[1] = Math.max(pa[1] + ey, pb[1] + ey);
        maxBounds[2] = Math.max(pa[2] + ez, pb[2] + ez);
    }
}




class $9f62a2679ad52b29$export$f4f11265faddf354 {
    get facetScaling() {
        return this._facetScaling;
    }
    offsetX(facetCoordX) {
        return ((facetCoordX + 0.5) / this._facetsX - 0.5) * (this.maxModelBoundsX - this.minModelBoundsX) / this._maxBounds;
    }
    offsetY(facetCoordY) {
        return ((facetCoordY + 0.5) / this._facetsY - 0.5) * (this.maxModelBoundsY - this.minModelBoundsY) / this._maxBounds;
    }
    offsetZ(facetCoordZ) {
        return ((facetCoordZ + 0.5) / this._facetsZ - 0.5) * (this.maxModelBoundsZ - this.minModelBoundsZ) / this._maxBounds;
    }
    constructor(core){
        this._core = core;
        this.modelOriginX = 0;
        this.modelOriginY = 0;
        this.modelOriginZ = 0;
        this.minModelBoundsX = 0;
        this.minModelBoundsY = 0;
        this.minModelBoundsZ = 0;
        this.maxModelBoundsX = 0;
        this.maxModelBoundsY = 0;
        this.maxModelBoundsZ = 0;
        this.minLayoutBoundsX = 0;
        this.minLayoutBoundsY = 0;
        this.minLayoutBoundsZ = 0;
        this.maxLayoutBoundsX = 0;
        this.maxLayoutBoundsY = 0;
        this.maxLayoutBoundsZ = 0;
        this._facetSpacingX = 0;
        this._facetSpacingY = 0;
        this._facetSpacingZ = 0;
        this._facetSizeX = 0;
        this._facetSizeY = 0;
        this._facetSizeZ = 0;
        this._facetsX = 1;
        this._facetsY = 1;
        this._facetsZ = 1;
    }
    _updateModelBounds(options) {
        this.minModelBoundsX = options.minBoundsX === undefined ? this.minLayoutBoundsX : options.minBoundsX;
        this.minModelBoundsY = options.minBoundsY === undefined ? this.minLayoutBoundsY : options.minBoundsY;
        this.minModelBoundsZ = options.minBoundsZ === undefined ? this.minLayoutBoundsZ : options.minBoundsZ;
        this.maxModelBoundsX = options.maxBoundsX === undefined ? this.maxLayoutBoundsX : options.maxBoundsX;
        this.maxModelBoundsY = options.maxBoundsY === undefined ? this.maxLayoutBoundsY : options.maxBoundsY;
        this.maxModelBoundsZ = options.maxBoundsZ === undefined ? this.maxLayoutBoundsZ : options.maxBoundsZ;
        this._isFacetted = options.facetsX !== undefined && options.facetsX > 1 && options.facetCoordsX != null || options.facetsY !== undefined && options.facetsY > 1 && options.facetCoordsY != null || options.facetsZ !== undefined && options.facetsZ > 1 && options.facetCoordsZ != null;
        this._facetSpacingX = options.facetSpacingX === undefined ? 0 : options.facetSpacingX;
        this._facetSpacingY = options.facetSpacingY === undefined ? 0 : options.facetSpacingY;
        this._facetSpacingZ = options.facetSpacingZ === undefined ? 0 : options.facetSpacingZ;
        let modelSizeX = this.maxModelBoundsX - this.minModelBoundsX;
        let modelSizeY = this.maxModelBoundsY - this.minModelBoundsY;
        let modelSizeZ = this.maxModelBoundsZ - this.minModelBoundsZ;
        const maxBounds = Math.max(modelSizeX, Math.max(modelSizeY, modelSizeZ));
        this._facetSizeX = modelSizeX;
        this._facetSizeY = modelSizeY;
        this._facetSizeZ = modelSizeZ;
        this._facetsX = options.facetCoordsX ? options.facetsX : 1;
        this._facetsY = options.facetCoordsY ? options.facetsY : 1;
        this._facetsZ = options.facetCoordsZ ? options.facetsZ : 1;
        this.minModelBoundsX -= this._facetSizeX * this._facetSpacingX / 2;
        this.minModelBoundsY -= this._facetSizeY * this._facetSpacingY / 2;
        this.minModelBoundsZ -= this._facetSizeZ * this._facetSpacingZ / 2;
        this.maxModelBoundsX = this.minModelBoundsX + this._facetsX * this._facetSizeX * (1 + this._facetSpacingX);
        this.maxModelBoundsY = this.minModelBoundsY + this._facetsY * this._facetSizeY * (1 + this._facetSpacingY);
        this.maxModelBoundsZ = this.minModelBoundsZ + this._facetsZ * this._facetSizeZ * (1 + this._facetSpacingZ);
        this.modelOriginX = (this.minModelBoundsX + this.maxModelBoundsX) / 2;
        this.modelOriginY = (this.minModelBoundsY + this.maxModelBoundsY) / 2;
        this.modelOriginZ = (this.minModelBoundsZ + this.maxModelBoundsZ) / 2;
        modelSizeX = this.maxModelBoundsX - this.minModelBoundsX;
        modelSizeY = this.maxModelBoundsY - this.minModelBoundsY;
        modelSizeZ = this.maxModelBoundsZ - this.minModelBoundsZ;
        this._maxBounds = Math.max(modelSizeX, Math.max(modelSizeY, modelSizeZ));
        this._boundsScaling = this._maxBounds == 0 ? 1 : 1 / this._maxBounds;
        this._facetScaling = maxBounds / this._maxBounds;
    }
    resetCumulativeLayoutBounds() {
        this.minCumulativeLayoutBoundsX = undefined;
        this.minCumulativeLayoutBoundsY = undefined;
        this.minCumulativeLayoutBoundsZ = undefined;
        this.maxCumulativeLayoutBoundsX = undefined;
        this.maxCumulativeLayoutBoundsY = undefined;
        this.maxCumulativeLayoutBoundsZ = undefined;
    }
    _updateCumulativeLayoutBounds() {
        this.minCumulativeLayoutBoundsX = this.minCumulativeLayoutBoundsX === undefined ? this.minLayoutBoundsX : Math.min(this.minCumulativeLayoutBoundsX, this.minLayoutBoundsX);
        this.minCumulativeLayoutBoundsY = this.minCumulativeLayoutBoundsY === undefined ? this.minLayoutBoundsY : Math.min(this.minCumulativeLayoutBoundsY, this.minLayoutBoundsY);
        this.minCumulativeLayoutBoundsZ = this.minCumulativeLayoutBoundsZ === undefined ? this.minLayoutBoundsZ : Math.min(this.minCumulativeLayoutBoundsZ, this.minLayoutBoundsZ);
        this.maxCumulativeLayoutBoundsX = this.maxCumulativeLayoutBoundsX === undefined ? this.maxLayoutBoundsX : Math.max(this.maxCumulativeLayoutBoundsX, this.maxLayoutBoundsX);
        this.maxCumulativeLayoutBoundsY = this.maxCumulativeLayoutBoundsY === undefined ? this.maxLayoutBoundsY : Math.max(this.maxCumulativeLayoutBoundsY, this.maxLayoutBoundsY);
        this.maxCumulativeLayoutBoundsZ = this.maxCumulativeLayoutBoundsZ === undefined ? this.maxLayoutBoundsZ : Math.max(this.maxCumulativeLayoutBoundsZ, this.maxLayoutBoundsZ);
    }
    unitToModelSize(unitSize) {
        return unitSize / this._boundsScaling;
    }
    unitToModelPositionX(unitPositionX) {
        return this.unitToModelSize(unitPositionX) + this.modelOriginX;
    }
    unitToModelPositionY(unitPositionY) {
        return this.unitToModelSize(unitPositionY) + this.modelOriginY;
    }
    unitToModelPositionZ(unitPositionZ) {
        return this.unitToModelSize(unitPositionZ) + this.modelOriginZ;
    }
    unitToModelPosition(unitPosition, modelPosition) {
        modelPosition[0] = this.unitToModelPositionX(unitPosition[0]);
        modelPosition[1] = this.unitToModelPositionY(unitPosition[1]);
        modelPosition[2] = this.unitToModelPositionZ(unitPosition[2]);
    }
    modelToUnitSize(modelSize) {
        return modelSize * this._boundsScaling;
    }
    modelToUnitPositionX(modelPositionX) {
        return (modelPositionX - this.modelOriginX) * this._boundsScaling;
    }
    modelToUnitPositionY(modelPositionY) {
        return (modelPositionY - this.modelOriginY) * this._boundsScaling;
    }
    modelToUnitPositionZ(modelPositionZ) {
        return (modelPositionZ - this.modelOriginZ) * this._boundsScaling;
    }
    modelToUnitPosition(modelPosition, unitPosition) {
        unitPosition[0] = this.modelToUnitPositionX(modelPosition[0]);
        unitPosition[1] = this.modelToUnitPositionY(modelPosition[1]);
        unitPosition[2] = this.modelToUnitPositionZ(modelPosition[2]);
    }
    inclusiveUnitBounds(buffer, ids, unitType, offset, count, minBounds, maxBounds) {
        (0, $31054a6c69637582$exports).set(minBounds, Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE);
        (0, $31054a6c69637582$exports).set(maxBounds, -Number.MAX_VALUE, -Number.MAX_VALUE, -Number.MAX_VALUE);
        const unitScale = (0, $31054a6c69637582$exports).create();
        const unitRotation = (0, $39ece26d1239bb77$exports).create();
        const unitTranslation = (0, $31054a6c69637582$exports).create();
        const lookup = buffer.lookup;
        const dataView = buffer.dataView;
        let minBounds0;
        let maxBounds0;
        let minBounds1;
        let maxBounds1;
        switch(unitType){
            case (0, $4a6417d29706362f$export$80d48287646c9e3b).sphere:
            case (0, $4a6417d29706362f$export$80d48287646c9e3b).sphereSdf:
                for(let i = 0; i < count; i++){
                    const id = ids[i + offset];
                    const index = lookup[id];
                    (0, $0a0587bd8b0d58e8$export$849e31d725692576).getTranslation(dataView, index, unitTranslation);
                    (0, $0a0587bd8b0d58e8$export$849e31d725692576).getScale(dataView, index, unitScale);
                    const radius = unitScale[0] / 2;
                    minBounds[0] = Math.min(minBounds[0], unitTranslation[0] - radius);
                    minBounds[1] = Math.min(minBounds[1], unitTranslation[1] - radius);
                    minBounds[2] = Math.min(minBounds[2], unitTranslation[2] - radius);
                    maxBounds[0] = Math.max(maxBounds[0], unitTranslation[0] + radius);
                    maxBounds[1] = Math.max(maxBounds[1], unitTranslation[1] + radius);
                    maxBounds[2] = Math.max(maxBounds[2], unitTranslation[2] + radius);
                }
                break;
            case (0, $4a6417d29706362f$export$80d48287646c9e3b).hexPrism:
            case (0, $4a6417d29706362f$export$80d48287646c9e3b).hexPrismSdf:
            case (0, $4a6417d29706362f$export$80d48287646c9e3b).block:
            case (0, $4a6417d29706362f$export$80d48287646c9e3b).blockSdf:
                minBounds0 = (0, $31054a6c69637582$exports).create();
                maxBounds0 = (0, $31054a6c69637582$exports).create();
                minBounds1 = (0, $31054a6c69637582$exports).create();
                maxBounds1 = (0, $31054a6c69637582$exports).create();
                for(let i = 0; i < count; i++){
                    const id = ids[i + offset];
                    const index = lookup[id];
                    (0, $0a0587bd8b0d58e8$export$849e31d725692576).getTranslation(dataView, index, unitTranslation);
                    (0, $0a0587bd8b0d58e8$export$849e31d725692576).getRotation(dataView, index, unitRotation);
                    (0, $0a0587bd8b0d58e8$export$849e31d725692576).getScale(dataView, index, unitScale);
                    minBounds0[0] = unitTranslation[0] - unitScale[0] / 2;
                    minBounds0[1] = unitTranslation[1] - unitScale[1] / 2;
                    minBounds0[2] = unitTranslation[2] - unitScale[2] / 2;
                    maxBounds0[0] = unitTranslation[0] + unitScale[0] / 2;
                    maxBounds0[1] = unitTranslation[1] + unitScale[1] / 2;
                    maxBounds0[2] = unitTranslation[2] + unitScale[2] / 2;
                    (0, $9614560ff899e49d$export$93b17801046b2267).rotateBounds(minBounds0, maxBounds0, unitRotation, minBounds1, maxBounds1, (0, $d4d7bd6cc65a5081$export$a002182e51710d39).VECTOR3_ZERO);
                    (0, $31054a6c69637582$exports).min(minBounds, minBounds, minBounds1);
                    (0, $31054a6c69637582$exports).max(maxBounds, maxBounds, maxBounds1);
                }
                break;
            case (0, $4a6417d29706362f$export$80d48287646c9e3b).cylinder:
            case (0, $4a6417d29706362f$export$80d48287646c9e3b).cylinderSdf:
                minBounds0 = (0, $31054a6c69637582$exports).create();
                maxBounds0 = (0, $31054a6c69637582$exports).create();
                const pa = (0, $31054a6c69637582$exports).create();
                const pb = (0, $31054a6c69637582$exports).create();
                const identityRotation = (0, $d4d7bd6cc65a5081$export$a002182e51710d39).VECTOR3_UNITY;
                let ca;
                for(let i = 0; i < count; i++){
                    const id = ids[i + offset];
                    const index = lookup[id];
                    (0, $0a0587bd8b0d58e8$export$849e31d725692576).getTranslation(dataView, index, unitTranslation);
                    (0, $0a0587bd8b0d58e8$export$849e31d725692576).getRotation(dataView, index, unitRotation);
                    (0, $0a0587bd8b0d58e8$export$849e31d725692576).getScale(dataView, index, unitScale);
                    const length = unitScale[1];
                    const radius = Math.max(unitScale[0], unitScale[2]);
                    if (length != 0 && radius != 0) {
                        if ((0, $39ece26d1239bb77$exports).equals(unitRotation, (0, $d4d7bd6cc65a5081$export$a002182e51710d39).QUAT_IDENTITY)) ca = identityRotation;
                        else {
                            ca = (0, $31054a6c69637582$exports).create();
                            (0, $31054a6c69637582$exports).transformQuat(ca, identityRotation, unitRotation);
                        }
                        (0, $31054a6c69637582$exports).scaleAndAdd(pa, unitTranslation, ca, -length * 0.5);
                        (0, $31054a6c69637582$exports).scaleAndAdd(pb, unitTranslation, ca, length * 0.5);
                        (0, $9614560ff899e49d$export$93b17801046b2267).cylinder(pa, pb, radius, minBounds0, maxBounds0);
                        (0, $31054a6c69637582$exports).min(minBounds, minBounds, minBounds0);
                        (0, $31054a6c69637582$exports).max(maxBounds, maxBounds, maxBounds0);
                    }
                }
                break;
        }
    }
}


class $5c05d7e02492b136$export$1c460fb4285edadc extends (0, $9f62a2679ad52b29$export$f4f11265faddf354) {
    layout(buffer, ids, options) {
        const start = window.performance.now();
        const offset = options.offset === undefined ? 0 : options.offset;
        const count = options.count === undefined ? ids.length : options.count;
        const positionScalingX = options.positionScalingX === undefined ? 1 : options.positionScalingX;
        const positionScalingY = options.positionScalingY === undefined ? 1 : options.positionScalingY;
        const positionScalingZ = options.positionScalingZ === undefined ? 1 : options.positionScalingZ;
        if (!this._positions || this._positions.length < buffer.length * 3) this._positions = new Float32Array(buffer.length * 3);
        this.minLayoutBoundsX = Number.MAX_VALUE;
        this.minLayoutBoundsY = Number.MAX_VALUE;
        this.minLayoutBoundsZ = Number.MAX_VALUE;
        this.maxLayoutBoundsX = -Number.MAX_VALUE;
        this.maxLayoutBoundsY = -Number.MAX_VALUE;
        this.maxLayoutBoundsZ = -Number.MAX_VALUE;
        const lookup = buffer.lookup;
        for(let i = 0; i < count; i++){
            const id = ids[i + offset];
            const index = lookup[id];
            let positionX = options.positionsX ? options.positionsX[id] * positionScalingX : 0;
            let positionY = options.positionsY ? options.positionsY[id] * positionScalingY : 0;
            let positionZ = options.positionsZ ? options.positionsZ[id] * positionScalingZ : 0;
            this._positions[index * 3] = positionX;
            this._positions[index * 3 + 1] = positionY;
            this._positions[index * 3 + 2] = positionZ;
            this.minLayoutBoundsX = Math.min(this.minLayoutBoundsX, positionX);
            this.minLayoutBoundsY = Math.min(this.minLayoutBoundsY, positionY);
            this.minLayoutBoundsZ = Math.min(this.minLayoutBoundsZ, positionZ);
            this.maxLayoutBoundsX = Math.max(this.maxLayoutBoundsX, positionX);
            this.maxLayoutBoundsY = Math.max(this.maxLayoutBoundsY, positionY);
            this.maxLayoutBoundsZ = Math.max(this.maxLayoutBoundsZ, positionZ);
        }
        this._updateCumulativeLayoutBounds();
        this._core.log.write((0, $4a6417d29706362f$export$243e62d78d3b544d).info, `${this.constructor.name.toLowerCase()} layout ${count} ${Math.round(window.performance.now() - start)}ms`);
    }
    update(buffer, ids, options) {
        const start = window.performance.now();
        const offset = options.offset === undefined ? 0 : options.offset;
        const count = options.count === undefined ? ids.length : options.count;
        const dataView = buffer.dataView;
        const _vec2 = (0, $91b0cc4981465964$exports).create();
        const _vec3 = (0, $31054a6c69637582$exports).create();
        const _vec4 = (0, $4c4ac78b213a9c07$exports).create();
        const _quat = (0, $39ece26d1239bb77$exports).create();
        const sizeScalingX = options.sizeScaling === undefined ? options.sizeScalingX === undefined ? 1 : options.sizeScalingX : options.sizeScaling;
        const sizeScalingY = options.sizeScaling === undefined ? options.sizeScalingY === undefined ? 1 : options.sizeScalingY : options.sizeScaling;
        const sizeScalingZ = options.sizeScaling === undefined ? options.sizeScalingZ === undefined ? 1 : options.sizeScalingZ : options.sizeScaling;
        const sizesX = options.sizes ? options.sizes : options.sizesX;
        const sizesY = options.sizes ? options.sizes : options.sizesY;
        const sizesZ = options.sizes ? options.sizes : options.sizesZ;
        const minSize = options.minSize === undefined ? 0 : options.minSize;
        const minColor = options.minColor === undefined ? 0 : options.minColor;
        const maxColor = options.maxColor === undefined ? 1 : options.maxColor;
        const minOrder = options.minOrder === undefined ? 0 : options.minOrder;
        const maxOrder = options.maxOrder === undefined ? 1 : options.maxOrder;
        const orderReverse = options.orderReverse === undefined ? false : options.orderReverse;
        const minStaggerOrder = options.minStaggerOrder === undefined ? 0 : options.minStaggerOrder;
        const maxStaggerOrder = options.maxStaggerOrder === undefined ? 1 : options.maxStaggerOrder;
        const staggerOrderReverse = options.staggerOrderReverse === undefined ? false : options.staggerOrderReverse;
        const reverseX = options.reverseX === undefined ? false : options.reverseX;
        const reverseY = options.reverseY === undefined ? false : options.reverseY;
        const reverseZ = options.reverseZ === undefined ? false : options.reverseZ;
        this._updateModelBounds(options);
        if (options.rotation) {
            _quat[0] = options.rotation[0];
            _quat[1] = options.rotation[1];
            _quat[2] = options.rotation[2];
            _quat[3] = options.rotation[3];
        } else (0, $39ece26d1239bb77$exports).rotationTo(_quat, this._core.config.identityRotation, (0, $d4d7bd6cc65a5081$export$a002182e51710d39).VECTOR3_UNITY);
        if (options.texCoord) {
            _vec4[0] = options.texCoord[0];
            _vec4[1] = options.texCoord[1];
            _vec4[2] = options.texCoord[2];
            _vec4[3] = options.texCoord[3];
        }
        const lookup = buffer.lookup;
        const selection = options.selected && options.selected.size > 0;
        for(let i = 0; i < count; i++){
            const id = ids[i + offset];
            const index = lookup[id];
            let positionX = this._positions[index * 3];
            let positionY = this._positions[index * 3 + 1];
            let positionZ = this._positions[index * 3 + 2];
            if (this._isFacetted) {
                if (reverseX) positionX = this.minModelBoundsX + this.minModelBoundsX + this._facetSizeX * (1 + this._facetSpacingX) - positionX;
                if (reverseY) positionY = this.minModelBoundsY + this.minModelBoundsY + this._facetSizeY * (1 + this._facetSpacingY) - positionY;
                if (reverseZ) positionZ = this.minModelBoundsZ + this.minModelBoundsZ + this._facetSizeZ * (1 + this._facetSpacingZ) - positionZ;
                const facetX = options.facetCoordsX ? options.facetCoordsX[id] : 0;
                const facetY = options.facetCoordsY ? options.facetCoordsY[id] : 0;
                const facetZ = options.facetCoordsZ ? options.facetCoordsZ[id] : 0;
                positionX += facetX * this._facetSizeX * (1 + this._facetSpacingX);
                positionY += facetY * this._facetSizeY * (1 + this._facetSpacingY);
                positionZ += facetZ * this._facetSizeZ * (1 + this._facetSpacingZ);
            } else {
                if (reverseX) positionX = this.minModelBoundsX + this.maxModelBoundsX - positionX;
                if (reverseY) positionY = this.minModelBoundsY + this.maxModelBoundsY - positionY;
                if (reverseZ) positionZ = this.minModelBoundsZ + this.maxModelBoundsZ - positionZ;
            }
            _vec3[0] = (positionX - this.modelOriginX) * this._boundsScaling;
            _vec3[1] = (positionY - this.modelOriginY) * this._boundsScaling;
            _vec3[2] = (positionZ - this.modelOriginZ) * this._boundsScaling;
            (0, $0a0587bd8b0d58e8$export$849e31d725692576).setTranslation(dataView, index, _vec3);
            _vec3[0] = Math.max((sizesX ? Math.abs(sizesX[id]) : 1) * sizeScalingX, minSize) * this._boundsScaling;
            _vec3[1] = Math.max((sizesY ? Math.abs(sizesY[id]) : 1) * sizeScalingY, minSize) * this._boundsScaling;
            _vec3[2] = Math.max((sizesZ ? Math.abs(sizesZ[id]) : 1) * sizeScalingZ, minSize) * this._boundsScaling;
            (0, $0a0587bd8b0d58e8$export$849e31d725692576).setScale(dataView, index, _vec3);
            if (options.rotations) {
                _quat[0] = options.rotations[id * 4];
                _quat[1] = options.rotations[id * 4 + 1];
                _quat[2] = options.rotations[id * 4 + 2];
                _quat[3] = options.rotations[id * 4 + 3];
                (0, $0a0587bd8b0d58e8$export$849e31d725692576).setRotation(dataView, index, _quat);
            } else (0, $0a0587bd8b0d58e8$export$849e31d725692576).setRotation(dataView, index, _quat);
            if (options.colors) {
                const size = 1 / (maxColor - minColor + 1);
                const color = (0, $2d4d1eb6f32f02f2$export$80a8c44b8858d625).normalize(options.colors[id], minColor, maxColor, size / 2, 1 - size / 2);
                if (options.colors1) {
                    const color1 = (0, $2d4d1eb6f32f02f2$export$80a8c44b8858d625).normalize(options.colors1[id], minColor, maxColor, size / 2, 1 - size / 2);
                    (0, $91b0cc4981465964$exports).set(_vec2, color, color1);
                } else (0, $91b0cc4981465964$exports).set(_vec2, color, color);
                (0, $0a0587bd8b0d58e8$export$849e31d725692576).setColor(dataView, index, _vec2);
            } else (0, $0a0587bd8b0d58e8$export$849e31d725692576).setColor(dataView, index, (0, $d4d7bd6cc65a5081$export$a002182e51710d39).VECTOR2_ONE);
            (0, $0a0587bd8b0d58e8$export$849e31d725692576).setIdHover(dataView, index, options.hover ? options.hover[id] : id);
            (0, $0a0587bd8b0d58e8$export$849e31d725692576).setSelected(dataView, index, selection ? options.selected.has(id) ? 1 : -1 : 0);
            if (options.order !== undefined) {
                const order = (0, $2d4d1eb6f32f02f2$export$80a8c44b8858d625).normalize(options.order[id], minOrder, maxOrder, 0, 1);
                _vec2[0] = orderReverse ? 1 - order : order;
            } else _vec2[0] = count == 1 ? 0 : i / (count - 1);
            if (options.staggerOrder !== undefined) _vec2[1] = options.staggerOrder;
            else if (options.staggerOrders) {
                const stagger = (0, $2d4d1eb6f32f02f2$export$80a8c44b8858d625).normalize(options.staggerOrders[id], minStaggerOrder, maxStaggerOrder, 0, 1);
                _vec2[1] = staggerOrderReverse ? 1 - stagger : stagger;
            } else _vec2[1] = count == 1 ? 0 : i / (count - 1);
            (0, $0a0587bd8b0d58e8$export$849e31d725692576).setOrder(dataView, index, _vec2);
            (0, $0a0587bd8b0d58e8$export$849e31d725692576).setMaterial(dataView, index, options.material ? options.material : options.materials ? options.materials[id] : 0);
            (0, $0a0587bd8b0d58e8$export$849e31d725692576).setRounding(dataView, index, options.rounding ? options.rounding * this._boundsScaling : options.roundings ? options.roundings[id] * this._boundsScaling : 0);
            (0, $0a0587bd8b0d58e8$export$849e31d725692576).setParameter1(dataView, index, options.parameter1 ? options.parameter1 : options.parameters1 ? options.parameters1[id] : 0);
            (0, $0a0587bd8b0d58e8$export$849e31d725692576).setParameter2(dataView, index, options.parameter2 ? options.parameter2 : options.parameters2 ? options.parameters2[id] : 0);
            (0, $0a0587bd8b0d58e8$export$849e31d725692576).setSdfBuffer(dataView, index, options.sdfBuffer ? options.sdfBuffer : options.sdfBuffers ? options.sdfBuffers[id] : this._core.config.sdfBuffer);
            (0, $0a0587bd8b0d58e8$export$849e31d725692576).setSdfBorder(dataView, index, options.sdfBorder ? options.sdfBorder : options.sdfBorders ? options.sdfBorders[id] : this._core.config.sdfBorder);
            if (options.texCoords) {
                _vec4[0] = options.texCoords[id * 4];
                _vec4[1] = options.texCoords[id * 4 + 1];
                _vec4[2] = options.texCoords[id * 4 + 2];
                _vec4[3] = options.texCoords[id * 4 + 3];
                (0, $0a0587bd8b0d58e8$export$849e31d725692576).setTexCoord(dataView, index, _vec4);
            } else (0, $0a0587bd8b0d58e8$export$849e31d725692576).setTexCoord(dataView, index, _vec4);
        }
        buffer.update();
        this._core.log.write((0, $4a6417d29706362f$export$243e62d78d3b544d).info, `${this.constructor.name.toLowerCase()} update ${count} ${Math.round(window.performance.now() - start)}ms`);
    }
}




class $4cef0568024a2460$export$84b019c42ae137d9 {
    render(elapsedTime, xrFrame) {}
    update(elapsedTime) {}
    constructor(key){
        this.key = key;
    }
}
class $4cef0568024a2460$export$b8efc38afdd4a742 {
    get isInitialized() {
        return this._isInitialized;
    }
    get minBoundsX() {
        return this._minBoundsX;
    }
    set minBoundsX(value) {
        if (value != this.minBoundsX) {
            this._minBoundsX = value;
            this._hasChanged = true;
        }
    }
    get maxBoundsX() {
        return this._maxBoundsX;
    }
    set maxBoundsX(value) {
        if (value != this.minBoundsX) {
            this._maxBoundsX = value;
            this._hasChanged = true;
        }
    }
    get minBoundsY() {
        return this._minBoundsY;
    }
    set minBoundsY(value) {
        if (value != this.minBoundsY) {
            this._minBoundsY = value;
            this._hasChanged = true;
        }
    }
    get maxBoundsY() {
        return this._maxBoundsY;
    }
    set maxBoundsY(value) {
        if (value != this.minBoundsY) {
            this._maxBoundsY = value;
            this._hasChanged = true;
        }
    }
    get minBoundsZ() {
        return this._minBoundsZ;
    }
    set minBoundsZ(value) {
        if (value != this.minBoundsZ) {
            this._minBoundsZ = value;
            this._hasChanged = true;
        }
    }
    get maxBoundsZ() {
        return this._maxBoundsZ;
    }
    set maxBoundsZ(value) {
        if (value != this.minBoundsZ) {
            this._maxBoundsZ = value;
            this._hasChanged = true;
        }
    }
    get unitType() {
        return this._unitType;
    }
    set unitType(value) {
        if (this._unitType != value) {
            this._unitType = value;
            this._hasChanged = true;
        }
    }
    get palette() {
        return this._palette;
    }
    set palette(value) {
        if (this._palette != value) {
            this._palette = value;
            this._hasChanged = true;
        }
    }
    get materials() {
        return this._materials;
    }
    set materials(value) {
        if (this._materials != value) {
            this._materials = value;
            this._hasChanged = true;
        }
    }
    get sizesX() {
        return this._sizesX;
    }
    set sizesX(value) {
        if (this._sizesX != value) {
            this._sizesX = value;
            this._hasChanged = true;
        }
    }
    get sizesY() {
        return this._sizesY;
    }
    set sizesY(value) {
        if (this._sizesY != value) {
            this._sizesY = value;
            this._hasChanged = true;
        }
    }
    get sizesZ() {
        return this._sizesZ;
    }
    set sizesZ(value) {
        if (this._sizesZ != value) {
            this._sizesZ = value;
            this._hasChanged = true;
        }
    }
    get spacing() {
        return this._spacing;
    }
    set spacing(value) {
        if (this._spacing != value) {
            this._spacing = value;
            this._hasChanged = true;
        }
    }
    get textVertices() {
        return this._textVertices;
    }
    get textIndices() {
        return this._textIndices;
    }
    get labelMMatrix() {
        return this._labelMMatrix;
    }
    set labelPositions(value) {
        if (this._labelPositions != value) {
            this._labelPositions = value;
            this._hasChanged = true;
        }
    }
    set labels(value) {
        if (this._labels != value) {
            this._labels = value;
            this._hasChanged = true;
        }
    }
    set labelSize(value) {
        if (this._labelSize != value) {
            this._labelSize = value;
            this._hasChanged = true;
        }
    }
    get labelOrientation() {
        return this._orientation;
    }
    set labelOrientation(value) {
        if (this._orientation != value) {
            this._orientation = value;
            this._hasChanged = true;
        }
    }
    get titleIndexCount() {
        return this._titleIndexCount;
    }
    get titleIndexOffset() {
        return this._titleIndexOffset;
    }
    get titleMMatrix() {
        return this._titleMMatrix;
    }
    set title(value) {
        if (this._title != value) {
            this._title = value;
            this._hasChanged = true;
        }
    }
    set titleSize(value) {
        if (this._titleSize != value) {
            this._titleSize = value;
            this._hasChanged = true;
        }
    }
    constructor(core, options){
        this._core = core;
        this._textMetric = {
            width: 0,
            maxHeight: 0,
            maxTop: 0
        };
    }
    initialize() {
        this._isInitialized = true;
    }
    update(elapsedTime) {
        if (this.isInitialized) {
            if (this._hasChanged) {
                const start = window.performance.now();
                this._hasChanged = false;
                (0, $31054a6c69637582$exports).set(this._size, this._maxBoundsX - this._minBoundsX, this._maxBoundsY - this._minBoundsY, this._maxBoundsZ - this._minBoundsZ);
                const maxBounds = Math.max(Math.max(this._size[0], this._size[1]), this._size[2]);
                (0, $31054a6c69637582$exports).scale(this._size, this._size, 1 / maxBounds);
                this._update(this._size);
                if (this.hasChangedCallback) this.hasChangedCallback();
                this._core.log.write((0, $4a6417d29706362f$export$243e62d78d3b544d).info, `key updated ${Math.round(window.performance.now() - start)}ms`);
            }
        }
    }
    _update(size) {}
}
class $4cef0568024a2460$export$1f02ce5a460c3bdd extends $4cef0568024a2460$export$b8efc38afdd4a742 {
    constructor(core, options){
        super(core, options);
        const minBoundsX = options.minBoundsX === undefined ? 0 : options.minBoundsX;
        const minBoundsY = options.minBoundsY === undefined ? 0 : options.minBoundsY;
        const minBoundsZ = options.minBoundsZ === undefined ? 0 : options.minBoundsZ;
        const maxBoundsX = options.maxBoundsX === undefined ? 0 : options.maxBoundsX;
        const maxBoundsY = options.maxBoundsY === undefined ? 0 : options.maxBoundsY;
        const maxBoundsZ = options.maxBoundsZ === undefined ? 0 : options.maxBoundsZ;
        const positionX = options.positionX === undefined ? 0 : options.positionX;
        const positionY = options.positionY === undefined ? 0 : options.positionY;
        const positionZ = options.positionZ === undefined ? 0 : options.positionZ;
        const sizeX = options.sizeX === undefined ? 1 : options.sizeX;
        const sizeY = options.sizeY === undefined ? 1 : options.sizeY;
        const sizeZ = options.sizeZ === undefined ? 1 : options.sizeZ;
        const spacing = options.spacing === undefined ? 1 : options.spacing;
        const labelScale = options.labelScale === undefined ? 1 : options.labelScale;
        const labelMaxGlyphs = options.labelMaxGlyphs === undefined ? this._core.config.keyLabelMaxGlyphs : options.labelMaxGlyphs;
        const titleScale = options.titleScale === undefined ? 1 : options.titleScale;
        const titleMaxGlyphs = options.titleMaxGlyphs === undefined ? this._core.config.keyTitleMaxGlyphs : options.titleMaxGlyphs;
        const font = options.font ? options.font : this._core.font;
        const horizontalAlignment = options.horizontalAlignment === undefined ? (0, $4a6417d29706362f$export$d94dcb5bec64086e).center : options.horizontalAlignment;
        const verticalAlignment = options.verticalAlignment === undefined ? (0, $4a6417d29706362f$export$c12e835f91722ef8).center : options.verticalAlignment;
        const orientation = options.orientation === undefined ? (0, $4a6417d29706362f$export$df54d73aa0ec5e82).horizontal : options.orientation;
        const labelPosition = options.labelPosition === undefined ? (0, $4a6417d29706362f$export$1c6bed1dcbac1312).right : options.labelPosition;
        const labelOrientation = options.labelOrientation === undefined ? (0, $4a6417d29706362f$export$df54d73aa0ec5e82).horizontal : options.labelOrientation;
        const rotation = (0, $39ece26d1239bb77$exports).create();
        let count = options.values.length;
        const ids = new Uint32Array(count);
        let minValue = Number.MAX_VALUE;
        let maxValue = -Number.MAX_VALUE;
        for(let i = 0; i < count; i++){
            ids[i] = i;
            const value = options.values[i];
            minValue = Math.min(minValue, value);
            maxValue = Math.max(maxValue, value);
        }
        const materialIds = new Uint32Array(count);
        for(let i = 0; i < count; i++)materialIds[i] = (0, $2d4d1eb6f32f02f2$export$80a8c44b8858d625).normalize(options.values[i], minValue, maxValue, 0, options.palette.length / 4 - 1);
        let glyphCount = 0;
        let totalLabelWidth = 0;
        let maxLabelWidth = 0;
        for(let i = 0; i < count; i++){
            const label = (0, $ee14aeb68f9f83d5$export$f080f423ca93034f).truncate(options.labels[i], labelMaxGlyphs);
            glyphCount += label.length;
            (0, $ee14aeb68f9f83d5$export$f080f423ca93034f).measure(font, label, this._textMetric);
            const width = this._textMetric.width;
            totalLabelWidth += width;
            maxLabelWidth = Math.max(width, maxLabelWidth);
        }
        let titleWidth = 0;
        let title;
        if (options.title) {
            title = (0, $ee14aeb68f9f83d5$export$f080f423ca93034f).truncate(options.title, titleMaxGlyphs);
            glyphCount += title.length;
            (0, $ee14aeb68f9f83d5$export$f080f423ca93034f).measure(font, title, this._textMetric);
            titleWidth = this._textMetric.width;
        }
        let width;
        let height;
        switch(orientation){
            case (0, $4a6417d29706362f$export$df54d73aa0ec5e82).horizontal:
                switch(labelPosition){
                    case (0, $4a6417d29706362f$export$1c6bed1dcbac1312).bottom:
                        switch(labelOrientation){
                            case (0, $4a6417d29706362f$export$df54d73aa0ec5e82).horizontal:
                                break;
                            case (0, $4a6417d29706362f$export$df54d73aa0ec5e82).vertical:
                                break;
                        }
                        break;
                    case (0, $4a6417d29706362f$export$1c6bed1dcbac1312).left:
                        switch(labelOrientation){
                            case (0, $4a6417d29706362f$export$df54d73aa0ec5e82).horizontal:
                                break;
                            case (0, $4a6417d29706362f$export$df54d73aa0ec5e82).vertical:
                                break;
                        }
                        break;
                    case (0, $4a6417d29706362f$export$1c6bed1dcbac1312).right:
                        switch(labelOrientation){
                            case (0, $4a6417d29706362f$export$df54d73aa0ec5e82).horizontal:
                                break;
                            case (0, $4a6417d29706362f$export$df54d73aa0ec5e82).vertical:
                                break;
                        }
                        break;
                    case (0, $4a6417d29706362f$export$1c6bed1dcbac1312).top:
                        switch(labelOrientation){
                            case (0, $4a6417d29706362f$export$df54d73aa0ec5e82).horizontal:
                                break;
                            case (0, $4a6417d29706362f$export$df54d73aa0ec5e82).vertical:
                                break;
                        }
                        break;
                }
                break;
            case (0, $4a6417d29706362f$export$df54d73aa0ec5e82).vertical:
                switch(labelPosition){
                    case (0, $4a6417d29706362f$export$1c6bed1dcbac1312).bottom:
                        switch(labelOrientation){
                            case (0, $4a6417d29706362f$export$df54d73aa0ec5e82).horizontal:
                                break;
                            case (0, $4a6417d29706362f$export$df54d73aa0ec5e82).vertical:
                                break;
                        }
                        break;
                    case (0, $4a6417d29706362f$export$1c6bed1dcbac1312).left:
                        switch(labelOrientation){
                            case (0, $4a6417d29706362f$export$df54d73aa0ec5e82).horizontal:
                                break;
                            case (0, $4a6417d29706362f$export$df54d73aa0ec5e82).vertical:
                                break;
                        }
                        break;
                    case (0, $4a6417d29706362f$export$1c6bed1dcbac1312).right:
                        switch(labelOrientation){
                            case (0, $4a6417d29706362f$export$df54d73aa0ec5e82).horizontal:
                                break;
                            case (0, $4a6417d29706362f$export$df54d73aa0ec5e82).vertical:
                                break;
                        }
                        break;
                    case (0, $4a6417d29706362f$export$1c6bed1dcbac1312).top:
                        switch(labelOrientation){
                            case (0, $4a6417d29706362f$export$df54d73aa0ec5e82).horizontal:
                                break;
                            case (0, $4a6417d29706362f$export$df54d73aa0ec5e82).vertical:
                                break;
                        }
                        break;
                }
                break;
        }
        switch(orientation){
            case (0, $4a6417d29706362f$export$df54d73aa0ec5e82).horizontal:
                width = Math.max(sizeX * count + spacing * (count - 1) + totalLabelWidth, titleWidth);
                height = sizeY;
                if (options.title) height += titleScale;
                break;
            case (0, $4a6417d29706362f$export$df54d73aa0ec5e82).vertical:
                width = Math.max(sizeX + labelScale / 2 + maxLabelWidth, titleWidth);
                height = sizeY * count + spacing * (count - 1);
                if (options.title) height += titleScale;
                break;
        }
        let originX = positionX;
        let originY = positionY;
        let originZ = positionZ;
        switch(horizontalAlignment){
            case (0, $4a6417d29706362f$export$d94dcb5bec64086e).center:
                break;
            case (0, $4a6417d29706362f$export$d94dcb5bec64086e).left:
                originX += width / 2;
                break;
            case (0, $4a6417d29706362f$export$d94dcb5bec64086e).right:
                originX -= width / 2;
                break;
        }
        switch(verticalAlignment){
            case (0, $4a6417d29706362f$export$c12e835f91722ef8).bottom:
                originY += height / 2;
                break;
            case (0, $4a6417d29706362f$export$c12e835f91722ef8).center:
                break;
            case (0, $4a6417d29706362f$export$c12e835f91722ef8).top:
                originY -= height / 2;
                break;
        }
        const positionsX = new Float64Array(count);
        const positionsY = new Float64Array(count);
        const positionsZ = new Float64Array(count);
        for(let i = 0; i < count; i++){
            positionsX[i] = originX - width / 2 + sizeX / 2;
            positionsY[i] = originY + height / 2 - i * (sizeY + spacing);
            positionsZ[i] = originZ + sizeZ / 2;
        }
        const scatter = new (0, $5c05d7e02492b136$export$1c460fb4285edadc)(this._core);
        const scatterLayoutOptions = {
            positionsX: positionsX,
            positionsY: positionsY,
            positionsZ: positionsZ
        };
        scatter.layout(this._transitionBuffer.currentBuffer, ids, scatterLayoutOptions);
        const scatterVertexOptions = {
            minBoundsX: minBoundsX,
            minBoundsY: minBoundsY,
            minBoundsZ: minBoundsZ,
            maxBoundsX: maxBoundsX,
            maxBoundsY: maxBoundsY,
            maxBoundsZ: maxBoundsZ,
            colors: options.values,
            minColor: minValue,
            maxColor: maxValue,
            sizeScalingX: sizeX,
            sizeScalingY: sizeY,
            sizeScalingZ: sizeZ,
            materials: materialIds
        };
        scatter.update(this._transitionBuffer.currentBuffer, ids, scatterVertexOptions);
        const labelSetOptions = {
            text: options.labels,
            maxGlyphs: glyphCount,
            scale: labelScale,
            font: font
        };
        const labelSet = new (0, $715a174735ed4fbb$export$f51a22c5863d0d80)(this._core, labelSetOptions);
        if (options.title) count++;
        const labelPositionsX = new Float64Array(count);
        const labelPositionsY = new Float64Array(count);
        const labelPositionsZ = new Float64Array(count);
        for(let i = 0; i < (options.title ? count - 1 : count); i++){
            labelPositionsX[i] = originX - width / 2 + sizeX + labelScale / 2;
            labelPositionsY[i] = positionsY[i];
            labelPositionsZ[i] = originZ;
        }
        options.title;
        labelSet.minBoundsX = minBoundsX;
        labelSet.minBoundsY = minBoundsY;
        labelSet.minBoundsZ = minBoundsZ;
        labelSet.maxBoundsX = maxBoundsX;
        labelSet.maxBoundsY = maxBoundsY;
        labelSet.maxBoundsZ = maxBoundsZ;
        labelSet.positionsX = positionsX;
        labelSet.positionsY = positionsY;
        labelSet.positionsZ = positionsZ;
        labelSet.rotation = new Float64Array([
            rotation[0],
            rotation[1],
            rotation[2],
            rotation[3]
        ]);
        labelSet.horizontalAlignment = (0, $4a6417d29706362f$export$d94dcb5bec64086e).left;
    }
}




var $4559f2a5f6bc9c8c$exports = {};

$parcel$export($4559f2a5f6bc9c8c$exports, "AxesBase", () => $2e2b6f93796e9c8a$export$a0569bcde4468e7f);
$parcel$export($4559f2a5f6bc9c8c$exports, "Cartesian2dAxes", () => $28691cf6913948f8$export$e3e79a454e5f8e5a);
$parcel$export($4559f2a5f6bc9c8c$exports, "Cartesian2dAxesHelper", () => $28691cf6913948f8$export$133913079d003c31);
$parcel$export($4559f2a5f6bc9c8c$exports, "Cartesian3dAxes", () => $4cd1e156df302e7a$export$b1b08d445768978);
$parcel$export($4559f2a5f6bc9c8c$exports, "Cartesian3dAxesHelper", () => $4cd1e156df302e7a$export$a623f6a4669f174c);
/*!
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 */ 




var $92f02b8a0655b486$exports = {};

$parcel$export($92f02b8a0655b486$exports, "AngleHelper", () => $a49c65c28e06311e$export$210d3b2db589eb5c);
$parcel$export($92f02b8a0655b486$exports, "AnimationHelper", () => $cc0e5bcb75088eeb$export$f1c8488f7ae08606);
$parcel$export($92f02b8a0655b486$exports, "ArrayHelper", () => $ee0d365f44abacf8$export$94a9a87466f562a3);
$parcel$export($92f02b8a0655b486$exports, "AxisHelper", () => $92acb7820f38feec$export$46c1eaab6b8d1e23);
$parcel$export($92f02b8a0655b486$exports, "Base64Helper", () => $22e502955a85a3df$export$ea5aaa763e911d0e);
$parcel$export($92f02b8a0655b486$exports, "BinHelper", () => $ce9642dece868acb$export$eecfe2b6190b0ed);
$parcel$export($92f02b8a0655b486$exports, "ColorHelper", () => $c37f3938111fba7e$export$a33ddd5b3ba7b208);
$parcel$export($92f02b8a0655b486$exports, "CsvHelper", () => $27dc24c82c71089a$export$a9e0444473dcb771);
$parcel$export($92f02b8a0655b486$exports, "FacetHelper", () => $c2a459ae4d3b0cbc$export$4b34289fff3e9e9d);
$parcel$export($92f02b8a0655b486$exports, "ForceDirectHelper", () => $1c75d3db8cc60612$export$6844396a695c449);
$parcel$export($92f02b8a0655b486$exports, "HexHelper", () => $24349737166db450$export$db005bf9e0fbda31);
$parcel$export($92f02b8a0655b486$exports, "HexBinHelper", () => $18a78f0c92aa12a4$export$917b5ee4d724090b);
$parcel$export($92f02b8a0655b486$exports, "LineHelper", () => $f981d40aaab0cc8d$export$a94506fb574265ab);
$parcel$export($92f02b8a0655b486$exports, "MathHelper", () => $2d4d1eb6f32f02f2$export$80a8c44b8858d625);
$parcel$export($92f02b8a0655b486$exports, "PseudoRandom", () => $2d4d1eb6f32f02f2$export$b8e288c3467acb0e);
$parcel$export($92f02b8a0655b486$exports, "MatrixHelper", () => $b920b5b69884770f$export$34bcf93e378e8ddd);
$parcel$export($92f02b8a0655b486$exports, "MercatorHelper", () => $9567e168ff06f2c9$export$33e818f0c514945e);
$parcel$export($92f02b8a0655b486$exports, "AlbersHelper", () => $9567e168ff06f2c9$export$4c4ef7713ed8a00d);
$parcel$export($92f02b8a0655b486$exports, "GeoJSONHelper", () => $9567e168ff06f2c9$export$618604db0cd69e78);
$parcel$export($92f02b8a0655b486$exports, "OctTreeHelper", () => $935506ebc69281c4$export$bf3a0f176b3bd0a8);
$parcel$export($92f02b8a0655b486$exports, "PaletteHelper", () => $11b5f927bd29379c$export$2ee509afc4628e4);
$parcel$export($92f02b8a0655b486$exports, "PathHelper", () => $a4596fc55355f0e1$export$433e0478e7f6ca93);
$parcel$export($92f02b8a0655b486$exports, "PickHelper", () => $a60d0d861ccf87e8$export$aadd933e49c67c12);
$parcel$export($92f02b8a0655b486$exports, "TableHelper", () => $38a1943f255fbbec$export$9ac52b025685a4d0);
$parcel$export($92f02b8a0655b486$exports, "TextHelper", () => $ee14aeb68f9f83d5$export$f080f423ca93034f);
$parcel$export($92f02b8a0655b486$exports, "TextureHelper", () => $a25f5529f6cda489$export$c41e4fcbf45db179);
$parcel$export($92f02b8a0655b486$exports, "TreeHelper", () => $f90460e72834bcbf$export$7b64922b0b192bef);
$parcel$export($92f02b8a0655b486$exports, "SetHelper", () => $33e5ac524dde1fe2$export$a30f602ccece8e25);
$parcel$export($92f02b8a0655b486$exports, "SdfHelper", () => $22ccc45c3c88d82f$export$98599ead9515fc06);
$parcel$export($92f02b8a0655b486$exports, "VectorHelper", () => $8c233993336ed54a$export$1c9ca61bb2a30bed);
/*!
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 */ 

/*!
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 */ class $ee0d365f44abacf8$export$94a9a87466f562a3 {
    static minIndex(orderedValues, offset, length, value) {
        let index = $ee0d365f44abacf8$export$94a9a87466f562a3.binarySearch(orderedValues, offset, length, value);
        if (index < 0) {
            index = ~index;
            index = Math.max(0, index);
        } else while(index > 0 && orderedValues[index - 1] == value)index--;
        return index;
    }
    static maxIndex(orderedValues, offset, length, value) {
        let index = $ee0d365f44abacf8$export$94a9a87466f562a3.binarySearch(orderedValues, offset, length, value);
        if (index < 0) index = ~index - 1;
        else {
            while(index < length - 1 && orderedValues[index + 1] == value)index++;
            index = Math.min(length, index);
        }
        return index;
    }
    static binarySearch(array, index, length, value) {
        let low = index;
        let high = index + length - 1;
        while(low <= high){
            const mid = low + (high - low >> 1);
            if (array[mid] == value) return mid;
            if (array[mid] <= value) low = mid + 1;
            else high = mid - 1;
        }
        return ~low;
    }
}



/*!
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 */ class $22e502955a85a3df$export$ea5aaa763e911d0e {
    uint6ToB64(nUint6) {
        return nUint6 < 26 ? nUint6 + 65 : nUint6 < 52 ? nUint6 + 71 : nUint6 < 62 ? nUint6 - 4 : nUint6 === 62 ? 43 : nUint6 === 63 ? 47 : 65;
    }
    base64EncArr(aBytes) {
        let nMod3 = 2;
        let sB64Enc = "";
        let nLen = aBytes.byteLength;
        let nUint24 = 0;
        for(let nIdx = 0; nIdx < nLen; nIdx++){
            nMod3 = nIdx % 3;
            if (nIdx > 0 && nIdx * 4 / 3 % 76 === 0) sB64Enc += "\r\n";
            nUint24 |= aBytes.getUint8(nIdx) << (16 >>> nMod3 & 24);
            if (nMod3 === 2 || aBytes.byteLength - nIdx === 1) {
                sB64Enc += String.fromCharCode(this.uint6ToB64(nUint24 >>> 18 & 63), this.uint6ToB64(nUint24 >>> 12 & 63), this.uint6ToB64(nUint24 >>> 6 & 63), this.uint6ToB64(nUint24 & 63));
                nUint24 = 0;
            }
        }
        return sB64Enc.substring(0, sB64Enc.length - 2 + nMod3) + (nMod3 === 2 ? "" : nMod3 === 1 ? "=" : "==");
    }
}


/*!
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 */ class $ce9642dece868acb$export$eecfe2b6190b0ed {
    static quantile(options) {
        const offset = options.offset === undefined ? 0 : options.offset;
        const count = options.count === undefined ? options.ids.length : options.count;
        const itemsPerBin = count / options.bins;
        let bin = 0;
        if (options.froms && options.tos) {
            const firstId = options.ids[offset];
            options.froms[0] = options.values[firstId];
        }
        for(let i = 0; i < count; i++){
            const id = options.ids[i + offset];
            if (i > Math.floor(itemsPerBin * (bin + 1))) {
                bin++;
                if (options.froms && options.tos) {
                    options.tos[bin - 1] = options.values[id];
                    const nextId = options.ids[i + offset + 1];
                    options.froms[bin] = options.values[nextId];
                }
            }
            options.binIds[id] = bin;
        }
        if (options.froms && options.tos) {
            const lastId = options.ids[count - 1 + offset];
            options.tos[options.bins - 1] = options.values[lastId];
        }
        return Math.floor(itemsPerBin);
    }
    static bin(options) {
        const offset = options.offset === undefined ? 0 : options.offset;
        const count = options.count === undefined ? options.ids.length : options.count;
        const counts = options.counts ? options.counts : new Float64Array(options.bins);
        let minValue = options.minValue;
        let maxValue = options.maxValue;
        if (options.isDiscrete || maxValue == minValue) {
            minValue -= 0.5;
            maxValue += 0.5;
        }
        const binSize = (maxValue - minValue) / options.bins;
        let maxCount = 0;
        for(let i = 0; i < count; i++){
            const id = options.ids[i + offset];
            const value = options.values[id];
            const binId = Math.max(Math.min(Math.floor((value - minValue) / binSize), options.bins - 1), 0);
            options.binIds[id] = binId;
            counts[binId]++;
            maxCount = Math.max(counts[binId], maxCount);
        }
        if (options.froms && options.tos) {
            for(let i = 0; i < options.bins; i++)if (options.isDiscrete || maxValue == minValue) {
                options.froms[i] = Math.ceil(minValue + binSize * i);
                options.tos[i] = Math.floor(minValue + binSize * (i + 1));
            } else {
                options.froms[i] = minValue + binSize * i;
                options.tos[i] = minValue + binSize * (i + 1);
            }
        }
        return maxCount;
    }
    static maxBins(minValue, maxValue, isDiscrete, maxBins) {
        if (isDiscrete) return Math.min(maxValue - minValue + 1, maxBins);
        else return maxBins;
    }
}


/*!
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 */ 
class $c37f3938111fba7e$export$a33ddd5b3ba7b208 {
    static luminance(rgb) {
        return rgb[0] * $c37f3938111fba7e$export$a33ddd5b3ba7b208.LUMINANCE[0] + rgb[1] * $c37f3938111fba7e$export$a33ddd5b3ba7b208.LUMINANCE[1] + rgb[2] * $c37f3938111fba7e$export$a33ddd5b3ba7b208.LUMINANCE[2];
    }
    static rgbToHex(r, g, b) {
        const r2 = `0${Math.round(r * 255).toString(16)}`;
        const g2 = `0${Math.round(g * 255).toString(16)}`;
        const b2 = `0${Math.round(b * 255).toString(16)}`;
        return `#${r2.substr(r2.length - 2, 2)}${g2.substr(g2.length - 2, 2)}${b2.substr(b2.length - 2, 2)}`;
    }
    static rgbToHsv(r, g, b, hsv) {
        let h, s, v, delta;
        const min = Math.min(Math.min(r, g), b);
        const max = Math.max(Math.max(r, g), b);
        delta = max - min;
        v = max;
        if (delta == 0) {
            h = -1;
            if (max == 0) s = -1;
            else s = 0;
            hsv[0] = h;
            hsv[1] = s;
            hsv[2] = v;
        }
        s = delta / max;
        if (r == max) h = (g - b) / delta;
        else if (g == max) h = 2 + (b - r) / delta;
        else h = 4 + (r - g) / delta;
        h *= 60;
        if (h < 0) h += 360;
        hsv[0] = h;
        hsv[1] = s;
        hsv[2] = v;
    }
    static hsvToRgb(h, s, v, rgb) {
        let sextant, r, g, b;
        if (s == 0) {
            r = g = b = v;
            rgb[0] = r;
            rgb[1] = g;
            rgb[2] = b;
        }
        let frac, p, q, t;
        h %= 360;
        h /= 60;
        sextant = Math.floor(h);
        frac = h - sextant;
        p = v * (1 - s);
        q = v * (1 - s * frac);
        t = v * (1 - s * (1 - frac));
        switch(sextant){
            case 0:
                r = v;
                g = t;
                b = p;
                break;
            case 1:
                r = q;
                g = v;
                b = p;
                break;
            case 2:
                r = p;
                g = v;
                b = t;
                break;
            case 3:
                r = p;
                g = q;
                b = v;
                break;
            case 4:
                r = t;
                g = p;
                b = v;
                break;
            default:
                r = v;
                g = p;
                b = q;
                break;
        }
        rgb[0] = r;
        rgb[1] = g;
        rgb[2] = b;
    }
}
$c37f3938111fba7e$export$a33ddd5b3ba7b208.LUMINANCE = (0, $31054a6c69637582$exports).fromValues(0.2126, 0.7152, 0.0722);


/*!
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 */ 
class $27dc24c82c71089a$export$a9e0444473dcb771 {
    constructor(core){
        this.QUOTE = '"';
        this.DELIMETER = ',';
        this.LINE_BREAKS = [
            '\n',
            '\r'
        ];
        this._core = core;
    }
    readline(text, row) {
        return this.read(text, row, 1)[0];
    }
    read(text, firstRow = 0, maxRows = Number.MAX_VALUE) {
        const start = window.performance.now();
        const rows = [];
        let rowBuffer = [];
        let row = 0;
        let columnBuffer = "";
        let quoted = false;
        for(let i = 0; i < text.length; i++){
            const char = text.charAt(i);
            if (char == this.QUOTE) {
                if (text.charAt(i + 1) == this.QUOTE) {
                    i++;
                    columnBuffer += this.QUOTE;
                } else quoted = !quoted;
            } else if (quoted) columnBuffer += char;
            else {
                if (char == this.DELIMETER) {
                    rowBuffer.push(columnBuffer);
                    columnBuffer = "";
                } else if (this.LINE_BREAKS.indexOf(char) > -1) {
                    rowBuffer.push(columnBuffer);
                    columnBuffer = "";
                    while(this.LINE_BREAKS.indexOf(text.charAt(i + 1)) > -1)i++;
                    if (row++ >= firstRow) rows.push(rowBuffer);
                    rowBuffer = [];
                    if (rows.length == maxRows) break;
                } else columnBuffer += char;
            }
        }
        if (columnBuffer != "") rowBuffer.push(columnBuffer);
        if (rowBuffer.length > 0) rows.push(rowBuffer);
        if (maxRows > 1) this._core.log.write((0, $4a6417d29706362f$export$243e62d78d3b544d).info, `csv ${rows.length} rows ${Math.round(window.performance.now() - start)}ms`);
        return rows;
    }
    writeLine(data) {
        let text = "";
        for(let i = 0; i < data.length; i++){
            let column = data[i];
            if (column) {
                const quotes = column.indexOf(this.DELIMETER) > -1 || column.indexOf(this.QUOTE) > -1;
                column = column.replace(/"/g, '""');
                if (quotes) column = `${this.QUOTE}${column}${this.QUOTE}`;
            }
            text += column;
            if (i < data.length - 1) text += this.DELIMETER;
        }
        return text;
    }
    writeAsJavaScriptArray(headings, data) {
        let text = "[[";
        for (let column of headings)text += `"${column}",`;
        text = text.slice(0, -1);
        text += "]\n";
        let row;
        for(let i = 0; i < data.length; i++){
            const line = data[i];
            row = "[";
            for(let j = 0; j < line.length; j++){
                const column = line[j];
                row += `"${column.replace(/"/g, '\\"')}",`;
            }
            row = row.slice(0, -1);
            row += "],\n";
            text += row;
        }
        text += "];";
        return text;
    }
}


/*!
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 */ 
class $c2a459ae4d3b0cbc$export$4b34289fff3e9e9d {
    constructor(core){
        this._core = core;
    }
    split1d(ids, facetsX, valuesX, orderedIds, facetIds, offsets, counts) {
        this.split3d(ids, facetsX, undefined, undefined, valuesX, null, null, orderedIds, facetIds, offsets, counts);
    }
    split2d(ids, facetsX, facetsY, valuesX, valuesY, orderedIds, facetIds, offsets, counts) {
        this.split3d(ids, facetsX, facetsY, undefined, valuesX, valuesY, null, orderedIds, facetIds, offsets, counts);
    }
    split3d(ids, facetsX, facetsY, facetsZ, valuesX, valuesY, valuesZ, orderedIds, facetIds, offsets, counts) {
        if (valuesX && facetIds.length != valuesX.length) this._core.log.write((0, $4a6417d29706362f$export$243e62d78d3b544d).warn, "facet helper split1d facetIds should be same length as facetValuesX");
        if (valuesY && facetIds.length != valuesY.length) this._core.log.write((0, $4a6417d29706362f$export$243e62d78d3b544d).warn, "facet helper split1d facetIds should be same length as facetValuesY");
        if (valuesZ && facetIds.length != valuesY.length) this._core.log.write((0, $4a6417d29706362f$export$243e62d78d3b544d).warn, "facet helper split1d facetIds should be same length as facetValuesY");
        const start = window.performance.now();
        if (facetsX === undefined) facetsX = 1;
        if (facetsY === undefined) facetsY = 1;
        if (facetsZ === undefined) facetsZ = 1;
        const maxFacetId = facetsX * facetsY * facetsZ - 1;
        for(let i = 0; i < ids.length; i++){
            const id = ids[i];
            const valueX = valuesX ? valuesX[id] : 0;
            const valueY = valuesY ? valuesY[id] : 0;
            const valueZ = valuesZ ? valuesZ[id] : 0;
            const facetId = valueX + valueY * facetsX + valueZ * facetsX * facetsZ;
            facetIds[id] = facetId;
            if (facetId > maxFacetId) this._core.log.write((0, $4a6417d29706362f$export$243e62d78d3b544d).warn, "facet overflow");
            counts[facetId]++;
        }
        let offset = 0;
        for(let i = 0; i < offsets.length; i++){
            const count = counts[i];
            offsets[i] = offset;
            offset += count;
        }
        const tempOffsets = new Uint32Array(offsets);
        for(let i = 0; i < ids.length; i++){
            const id = ids[i];
            const facetId = facetIds[id];
            offset = tempOffsets[facetId]++;
            orderedIds[offset] = id;
        }
        this._core.log.write((0, $4a6417d29706362f$export$243e62d78d3b544d).info, `facet split ${Math.round(window.performance.now() - start)}ms`);
    }
    wrap1d(ids, values, columns, coordsX, coordsY) {
        const start = window.performance.now();
        let rows = 0;
        for(let i = 0; i < ids.length; i++){
            const id = ids[i];
            const value = values[id];
            coordsX[id] = value % columns;
            const row = Math.floor(value / columns);
            coordsY[id] = row;
            rows = Math.max(row, rows);
        }
        this._core.log.write((0, $4a6417d29706362f$export$243e62d78d3b544d).info, `facet wrap ${Math.round(window.performance.now() - start)}ms`);
        return rows + 1;
    }
}


/*!
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 */ /*!
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 */ class $935506ebc69281c4$export$75da59b8cfa595f3 {
}
class $935506ebc69281c4$export$bf3a0f176b3bd0a8 {
    constructor(options){
        this._ids = options.ids;
        this._positionsX = options.positionsX;
        this._positionsY = options.positionsY;
        this._positionsZ = options.positionsZ;
        this._masses = options.masses;
        this._maxLevel = options.maxLevel;
        this.root = new $935506ebc69281c4$export$75da59b8cfa595f3();
        this.root.minBoundsX = options.minBoundsX;
        this.root.minBoundsY = options.minBoundsY;
        this.root.minBoundsZ = options.minBoundsZ;
        this.root.maxBoundsX = options.maxBoundsX;
        this.root.maxBoundsY = options.maxBoundsY;
        this.root.maxBoundsZ = options.maxBoundsZ;
        this.root.level = 0;
        this.root.octKey = "";
        this._buildTree(this.root, this._ids);
    }
    _buildTree(parent, ids) {
        const centerX = (parent.minBoundsX + parent.maxBoundsX) / 2;
        const centerY = (parent.minBoundsY + parent.maxBoundsY) / 2;
        const centerZ = (parent.minBoundsZ + parent.maxBoundsZ) / 2;
        const minBoundsX = [];
        const minBoundsY = [];
        const minBoundsZ = [];
        const maxBoundsX = [];
        const maxBoundsY = [];
        const maxBoundsZ = [];
        minBoundsX.push(parent.minBoundsX);
        minBoundsY.push(parent.minBoundsY);
        minBoundsZ.push(parent.minBoundsZ);
        maxBoundsX.push(centerX);
        maxBoundsY.push(centerY);
        maxBoundsZ.push(centerZ);
        minBoundsX.push(centerX);
        minBoundsY.push(parent.minBoundsY);
        minBoundsZ.push(parent.minBoundsZ);
        maxBoundsX.push(parent.maxBoundsX);
        maxBoundsY.push(centerY);
        maxBoundsZ.push(centerZ);
        minBoundsX.push(centerX);
        minBoundsY.push(parent.minBoundsY);
        minBoundsZ.push(centerZ);
        maxBoundsX.push(parent.maxBoundsX);
        maxBoundsY.push(centerY);
        maxBoundsZ.push(parent.maxBoundsZ);
        minBoundsX.push(parent.minBoundsX);
        minBoundsY.push(parent.minBoundsY);
        minBoundsZ.push(centerZ);
        maxBoundsX.push(centerX);
        maxBoundsY.push(centerY);
        maxBoundsZ.push(parent.maxBoundsZ);
        minBoundsX.push(parent.minBoundsX);
        minBoundsY.push(centerY);
        minBoundsZ.push(parent.minBoundsZ);
        maxBoundsX.push(centerX);
        maxBoundsY.push(parent.maxBoundsY);
        maxBoundsZ.push(centerZ);
        minBoundsX.push(centerX);
        minBoundsY.push(centerY);
        minBoundsZ.push(parent.minBoundsZ);
        maxBoundsX.push(parent.maxBoundsX);
        maxBoundsY.push(parent.maxBoundsY);
        maxBoundsZ.push(centerZ);
        minBoundsX.push(centerX);
        minBoundsY.push(centerY);
        minBoundsZ.push(centerZ);
        maxBoundsX.push(parent.maxBoundsX);
        maxBoundsY.push(parent.maxBoundsY);
        maxBoundsZ.push(parent.maxBoundsZ);
        minBoundsX.push(parent.minBoundsX);
        minBoundsY.push(centerY);
        minBoundsZ.push(centerZ);
        maxBoundsX.push(centerX);
        maxBoundsY.push(parent.maxBoundsY);
        maxBoundsZ.push(parent.maxBoundsZ);
        const masses = new Float64Array(8);
        const centerOfMassesX = new Float64Array(8);
        const centerOfMassesY = new Float64Array(8);
        const centerOfMassesZ = new Float64Array(8);
        const buckets = [
            [],
            [],
            [],
            [],
            [],
            [],
            [],
            []
        ];
        for(let i = 0; i < ids.length; i++){
            const index = ids[i];
            const x = this._positionsX[index];
            const y = this._positionsY[index];
            const z = this._positionsZ[index];
            const mass = this._masses[index];
            for(let j = 0; j < 8; j++)if (minBoundsX[j] <= x && maxBoundsX[j] >= x && minBoundsY[j] <= y && maxBoundsY[j] >= y && minBoundsZ[j] <= z && maxBoundsZ[j] >= z) {
                buckets[j].push(index);
                masses[j] += mass;
                centerOfMassesX[j] += x * mass;
                centerOfMassesY[j] += y * mass;
                centerOfMassesZ[j] += z * mass;
                break;
            }
        }
        parent.children = [];
        for(let i = 0; i < 8; i++)if (buckets[i].length > 0) {
            const child = new $935506ebc69281c4$export$75da59b8cfa595f3();
            child.minBoundsX = minBoundsX[i];
            child.minBoundsY = minBoundsY[i];
            child.minBoundsZ = minBoundsZ[i];
            child.maxBoundsX = maxBoundsX[i];
            child.maxBoundsY = maxBoundsY[i];
            child.maxBoundsZ = maxBoundsZ[i];
            child.mass = masses[i];
            child.centerOfMassX = centerOfMassesX[i] / masses[i];
            child.centerOfMassY = centerOfMassesY[i] / masses[i];
            child.centerOfMassZ = centerOfMassesZ[i] / masses[i];
            child.level = parent.level + 1;
            child.octKey += i.toString();
            child.parent = parent;
            child.ids = new Uint32Array(buckets[i]);
            parent.children.push(child);
            if (child.ids.length > 1 && child.level < this._maxLevel) this._buildTree(child, child.ids);
        }
    }
}


class $1c75d3db8cc60612$export$6844396a695c449 {
    set gravity(value) {
        this._gravity = value;
    }
    get gravity() {
        return this._gravity;
    }
    set attraction(value) {
        this._attraction = value;
    }
    get attraction() {
        return this._attraction;
    }
    set repulsion(value) {
        this._repulsion = value;
    }
    get repulsion() {
        return this._repulsion;
    }
    set interval(value) {
        this._interval = value;
    }
    get interval() {
        return this._interval;
    }
    set maxDistance(value) {
        this._maxDistance = value;
    }
    get maxDistance() {
        return this._maxDistance;
    }
    set iterationsPerLayout(value) {
        this._iteractionsPerLayout = value;
    }
    get iterationsPerLayout() {
        return this._iteractionsPerLayout;
    }
    set edgeWeightPower(value) {
        this._edgeWeightPower = value;
    }
    get edgeWeightPower() {
        return this._edgeWeightPower;
    }
    set theta(value) {
        this._theta = value;
    }
    get theta() {
        return this._theta;
    }
    get iterations() {
        return this._totalIterations;
    }
    get totalRepulsion() {
        return this._totalRepulsion;
    }
    get nodePositionsX() {
        return this._nodePositionsX;
    }
    get nodePositionsY() {
        return this._nodePositionsY;
    }
    get nodePositionsZ() {
        return this._nodePositionsZ;
    }
    get lockX() {
        return this._lockX;
    }
    set lockX(value) {
        this._lockX = value;
    }
    get lockY() {
        return this._lockY;
    }
    set lockY(value) {
        this._lockY = value;
    }
    get lockZ() {
        return this._lockZ;
    }
    set lockZ(value) {
        this._lockZ = value;
    }
    constructor(options){
        this._forcesX = new Float64Array(options.nodeIds.length);
        this._forcesY = new Float64Array(options.nodeIds.length);
        this._forcesZ = new Float64Array(options.nodeIds.length);
        this._totalIterations = 0;
        this._totalRepulsion = 0;
        this._repulsion = options.repulsion || 1;
        this._attraction = options.attraction || 1;
        this._gravity = options.gravity || 1;
        this._interval = options.interval || 1;
        this._maxDistance = options.maxDistance || 1;
        this._iteractionsPerLayout = options.iterationsPerLayout || 1;
        this._theta = options.theta || 1;
        this._nodeIds = options.nodeIds;
        this._nodePositionsX = options.nodePositionsX;
        this._nodePositionsY = options.nodePositionsY;
        this._nodePositionsZ = options.nodePositionsZ;
        this._nodeWeights = options.nodeWeights || new Float64Array(this._nodeIds.length).fill(1);
        this._edgeIds = options.edgeIds;
        this._edgeFromIds = options.edgeFromIds;
        this._edgeToIds = options.edgeToIds;
        this._edgeWeights = options.edgeWeights || new Float64Array(this._edgeIds.length).fill(1);
        this._edgeWeightPower = options.edgeWeightPower || 1;
    }
    layout() {
        this._minBoundsX = Number.MAX_VALUE;
        this._minBoundsY = Number.MAX_VALUE;
        this._minBoundsZ = Number.MAX_VALUE;
        this._maxBoundsX = -Number.MAX_VALUE;
        this._maxBoundsY = -Number.MAX_VALUE;
        this._maxBoundsZ = -Number.MAX_VALUE;
        for(let i = 0; i < this._nodeIds.length; i++){
            this._minBoundsX = Math.min(this._minBoundsX, this._nodePositionsX[i]);
            this._minBoundsY = Math.min(this._minBoundsY, this._nodePositionsY[i]);
            this._minBoundsZ = Math.min(this._minBoundsZ, this._nodePositionsZ[i]);
            this._maxBoundsX = Math.max(this._maxBoundsX, this._nodePositionsX[i]);
            this._maxBoundsY = Math.max(this._maxBoundsY, this._nodePositionsY[i]);
            this._maxBoundsZ = Math.max(this._maxBoundsZ, this._nodePositionsZ[i]);
        }
        for(let iteration = 0; iteration < this._iteractionsPerLayout; iteration++){
            for(let i = 0; i < this._nodeIds.length; i++){
                const id = this._nodeIds[i];
                this._forcesX[id] = 0;
                this._forcesY[id] = 0;
                this._forcesZ[id] = 0;
            }
            for(let i = 0; i < this._nodeIds.length; i++){
                const id = this._nodeIds[i];
                let dx = this._nodePositionsX[id];
                let dy = this._nodePositionsY[id];
                let dz = this._nodePositionsZ[id];
                const distanceSquared = dx * dx + dy * dy + dz * dz;
                if (distanceSquared > 0) {
                    const distance = Math.sqrt(distanceSquared);
                    dx /= distance;
                    dy /= distance;
                    dz /= distance;
                    const magnitude = -this._nodeWeights[id] * this._gravity;
                    this._forcesX[id] += magnitude * dx;
                    this._forcesY[id] += magnitude * dy;
                    this._forcesZ[id] += magnitude * dz;
                }
            }
            for(let i = 0; i < this._edgeIds.length; i++){
                const id = this._edgeIds[i];
                const fromId = this._edgeFromIds[id];
                const toId = this._edgeToIds[id];
                const x1 = this._nodePositionsX[fromId];
                const y1 = this._nodePositionsY[fromId];
                const z1 = this._nodePositionsZ[fromId];
                const x2 = this._nodePositionsX[toId];
                const y2 = this._nodePositionsY[toId];
                const z2 = this._nodePositionsZ[toId];
                let dx = x1 - x2;
                let dy = y1 - y2;
                let dz = z1 - z2;
                const distanceSquared = dx * dx + dy * dy + dz * dz;
                if (distanceSquared > 0) {
                    let distance = Math.sqrt(distanceSquared);
                    dx /= distance;
                    dy /= distance;
                    dz /= distance;
                    const magnitude = -distance * this._attraction * Math.pow(this._edgeWeights[id], this._edgeWeightPower);
                    this._forcesX[fromId] += magnitude * dx;
                    this._forcesY[fromId] += magnitude * dy;
                    this._forcesZ[fromId] += magnitude * dz;
                    this._forcesX[toId] -= magnitude * dx;
                    this._forcesY[toId] -= magnitude * dy;
                    this._forcesZ[toId] -= magnitude * dz;
                }
            }
            const minBounds = Math.min(Math.min(this._minBoundsX, this._minBoundsY), this._minBoundsZ);
            const maxBounds = Math.max(Math.max(this._maxBoundsX, this._maxBoundsY), this._maxBoundsZ);
            const size = maxBounds - minBounds;
            const maxLevel = 10;
            const minBoundsX = minBounds;
            const minBoundsY = minBounds;
            const minBoundsZ = minBounds;
            const maxBoundsX = maxBounds;
            const maxBoundsY = maxBounds;
            const maxBoundsZ = maxBounds;
            const octTreeOptions = {
                minBoundsX: minBoundsX,
                minBoundsY: minBoundsY,
                minBoundsZ: minBoundsZ,
                maxBoundsX: maxBoundsX,
                maxBoundsY: maxBoundsY,
                maxBoundsZ: maxBoundsZ,
                maxLevel: maxLevel,
                ids: this._nodeIds,
                positionsX: this._nodePositionsX,
                positionsY: this._nodePositionsY,
                positionsZ: this._nodePositionsZ,
                masses: this._nodeWeights
            };
            const octTree = new (0, $935506ebc69281c4$export$bf3a0f176b3bd0a8)(octTreeOptions);
            this._totalRepulsion = 0;
            for(let i = 0; i < this._nodeIds.length; i++){
                const id = this._nodeIds[i];
                this._forceX = 0;
                this._forceY = 0;
                this._forceZ = 0;
                this.calculateRepulsion(octTree.root, id);
                this._forcesX[id] += this._forceX;
                this._forcesY[id] += this._forceY;
                this._forcesZ[id] += this._forceZ;
                this._totalRepulsion += Math.sqrt(this._forceX * this._forceX + this._forceY * this._forceY + this._forceZ * this._forceZ);
            }
            const timeSquared = this._interval * this._interval;
            for(let i = 0; i < this._nodeIds.length; i++){
                const id = this._nodeIds[i];
                const mass = this._nodeWeights[id];
                const ax = this._forcesX[id] / mass;
                const ay = this._forcesY[id] / mass;
                const az = this._forcesZ[id] / mass;
                let dx = ax * timeSquared / 2;
                let dy = ay * timeSquared / 2;
                let dz = az * timeSquared / 2;
                const distanceSquared = dx * dx + dy * dy + dz * dz;
                const distance = Math.sqrt(distanceSquared);
                if (distance > this._maxDistance * size) {
                    dx *= this._maxDistance * size / distance;
                    dy *= this._maxDistance * size / distance;
                    dz *= this._maxDistance * size / distance;
                }
                if (!this._lockX) this._nodePositionsX[id] += dx;
                if (!this._lockY) this._nodePositionsY[id] += dy;
                if (!this._lockZ) this._nodePositionsZ[id] += dz;
            }
        }
        if (this.layoutCallback) this.layoutCallback();
    }
    calculateRepulsion(parent, id1) {
        const x1 = this._nodePositionsX[id1];
        const y1 = this._nodePositionsY[id1];
        const z1 = this._nodePositionsZ[id1];
        for(let k = 0; k < parent.children.length; k++){
            const child = parent.children[k];
            if (!child.children) for(let i = 0; i < child.ids.length; i++){
                const id2 = child.ids[i];
                if (id1 != id2) {
                    const x2 = this._nodePositionsX[id2];
                    const y2 = this._nodePositionsY[id2];
                    const z2 = this._nodePositionsZ[id2];
                    let dx = x1 - x2;
                    let dy = y1 - y2;
                    let dz = z1 - z2;
                    let distanceSquared = dx * dx + dy * dy + dz * dz;
                    if (distanceSquared > 0) {
                        let distance = Math.sqrt(distanceSquared);
                        dx /= distance;
                        dy /= distance;
                        dz /= distance;
                        const magnitude = this._repulsion * this._nodeWeights[id1] * this._nodeWeights[id2] / distanceSquared;
                        this._forceX += dx * magnitude;
                        this._forceY += dy * magnitude;
                        this._forceZ += dz * magnitude;
                    }
                }
            }
            else {
                let dx = x1 - child.centerOfMassX;
                let dy = y1 - child.centerOfMassY;
                let dz = z1 - child.centerOfMassZ;
                const distanceSquared = dx * dx + dy * dy + dz * dz;
                if (distanceSquared > 0) {
                    const distance = Math.sqrt(distanceSquared);
                    dx /= distance;
                    dy /= distance;
                    dz /= distance;
                    const width = child.maxBoundsX - child.minBoundsX;
                    if (width / distance < this._theta) {
                        const magnitude = this._repulsion * this._nodeWeights[id1] * child.mass / distanceSquared;
                        this._forceX += dx * magnitude;
                        this._forceY += dy * magnitude;
                        this._forceZ += dz * magnitude;
                    } else this.calculateRepulsion(child, id1);
                }
            }
        }
    }
}


/*!
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 */ 



class $24349737166db450$export$db005bf9e0fbda31 {
    static width(size, orientation) {
        if (orientation == (0, $4a6417d29706362f$export$9ac0daa892cfa13e).pointyTop) return (0, $d4d7bd6cc65a5081$export$a002182e51710d39).ROOT_THREE * size;
        else return 2 * size;
    }
    static height(size, orientation) {
        if (orientation == (0, $4a6417d29706362f$export$9ac0daa892cfa13e).pointyTop) return 2 * size;
        else return (0, $d4d7bd6cc65a5081$export$a002182e51710d39).ROOT_THREE * size;
    }
    static pointyHexCorner(center, size, i, position) {
        const angle = (0, $a49c65c28e06311e$export$210d3b2db589eb5c).degreesToRadians(60 * i - 30);
        position[0] = center[0] + size * Math.cos(angle);
        position[1] = center[1] + size * Math.sin(angle);
    }
    static cubeToAxial(cube, hex) {
        hex[0] = cube[0];
        hex[1] = cube[2];
    }
    static axialToCube(hex, cube) {
        const x = hex[0];
        const z = hex[1];
        const y = -x - z;
        cube[0] = x;
        cube[1] = y;
        cube[2] = z;
    }
    static cubeToOddr(cube, hex) {
        const col = cube[0] + (cube[2] - (cube[2] & 1)) / 2;
        const row = cube[2];
        hex[0] = col;
        hex[1] = row;
    }
    static oddrToCube(hex, cube) {
        const x = hex[0] - (hex[1] - (hex[1] & 1)) / 2;
        const z = hex[1];
        const y = -x - z;
        cube[0] = x;
        cube[1] = y;
        cube[2] = z;
    }
    static pointyHexToPixel(hex, size, point) {
        point[0] = size * ((0, $d4d7bd6cc65a5081$export$a002182e51710d39).ROOT_THREE * hex[0] + (0, $d4d7bd6cc65a5081$export$a002182e51710d39).ROOT_THREE / 2 * hex[1]);
        point[1] = size * (1.5 * hex[1]);
    }
    static pixelToPointyHex(point, size, hex) {
        hex[0] = ((0, $d4d7bd6cc65a5081$export$a002182e51710d39).ROOT_THREE / 3 * point[0] - 1 / 3 * point[1]) / size;
        hex[1] = 2 / 3 * point[1] / size;
        this.hexRound(hex, hex);
    }
    static hexRound(hex, hexRound) {
        const cube = this._vec3;
        this.axialToCube(hex, cube);
        this.cubeRound(cube, cube);
        this.cubeToAxial(cube, hexRound);
    }
    static cubeRound(cube, cubeRound) {
        let rx = Math.round(cube[0]);
        let ry = Math.round(cube[1]);
        let rz = Math.round(cube[2]);
        const x_diff = Math.abs(rx - cube[0]);
        const y_diff = Math.abs(ry - cube[1]);
        const z_diff = Math.abs(rz - cube[2]);
        if (x_diff > y_diff && x_diff > z_diff) rx = -ry - rz;
        else if (y_diff > z_diff) ry = -rx - rz;
        else rz = -rx - ry;
        cubeRound[0] = rx;
        cubeRound[1] = ry;
        cubeRound[2] = rz;
    }
}
$24349737166db450$export$db005bf9e0fbda31._vec3 = (0, $31054a6c69637582$exports).create();


/*!
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 */ 



class $18a78f0c92aa12a4$export$917b5ee4d724090b {
    static bin(options) {
        const offset = options.offset === undefined ? 0 : options.offset;
        const count = options.count === undefined ? options.ids.length : options.count;
        const width = (options.maxValueX - options.minValueX) / options.binsX;
        const minValueX = options.minValueX - width / 2;
        const binsX = options.binsX + 1;
        const size = width / (0, $d4d7bd6cc65a5081$export$a002182e51710d39).ROOT_THREE;
        const height = 2 * size;
        const heightBetweenCenters = 3 * height / 4;
        const binsY = Math.ceil((options.maxValueY - options.minValueY) / heightBetweenCenters) + 1;
        const minValueY = options.minValueY;
        const minQ = -Math.floor(binsY / 2);
        const maxBins = (binsX - minQ) * binsY;
        const binCounts = new Float64Array(maxBins);
        const binLookup = new Uint32Array(maxBins);
        const point = (0, $91b0cc4981465964$exports).create();
        const hex = (0, $91b0cc4981465964$exports).create();
        let nonEmptyBins = 0;
        let minCount = Number.MAX_VALUE;
        let maxCount = -Number.MAX_VALUE;
        for(let i = 0; i < count; i++){
            const id = options.ids[i + offset];
            point[0] = options.valuesX[id] - minValueX;
            point[1] = options.valuesY[id] - minValueY;
            (0, $24349737166db450$export$db005bf9e0fbda31).pixelToPointyHex(point, size, hex);
            const q = hex[0] - minQ;
            const r = hex[1];
            const binId = q + r * (binsX - minQ);
            if (binCounts[binId] == 0) {
                binLookup[binId] = nonEmptyBins;
                nonEmptyBins++;
            }
            binCounts[binId]++;
            options.binIds[id] = binId;
            minCount = Math.min(minCount, binCounts[binId]);
            maxCount = Math.max(maxCount, binCounts[binId]);
        }
        const positionsX = new Float64Array(nonEmptyBins);
        const positionsY = new Float64Array(nonEmptyBins);
        const counts = new Uint32Array(nonEmptyBins);
        const lookup = {};
        for(let i = 0; i < maxBins; i++){
            const count = binCounts[i];
            if (count > 0) {
                const index = binLookup[i];
                lookup[i] = index;
                counts[index] = count;
                const q = i % (binsX - minQ);
                const r = Math.floor(i / (binsX - minQ));
                hex[0] = q + minQ;
                hex[1] = r;
                (0, $24349737166db450$export$db005bf9e0fbda31).pointyHexToPixel(hex, size, point);
                positionsX[index] = point[0] + minValueX;
                positionsY[index] = point[1] + minValueY;
            }
        }
        const result = {
            binIds: options.binIds,
            positionsX: positionsX,
            positionsY: positionsY,
            counts: counts,
            minCount: minCount,
            maxCount: maxCount,
            orientation: (0, $4a6417d29706362f$export$9ac0daa892cfa13e).pointyTop,
            size: size,
            lookup: lookup,
            binsY: binsY
        };
        return result;
    }
}


/*!
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 */ 
class $f981d40aaab0cc8d$export$a94506fb574265ab {
    constructor(core){
        this._core = core;
    }
    connect(orderedIds, series, toIds, offset = 0, count = orderedIds.length) {
        const start = window.performance.now();
        const lines = new Set();
        const lookup = {};
        for(let i = offset; i < count; i++){
            const id = orderedIds[i + offset];
            const value = series[id];
            const fromId = lookup[value];
            if (fromId != null) {
                toIds[fromId] = id;
                lines.add(value);
            }
            lookup[value] = id;
            toIds[id] = id;
        }
        this._core.log.write((0, $4a6417d29706362f$export$243e62d78d3b544d).info, `${lines.size} lines connected ${Math.round(window.performance.now() - start)}ms`);
        return lines.size;
    }
}






/*!
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 */ 


class $11b5f927bd29379c$export$2ee509afc4628e4 {
    static resample(colorsIn, divisionsOut, reverse) {
        const divisionsIn = colorsIn.length / 3;
        const colorsOut = new Uint8Array(divisionsOut * 4);
        for(let i = 0; i < divisionsOut; i++){
            const positionOut = (i + 0.5) / divisionsOut;
            const positionIn = positionOut * (divisionsIn - 1);
            const stepIn = Math.floor(positionIn);
            const fractIn = positionIn - stepIn;
            const j = reverse ? divisionsOut - i - 1 : i;
            colorsOut[j * 4] = (0, $2d4d1eb6f32f02f2$export$80a8c44b8858d625).lerp(colorsIn[stepIn * 3], colorsIn[(stepIn + 1) * 3], fractIn);
            colorsOut[j * 4 + 1] = (0, $2d4d1eb6f32f02f2$export$80a8c44b8858d625).lerp(colorsIn[stepIn * 3 + 1], colorsIn[(stepIn + 1) * 3 + 1], fractIn);
            colorsOut[j * 4 + 2] = (0, $2d4d1eb6f32f02f2$export$80a8c44b8858d625).lerp(colorsIn[stepIn * 3 + 2], colorsIn[(stepIn + 1) * 3 + 2], fractIn);
            colorsOut[j * 4 + 3] = 255;
        }
        return colorsOut;
    }
    static truncate(colorsIn, divisionsOut, reverse) {
        const divisionsIn = colorsIn.length / 3;
        const colorsOut = new Uint8Array(divisionsOut * 4);
        for(let i = 0; i < Math.min(divisionsIn, divisionsOut); i++){
            const j = reverse ? divisionsOut - i - 1 : i;
            colorsOut[j * 4] = colorsIn[i * 3];
            colorsOut[j * 4 + 1] = colorsIn[i * 3 + 1];
            colorsOut[j * 4 + 2] = colorsIn[i * 3 + 2];
            colorsOut[j * 4 + 3] = 255;
        }
        return colorsOut;
    }
    static resampleStops(stops, divisions, reverse) {
        const colorsOut = new Uint8Array(divisions * 4);
        let from = 0;
        let to = 0;
        for(let i = 0; i < divisions; i++){
            const positionOut = (i + 0.5) / divisions;
            while(stops[from].position < positionOut && from < stops.length - 1)from++;
            from = Math.max(from - 1, 0);
            to = Math.min(from + 1, stops.length - 1);
            const fromStop = stops[from];
            const toStop = stops[to];
            const fract = from == to ? 0 : (positionOut - fromStop.position) / (toStop.position - fromStop.position);
            const j = reverse ? divisions - i - 1 : i;
            colorsOut[j * 4] = (0, $2d4d1eb6f32f02f2$export$80a8c44b8858d625).lerp(fromStop.r, toStop.r, fract);
            colorsOut[j * 4 + 1] = (0, $2d4d1eb6f32f02f2$export$80a8c44b8858d625).lerp(fromStop.g, toStop.g, fract);
            colorsOut[j * 4 + 2] = (0, $2d4d1eb6f32f02f2$export$80a8c44b8858d625).lerp(fromStop.b, toStop.b, fract);
            colorsOut[j * 4 + 3] = 255;
        }
        return colorsOut;
    }
    static lerpRgb(from, to, divisions) {
        const colors = new Uint8Array(divisions * 4);
        for(let i = 0; i < divisions; i++){
            const amount = i / (divisions - 1);
            colors[i * 4] = (0, $2d4d1eb6f32f02f2$export$80a8c44b8858d625).lerp(from[0], to[0], amount);
            colors[i * 4 + 1] = (0, $2d4d1eb6f32f02f2$export$80a8c44b8858d625).lerp(from[1], to[1], amount);
            colors[i * 4 + 2] = (0, $2d4d1eb6f32f02f2$export$80a8c44b8858d625).lerp(from[2], to[2], amount);
            colors[i * 4 + 3] = 0xff;
        }
        return colors;
    }
    static lerpHsv(from, to, divisions) {
        const colors = new Uint8Array(divisions * 4);
        for(let i = 0; i < divisions; i++){
            const amount = i / (divisions - 1);
            const h = (0, $2d4d1eb6f32f02f2$export$80a8c44b8858d625).lerp(from[0], to[0], amount);
            const s = (0, $2d4d1eb6f32f02f2$export$80a8c44b8858d625).lerp(from[1], to[1], amount);
            const v = (0, $2d4d1eb6f32f02f2$export$80a8c44b8858d625).lerp(from[2], to[2], amount);
            (0, $c37f3938111fba7e$export$a33ddd5b3ba7b208).hsvToRgb(h, s, v, $11b5f927bd29379c$export$2ee509afc4628e4._rgb);
            colors[i * 4] = $11b5f927bd29379c$export$2ee509afc4628e4._rgb[0] * 0xff;
            colors[i * 4 + 1] = $11b5f927bd29379c$export$2ee509afc4628e4._rgb[1] * 0xff;
            colors[i * 4 + 2] = $11b5f927bd29379c$export$2ee509afc4628e4._rgb[2] * 0xff;
            colors[i * 4 + 3] = 0xff;
        }
        return colors;
    }
}
$11b5f927bd29379c$export$2ee509afc4628e4._rgb = (0, $31054a6c69637582$exports).create();


/*!
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 */ class $a4596fc55355f0e1$export$433e0478e7f6ca93 {
    static getFilenameWithoutExtension(path) {
        const dot = path.lastIndexOf('.');
        if (dot == -1) return path;
        else {
            const start = path.lastIndexOf('/') == -1 ? 0 : path.lastIndexOf('/') + 1;
            return path.substring(start, dot);
        }
    }
    static getExtension(path) {
        const dot = path.lastIndexOf('.');
        if (dot == -1 || dot == path.length - 1) return null;
        else return path.substring(dot + 1, path.length);
    }
    static getFilename(path) {
        if (path.lastIndexOf('/') == -1) return path;
        else {
            const start = path.lastIndexOf('/') + 1;
            return path.substring(start, path.length);
        }
    }
    static getPath(path) {
        if (path.lastIndexOf('/') == -1) return "";
        else return path.substring(0, path.lastIndexOf('/'));
    }
    static combine(first, second) {
        const seperator = first.lastIndexOf('/') == first.length - 1;
        if (second.indexOf('/') == 0) {
            if (seperator) return first.substring(0, first.length - 1) + second;
            else return first + second;
        } else {
            if (seperator) return first + second;
            else return first + '/' + second;
        }
    }
}



/*!
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 */ 
/*!
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 */ /*!
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 */ 

class $b4dbeddbb8ed9d60$export$ec91da630f36d5ea {
    get ids() {
        return this._ids;
    }
    constructor(core, ids, data, headings, columnTypes, numericValues){
        this._core = core;
        this._ids = ids;
        this._data = data;
        this._columnTypes = columnTypes;
        this._numericValues = numericValues;
        this._stringValues = Array(columnTypes.length).fill(null);
        this._hasMinMaxValues = Array(columnTypes.length).fill(false);
        this._minValues = Array(columnTypes.length).fill(0);
        this._maxValues = Array(columnTypes.length).fill(0);
        this._distinctStrings = Array(columnTypes.length).fill(null);
        this._orderedIds = Array(columnTypes.length).fill(null);
        this._orderedValues = Array(columnTypes.length).fill(null);
    }
    columnValues(column) {
        if (this._columnTypes[column] == (0, $98a24d29667ae67f$export$7ce43d0a8f00d826).string) return this._createStringValues(column);
        else return this._createNumericValues(column);
    }
    minValue(column) {
        this._createMinMaxValues(column);
        return this._minValues[column];
    }
    maxValue(column) {
        this._createMinMaxValues(column);
        return this._maxValues[column];
    }
    distinctStrings(column) {
        if (this._columnTypes[column] == (0, $98a24d29667ae67f$export$7ce43d0a8f00d826).string) {
            this._createStringValues(column);
            return this._distinctStrings[column];
        } else return null;
    }
    toJSON(ids, columns) {
        const rows = [];
        for(let i = 0; i < ids.length; i++){
            const rowIndex = ids[i];
            const row = [];
            for(let j = 0; j < columns.length; j++){
                const columnIndex = columns[j];
                switch(this._columnTypes[columnIndex]){
                    case (0, $98a24d29667ae67f$export$7ce43d0a8f00d826).date:
                    case (0, $98a24d29667ae67f$export$7ce43d0a8f00d826).string:
                        row.push(this._data[rowIndex][columnIndex]);
                        break;
                    case (0, $98a24d29667ae67f$export$7ce43d0a8f00d826).integer:
                    case (0, $98a24d29667ae67f$export$7ce43d0a8f00d826).float:
                        const numericValues = this._createNumericValues(columnIndex);
                        row.push(numericValues[rowIndex]);
                        break;
                }
            }
            rows.push(row);
        }
        return JSON.stringify(rows);
    }
    orderedIds(column) {
        if (!this._orderedIds[column]) {
            const start = window.performance.now();
            const orderedIds = new Uint32Array(this._ids);
            const values = this._columnTypes[column] == (0, $98a24d29667ae67f$export$7ce43d0a8f00d826).string ? this._createStringValues(column) : this._createNumericValues(column);
            orderedIds.sort(function(a, b) {
                return values[a] - values[b];
            });
            this._orderedIds[column] = orderedIds;
            this._core.log.write((0, $4a6417d29706362f$export$243e62d78d3b544d).info, `ordered ids ${column} ${Math.round(window.performance.now() - start)}ms`);
        }
        return this._orderedIds[column];
    }
    orderedValues(column) {
        if (!this._orderedValues[column]) {
            const start = window.performance.now();
            const values = this._columnTypes[column] == (0, $98a24d29667ae67f$export$7ce43d0a8f00d826).string ? this._createStringValues(column) : this._createNumericValues(column);
            const orderedIds = this.orderedIds(column);
            const orderedValues = new Float64Array(this._ids.length);
            for(let i = 0; i < this._ids.length; i++)orderedValues[i] = values[orderedIds[i]];
            this._orderedValues[column] = orderedValues;
            this._core.log.write((0, $4a6417d29706362f$export$243e62d78d3b544d).info, `ordered values ${column} ${Math.round(window.performance.now() - start)}ms`);
        }
        return this._orderedValues[column];
    }
    distinctStringsOrdered(ids, column, stringValues) {
        if (this._columnTypes[column] == (0, $98a24d29667ae67f$export$7ce43d0a8f00d826).string) {
            const distinctStrings = [];
            const distinctStringValues = {};
            const set = new Set();
            for(let i = 0; i < ids.length; i++){
                const id = ids[i];
                const string = this._data[id][column];
                let value;
                if (!set.has(string)) {
                    distinctStrings.push(string);
                    value = set.size;
                    distinctStringValues[string] = value;
                    set.add(string);
                } else value = distinctStringValues[string];
                stringValues[id] = value;
            }
            return distinctStrings;
        } else return null;
    }
    _createMinMaxValues(column) {
        if (!this._hasMinMaxValues[column]) {
            const type = this._columnTypes[column];
            let min, max;
            if (type == (0, $98a24d29667ae67f$export$7ce43d0a8f00d826).string) {
                this._createStringValues(column);
                min = 0;
                max = this._distinctStrings[column].length - 1;
            } else {
                const numericValues = this._createNumericValues(column);
                min = Number.MAX_VALUE;
                max = -Number.MAX_VALUE;
                for(let i = 0; i < this._ids.length; i++){
                    const id = this._ids[i];
                    const value = numericValues[id];
                    min = Math.min(min, value);
                    max = Math.max(max, value);
                }
            }
            this._minValues[column] = min;
            this._maxValues[column] = max;
            this._hasMinMaxValues[column] = true;
        }
    }
    _createNumericValues(column) {
        if (!this._numericValues[column]) {
            const numericValues = new Float64Array(this._data.length);
            const type = this._columnTypes[column];
            if (type == (0, $98a24d29667ae67f$export$7ce43d0a8f00d826).float) for(let i = 0; i < this._data.length; i++){
                const value = parseFloat(this._data[i][column]);
                numericValues[i] = value;
            }
            else if (type == (0, $98a24d29667ae67f$export$7ce43d0a8f00d826).integer) for(let i = 0; i < this._data.length; i++){
                const value = parseInt(this._data[i][column]);
                numericValues[i] = value;
            }
            else if (type == (0, $98a24d29667ae67f$export$7ce43d0a8f00d826).date) for(let i = 0; i < this._data.length; i++){
                const value = Date.parse(this._data[i][column]);
                numericValues[i] = value;
            }
            this._numericValues[column] = numericValues;
        }
        return this._numericValues[column];
    }
    _createStringValues(column) {
        if (!this._stringValues[column]) {
            this._stringValues[column] = new Float64Array(this._data.length);
            this._distinctStrings[column] = this.distinctStringsOrdered(this._ids, column, this._stringValues[column]);
            this._minValues[column] = 0;
            this._maxValues[column] = this._distinctStrings[column].length - 1;
            this._hasMinMaxValues[column] = true;
        }
        return this._stringValues[column];
    }
}


class $98a24d29667ae67f$export$54ec01a60f47d33d {
    get data() {
        return this._data;
    }
    get headings() {
        return this._headings;
    }
    get all() {
        return this._all;
    }
    get isInitialized() {
        return this._isInitialized;
    }
    get filter() {
        return this._filter;
    }
    set filter(value) {
        if (this._filter !== value) {
            this._filter = value;
            if (this.filterChangedCallback) this.filterChangedCallback();
        }
    }
    getColumnType(column) {
        return this._columnTypes[column];
    }
    isColumnDiscrete(column) {
        return (this._columnTypes[column] & $98a24d29667ae67f$export$7ce43d0a8f00d826.discrete) > 0;
    }
    isColumnNumeric(column) {
        return (this._columnTypes[column] & $98a24d29667ae67f$export$7ce43d0a8f00d826.numeric) > 0;
    }
    isColumnContinuous(column) {
        return (this._columnTypes[column] & $98a24d29667ae67f$export$7ce43d0a8f00d826.continuous) > 0;
    }
    constructor(core, headings, data, columnTypes){
        this._core = core;
        this._headings = headings;
        this._data = data;
        this._columnTypes = columnTypes;
        this._numericValues = Array(columnTypes.length).fill(null);
        const indices = new Uint32Array(data.length);
        for(let i = 0; i < indices.length; i++)indices[i] = i;
        this._all = new (0, $b4dbeddbb8ed9d60$export$ec91da630f36d5ea)(core, indices, data, headings, columnTypes, this._numericValues);
        this._isInitialized = true;
    }
    createFilter(ids) {
        return new (0, $b4dbeddbb8ed9d60$export$ec91da630f36d5ea)(this._core, ids, this._data, this._headings, this._columnTypes, this._numericValues);
    }
}
const $98a24d29667ae67f$export$7ce43d0a8f00d826 = {
    none: 0,
    float: 1,
    integer: 2,
    string: 4,
    date: 8,
    continuous: 9,
    discrete: 6,
    numeric: 11
};


class $38a1943f255fbbec$export$9ac52b025685a4d0 {
    constructor(core){
        this._core = core;
    }
    compatibleTypes(data, firstRow = 0, maxRows = Number.MAX_VALUE) {
        const start = window.performance.now();
        const types = [];
        const integers = [];
        let values = data[firstRow];
        let parsedFloat, parsedDate;
        for(let i = 0; i < values.length; i++){
            const value = values[i];
            parsedFloat = Number(value);
            parsedDate = Date.parse(value);
            let integer = false;
            let type;
            if (!isNaN(parsedFloat)) {
                type = (0, $98a24d29667ae67f$export$7ce43d0a8f00d826).float;
                integer = Number.isSafeInteger(parsedFloat);
            } else if (!isNaN(parsedDate)) type = (0, $98a24d29667ae67f$export$7ce43d0a8f00d826).date;
            else type = (0, $98a24d29667ae67f$export$7ce43d0a8f00d826).string;
            types.push(type);
            integers.push(integer);
        }
        for(let i = firstRow + 1; i < Math.min(data.length, firstRow + maxRows); i++){
            values = data[i];
            for(let j = 0; j < values.length; j++)if (types[j] != (0, $98a24d29667ae67f$export$7ce43d0a8f00d826).string) {
                const value = values[j];
                parsedFloat = Number(value);
                if (types[j] == (0, $98a24d29667ae67f$export$7ce43d0a8f00d826).float) {
                    if (isNaN(parsedFloat)) {
                        types[j] = (0, $98a24d29667ae67f$export$7ce43d0a8f00d826).string;
                        integers[j] = false;
                    } else if (integers[j]) integers[j] = Number.isSafeInteger(parsedFloat);
                } else if (types[j] == (0, $98a24d29667ae67f$export$7ce43d0a8f00d826).date) {
                    parsedDate = Date.parse(value);
                    if (isNaN(parsedDate)) types[j] = (0, $98a24d29667ae67f$export$7ce43d0a8f00d826).string;
                }
            }
        }
        const compatibleTypes = [];
        for(let i = 0; i < types.length; i++){
            let compatible = types[i] | (0, $98a24d29667ae67f$export$7ce43d0a8f00d826).string;
            if (integers[i]) compatible |= (0, $98a24d29667ae67f$export$7ce43d0a8f00d826).integer;
            compatibleTypes.push(compatible);
        }
        this._core.log.write((0, $4a6417d29706362f$export$243e62d78d3b544d).info, `compatible types ${Math.round(window.performance.now() - start)}ms`);
        return compatibleTypes;
    }
    inferTypes(data, firstRow = 0, maxRows = Number.MAX_VALUE) {
        const columnTypes = [];
        const compatibleTypes = this.compatibleTypes(data, firstRow, maxRows);
        for(let i = 0; i < compatibleTypes.length; i++){
            let columnType;
            const compatibleType = compatibleTypes[i];
            if (compatibleType & (0, $98a24d29667ae67f$export$7ce43d0a8f00d826).integer) columnType = (0, $98a24d29667ae67f$export$7ce43d0a8f00d826).integer;
            else if (compatibleType & (0, $98a24d29667ae67f$export$7ce43d0a8f00d826).float) columnType = (0, $98a24d29667ae67f$export$7ce43d0a8f00d826).float;
            else if (compatibleType & (0, $98a24d29667ae67f$export$7ce43d0a8f00d826).date) columnType = (0, $98a24d29667ae67f$export$7ce43d0a8f00d826).date;
            else columnType = (0, $98a24d29667ae67f$export$7ce43d0a8f00d826).string;
            columnTypes.push(columnType);
        }
        return columnTypes;
    }
    convertToObject(table) {
        const headings = table.headings;
        const jsonObject = [];
        for(let i = 0; i < table.all.ids.length; i++){
            const row = {};
            for(let j = 0; j < headings.length; j++){
                const column = headings[j];
                const value = table.all.columnValues(j)[i];
                switch(table.getColumnType(j)){
                    case (0, $98a24d29667ae67f$export$7ce43d0a8f00d826).integer:
                    case (0, $98a24d29667ae67f$export$7ce43d0a8f00d826).float:
                        row[column] = value;
                        break;
                    case (0, $98a24d29667ae67f$export$7ce43d0a8f00d826).string:
                    case (0, $98a24d29667ae67f$export$7ce43d0a8f00d826).date:
                    default:
                        row[column] = table.data[i][j];
                        break;
                }
                jsonObject.push(row);
            }
        }
        return jsonObject;
    }
}



/*!
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 */ 
class $a25f5529f6cda489$export$c41e4fcbf45db179 {
    static create(gl, width, height, format, type, filter, bytes, internalFormat = format) {
        const texture = gl.createTexture();
        gl.bindTexture(gl.TEXTURE_2D, texture);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, filter);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, filter);
        gl.texImage2D(gl.TEXTURE_2D, 0, internalFormat, width, height, 0, format, type, bytes);
        return texture;
    }
    static fromImage(gl, image, mipmaps, filter) {
        const texture = gl.createTexture();
        gl.bindTexture(gl.TEXTURE_2D, texture);
        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, image);
        if (mipmaps && (0, $2d4d1eb6f32f02f2$export$80a8c44b8858d625).isPowerOf2(image.width) && (0, $2d4d1eb6f32f02f2$export$80a8c44b8858d625).isPowerOf2(image.height)) gl.generateMipmap(gl.TEXTURE_2D);
        else {
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, filter);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, filter);
        }
        gl.bindTexture(gl.TEXTURE_2D, null);
        return texture;
    }
    static cubemapFromImages(gl, images) {
        const texture = gl.createTexture();
        gl.bindTexture(gl.TEXTURE_CUBE_MAP, texture);
        const targets = [
            gl.TEXTURE_CUBE_MAP_POSITIVE_X,
            gl.TEXTURE_CUBE_MAP_NEGATIVE_X,
            gl.TEXTURE_CUBE_MAP_POSITIVE_Y,
            gl.TEXTURE_CUBE_MAP_NEGATIVE_Y,
            gl.TEXTURE_CUBE_MAP_POSITIVE_Z,
            gl.TEXTURE_CUBE_MAP_NEGATIVE_Z
        ];
        for(let i = 0; i < 6; i++){
            gl.texImage2D(targets[i], 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, images[i]);
            gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
            gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
        }
        gl.generateMipmap(gl.TEXTURE_CUBE_MAP);
        gl.bindTexture(gl.TEXTURE_CUBE_MAP, null);
        return texture;
    }
}


/*!
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 */ class $f90460e72834bcbf$export$7b64922b0b192bef {
    static parentChildren(ids, parentIds, childIds) {
        const rootIds = [];
        const degrees = new Uint32Array(ids.length);
        const indices = {};
        const children = {};
        for(let i = 0; i < ids.length; i++){
            const index = ids[i];
            const parentId = parentIds[index];
            const childId = childIds[index];
            indices[childId] = index;
            if (children[parentId] === undefined) {
                children[parentId] = [];
                degrees[index] = 1;
            }
            if (parentId < 0 || parentId == childId) rootIds.push(parentId);
            else {
                children[parentId].push(childId);
                degrees[index]++;
            }
        }
        return {
            rootIds: rootIds,
            indices: indices,
            children: children,
            degrees: degrees
        };
    }
    static tree(rootId, indices, children, positions, widths, descendents) {
        let nextId = 0;
        const idsArray = [];
        let maxDescendents = 0;
        const buildTree = (parentId)=>{
            const index = indices[parentId];
            idsArray.push(index);
            const childIds = children[parentId];
            if (childIds !== undefined) {
                const start = nextId;
                let total = 0;
                for(let i = 0; i < childIds.length; i++){
                    buildTree(childIds[i]);
                    total += descendents[indices[childIds[i]]] + 1;
                }
                const end = nextId - 1;
                positions[index] = (start + end) / 2;
                descendents[index] = total;
                maxDescendents = Math.max(maxDescendents, total);
                widths[index] = end - start + 1;
            } else {
                widths[index] = 1;
                positions[index] = nextId++;
            }
        };
        buildTree(rootId);
        const maxPosition = nextId - 1;
        return {
            ids: new Uint32Array(idsArray),
            maxDescendents: maxDescendents,
            maxPosition: maxPosition
        };
    }
}


/*!
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 */ class $33e5ac524dde1fe2$export$a30f602ccece8e25 {
    static new(a, b) {
        a.clear();
        for (let item of b)a.add(item);
    }
    static union(a, b) {
        for (let item of b)a.add(item);
    }
    static intersection(a, b) {
        const c = new Set(b);
        for (let item of a)if (!c.has(item)) a.delete(item);
        for (let item of b)if (!a.has(item)) a.delete(item);
    }
    static symmetricDifference(a, b) {
        for (let item of b)if (a.has(item)) a.delete(item);
        else a.add(item);
    }
    static difference(a, b) {
        for (let item of b)a.delete(item);
    }
}


/*!
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 */ class $22ccc45c3c88d82f$export$98599ead9515fc06 {
    static _circle(px, py, r) {
        return Math.sqrt(px * px + py * py) - r;
    }
    static _box(px, py, bx, by) {
        const dx0 = Math.abs(px) - bx;
        const dy0 = Math.abs(py) - by;
        const dx1 = Math.max(dx0, 0);
        const dy1 = Math.max(dy0, 0);
        return Math.sqrt(dx1 * dx1 + dy1 * dy1) + Math.min(Math.max(dx0, dy0), 0);
    }
    static _create(width, height, edge, sdf) {
        const pixels = new Uint8ClampedArray(width * height * 4);
        for(let y = 0; y < height; y++)for(let x = 0; x < width; x++){
            const d = edge - sdf(x - width / 2, y - height / 2);
            const offset = (x + y * height) * 4;
            pixels[offset] = d;
            pixels[offset + 1] = d;
            pixels[offset + 2] = d;
            pixels[offset + 3] = 0xff;
        }
        return new ImageData(pixels, width, height);
    }
    static circle(imageWidth, imageHeight, radius, edgeValue) {
        const sdf = (x, y)=>this._circle(x, y, radius);
        return this._create(imageWidth, imageHeight, edgeValue, sdf);
    }
    static box(imageWidth, imageHeight, boxWidth, boxHeight, edgeValue, rounding = 0) {
        const sdf = (x, y)=>this._box(x, y, boxWidth - rounding, boxHeight - rounding) - rounding;
        return this._create(imageWidth, imageHeight, edgeValue, sdf);
    }
}


/*!
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 */ 

class $8c233993336ed54a$export$1c9ca61bb2a30bed {
    static orthonormalBasis(n, b1, b2) {
        if (n[0] > 0.9) (0, $31054a6c69637582$exports).copy(b1, (0, $d4d7bd6cc65a5081$export$a002182e51710d39).VECTOR3_UNITY);
        else (0, $31054a6c69637582$exports).copy(b1, (0, $d4d7bd6cc65a5081$export$a002182e51710d39).VECTOR3_UNITX);
        (0, $31054a6c69637582$exports).scaleAndAdd(b1, b1, n, -(0, $31054a6c69637582$exports).dot(b1, n));
        (0, $31054a6c69637582$exports).normalize(b1, b1);
        (0, $31054a6c69637582$exports).cross(b2, n, b1);
    }
}




var $f35934b4176df23d$exports = {};

$parcel$export($f35934b4176df23d$exports, "Bar", () => $04ac1aab8410c289$export$bbc6c6369b38e3d1);
$parcel$export($f35934b4176df23d$exports, "Cube", () => $e6a9bd14c029e5f0$export$a15f0a83a652dd40);
$parcel$export($f35934b4176df23d$exports, "Line", () => $ba0727adc7665af3$export$17d680238e50603e);
$parcel$export($f35934b4176df23d$exports, "Tree", () => $82ef55b00856d713$export$7fbedc92909ed28e);
$parcel$export($f35934b4176df23d$exports, "PythagorasTree", () => $82ef55b00856d713$export$b74c7d46bc92515c);
$parcel$export($f35934b4176df23d$exports, "Scatter", () => $5c05d7e02492b136$export$1c460fb4285edadc);
$parcel$export($f35934b4176df23d$exports, "Sheet", () => $8be06baf1546635b$export$a9bf29f8d87ebbee);
$parcel$export($f35934b4176df23d$exports, "SquarifiedTreeMap", () => $05bc96b85bb3a34e$export$ce1cde616fb0ca7e);
$parcel$export($f35934b4176df23d$exports, "CubifiedTreeMap", () => $05bc96b85bb3a34e$export$3ca73d0a8bf0e96e);
$parcel$export($f35934b4176df23d$exports, "Stack", () => $385fd844fe700a1a$export$694e0d28c7ffc90c);
$parcel$export($f35934b4176df23d$exports, "StackTreeMap", () => $385fd844fe700a1a$export$75310880a535fd3b);
/*!
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 */ /*!
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 */ 





class $04ac1aab8410c289$export$bbc6c6369b38e3d1 extends (0, $9f62a2679ad52b29$export$f4f11265faddf354) {
    layout(buffer, ids, options) {
        const start = window.performance.now();
        const offset = options.offset === undefined ? 0 : options.offset;
        const count = options.count === undefined ? ids.length : options.count;
        const positionScalingX = options.positionScalingX === undefined ? 1 : options.positionScalingX;
        const positionScalingZ = options.positionScalingZ === undefined ? 1 : options.positionScalingZ;
        const heightScaling = options.heightScaling === undefined ? 1 : options.heightScaling;
        const minHeight = options.minHeight === undefined ? 0 : options.minHeight;
        const paddingX = options.paddingX == undefined ? 0 : options.paddingX * positionScalingX;
        const paddingZ = options.paddingZ == undefined ? 0 : options.paddingZ * positionScalingZ;
        if (!this._positions || this._positions.length < buffer.length * 3) {
            this._positions = new Float32Array(buffer.length * 3);
            this._sizes = new Float32Array(buffer.length * 3);
        }
        this.minLayoutBoundsX = Number.MAX_VALUE;
        this.minLayoutBoundsY = Number.MAX_VALUE;
        this.minLayoutBoundsZ = Number.MAX_VALUE;
        this.maxLayoutBoundsX = -Number.MAX_VALUE;
        this.maxLayoutBoundsY = -Number.MAX_VALUE;
        this.maxLayoutBoundsZ = -Number.MAX_VALUE;
        let positionX, positionY, positionZ;
        let sizeX, sizeY, sizeZ;
        const lookup = buffer.lookup;
        for(let i = 0; i < count; i++){
            const id = ids[i + offset];
            const index = lookup[id];
            const height = Math.max(options.heights ? options.heights[id] * heightScaling : heightScaling, minHeight);
            positionX = options.positionsX ? options.positionsX[id] * positionScalingX : 0;
            positionY = height / 2;
            positionZ = options.positionsZ ? options.positionsZ[id] * positionScalingZ : 0;
            this._positions[index * 3] = positionX;
            this._positions[index * 3 + 1] = positionY;
            this._positions[index * 3 + 2] = positionZ;
            sizeX = (options.sizeX === undefined ? options.sizesX ? options.sizesX[id] : 1 : options.sizeX) * positionScalingX;
            sizeY = Math.abs(height);
            sizeZ = (options.sizeZ === undefined ? options.sizesZ ? options.sizesZ[id] : 1 : options.sizeZ) * positionScalingZ;
            this.minLayoutBoundsX = Math.min(this.minLayoutBoundsX, positionX - sizeX / 2);
            this.minLayoutBoundsY = Math.min(this.minLayoutBoundsY, positionY - sizeY / 2);
            this.minLayoutBoundsZ = Math.min(this.minLayoutBoundsZ, positionZ - sizeZ / 2);
            this.maxLayoutBoundsX = Math.max(this.maxLayoutBoundsX, positionX + sizeX / 2);
            this.maxLayoutBoundsY = Math.max(this.maxLayoutBoundsY, positionY + sizeY / 2);
            this.maxLayoutBoundsZ = Math.max(this.maxLayoutBoundsZ, positionZ + sizeZ / 2);
            this._sizes[index * 3] = Math.max(sizeX - paddingX, 0);
            this._sizes[index * 3 + 1] = sizeY;
            this._sizes[index * 3 + 2] = Math.max(sizeZ - paddingZ, 0);
        }
        this._updateCumulativeLayoutBounds();
        this._core.log.write((0, $4a6417d29706362f$export$243e62d78d3b544d).info, `${this.constructor.name.toLowerCase()} layout ${count} ${Math.round(window.performance.now() - start)}ms`);
    }
    update(buffer, ids, options) {
        const start = window.performance.now();
        const offset = options.offset === undefined ? 0 : options.offset;
        const count = options.count === undefined ? ids.length : options.count;
        const dataView = buffer.dataView;
        const _vec2 = (0, $91b0cc4981465964$exports).create();
        const _vec3 = (0, $31054a6c69637582$exports).create();
        const _quat = (0, $39ece26d1239bb77$exports).create();
        const minColor = options.minColor === undefined ? 0 : options.minColor;
        const maxColor = options.maxColor === undefined ? 1 : options.maxColor;
        const minOrder = options.minOrder === undefined ? 0 : options.minOrder;
        const maxOrder = options.maxOrder === undefined ? 1 : options.maxOrder;
        const orderReverse = options.orderReverse === undefined ? false : options.orderReverse;
        const minStaggerOrder = options.minStaggerOrder === undefined ? 0 : options.minStaggerOrder;
        const maxStaggerOrder = options.maxStaggerOrder === undefined ? 1 : options.maxStaggerOrder;
        const staggerOrderReverse = options.staggerOrderReverse === undefined ? false : options.staggerOrderReverse;
        const reverseX = options.reverseX === undefined ? false : options.reverseX;
        const reverseY = options.reverseY === undefined ? false : options.reverseY;
        const reverseZ = options.reverseZ === undefined ? false : options.reverseZ;
        this._updateModelBounds(options);
        (0, $39ece26d1239bb77$exports).rotationTo(_quat, this._core.config.identityRotation, (0, $d4d7bd6cc65a5081$export$a002182e51710d39).VECTOR3_UNITY);
        const lookup = buffer.lookup;
        const selection = options.selected && options.selected.size > 0;
        for(let i = 0; i < count; i++){
            const id = ids[i + offset];
            const index = lookup[id];
            let positionX = this._positions[index * 3];
            let positionY = this._positions[index * 3 + 1];
            let positionZ = this._positions[index * 3 + 2];
            if (this._isFacetted) {
                if (reverseX) positionX = this.minModelBoundsX + this.minModelBoundsX + this._facetSizeX * (1 + this._facetSpacingX) - positionX;
                if (reverseY) positionY = this.minModelBoundsY + this.minModelBoundsY + this._facetSizeY * (1 + this._facetSpacingY) - positionY;
                if (reverseZ) positionZ = this.minModelBoundsZ + this.minModelBoundsZ + this._facetSizeZ * (1 + this._facetSpacingZ) - positionZ;
                const facetX = options.facetCoordsX ? options.facetCoordsX[id] : 0;
                const facetY = options.facetCoordsY ? options.facetCoordsY[id] : 0;
                const facetZ = options.facetCoordsZ ? options.facetCoordsZ[id] : 0;
                positionX += facetX * this._facetSizeX * (1 + this._facetSpacingX);
                positionY += facetY * this._facetSizeY * (1 + this._facetSpacingY);
                positionZ += facetZ * this._facetSizeZ * (1 + this._facetSpacingZ);
            } else {
                if (reverseX) positionX = this.minModelBoundsX + this.maxModelBoundsX - positionX;
                if (reverseY) positionY = this.minModelBoundsY + this.maxModelBoundsY - positionY;
                if (reverseZ) positionZ = this.minModelBoundsZ + this.maxModelBoundsZ - positionZ;
            }
            _vec3[0] = (positionX - this.modelOriginX) * this._boundsScaling;
            _vec3[1] = (positionY - this.modelOriginY) * this._boundsScaling;
            _vec3[2] = (positionZ - this.modelOriginZ) * this._boundsScaling;
            (0, $0a0587bd8b0d58e8$export$849e31d725692576).setTranslation(dataView, index, _vec3);
            _vec3[0] = this._sizes[index * 3] * this._boundsScaling;
            _vec3[1] = this._sizes[index * 3 + 1] * this._boundsScaling;
            _vec3[2] = this._sizes[index * 3 + 2] * this._boundsScaling;
            (0, $0a0587bd8b0d58e8$export$849e31d725692576).setScale(dataView, index, _vec3);
            (0, $0a0587bd8b0d58e8$export$849e31d725692576).setRotation(dataView, index, _quat);
            if (options.colors) {
                const size = 1 / (maxColor - minColor + 1);
                const color = (0, $2d4d1eb6f32f02f2$export$80a8c44b8858d625).normalize(options.colors[id], minColor, maxColor, size / 2, 1 - size / 2);
                if (options.colors1) {
                    const color1 = (0, $2d4d1eb6f32f02f2$export$80a8c44b8858d625).normalize(options.colors1[id], minColor, maxColor, size / 2, 1 - size / 2);
                    (0, $91b0cc4981465964$exports).set(_vec2, color, color1);
                } else (0, $91b0cc4981465964$exports).set(_vec2, color, color);
                (0, $0a0587bd8b0d58e8$export$849e31d725692576).setColor(dataView, index, _vec2);
            } else (0, $0a0587bd8b0d58e8$export$849e31d725692576).setColor(dataView, index, (0, $d4d7bd6cc65a5081$export$a002182e51710d39).VECTOR2_ONE);
            (0, $0a0587bd8b0d58e8$export$849e31d725692576).setIdHover(dataView, index, options.hover ? options.hover[id] : id);
            (0, $0a0587bd8b0d58e8$export$849e31d725692576).setSelected(dataView, index, selection ? options.selected.has(id) ? 1 : -1 : 0);
            if (options.order !== undefined) {
                const order = (0, $2d4d1eb6f32f02f2$export$80a8c44b8858d625).normalize(options.order[id], minOrder, maxOrder, 0, 1);
                _vec2[0] = orderReverse ? 1 - order : order;
            } else _vec2[0] = count == 1 ? 0 : i / (count - 1);
            if (options.staggerOrder !== undefined) _vec2[1] = options.staggerOrder;
            else if (options.staggerOrders) {
                const stagger = (0, $2d4d1eb6f32f02f2$export$80a8c44b8858d625).normalize(options.staggerOrders[id], minStaggerOrder, maxStaggerOrder, 0, 1);
                _vec2[1] = staggerOrderReverse ? 1 - stagger : stagger;
            } else _vec2[1] = count == 1 ? 0 : i / (count - 1);
            (0, $0a0587bd8b0d58e8$export$849e31d725692576).setOrder(dataView, index, _vec2);
            (0, $0a0587bd8b0d58e8$export$849e31d725692576).setMaterial(dataView, index, options.material ? options.material : options.materials ? options.materials[id] : 0);
            (0, $0a0587bd8b0d58e8$export$849e31d725692576).setRounding(dataView, index, options.rounding ? options.rounding * this._boundsScaling : options.roundings ? options.roundings[id] * this._boundsScaling : 0);
            (0, $0a0587bd8b0d58e8$export$849e31d725692576).setSdfBuffer(dataView, index, options.sdfBuffer ? options.sdfBuffer : options.sdfBuffers ? options.sdfBuffers[id] : this._core.config.sdfBuffer);
            (0, $0a0587bd8b0d58e8$export$849e31d725692576).setSdfBorder(dataView, index, options.sdfBorder ? options.sdfBorder : options.sdfBorders ? options.sdfBorders[id] : this._core.config.sdfBorder);
        }
        buffer.update();
        this._core.log.write((0, $4a6417d29706362f$export$243e62d78d3b544d).info, `${this.constructor.name.toLowerCase()} update ${count} ${Math.round(window.performance.now() - start)}ms`);
    }
}


/*!
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 */ 





class $e6a9bd14c029e5f0$export$a15f0a83a652dd40 extends (0, $9f62a2679ad52b29$export$f4f11265faddf354) {
    getPositionX(index) {
        return this._positions[index * 3];
    }
    getPositionY(index) {
        return this._positions[index * 3 + 1];
    }
    getPositionZ(index) {
        return this._positions[index * 3 + 2];
    }
    layout(buffer, ids, options) {
        const start = window.performance.now();
        const offset = options.offset === undefined ? 0 : options.offset;
        const count = options.count === undefined ? ids.length : options.count;
        const side = options.side === undefined ? Math.ceil(Math.cbrt(count)) : options.side;
        if (!this._positions || this._positions.length < buffer.length * 3) this._positions = new Float32Array(buffer.length * 3);
        this.minLayoutBoundsX = 0;
        this.minLayoutBoundsY = 0;
        this.minLayoutBoundsZ = 0;
        this.maxLayoutBoundsX = 0;
        this.maxLayoutBoundsY = 0;
        this.maxLayoutBoundsZ = 0;
        const lookup = buffer.lookup;
        for(let i = 0; i < count; i++){
            const id = ids[i + offset];
            const index = lookup[id];
            const y = Math.floor(i / (side * side));
            const z = Math.floor((i - y * side * side) / side);
            const x = i - y * side * side - z * side;
            this._positions[index * 3] = x;
            this._positions[index * 3 + 1] = y;
            this._positions[index * 3 + 2] = z;
            this.maxLayoutBoundsX = Math.max(this.maxLayoutBoundsX, x);
            this.maxLayoutBoundsY = Math.max(this.maxLayoutBoundsY, y);
            this.maxLayoutBoundsZ = Math.max(this.maxLayoutBoundsZ, z);
        }
        this._updateCumulativeLayoutBounds();
        this._core.log.write((0, $4a6417d29706362f$export$243e62d78d3b544d).info, `${this.constructor.name.toLowerCase()} layout ${count} ${Math.round(window.performance.now() - start)}ms`);
    }
    update(buffer, ids, options) {
        const start = window.performance.now();
        const offset = options.offset === undefined ? 0 : options.offset;
        const count = options.count === undefined ? ids.length : options.count;
        const dataView = buffer.dataView;
        const _vec2 = (0, $91b0cc4981465964$exports).create();
        const _vec3 = (0, $31054a6c69637582$exports).create();
        const minColor = options.minColor === undefined ? 0 : options.minColor;
        const maxColor = options.maxColor === undefined ? 1 : options.maxColor;
        const minOrder = options.minOrder === undefined ? 0 : options.minOrder;
        const maxOrder = options.maxOrder === undefined ? 1 : options.maxOrder;
        const orderReverse = options.orderReverse === undefined ? false : options.orderReverse;
        const minStaggerOrder = options.minStaggerOrder === undefined ? 0 : options.minStaggerOrder;
        const maxStaggerOrder = options.maxStaggerOrder === undefined ? 1 : options.maxStaggerOrder;
        const staggerOrderReverse = options.staggerOrderReverse === undefined ? false : options.staggerOrderReverse;
        const padding = options.padding === undefined ? 0 : options.padding;
        const reverseX = options.reverseX === undefined ? false : options.reverseX;
        const reverseY = options.reverseY === undefined ? false : options.reverseY;
        const reverseZ = options.reverseZ === undefined ? false : options.reverseZ;
        this._updateModelBounds(options);
        const scale = (0, $31054a6c69637582$exports).fromValues((1 - padding) * this._boundsScaling, (1 - padding) * this._boundsScaling, (1 - padding) * this._boundsScaling);
        const lookup = buffer.lookup;
        const selection = options.selected && options.selected.size > 0;
        for(let i = 0; i < count; i++){
            const id = ids[i + offset];
            const index = lookup[id];
            let positionX = this._positions[index * 3];
            let positionY = this._positions[index * 3 + 1];
            let positionZ = this._positions[index * 3 + 2];
            if (this._isFacetted) {
                if (reverseX) positionX = this.minModelBoundsX + this.minModelBoundsX + this._facetSizeX * (1 + this._facetSpacingX) - positionX;
                if (reverseY) positionY = this.minModelBoundsY + this.minModelBoundsY + this._facetSizeY * (1 + this._facetSpacingY) - positionY;
                if (reverseZ) positionZ = this.minModelBoundsZ + this.minModelBoundsZ + this._facetSizeZ * (1 + this._facetSpacingZ) - positionZ;
                const facetX = options.facetCoordsX ? options.facetCoordsX[id] : 0;
                const facetY = options.facetCoordsY ? options.facetCoordsY[id] : 0;
                const facetZ = options.facetCoordsZ ? options.facetCoordsZ[id] : 0;
                positionX += facetX * this._facetSizeX * (1 + this._facetSpacingX);
                positionY += facetY * this._facetSizeY * (1 + this._facetSpacingY);
                positionZ += facetZ * this._facetSizeZ * (1 + this._facetSpacingZ);
            } else {
                if (reverseX) positionX = this.minModelBoundsX + this.maxModelBoundsX - positionX;
                if (reverseY) positionY = this.minModelBoundsY + this.maxModelBoundsY - positionY;
                if (reverseZ) positionZ = this.minModelBoundsZ + this.maxModelBoundsZ - positionZ;
            }
            _vec3[0] = (positionX - this.modelOriginX) * this._boundsScaling;
            _vec3[1] = (positionY - this.modelOriginY) * this._boundsScaling;
            _vec3[2] = (positionZ - this.modelOriginZ) * this._boundsScaling;
            (0, $0a0587bd8b0d58e8$export$849e31d725692576).setTranslation(dataView, index, _vec3);
            (0, $0a0587bd8b0d58e8$export$849e31d725692576).setScale(dataView, index, scale);
            (0, $0a0587bd8b0d58e8$export$849e31d725692576).setRotation(dataView, index, (0, $d4d7bd6cc65a5081$export$a002182e51710d39).QUAT_IDENTITY);
            if (options.colors) {
                const size = 1 / (maxColor - minColor + 1);
                const color = (0, $2d4d1eb6f32f02f2$export$80a8c44b8858d625).normalize(options.colors[id], minColor, maxColor, size / 2, 1 - size / 2);
                _vec2[0] = color;
                _vec2[1] = color;
                (0, $0a0587bd8b0d58e8$export$849e31d725692576).setColor(dataView, index, _vec2);
            } else (0, $0a0587bd8b0d58e8$export$849e31d725692576).setColor(dataView, index, (0, $d4d7bd6cc65a5081$export$a002182e51710d39).VECTOR2_ONE);
            (0, $0a0587bd8b0d58e8$export$849e31d725692576).setIdHover(dataView, index, options.hover ? options.hover[id] : id);
            (0, $0a0587bd8b0d58e8$export$849e31d725692576).setSelected(dataView, index, selection ? options.selected.has(id) ? 1 : -1 : 0);
            if (options.order !== undefined) {
                const order = (0, $2d4d1eb6f32f02f2$export$80a8c44b8858d625).normalize(options.order[id], minOrder, maxOrder, 0, 1);
                _vec2[0] = orderReverse ? 1 - order : order;
            } else _vec2[0] = count == 1 ? 0 : i / (count - 1);
            if (options.staggerOrder !== undefined) _vec2[1] = options.staggerOrder;
            else if (options.staggerOrders) {
                const stagger = (0, $2d4d1eb6f32f02f2$export$80a8c44b8858d625).normalize(options.staggerOrders[id], minStaggerOrder, maxStaggerOrder, 0, 1);
                _vec2[1] = staggerOrderReverse ? 1 - stagger : stagger;
            } else _vec2[1] = count == 1 ? 0 : i / (count - 1);
            (0, $0a0587bd8b0d58e8$export$849e31d725692576).setOrder(dataView, index, _vec2);
            (0, $0a0587bd8b0d58e8$export$849e31d725692576).setMaterial(dataView, index, options.material ? options.material : options.materials ? options.materials[id] : 0);
            (0, $0a0587bd8b0d58e8$export$849e31d725692576).setRounding(dataView, index, options.rounding ? options.rounding * this._boundsScaling : options.roundings ? options.roundings[id] * this._boundsScaling : 0);
            (0, $0a0587bd8b0d58e8$export$849e31d725692576).setSdfBuffer(dataView, index, options.sdfBuffer ? options.sdfBuffer : options.sdfBuffers ? options.sdfBuffers[id] : this._core.config.sdfBuffer);
            (0, $0a0587bd8b0d58e8$export$849e31d725692576).setSdfBorder(dataView, index, options.sdfBorder ? options.sdfBorder : options.sdfBorders ? options.sdfBorders[id] : this._core.config.sdfBorder);
        }
        buffer.update();
        this._core.log.write((0, $4a6417d29706362f$export$243e62d78d3b544d).info, `${this.constructor.name.toLowerCase()} update ${count} ${Math.round(window.performance.now() - start)} ms`);
    }
}


/*!
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 */ 





class $ba0727adc7665af3$export$17d680238e50603e extends (0, $9f62a2679ad52b29$export$f4f11265faddf354) {
    layout(buffer, ids, fromIds, toIds, options) {
        const start = window.performance.now();
        const offset = options.offset === undefined ? 0 : options.offset;
        const count = options.count === undefined ? ids.length : options.count;
        const positionScalingX = options.positionScalingX === undefined ? 1 : options.positionScalingX;
        const positionScalingY = options.positionScalingY === undefined ? 1 : options.positionScalingY;
        const positionScalingZ = options.positionScalingZ === undefined ? 1 : options.positionScalingZ;
        const sizeScalingX = options.sizeScaling === undefined ? options.sizeScalingX === undefined ? 1 : options.sizeScalingX : options.sizeScaling;
        const sizeScalingY = options.sizeScaling === undefined ? options.sizeScalingY === undefined ? 1 : options.sizeScalingY : options.sizeScaling;
        const sizeScalingZ = options.sizeScaling === undefined ? options.sizeScalingZ === undefined ? 1 : options.sizeScalingZ : options.sizeScaling;
        const minSize = options.minSize === undefined ? 0 : options.minSize;
        const offsetScaling = options.offsetScaling === undefined ? 1 : options.offsetScaling;
        if (!this._positions || this._positions.length < buffer.length * 3) {
            this._positions = new Float32Array(buffer.length * 3);
            this._sizes = new Float32Array(buffer.length * 3);
            this._rotations = new Float32Array(buffer.length * 4);
        }
        this.minLayoutBoundsX = Number.MAX_VALUE;
        this.minLayoutBoundsY = Number.MAX_VALUE;
        this.minLayoutBoundsZ = Number.MAX_VALUE;
        this.maxLayoutBoundsX = -Number.MAX_VALUE;
        this.maxLayoutBoundsY = -Number.MAX_VALUE;
        this.maxLayoutBoundsZ = -Number.MAX_VALUE;
        const _vec3 = (0, $31054a6c69637582$exports).create();
        const _quat = (0, $39ece26d1239bb77$exports).create();
        const direction = (0, $31054a6c69637582$exports).create();
        const lookup = buffer.lookup;
        for(let i = 0; i < count; i++){
            const id = ids[i + offset];
            const fromId = fromIds[id];
            const toId = toIds[id];
            const index = lookup[id];
            let toPositionX = options.positionsX ? options.positionsX[toId] * positionScalingX : 0;
            let toPositionY = options.positionsY ? options.positionsY[toId] * positionScalingY : 0;
            let toPositionZ = options.positionsZ ? options.positionsZ[toId] * positionScalingZ : 0;
            let fromPositionX = options.positionsX ? options.positionsX[fromId] * positionScalingX : 0;
            let fromPositionY = options.positionsY ? options.positionsY[fromId] * positionScalingY : 0;
            let fromPositionZ = options.positionsZ ? options.positionsZ[fromId] * positionScalingZ : 0;
            if (fromId == toId) {
                this._sizes[index * 3] = 0;
                this._sizes[index * 3 + 1] = 0;
                this._sizes[index * 3 + 2] = 0;
                this._rotations[index * 4] = 0;
                this._rotations[index * 4 + 1] = 0;
                this._rotations[index * 4 + 2] = 0;
                this._rotations[index * 4 + 3] = 1;
            } else {
                direction[0] = toPositionX - fromPositionX;
                direction[1] = toPositionY - fromPositionY;
                direction[2] = toPositionZ - fromPositionZ;
                let length = (0, $31054a6c69637582$exports).length(direction);
                (0, $31054a6c69637582$exports).scale(direction, direction, 1 / length);
                (0, $39ece26d1239bb77$exports).rotationTo(_quat, this._core.config.identityRotation, direction);
                this._rotations[index * 4] = _quat[0];
                this._rotations[index * 4 + 1] = _quat[1];
                this._rotations[index * 4 + 2] = _quat[2];
                this._rotations[index * 4 + 3] = _quat[3];
                if (options.offsets) {
                    const fromOffset = options.offsets[fromId] * offsetScaling / 2;
                    const toOffset = options.offsets[toId] * offsetScaling / 2;
                    toPositionX -= direction[0] * toOffset;
                    toPositionY -= direction[1] * toOffset;
                    toPositionZ -= direction[2] * toOffset;
                    fromPositionX += direction[0] * fromOffset;
                    fromPositionY += direction[1] * fromOffset;
                    fromPositionZ += direction[2] * fromOffset;
                    length = Math.max(length - toOffset - fromOffset, minSize);
                }
                this._sizes[index * 3 + 1] = Math.max(length * sizeScalingY, minSize);
                if (options.lineSizes) {
                    this._sizes[index * 3] = Math.max(options.lineSizes[id] * sizeScalingX, minSize);
                    this._sizes[index * 3 + 2] = Math.max(options.lineSizes[id] * sizeScalingZ, minSize);
                } else if (options.endSizes) {
                    this._sizes[index * 3] = Math.max(options.endSizes[fromId] * sizeScalingX, minSize);
                    this._sizes[index * 3 + 2] = Math.max(options.endSizes[toId] * sizeScalingZ, minSize);
                } else {
                    this._sizes[index * 3] = sizeScalingX;
                    this._sizes[index * 3 + 2] = sizeScalingZ;
                }
            }
            _vec3[0] = (fromPositionX + toPositionX) / 2;
            _vec3[1] = (fromPositionY + toPositionY) / 2;
            _vec3[2] = (fromPositionZ + toPositionZ) / 2;
            this._positions[index * 3] = _vec3[0];
            this._positions[index * 3 + 1] = _vec3[1];
            this._positions[index * 3 + 2] = _vec3[2];
            this.minLayoutBoundsX = Math.min(this.minLayoutBoundsX, fromPositionX);
            this.minLayoutBoundsY = Math.min(this.minLayoutBoundsY, fromPositionY);
            this.minLayoutBoundsZ = Math.min(this.minLayoutBoundsZ, fromPositionZ);
            this.minLayoutBoundsX = Math.min(this.minLayoutBoundsX, toPositionX);
            this.minLayoutBoundsY = Math.min(this.minLayoutBoundsY, toPositionY);
            this.minLayoutBoundsZ = Math.min(this.minLayoutBoundsZ, toPositionZ);
            this.maxLayoutBoundsX = Math.max(this.maxLayoutBoundsX, fromPositionX);
            this.maxLayoutBoundsY = Math.max(this.maxLayoutBoundsY, fromPositionY);
            this.maxLayoutBoundsZ = Math.max(this.maxLayoutBoundsZ, fromPositionZ);
            this.maxLayoutBoundsX = Math.max(this.maxLayoutBoundsX, toPositionX);
            this.maxLayoutBoundsY = Math.max(this.maxLayoutBoundsY, toPositionY);
            this.maxLayoutBoundsZ = Math.max(this.maxLayoutBoundsZ, toPositionZ);
        }
        this._updateCumulativeLayoutBounds();
        this._core.log.write((0, $4a6417d29706362f$export$243e62d78d3b544d).info, `${this.constructor.name.toLowerCase()} layout ${count} ${Math.round(window.performance.now() - start)}ms`);
    }
    update(buffer, ids, fromIds, toIds, options) {
        const start = window.performance.now();
        const offset = options.offset === undefined ? 0 : options.offset;
        const count = options.count === undefined ? ids.length : options.count;
        const dataView = buffer.dataView;
        const _vec2 = (0, $91b0cc4981465964$exports).create();
        const _vec3 = (0, $31054a6c69637582$exports).create();
        const _quat = (0, $39ece26d1239bb77$exports).create();
        const endMinColor = options.endMinColor === undefined ? 0 : options.endMinColor;
        const endMaxColor = options.endMaxColor === undefined ? 1 : options.endMaxColor;
        const lineMinColor = options.lineMinColor === undefined ? 0 : options.lineMinColor;
        const lineMaxColor = options.lineMaxColor === undefined ? 1 : options.lineMaxColor;
        const minOrder = options.minOrder === undefined ? 0 : options.minOrder;
        const maxOrder = options.maxOrder === undefined ? 1 : options.maxOrder;
        const orderReverse = options.orderReverse === undefined ? false : options.orderReverse;
        const minStaggerOrder = options.minStaggerOrder === undefined ? 0 : options.minStaggerOrder;
        const maxStaggerOrder = options.maxStaggerOrder === undefined ? 1 : options.maxStaggerOrder;
        const staggerOrderReverse = options.staggerOrderReverse === undefined ? false : options.staggerOrderReverse;
        const reverseX = options.reverseX === undefined ? false : options.reverseX;
        const reverseY = options.reverseY === undefined ? false : options.reverseY;
        const reverseZ = options.reverseZ === undefined ? false : options.reverseZ;
        this._updateModelBounds(options);
        const lookup = buffer.lookup;
        const selection = options.selected && options.selected.size > 0;
        for(let i = 0; i < count; i++){
            const id = ids[i + offset];
            const fromId = fromIds[id];
            const toId = toIds[id];
            const index = lookup[id];
            let positionX = this._positions[index * 3];
            let positionY = this._positions[index * 3 + 1];
            let positionZ = this._positions[index * 3 + 2];
            if (this._isFacetted) {
                if (reverseX) positionX = this.minModelBoundsX + this.minModelBoundsX + this._facetSizeX * (1 + this._facetSpacingX) - positionX;
                if (reverseY) positionY = this.minModelBoundsY + this.minModelBoundsY + this._facetSizeY * (1 + this._facetSpacingY) - positionY;
                if (reverseZ) positionZ = this.minModelBoundsZ + this.minModelBoundsZ + this._facetSizeZ * (1 + this._facetSpacingZ) - positionZ;
                const facetX = options.facetCoordsX ? options.facetCoordsX[id] : 0;
                const facetY = options.facetCoordsY ? options.facetCoordsY[id] : 0;
                const facetZ = options.facetCoordsZ ? options.facetCoordsZ[id] : 0;
                positionX += facetX * this._facetSizeX * (1 + this._facetSpacingX);
                positionY += facetY * this._facetSizeY * (1 + this._facetSpacingY);
                positionZ += facetZ * this._facetSizeZ * (1 + this._facetSpacingZ);
            } else {
                if (reverseX) positionX = this.minModelBoundsX + this.maxModelBoundsX - positionX;
                if (reverseY) positionY = this.minModelBoundsY + this.maxModelBoundsY - positionY;
                if (reverseZ) positionZ = this.minModelBoundsZ + this.maxModelBoundsZ - positionZ;
            }
            _vec3[0] = (positionX - this.modelOriginX) * this._boundsScaling;
            _vec3[1] = (positionY - this.modelOriginY) * this._boundsScaling;
            _vec3[2] = (positionZ - this.modelOriginZ) * this._boundsScaling;
            (0, $0a0587bd8b0d58e8$export$849e31d725692576).setTranslation(dataView, index, _vec3);
            _vec3[0] = this._sizes[index * 3] * this._boundsScaling;
            _vec3[1] = this._sizes[index * 3 + 1] * this._boundsScaling;
            _vec3[2] = this._sizes[index * 3 + 2] * this._boundsScaling;
            (0, $0a0587bd8b0d58e8$export$849e31d725692576).setScale(dataView, index, _vec3);
            _quat[0] = this._rotations[index * 4];
            _quat[1] = this._rotations[index * 4 + 1];
            _quat[2] = this._rotations[index * 4 + 2];
            _quat[3] = this._rotations[index * 4 + 3];
            if (reverseX) {
                _quat[1] = -_quat[1];
                _quat[2] = -_quat[2];
            }
            if (reverseY) {
                _quat[0] = -_quat[0];
                _quat[2] = -_quat[2];
            }
            if (reverseZ) {
                _quat[0] = -_quat[0];
                _quat[1] = -_quat[1];
            }
            (0, $0a0587bd8b0d58e8$export$849e31d725692576).setRotation(dataView, index, _quat);
            let size;
            if (options.endColors) {
                size = 1 / (endMaxColor - endMinColor + 1);
                const fromColor = (0, $2d4d1eb6f32f02f2$export$80a8c44b8858d625).normalize(options.endColors[fromId], endMinColor, endMaxColor, size / 2, 1 - size / 2);
                const toColor = (0, $2d4d1eb6f32f02f2$export$80a8c44b8858d625).normalize(options.endColors[toId], endMinColor, endMaxColor, size / 2, 1 - size / 2);
                (0, $91b0cc4981465964$exports).set(_vec2, fromColor, toColor);
                (0, $0a0587bd8b0d58e8$export$849e31d725692576).setColor(dataView, index, _vec2);
            } else if (options.lineColors) {
                size = 1 / (lineMaxColor - lineMinColor + 1);
                const color = (0, $2d4d1eb6f32f02f2$export$80a8c44b8858d625).normalize(options.lineColors[id], lineMinColor, lineMaxColor, size / 2, 1 - size / 2);
                (0, $91b0cc4981465964$exports).set(_vec2, color, color);
                (0, $0a0587bd8b0d58e8$export$849e31d725692576).setColor(dataView, index, _vec2);
            } else (0, $0a0587bd8b0d58e8$export$849e31d725692576).setColor(dataView, index, (0, $d4d7bd6cc65a5081$export$a002182e51710d39).VECTOR2_ONE);
            (0, $0a0587bd8b0d58e8$export$849e31d725692576).setIdHover(dataView, index, options.hover ? options.hover[id] : id);
            (0, $0a0587bd8b0d58e8$export$849e31d725692576).setSelected(dataView, index, selection ? options.selected.has(id) ? 1 : -1 : 0);
            if (options.order !== undefined) {
                const order = (0, $2d4d1eb6f32f02f2$export$80a8c44b8858d625).normalize(options.order[id], minOrder, maxOrder, 0, 1);
                _vec2[0] = orderReverse ? 1 - order : order;
            } else _vec2[0] = count == 1 ? 0 : i / (count - 1);
            if (options.staggerOrder !== undefined) _vec2[1] = options.staggerOrder;
            else if (options.staggerOrders) {
                const stagger = (0, $2d4d1eb6f32f02f2$export$80a8c44b8858d625).normalize(options.staggerOrders[id], minStaggerOrder, maxStaggerOrder, 0, 1);
                _vec2[1] = staggerOrderReverse ? 1 - stagger : stagger;
            } else _vec2[1] = count == 1 ? 0 : i / (count - 1);
            (0, $0a0587bd8b0d58e8$export$849e31d725692576).setOrder(dataView, index, _vec2);
            (0, $0a0587bd8b0d58e8$export$849e31d725692576).setMaterial(dataView, index, options.material ? options.material : options.materials ? options.materials[id] : 0);
            (0, $0a0587bd8b0d58e8$export$849e31d725692576).setRounding(dataView, index, options.rounding ? options.rounding * this._boundsScaling : options.roundings ? options.roundings[id] * this._boundsScaling : 0);
            (0, $0a0587bd8b0d58e8$export$849e31d725692576).setSdfBuffer(dataView, index, options.sdfBuffer ? options.sdfBuffer : options.sdfBuffers ? options.sdfBuffers[id] : this._core.config.sdfBuffer);
            (0, $0a0587bd8b0d58e8$export$849e31d725692576).setSdfBorder(dataView, index, options.sdfBorder ? options.sdfBorder : options.sdfBorders ? options.sdfBorders[id] : this._core.config.sdfBorder);
        }
        buffer.update();
        this._core.log.write((0, $4a6417d29706362f$export$243e62d78d3b544d).info, `${this.constructor.name.toLowerCase()} update ${count} ${Math.round(window.performance.now() - start)}ms`);
    }
}


/*!
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 */ 






class $82ef55b00856d713$export$b74c7d46bc92515c extends (0, $9f62a2679ad52b29$export$f4f11265faddf354) {
    get levels() {
        return this._levels;
    }
    get maxLevel() {
        return this._maxLevel;
    }
    get volumes() {
        return this._volumes;
    }
    constructor(core){
        super(core);
        this._vec3 = (0, $31054a6c69637582$exports).create();
        this._quat = (0, $39ece26d1239bb77$exports).create();
        this._parentRight = (0, $31054a6c69637582$exports).create();
        this._parentUp = (0, $31054a6c69637582$exports).create();
        this._parentForward = (0, $31054a6c69637582$exports).create();
        this._parentTranslation = (0, $31054a6c69637582$exports).create();
        this._parentScale = (0, $31054a6c69637582$exports).create();
        this._parentRotation = (0, $39ece26d1239bb77$exports).create();
        this._parentTwist = (0, $39ece26d1239bb77$exports).create();
        this._childRotation = (0, $39ece26d1239bb77$exports).create();
    }
    static calculateTotalVertices(level) {
        return (2 << level) - 1;
    }
    static calculateMaxLevel(vertices) {
        return Math.ceil(Math.log2(vertices + 1)) - 1;
    }
    layout(buffer, ids, options) {
        const start = window.performance.now();
        const scalingX = options.scalingX === undefined ? 1 : options.scalingX;
        const scalingY = options.scalingY === undefined ? 1 : options.scalingY;
        const scalingZ = options.scalingZ === undefined ? 1 : options.scalingZ;
        this._angle = options.angle === undefined ? (0, $a49c65c28e06311e$export$210d3b2db589eb5c).degreesToRadians(45) : options.angle;
        this._randomAngle = options.randomAngle === undefined ? 0 : options.randomAngle;
        this._twist = options.twist === undefined ? 0 : options.twist;
        this._randomTwist = options.randomTwist === undefined ? 0 : options.randomTwist;
        if (!this._positions || this._positions.length < buffer.length * 3) {
            this._positions = new Float64Array(buffer.length * 3);
            this._sizes = new Float64Array(buffer.length * 3);
            this._rotations = new Float64Array(buffer.length * 4);
            this._levels = new Uint32Array(buffer.length);
            this._volumes = new Float64Array(buffer.length);
        }
        this._maxLevel = $82ef55b00856d713$export$b74c7d46bc92515c.calculateMaxLevel(ids.length);
        const lookup = buffer.lookup;
        const id = ids[0];
        const index = lookup[id];
        this._levels[index] = 0;
        this._positions[index * 3] = 0;
        this._positions[index * 3 + 1] = 0;
        this._positions[index * 3 + 2] = 0;
        this.minLayoutBoundsX = 0;
        this.minLayoutBoundsY = 0;
        this.minLayoutBoundsZ = 0;
        this.maxLayoutBoundsX = 0;
        this.maxLayoutBoundsY = 0;
        this.maxLayoutBoundsZ = 0;
        this._rotations[index * 4] = 0;
        this._rotations[index * 4 + 1] = 0;
        this._rotations[index * 4 + 2] = 0;
        this._rotations[index * 4 + 3] = 1;
        this._sizes[index * 3] = scalingX;
        this._sizes[index * 3 + 1] = scalingY;
        this._sizes[index * 3 + 2] = scalingZ;
        this._volumes[index] = scalingX * scalingY * scalingZ;
        this._count = 1;
        const pseudoRandom = new (0, $2d4d1eb6f32f02f2$export$b8e288c3467acb0e)(0);
        this._branch(index, ids, lookup, pseudoRandom);
        this._updateCumulativeLayoutBounds();
        this._core.log.write((0, $4a6417d29706362f$export$243e62d78d3b544d).info, `${this.constructor.name.toLowerCase()} layout ${ids.length} vertices ${Math.round(window.performance.now() - start)}ms`);
    }
    update(buffer, ids, options) {
        const start = window.performance.now();
        const dataView = buffer.dataView;
        const _vec2 = (0, $91b0cc4981465964$exports).create();
        const _vec3 = (0, $31054a6c69637582$exports).create();
        const _quat = (0, $39ece26d1239bb77$exports).create();
        const minColor = options.minColor === undefined ? 0 : options.minColor;
        const maxColor = options.maxColor === undefined ? 1 : options.maxColor;
        const minOrder = options.minOrder === undefined ? 0 : options.minOrder;
        const maxOrder = options.maxOrder === undefined ? 1 : options.maxOrder;
        const orderReverse = options.orderReverse === undefined ? false : options.orderReverse;
        const minStaggerOrder = options.minStaggerOrder === undefined ? 0 : options.minStaggerOrder;
        const maxStaggerOrder = options.maxStaggerOrder === undefined ? 1 : options.maxStaggerOrder;
        const staggerOrderReverse = options.staggerOrderReverse === undefined ? false : options.staggerOrderReverse;
        const reverseX = options.reverseX === undefined ? false : options.reverseX;
        const reverseY = options.reverseY === undefined ? false : options.reverseY;
        const reverseZ = options.reverseZ === undefined ? false : options.reverseZ;
        this._updateModelBounds(options);
        const lookup = buffer.lookup;
        const selection = options.selected && options.selected.size > 0;
        for(let i = 0; i < ids.length; i++){
            const id = ids[i];
            const index = lookup[id];
            let positionX = this._positions[index * 3];
            let positionY = this._positions[index * 3 + 1];
            let positionZ = this._positions[index * 3 + 2];
            if (reverseX) positionX = this.modelOriginX + this.modelOriginX - positionX;
            if (reverseY) positionY = this.modelOriginY + this.modelOriginY - positionY;
            if (reverseZ) positionZ = this.modelOriginZ + this.modelOriginZ - positionZ;
            _vec3[0] = (positionX - this.modelOriginX) * this._boundsScaling;
            _vec3[1] = (positionY - this.modelOriginY) * this._boundsScaling;
            _vec3[2] = (positionZ - this.modelOriginZ) * this._boundsScaling;
            (0, $0a0587bd8b0d58e8$export$849e31d725692576).setTranslation(dataView, index, _vec3);
            _vec3[0] = this._sizes[index * 3] * this._boundsScaling;
            _vec3[1] = this._sizes[index * 3 + 1] * this._boundsScaling;
            _vec3[2] = this._sizes[index * 3 + 2] * this._boundsScaling;
            (0, $0a0587bd8b0d58e8$export$849e31d725692576).setScale(dataView, index, _vec3);
            _quat[0] = this._rotations[index * 4];
            _quat[1] = this._rotations[index * 4 + 1];
            _quat[2] = this._rotations[index * 4 + 2];
            _quat[3] = this._rotations[index * 4 + 3];
            if (reverseX) {
                _quat[1] = -_quat[1];
                _quat[2] = -_quat[2];
            }
            if (reverseY) {
                _quat[0] = -_quat[0];
                _quat[2] = -_quat[2];
            }
            if (reverseZ) {
                _quat[0] = -_quat[0];
                _quat[1] = -_quat[1];
            }
            (0, $0a0587bd8b0d58e8$export$849e31d725692576).setRotation(dataView, index, _quat);
            if (options.colors) {
                const size = 1 / (maxColor - minColor + 1);
                const color = (0, $2d4d1eb6f32f02f2$export$80a8c44b8858d625).normalize(options.colors[id], minColor, maxColor, size / 2, 1 - size / 2);
                (0, $91b0cc4981465964$exports).set(_vec2, color, color);
                (0, $0a0587bd8b0d58e8$export$849e31d725692576).setColor(dataView, index, _vec2);
            } else (0, $0a0587bd8b0d58e8$export$849e31d725692576).setColor(dataView, index, (0, $d4d7bd6cc65a5081$export$a002182e51710d39).VECTOR2_ONE);
            (0, $0a0587bd8b0d58e8$export$849e31d725692576).setIdHover(dataView, index, options.hover ? options.hover[id] : id);
            (0, $0a0587bd8b0d58e8$export$849e31d725692576).setSelected(dataView, index, selection ? options.selected.has(id) ? 1 : -1 : 0);
            if (options.order !== undefined) {
                const order = (0, $2d4d1eb6f32f02f2$export$80a8c44b8858d625).normalize(options.order[id], minOrder, maxOrder, 0, 1);
                _vec2[0] = orderReverse ? 1 - order : order;
            } else _vec2[0] = i / (ids.length - 1);
            if (options.staggerOrder !== undefined) _vec2[1] = options.staggerOrder;
            else if (options.staggerOrders) {
                const stagger = (0, $2d4d1eb6f32f02f2$export$80a8c44b8858d625).normalize(options.staggerOrders[id], minStaggerOrder, maxStaggerOrder, 0, 1);
                _vec2[1] = staggerOrderReverse ? 1 - stagger : stagger;
            } else _vec2[1] = i / (ids.length - 1);
            (0, $0a0587bd8b0d58e8$export$849e31d725692576).setOrder(dataView, index, _vec2);
            (0, $0a0587bd8b0d58e8$export$849e31d725692576).setMaterial(dataView, index, options.material ? options.material : options.materials ? options.materials[id] : 0);
            (0, $0a0587bd8b0d58e8$export$849e31d725692576).setRounding(dataView, index, options.rounding ? options.rounding * this._boundsScaling : options.roundings ? options.roundings[id] * this._boundsScaling : 0);
            (0, $0a0587bd8b0d58e8$export$849e31d725692576).setSdfBuffer(dataView, index, options.sdfBuffer ? options.sdfBuffer : options.sdfBuffers ? options.sdfBuffers[id] : this._core.config.sdfBuffer);
            (0, $0a0587bd8b0d58e8$export$849e31d725692576).setSdfBorder(dataView, index, options.sdfBorder ? options.sdfBorder : options.sdfBorders ? options.sdfBorders[id] : this._core.config.sdfBorder);
        }
        buffer.update();
        this._core.log.write((0, $4a6417d29706362f$export$243e62d78d3b544d).info, `${this.constructor.name.toLowerCase()} update ${ids.length} vertices ${Math.round(window.performance.now() - start)}ms`);
    }
    _branch(parentIndex, ids, lookup, pseudoRandom) {
        const parentLevel = this._levels[parentIndex];
        if (parentLevel < this._maxLevel && this._count < ids.length) {
            let angle = this._angle + (pseudoRandom.nextFloat() * 2 - 1) * this._randomAngle;
            let twist = this._twist + (pseudoRandom.nextFloat() * 2 - 1) * this._randomTwist;
            angle = (0, $2d4d1eb6f32f02f2$export$80a8c44b8858d625).clamp(angle, -(0, $d4d7bd6cc65a5081$export$a002182e51710d39).PI_OVER_TWO, (0, $d4d7bd6cc65a5081$export$a002182e51710d39).PI_OVER_TWO);
            twist = (0, $2d4d1eb6f32f02f2$export$80a8c44b8858d625).clamp(twist, -(0, $d4d7bd6cc65a5081$export$a002182e51710d39).PI_OVER_TWO, (0, $d4d7bd6cc65a5081$export$a002182e51710d39).PI_OVER_TWO);
            this._parentTranslation[0] = this._positions[parentIndex * 3];
            this._parentTranslation[1] = this._positions[parentIndex * 3 + 1];
            this._parentTranslation[2] = this._positions[parentIndex * 3 + 2];
            this._parentRotation[0] = this._rotations[parentIndex * 4];
            this._parentRotation[1] = this._rotations[parentIndex * 4 + 1];
            this._parentRotation[2] = this._rotations[parentIndex * 4 + 2];
            this._parentRotation[3] = this._rotations[parentIndex * 4 + 3];
            this._parentScale[0] = this._sizes[parentIndex * 3];
            this._parentScale[1] = this._sizes[parentIndex * 3 + 1];
            this._parentScale[2] = this._sizes[parentIndex * 3 + 2];
            (0, $31054a6c69637582$exports).transformQuat(this._parentUp, (0, $d4d7bd6cc65a5081$export$a002182e51710d39).VECTOR3_UNITY, this._parentRotation);
            (0, $39ece26d1239bb77$exports).setAxisAngle(this._quat, this._parentUp, twist);
            (0, $39ece26d1239bb77$exports).normalize(this._quat, this._quat);
            (0, $39ece26d1239bb77$exports).multiply(this._parentTwist, this._quat, this._parentRotation);
            (0, $31054a6c69637582$exports).transformQuat(this._parentRight, (0, $d4d7bd6cc65a5081$export$a002182e51710d39).VECTOR3_UNITX, this._parentTwist);
            (0, $31054a6c69637582$exports).transformQuat(this._parentForward, (0, $d4d7bd6cc65a5081$export$a002182e51710d39).VECTOR3_UNITZ, this._parentTwist);
            const childId1 = ids[this._count++];
            const childIndex1 = lookup[childId1];
            let cos = Math.cos(angle);
            this._sizes[childIndex1 * 3] = this._parentScale[0] * cos;
            this._sizes[childIndex1 * 3 + 1] = this._parentScale[1] * cos;
            this._sizes[childIndex1 * 3 + 2] = this._parentScale[2] * cos;
            (0, $39ece26d1239bb77$exports).setAxisAngle(this._quat, this._parentForward, angle);
            (0, $39ece26d1239bb77$exports).normalize(this._quat, this._quat);
            (0, $39ece26d1239bb77$exports).multiply(this._childRotation, this._quat, this._parentTwist);
            this._rotations[childIndex1 * 4] = this._childRotation[0];
            this._rotations[childIndex1 * 4 + 1] = this._childRotation[1];
            this._rotations[childIndex1 * 4 + 2] = this._childRotation[2];
            this._rotations[childIndex1 * 4 + 3] = this._childRotation[3];
            const halfparentScaleX = this._parentScale[0] * 0.5;
            const halfparentScaleY = this._parentScale[1] * 0.5;
            this._vec3[0] = this._parentUp[0] * halfparentScaleY * cos + this._parentRight[0] * halfparentScaleX * cos;
            this._vec3[1] = this._parentUp[1] * halfparentScaleY * cos + this._parentRight[1] * halfparentScaleX * cos;
            this._vec3[2] = this._parentUp[2] * halfparentScaleY * cos + this._parentRight[2] * halfparentScaleX * cos;
            (0, $31054a6c69637582$exports).transformQuat(this._vec3, this._vec3, this._quat);
            const childTranslationX = this._parentTranslation[0] + this._vec3[0] + this._parentUp[0] * halfparentScaleY - this._parentRight[0] * halfparentScaleX;
            const childTranslationY = this._parentTranslation[1] + this._vec3[1] + this._parentUp[1] * halfparentScaleY - this._parentRight[1] * halfparentScaleX;
            const childTranslationZ = this._parentTranslation[2] + this._vec3[2] + this._parentUp[2] * halfparentScaleY - this._parentRight[2] * halfparentScaleX;
            this._positions[childIndex1 * 3] = childTranslationX;
            this._positions[childIndex1 * 3 + 1] = childTranslationY;
            this._positions[childIndex1 * 3 + 2] = childTranslationZ;
            this._levels[childIndex1] = parentLevel + 1;
            this._volumes[childIndex1] = this._sizes[childIndex1 * 3] * this._sizes[childIndex1 * 3 + 1] * this._sizes[childIndex1 * 3 + 2];
            this.minLayoutBoundsX = Math.min(this.minLayoutBoundsX, childTranslationX);
            this.minLayoutBoundsY = Math.min(this.minLayoutBoundsY, childTranslationY);
            this.minLayoutBoundsZ = Math.min(this.minLayoutBoundsZ, childTranslationZ);
            this.maxLayoutBoundsX = Math.max(this.maxLayoutBoundsX, childTranslationX);
            this.maxLayoutBoundsY = Math.max(this.maxLayoutBoundsY, childTranslationY);
            this.maxLayoutBoundsZ = Math.max(this.maxLayoutBoundsZ, childTranslationZ);
            if (this._count < ids.length) {
                const childId2 = ids[this._count++];
                const childIndex2 = lookup[childId2];
                cos = Math.cos((0, $d4d7bd6cc65a5081$export$a002182e51710d39).PI_OVER_TWO - angle);
                this._sizes[childIndex2 * 3] = this._parentScale[0] * cos;
                this._sizes[childIndex2 * 3 + 1] = this._parentScale[1] * cos;
                this._sizes[childIndex2 * 3 + 2] = this._parentScale[2] * cos;
                (0, $39ece26d1239bb77$exports).setAxisAngle(this._quat, this._parentForward, angle - (0, $d4d7bd6cc65a5081$export$a002182e51710d39).PI_OVER_TWO);
                (0, $39ece26d1239bb77$exports).normalize(this._quat, this._quat);
                (0, $39ece26d1239bb77$exports).multiply(this._childRotation, this._quat, this._parentTwist);
                this._rotations[childIndex2 * 4] = this._childRotation[0];
                this._rotations[childIndex2 * 4 + 1] = this._childRotation[1];
                this._rotations[childIndex2 * 4 + 2] = this._childRotation[2];
                this._rotations[childIndex2 * 4 + 3] = this._childRotation[3];
                this._vec3[0] = this._parentUp[0] * halfparentScaleY * cos - this._parentRight[0] * halfparentScaleX * cos;
                this._vec3[1] = this._parentUp[1] * halfparentScaleY * cos - this._parentRight[1] * halfparentScaleX * cos;
                this._vec3[2] = this._parentUp[2] * halfparentScaleY * cos - this._parentRight[2] * halfparentScaleX * cos;
                (0, $31054a6c69637582$exports).transformQuat(this._vec3, this._vec3, this._quat);
                const childTranslationX = this._parentTranslation[0] + this._vec3[0] + this._parentUp[0] * halfparentScaleY + this._parentRight[0] * halfparentScaleX;
                const childTranslationY = this._parentTranslation[1] + this._vec3[1] + this._parentUp[1] * halfparentScaleY + this._parentRight[1] * halfparentScaleX;
                const childTranslationZ = this._parentTranslation[2] + this._vec3[2] + this._parentUp[2] * halfparentScaleY + this._parentRight[2] * halfparentScaleX;
                this._positions[childIndex2 * 3] = childTranslationX;
                this._positions[childIndex2 * 3 + 1] = childTranslationY;
                this._positions[childIndex2 * 3 + 2] = childTranslationZ;
                this._levels[childIndex2] = parentLevel + 1;
                this._volumes[childIndex2] = this._sizes[childIndex2 * 3] * this._sizes[childIndex2 * 3 + 1] * this._sizes[childIndex2 * 3 + 2];
                this.minLayoutBoundsX = Math.min(this.minLayoutBoundsX, childTranslationX);
                this.minLayoutBoundsY = Math.min(this.minLayoutBoundsY, childTranslationY);
                this.minLayoutBoundsZ = Math.min(this.minLayoutBoundsZ, childTranslationZ);
                this.maxLayoutBoundsX = Math.max(this.maxLayoutBoundsX, childTranslationX);
                this.maxLayoutBoundsY = Math.max(this.maxLayoutBoundsY, childTranslationY);
                this.maxLayoutBoundsZ = Math.max(this.maxLayoutBoundsZ, childTranslationZ);
                this._branch(childIndex1, ids, lookup, pseudoRandom);
                this._branch(childIndex2, ids, lookup, pseudoRandom);
            }
        }
    }
}
class $82ef55b00856d713$export$7fbedc92909ed28e extends (0, $9f62a2679ad52b29$export$f4f11265faddf354) {
    getPositionX(index) {
        return this._positions[index * 3];
    }
    getPositionY(index) {
        return this._positions[index * 3 + 1];
    }
    getPositionZ(index) {
        return this._positions[index * 3 + 2];
    }
    getSizeX(index) {
        return this._sizes[index * 3];
    }
    getSizeY(index) {
        return this._sizes[index * 3 + 1];
    }
    getSizeZ(index) {
        return this._sizes[index * 3 + 2];
    }
    constructor(core){
        super(core);
        this._vec3 = (0, $31054a6c69637582$exports).create();
        this._quat = (0, $39ece26d1239bb77$exports).create();
        this._childRotation = (0, $39ece26d1239bb77$exports).create();
        this._parentRight = (0, $31054a6c69637582$exports).create();
        this._parentUp = (0, $31054a6c69637582$exports).create();
        this._parentForward = (0, $31054a6c69637582$exports).create();
        this._parentRotation = (0, $39ece26d1239bb77$exports).create();
        this._parentTwist = (0, $39ece26d1239bb77$exports).create();
    }
    layout(buffer, ids, options) {
        const start = window.performance.now();
        const rootId = options.rootId;
        this._sizeX = options.sizeX === undefined ? 1 : options.sizeX;
        this._sizeY = options.sizeY === undefined ? 1 : options.sizeY;
        this._sizeZ = options.sizeZ === undefined ? 1 : options.sizeZ;
        this._angle = options.angle === undefined ? (0, $a49c65c28e06311e$export$210d3b2db589eb5c).degreesToRadians(45) : options.angle;
        this._randomAngle = options.randomAngle === undefined ? 0 : options.randomAngle;
        this._twist = options.twist === undefined ? 0 : options.twist;
        this._lengthScaling = options.lengthScaling === undefined ? 1 : options.lengthScaling;
        this._thicknessScaling = options.thicknessScaling === undefined ? 1 : options.thicknessScaling;
        this._randomTwist = options.randomTwist === undefined ? 0 : options.randomTwist;
        this._randomSplit = options.randomSplit === undefined ? 0 : options.randomSplit;
        this._randomLengthScaling = options.randomLengthScaling === undefined ? 0 : options.randomLengthScaling;
        this._randomThicknessScaling = options.randomThicknessScaling === undefined ? 0 : options.randomThicknessScaling;
        this._minLength = options.minLength === undefined ? 0 : options.minLength;
        this._minThickness = options.minThickness === undefined ? 0 : options.minThickness;
        this._lengthScalings = options.lengthScalings;
        this._thicknessScalings = options.thicknessScalings;
        this._splitAngles = options.splitAngles;
        this._angles = options.angles;
        if (!this._positions || this._positions.length < buffer.length * 3) {
            this._positions = new Float64Array(buffer.length * 3);
            this._sizes = new Float64Array(buffer.length * 3);
            this._rotations = new Float64Array(buffer.length * 4);
            this._parentRights = new Float64Array(buffer.length * 3);
            this._parentUps = new Float64Array(buffer.length * 3);
            this._parentForwards = new Float64Array(buffer.length * 3);
            this._parentTwists = new Float64Array(buffer.length * 4);
        }
        const lookup = buffer.lookup;
        const indices = {};
        const children = {};
        for(let i = 0; i < ids.length; i++){
            const id = ids[i];
            const index = lookup[id];
            const parentId = options.parentIds[index];
            const childId = options.childIds[index];
            indices[childId] = index;
            if (childId === rootId) children[rootId] = [];
            else {
                if (children[parentId] === undefined) children[parentId] = [];
                children[parentId].push(childId);
            }
        }
        const index = indices[rootId];
        this._positions[index * 3] = 0;
        this._positions[index * 3 + 1] = 0;
        this._positions[index * 3 + 2] = 0;
        this.minLayoutBoundsX = 0;
        this.minLayoutBoundsY = 0;
        this.minLayoutBoundsZ = 0;
        this.maxLayoutBoundsX = 0;
        this.maxLayoutBoundsY = 0;
        this.maxLayoutBoundsZ = 0;
        this._rotations[index * 4] = 0;
        this._rotations[index * 4 + 1] = 0;
        this._rotations[index * 4 + 2] = 0;
        this._rotations[index * 4 + 3] = 1;
        this._sizes[index * 3 + 1] = this._sizeY;
        this._sizes[index * 3] = this._sizeX;
        this._sizes[index * 3 + 2] = this._sizeZ;
        if (this._lengthScalings) {
            this._lengthScaling = this._lengthScalings[index];
            this._sizes[index * 3 + 1] *= this._lengthScaling;
        }
        if (this._thicknessScalings) {
            this._thicknessScaling = this._thicknessScalings[index];
            this._sizes[index * 3] *= this._thicknessScaling;
            this._sizes[index * 3 + 2] *= this._thicknessScaling;
        }
        const pseudoRandom = new (0, $2d4d1eb6f32f02f2$export$b8e288c3467acb0e)(0);
        this._branch(rootId, indices, children, pseudoRandom);
        this._updateCumulativeLayoutBounds();
        this._core.log.write((0, $4a6417d29706362f$export$243e62d78d3b544d).info, `${this.constructor.name.toLowerCase()} layout ${ids.length} vertices ${Math.round(window.performance.now() - start)}ms`);
    }
    update(buffer, ids, options) {
        const start = window.performance.now();
        const dataView = buffer.dataView;
        const _vec2 = (0, $91b0cc4981465964$exports).create();
        const _vec3 = (0, $31054a6c69637582$exports).create();
        const _quat = (0, $39ece26d1239bb77$exports).create();
        const minColor = options.minColor === undefined ? 0 : options.minColor;
        const maxColor = options.maxColor === undefined ? 1 : options.maxColor;
        const minOrder = options.minOrder === undefined ? 0 : options.minOrder;
        const maxOrder = options.maxOrder === undefined ? 1 : options.maxOrder;
        const orderReverse = options.orderReverse === undefined ? false : options.orderReverse;
        const minStaggerOrder = options.minStaggerOrder === undefined ? 0 : options.minStaggerOrder;
        const maxStaggerOrder = options.maxStaggerOrder === undefined ? 1 : options.maxStaggerOrder;
        const staggerOrderReverse = options.staggerOrderReverse === undefined ? false : options.staggerOrderReverse;
        const reverseX = options.reverseX === undefined ? false : options.reverseX;
        const reverseY = options.reverseY === undefined ? false : options.reverseY;
        const reverseZ = options.reverseZ === undefined ? false : options.reverseZ;
        this._updateModelBounds(options);
        const lookup = buffer.lookup;
        const selection = options.selected && options.selected.size > 0;
        for(let i = 0; i < ids.length; i++){
            const id = ids[i];
            const index = lookup[id];
            let positionX = this._positions[index * 3];
            let positionY = this._positions[index * 3 + 1];
            let positionZ = this._positions[index * 3 + 2];
            if (reverseX) positionX = this.modelOriginX + this.modelOriginX - positionX;
            if (reverseY) positionY = this.modelOriginY + this.modelOriginY - positionY;
            if (reverseZ) positionZ = this.modelOriginZ + this.modelOriginZ - positionZ;
            _vec3[0] = (positionX - this.modelOriginX) * this._boundsScaling;
            _vec3[1] = (positionY - this.modelOriginY) * this._boundsScaling;
            _vec3[2] = (positionZ - this.modelOriginZ) * this._boundsScaling;
            (0, $0a0587bd8b0d58e8$export$849e31d725692576).setTranslation(dataView, index, _vec3);
            _vec3[0] = this._sizes[index * 3] * this._boundsScaling;
            _vec3[1] = this._sizes[index * 3 + 1] * this._boundsScaling;
            _vec3[2] = this._sizes[index * 3 + 2] * this._boundsScaling;
            (0, $0a0587bd8b0d58e8$export$849e31d725692576).setScale(dataView, index, _vec3);
            _quat[0] = this._rotations[index * 4];
            _quat[1] = this._rotations[index * 4 + 1];
            _quat[2] = this._rotations[index * 4 + 2];
            _quat[3] = this._rotations[index * 4 + 3];
            if (reverseX) {
                _quat[1] = -_quat[1];
                _quat[2] = -_quat[2];
            }
            if (reverseY) {
                _quat[0] = -_quat[0];
                _quat[2] = -_quat[2];
            }
            if (reverseZ) {
                _quat[0] = -_quat[0];
                _quat[1] = -_quat[1];
            }
            (0, $0a0587bd8b0d58e8$export$849e31d725692576).setRotation(dataView, index, _quat);
            if (options.colors) {
                const size = 1 / (maxColor - minColor + 1);
                const color = (0, $2d4d1eb6f32f02f2$export$80a8c44b8858d625).normalize(options.colors[id], minColor, maxColor, size / 2, 1 - size / 2);
                (0, $91b0cc4981465964$exports).set(_vec2, color, color);
                (0, $0a0587bd8b0d58e8$export$849e31d725692576).setColor(dataView, index, _vec2);
            } else (0, $0a0587bd8b0d58e8$export$849e31d725692576).setColor(dataView, index, (0, $d4d7bd6cc65a5081$export$a002182e51710d39).VECTOR2_ONE);
            (0, $0a0587bd8b0d58e8$export$849e31d725692576).setIdHover(dataView, index, options.hover ? options.hover[id] : id);
            (0, $0a0587bd8b0d58e8$export$849e31d725692576).setSelected(dataView, index, selection ? options.selected.has(id) ? 1 : -1 : 0);
            if (options.order !== undefined) {
                const order = (0, $2d4d1eb6f32f02f2$export$80a8c44b8858d625).normalize(options.order[id], minOrder, maxOrder, 0, 1);
                _vec2[0] = orderReverse ? 1 - order : order;
            } else _vec2[0] = i / (ids.length - 1);
            if (options.staggerOrder !== undefined) _vec2[1] = options.staggerOrder;
            else if (options.staggerOrders) {
                const stagger = (0, $2d4d1eb6f32f02f2$export$80a8c44b8858d625).normalize(options.staggerOrders[id], minStaggerOrder, maxStaggerOrder, 0, 1);
                _vec2[1] = staggerOrderReverse ? 1 - stagger : stagger;
            } else _vec2[1] = i / (ids.length - 1);
            (0, $0a0587bd8b0d58e8$export$849e31d725692576).setOrder(dataView, index, _vec2);
            (0, $0a0587bd8b0d58e8$export$849e31d725692576).setMaterial(dataView, index, options.material ? options.material : options.materials ? options.materials[id] : 0);
            (0, $0a0587bd8b0d58e8$export$849e31d725692576).setRounding(dataView, index, options.rounding ? options.rounding * this._boundsScaling : options.roundings ? options.roundings[id] * this._boundsScaling : 0);
            (0, $0a0587bd8b0d58e8$export$849e31d725692576).setSdfBuffer(dataView, index, options.sdfBuffer ? options.sdfBuffer : options.sdfBuffers ? options.sdfBuffers[id] : this._core.config.sdfBuffer);
            (0, $0a0587bd8b0d58e8$export$849e31d725692576).setSdfBorder(dataView, index, options.sdfBorder ? options.sdfBorder : options.sdfBorders ? options.sdfBorders[id] : this._core.config.sdfBorder);
        }
        buffer.update();
        this._core.log.write((0, $4a6417d29706362f$export$243e62d78d3b544d).info, `${this.constructor.name.toLowerCase()} update ${ids.length} vertices ${Math.round(window.performance.now() - start)}ms`);
    }
    _branch(parentId, indices, children, pseudoRandom) {
        const childIds = children[parentId];
        const parentIndex = indices[parentId];
        this._parentRotation[0] = this._rotations[parentIndex * 4];
        this._parentRotation[1] = this._rotations[parentIndex * 4 + 1];
        this._parentRotation[2] = this._rotations[parentIndex * 4 + 2];
        this._parentRotation[3] = this._rotations[parentIndex * 4 + 3];
        (0, $31054a6c69637582$exports).transformQuat(this._parentUp, (0, $d4d7bd6cc65a5081$export$a002182e51710d39).VECTOR3_UNITY, this._parentRotation);
        this._parentUps[parentIndex * 3] = this._parentUp[0];
        this._parentUps[parentIndex * 3 + 1] = this._parentUp[1];
        this._parentUps[parentIndex * 3 + 2] = this._parentUp[2];
        let twist = this._twist + (pseudoRandom.nextFloat() * 2 - 1) * this._randomTwist;
        twist = (0, $2d4d1eb6f32f02f2$export$80a8c44b8858d625).clamp(twist, -(0, $d4d7bd6cc65a5081$export$a002182e51710d39).PI_OVER_TWO, (0, $d4d7bd6cc65a5081$export$a002182e51710d39).PI_OVER_TWO);
        (0, $39ece26d1239bb77$exports).setAxisAngle(this._quat, this._parentUp, twist);
        (0, $39ece26d1239bb77$exports).normalize(this._quat, this._quat);
        (0, $39ece26d1239bb77$exports).multiply(this._parentTwist, this._quat, this._parentRotation);
        this._parentTwists[parentIndex * 4] = this._parentTwist[0];
        this._parentTwists[parentIndex * 4 + 1] = this._parentTwist[1];
        this._parentTwists[parentIndex * 4 + 2] = this._parentTwist[2];
        this._parentTwists[parentIndex * 4 + 3] = this._parentTwist[3];
        (0, $31054a6c69637582$exports).transformQuat(this._parentRight, (0, $d4d7bd6cc65a5081$export$a002182e51710d39).VECTOR3_UNITX, this._parentTwist);
        this._parentRights[parentIndex * 3] = this._parentRight[0];
        this._parentRights[parentIndex * 3 + 1] = this._parentRight[1];
        this._parentRights[parentIndex * 3 + 2] = this._parentRight[2];
        (0, $31054a6c69637582$exports).transformQuat(this._parentForward, (0, $d4d7bd6cc65a5081$export$a002182e51710d39).VECTOR3_UNITZ, this._parentTwist);
        this._parentForwards[parentIndex * 3] = this._parentForward[0];
        this._parentForwards[parentIndex * 3 + 1] = this._parentForward[1];
        this._parentForwards[parentIndex * 3 + 2] = this._parentForward[2];
        for(let i = 0; i < childIds.length; i++){
            const childId = childIds[i];
            const childIndex = indices[childId];
            const parentScaleX = this._sizes[parentIndex * 3];
            const parentScaleY = this._sizes[parentIndex * 3 + 1];
            const parentScaleZ = this._sizes[parentIndex * 3 + 2];
            this._parentUp[0] = this._parentUps[parentIndex * 3];
            this._parentUp[1] = this._parentUps[parentIndex * 3 + 1];
            this._parentUp[2] = this._parentUps[parentIndex * 3 + 2];
            this._parentTwist[0] = this._parentTwists[parentIndex * 4];
            this._parentTwist[1] = this._parentTwists[parentIndex * 4 + 1];
            this._parentTwist[2] = this._parentTwists[parentIndex * 4 + 2];
            this._parentTwist[3] = this._parentTwists[parentIndex * 4 + 3];
            if (this._lengthScalings) {
                const lengthScale = this._lengthScalings[childIndex] + (pseudoRandom.nextFloat() * 2 - 1) * this._randomLengthScaling;
                this._sizes[childIndex * 3 + 1] = Math.max(this._sizeY * lengthScale, this._minLength);
            } else {
                const lengthScale = this._lengthScaling + (pseudoRandom.nextFloat() * 2 - 1) * this._randomLengthScaling;
                this._sizes[childIndex * 3 + 1] = Math.max(parentScaleY * lengthScale, this._minLength);
            }
            if (this._thicknessScalings) {
                const thicknessScale = this._thicknessScalings[childIndex] + (pseudoRandom.nextFloat() * 2 - 1) * this._randomThicknessScaling;
                this._sizes[childIndex * 3] = Math.max(this._sizeX * thicknessScale, this._minThickness);
                this._sizes[childIndex * 3 + 2] = Math.max(this._sizeZ * thicknessScale, this._minThickness);
            } else {
                const thicknessScale = this._thicknessScaling + (pseudoRandom.nextFloat() * 2 - 1) * this._randomThicknessScaling;
                this._sizes[childIndex * 3] = Math.max(parentScaleX * thicknessScale, this._minThickness);
                this._sizes[childIndex * 3 + 2] = Math.max(parentScaleZ * thicknessScale, this._minThickness);
            }
            let split;
            if (this._splitAngles) split = this._splitAngles[childIndex];
            else split = (0, $d4d7bd6cc65a5081$export$a002182e51710d39).TWO_PI * i / childIds.length;
            split += (pseudoRandom.nextFloat() * 2 - 1) * this._randomSplit;
            (0, $39ece26d1239bb77$exports).setAxisAngle(this._quat, this._parentUp, split);
            (0, $39ece26d1239bb77$exports).normalize(this._quat, this._quat);
            (0, $39ece26d1239bb77$exports).multiply(this._childRotation, this._quat, this._parentTwist);
            let angle;
            if (this._angles) angle = this._angles[childIndex];
            else angle = this._angle;
            angle += (pseudoRandom.nextFloat() * 2 - 1) * this._randomAngle;
            angle = (0, $2d4d1eb6f32f02f2$export$80a8c44b8858d625).clamp(angle, -(0, $d4d7bd6cc65a5081$export$a002182e51710d39).PI_OVER_TWO, (0, $d4d7bd6cc65a5081$export$a002182e51710d39).PI_OVER_TWO);
            (0, $39ece26d1239bb77$exports).setAxisAngle(this._quat, (0, $d4d7bd6cc65a5081$export$a002182e51710d39).VECTOR3_UNITX, angle);
            (0, $39ece26d1239bb77$exports).normalize(this._quat, this._quat);
            (0, $39ece26d1239bb77$exports).multiply(this._childRotation, this._childRotation, this._quat);
            this._rotations[childIndex * 4] = this._childRotation[0];
            this._rotations[childIndex * 4 + 1] = this._childRotation[1];
            this._rotations[childIndex * 4 + 2] = this._childRotation[2];
            this._rotations[childIndex * 4 + 3] = this._childRotation[3];
            const halfParentScaleY = parentScaleY * 0.5;
            const halfChildScaleY = this._sizes[childIndex * 3 + 1] * 0.5;
            (0, $31054a6c69637582$exports).transformQuat(this._vec3, (0, $d4d7bd6cc65a5081$export$a002182e51710d39).VECTOR3_UNITY, this._childRotation);
            const childTranslationX = this._positions[parentIndex * 3] + this._parentUp[0] * halfParentScaleY + this._vec3[0] * halfChildScaleY;
            const childTranslationY = this._positions[parentIndex * 3 + 1] + this._parentUp[1] * halfParentScaleY + this._vec3[1] * halfChildScaleY;
            const childTranslationZ = this._positions[parentIndex * 3 + 2] + this._parentUp[2] * halfParentScaleY + this._vec3[2] * halfChildScaleY;
            this._positions[childIndex * 3] = childTranslationX;
            this._positions[childIndex * 3 + 1] = childTranslationY;
            this._positions[childIndex * 3 + 2] = childTranslationZ;
            this.minLayoutBoundsX = Math.min(this.minLayoutBoundsX, childTranslationX);
            this.minLayoutBoundsY = Math.min(this.minLayoutBoundsY, childTranslationY);
            this.minLayoutBoundsZ = Math.min(this.minLayoutBoundsZ, childTranslationZ);
            this.maxLayoutBoundsX = Math.max(this.maxLayoutBoundsX, childTranslationX);
            this.maxLayoutBoundsY = Math.max(this.maxLayoutBoundsY, childTranslationY);
            this.maxLayoutBoundsZ = Math.max(this.maxLayoutBoundsZ, childTranslationZ);
            if (children[childId]) this._branch(childId, indices, children, pseudoRandom);
        }
    }
}



/*!
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 */ 





class $8be06baf1546635b$export$a9bf29f8d87ebbee extends (0, $9f62a2679ad52b29$export$f4f11265faddf354) {
    getPositionX(index) {
        return this._positions[index * 3];
    }
    getPositionY(index) {
        return this._positions[index * 3 + 1];
    }
    getPositionZ(index) {
        return this._positions[index * 3 + 2];
    }
    layout(buffer, ids, options) {
        const start = window.performance.now();
        const offset = options.offset === undefined ? 0 : options.offset;
        const count = options.count === undefined ? ids.length : options.count;
        const side = options.side === undefined ? Math.ceil(Math.sqrt(count)) : options.side;
        if (!this._positions || this._positions.length < buffer.length * 3) this._positions = new Float32Array(buffer.length * 3);
        this.minLayoutBoundsX = 0;
        this.minLayoutBoundsY = 0;
        this.minLayoutBoundsZ = 0;
        this.maxLayoutBoundsX = 0;
        this.maxLayoutBoundsY = 0;
        this.maxLayoutBoundsZ = 0;
        const lookup = buffer.lookup;
        for(let i = 0; i < count; i++){
            const id = ids[i + offset];
            const index = lookup[id];
            const y = Math.floor(i / side);
            const x = i - y * side;
            this._positions[index * 3] = x;
            this._positions[index * 3 + 1] = y;
            this._positions[index * 3 + 2] = 0;
            this.maxLayoutBoundsX = Math.max(this.maxLayoutBoundsX, x);
            this.maxLayoutBoundsY = Math.max(this.maxLayoutBoundsY, y);
        }
        this._updateCumulativeLayoutBounds();
        this._core.log.write((0, $4a6417d29706362f$export$243e62d78d3b544d).info, `${this.constructor.name.toLowerCase()} layout ${count} ${Math.round(window.performance.now() - start)}ms`);
    }
    update(buffer, ids, options) {
        const start = window.performance.now();
        const offset = options.offset === undefined ? 0 : options.offset;
        const count = options.count === undefined ? ids.length : options.count;
        const dataView = buffer.dataView;
        const _vec2 = (0, $91b0cc4981465964$exports).create();
        const _vec3 = (0, $31054a6c69637582$exports).create();
        const minColor = options.minColor === undefined ? 0 : options.minColor;
        const maxColor = options.maxColor === undefined ? 1 : options.maxColor;
        const minOrder = options.minOrder === undefined ? 0 : options.minOrder;
        const maxOrder = options.maxOrder === undefined ? 1 : options.maxOrder;
        const orderReverse = options.orderReverse === undefined ? false : options.orderReverse;
        const minStaggerOrder = options.minStaggerOrder === undefined ? 0 : options.minStaggerOrder;
        const maxStaggerOrder = options.maxStaggerOrder === undefined ? 1 : options.maxStaggerOrder;
        const staggerOrderReverse = options.staggerOrderReverse === undefined ? false : options.staggerOrderReverse;
        const padding = options.padding === undefined ? 0 : options.padding;
        const thickness = options.thickness === undefined ? 1 : options.thickness;
        const reverseX = options.reverseX === undefined ? false : options.reverseX;
        const reverseY = options.reverseY === undefined ? false : options.reverseY;
        const reverseZ = options.reverseZ === undefined ? false : options.reverseZ;
        this._updateModelBounds(options);
        const scale = (0, $31054a6c69637582$exports).fromValues((1 - padding) * this._boundsScaling, (1 - padding) * this._boundsScaling, thickness * this._boundsScaling);
        const lookup = buffer.lookup;
        const selection = options.selected && options.selected.size > 0;
        for(let i = 0; i < count; i++){
            const id = ids[i + offset];
            const index = lookup[id];
            let positionX = this._positions[index * 3];
            let positionY = this._positions[index * 3 + 1];
            let positionZ = this._positions[index * 3 + 2];
            if (this._isFacetted) {
                if (reverseX) positionX = this.minModelBoundsX + this.minModelBoundsX + this._facetSizeX * (1 + this._facetSpacingX) - positionX;
                if (reverseY) positionY = this.minModelBoundsY + this.minModelBoundsY + this._facetSizeY * (1 + this._facetSpacingY) - positionY;
                if (reverseZ) positionZ = this.minModelBoundsZ + this.minModelBoundsZ + this._facetSizeZ * (1 + this._facetSpacingZ) - positionZ;
                const facetX = options.facetCoordsX ? options.facetCoordsX[id] : 0;
                const facetY = options.facetCoordsY ? options.facetCoordsY[id] : 0;
                const facetZ = options.facetCoordsZ ? options.facetCoordsZ[id] : 0;
                positionX += facetX * this._facetSizeX * (1 + this._facetSpacingX);
                positionY += facetY * this._facetSizeY * (1 + this._facetSpacingY);
                positionZ += facetZ * this._facetSizeZ * (1 + this._facetSpacingZ);
            } else {
                if (reverseX) positionX = this.minModelBoundsX + this.maxModelBoundsX - positionX;
                if (reverseY) positionY = this.minModelBoundsY + this.maxModelBoundsY - positionY;
                if (reverseZ) positionZ = this.minModelBoundsZ + this.maxModelBoundsZ - positionZ;
            }
            _vec3[0] = (positionX - this.modelOriginX) * this._boundsScaling;
            _vec3[1] = (positionY - this.modelOriginY) * this._boundsScaling;
            _vec3[2] = (positionZ - this.modelOriginZ) * this._boundsScaling;
            (0, $0a0587bd8b0d58e8$export$849e31d725692576).setTranslation(dataView, index, _vec3);
            (0, $0a0587bd8b0d58e8$export$849e31d725692576).setScale(dataView, index, scale);
            (0, $0a0587bd8b0d58e8$export$849e31d725692576).setRotation(dataView, index, (0, $d4d7bd6cc65a5081$export$a002182e51710d39).QUAT_IDENTITY);
            if (options.colors) {
                const size = 1 / (maxColor - minColor + 1);
                const color = (0, $2d4d1eb6f32f02f2$export$80a8c44b8858d625).normalize(options.colors[id], minColor, maxColor, size / 2, 1 - size / 2);
                (0, $91b0cc4981465964$exports).set(_vec2, color, color);
                (0, $0a0587bd8b0d58e8$export$849e31d725692576).setColor(dataView, index, _vec2);
            } else (0, $0a0587bd8b0d58e8$export$849e31d725692576).setColor(dataView, index, (0, $d4d7bd6cc65a5081$export$a002182e51710d39).VECTOR2_ONE);
            (0, $0a0587bd8b0d58e8$export$849e31d725692576).setIdHover(dataView, index, options.hover ? options.hover[id] : id);
            (0, $0a0587bd8b0d58e8$export$849e31d725692576).setSelected(dataView, index, selection ? options.selected.has(id) ? 1 : -1 : 0);
            if (options.order !== undefined) {
                const order = (0, $2d4d1eb6f32f02f2$export$80a8c44b8858d625).normalize(options.order[id], minOrder, maxOrder, 0, 1);
                _vec2[0] = orderReverse ? 1 - order : order;
            } else _vec2[0] = count == 1 ? 0 : i / (count - 1);
            if (options.staggerOrder !== undefined) _vec2[1] = options.staggerOrder;
            else if (options.staggerOrders) {
                const stagger = (0, $2d4d1eb6f32f02f2$export$80a8c44b8858d625).normalize(options.staggerOrders[id], minStaggerOrder, maxStaggerOrder, 0, 1);
                _vec2[1] = staggerOrderReverse ? 1 - stagger : stagger;
            } else _vec2[1] = count == 1 ? 0 : i / (count - 1);
            (0, $0a0587bd8b0d58e8$export$849e31d725692576).setOrder(dataView, index, _vec2);
            (0, $0a0587bd8b0d58e8$export$849e31d725692576).setMaterial(dataView, index, options.material ? options.material : options.materials ? options.materials[id] : 0);
            (0, $0a0587bd8b0d58e8$export$849e31d725692576).setRounding(dataView, index, options.rounding ? options.rounding * this._boundsScaling : options.roundings ? options.roundings[id] * this._boundsScaling : 0);
            (0, $0a0587bd8b0d58e8$export$849e31d725692576).setSdfBuffer(dataView, index, options.sdfBuffer ? options.sdfBuffer : options.sdfBuffers ? options.sdfBuffers[id] : this._core.config.sdfBuffer);
            (0, $0a0587bd8b0d58e8$export$849e31d725692576).setSdfBorder(dataView, index, options.sdfBorder ? options.sdfBorder : options.sdfBorders ? options.sdfBorders[id] : this._core.config.sdfBorder);
        }
        buffer.update();
        this._core.log.write((0, $4a6417d29706362f$export$243e62d78d3b544d).info, `${this.constructor.name.toLowerCase()} update ${count} ${Math.round(window.performance.now() - start)} ms`);
    }
}


/*!
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 */ 





class $05bc96b85bb3a34e$export$ce1cde616fb0ca7e extends (0, $9f62a2679ad52b29$export$f4f11265faddf354) {
    get positionsX() {
        return this._positionsX;
    }
    get positionsY() {
        return this._positionsY;
    }
    get sizesX() {
        return this._sizesX;
    }
    get sizesY() {
        return this._sizesY;
    }
    layout(buffer, ids, options) {
        const start = window.performance.now();
        const size = options.size == undefined ? 1 : options.size;
        let offset = options.offset === undefined ? 0 : options.offset;
        let count = options.count === undefined ? ids.length : options.count;
        this.minLayoutBoundsX = options.minBoundsX;
        this.minLayoutBoundsY = options.minBoundsY;
        this.minLayoutBoundsZ = options.minBoundsZ;
        this.maxLayoutBoundsX = options.maxBoundsX;
        this.maxLayoutBoundsY = options.maxBoundsY;
        this.maxLayoutBoundsZ = options.maxBoundsZ;
        const sizeX = this.maxLayoutBoundsX - this.minLayoutBoundsX;
        const sizeY = this.maxLayoutBoundsY - this.minLayoutBoundsY;
        if (options.sizes) {
            for(let i = 0; i < count; i++){
                if (options.sizes[ids[offset]] > 0) break;
                offset++;
                count--;
            }
            if (count == 0) return;
        } else if (size <= 0) return;
        if (!this._positionsX || this._positionsX.length < buffer.length) {
            this._positionsX = new Float32Array(buffer.length);
            this._positionsY = new Float32Array(buffer.length);
            this._sizesX = new Float32Array(buffer.length);
            this._sizesY = new Float32Array(buffer.length);
        }
        $05bc96b85bb3a34e$export$ece3d818ad8f3b75.squarifiedLayout(ids, options.sizes, this._positionsX, this._positionsY, this._sizesX, this._sizesY, offset, offset + count - 1, this.minLayoutBoundsX, this.minLayoutBoundsY, sizeX, sizeY, buffer.lookup);
        this._updateCumulativeLayoutBounds();
        this._core.log.write((0, $4a6417d29706362f$export$243e62d78d3b544d).info, `${this.constructor.name.toLowerCase()} layout ${count} ${Math.round(window.performance.now() - start)}ms`);
    }
    update(buffer, ids, options) {
        const start = window.performance.now();
        const offset = options.offset === undefined ? 0 : options.offset;
        const count = options.count === undefined ? ids.length : options.count;
        const dataView = buffer.dataView;
        const _vec2 = (0, $91b0cc4981465964$exports).create();
        const _vec3 = (0, $31054a6c69637582$exports).create();
        const _quat = (0, $39ece26d1239bb77$exports).create();
        const heights = options.heights;
        const minHeight = options.minHeight === undefined ? 0 : options.minHeight;
        const minColor = options.minColor === undefined ? 0 : options.minColor;
        const maxColor = options.maxColor === undefined ? 1 : options.maxColor;
        const minOrder = options.minOrder === undefined ? 0 : options.minOrder;
        const maxOrder = options.maxOrder === undefined ? 1 : options.maxOrder;
        const orderReverse = options.orderReverse === undefined ? false : options.orderReverse;
        const minStaggerOrder = options.minStaggerOrder === undefined ? 0 : options.minStaggerOrder;
        const maxStaggerOrder = options.maxStaggerOrder === undefined ? 1 : options.maxStaggerOrder;
        const staggerOrderReverse = options.staggerOrderReverse === undefined ? false : options.staggerOrderReverse;
        const padding = options.padding === undefined ? 0 : options.padding;
        const reverseX = options.reverseX === undefined ? false : options.reverseX;
        const reverseY = options.reverseY === undefined ? false : options.reverseY;
        const reverseZ = options.reverseZ === undefined ? false : options.reverseZ;
        this._updateModelBounds(options);
        (0, $39ece26d1239bb77$exports).rotationTo(_quat, this._core.config.identityRotation, (0, $d4d7bd6cc65a5081$export$a002182e51710d39).VECTOR3_UNITY);
        let maxHeight;
        if (heights) {
            maxHeight = 0;
            for(let i = 0; i < count; i++){
                const id = ids[i + offset];
                maxHeight = Math.max(heights[id], maxHeight);
            }
        } else maxHeight = 1;
        const heightScaling = (this.maxLayoutBoundsZ - this.minLayoutBoundsZ) / maxHeight;
        const lookup = buffer.lookup;
        const selection = options.selected && options.selected.size > 0;
        for(let i = 0; i < count; i++){
            const id = ids[i + offset];
            const index = lookup[id];
            const height = Math.max(heights ? heights[id] * heightScaling : heightScaling, minHeight);
            let positionX = this._positionsX[index];
            let positionY = this._positionsY[index];
            let positionZ = this.minLayoutBoundsZ + height / 2;
            if (this._isFacetted) {
                if (reverseX) positionX = this.minModelBoundsX + this.minModelBoundsX + this._facetSizeX * (1 + this._facetSpacingX) - positionX;
                if (reverseY) positionY = this.minModelBoundsY + this.minModelBoundsY + this._facetSizeY * (1 + this._facetSpacingY) - positionY;
                if (reverseZ) positionZ = this.minModelBoundsZ + this.minModelBoundsZ + this._facetSizeZ * (1 + this._facetSpacingZ) - positionZ;
                const facetX = options.facetCoordsX ? options.facetCoordsX[id] : 0;
                const facetY = options.facetCoordsY ? options.facetCoordsY[id] : 0;
                const facetZ = options.facetCoordsZ ? options.facetCoordsZ[id] : 0;
                positionX += facetX * this._facetSizeX * (1 + this._facetSpacingX);
                positionY += facetY * this._facetSizeY * (1 + this._facetSpacingY);
                positionZ += facetZ * this._facetSizeZ * (1 + this._facetSpacingZ);
            } else {
                if (reverseX) positionX = this.minModelBoundsX + this.maxModelBoundsX - positionX;
                if (reverseY) positionY = this.minModelBoundsY + this.maxModelBoundsY - positionY;
                if (reverseZ) positionZ = this.minModelBoundsZ + this.maxModelBoundsZ - positionZ;
            }
            _vec3[0] = (positionX - this.modelOriginX) * this._boundsScaling;
            _vec3[1] = (positionY - this.modelOriginY) * this._boundsScaling;
            _vec3[2] = (positionZ - this.modelOriginZ) * this._boundsScaling;
            (0, $0a0587bd8b0d58e8$export$849e31d725692576).setTranslation(dataView, index, _vec3);
            _vec3[0] = Math.max((this._sizesX[index] - padding) * this._boundsScaling, 0);
            _vec3[1] = Math.max((this._sizesY[index] - padding) * this._boundsScaling, 0);
            _vec3[2] = height * this._boundsScaling;
            (0, $0a0587bd8b0d58e8$export$849e31d725692576).setScale(dataView, index, _vec3);
            (0, $0a0587bd8b0d58e8$export$849e31d725692576).setRotation(dataView, index, _quat);
            if (options.colors) {
                const size = 1 / (maxColor - minColor + 1);
                const color = (0, $2d4d1eb6f32f02f2$export$80a8c44b8858d625).normalize(options.colors[id], minColor, maxColor, size / 2, 1 - size / 2);
                (0, $91b0cc4981465964$exports).set(_vec2, color, color);
                (0, $0a0587bd8b0d58e8$export$849e31d725692576).setColor(dataView, index, _vec2);
            } else (0, $0a0587bd8b0d58e8$export$849e31d725692576).setColor(dataView, index, (0, $d4d7bd6cc65a5081$export$a002182e51710d39).VECTOR2_ONE);
            (0, $0a0587bd8b0d58e8$export$849e31d725692576).setIdHover(dataView, index, options.hover ? options.hover[id] : id);
            (0, $0a0587bd8b0d58e8$export$849e31d725692576).setSelected(dataView, index, selection ? options.selected.has(id) ? 1 : -1 : 0);
            if (options.order !== undefined) {
                const order = (0, $2d4d1eb6f32f02f2$export$80a8c44b8858d625).normalize(options.order[id], minOrder, maxOrder, 0, 1);
                _vec2[0] = orderReverse ? 1 - order : order;
            } else _vec2[0] = count == 1 ? 0 : i / (count - 1);
            if (options.staggerOrder !== undefined) _vec2[1] = options.staggerOrder;
            else if (options.staggerOrders) {
                const stagger = (0, $2d4d1eb6f32f02f2$export$80a8c44b8858d625).normalize(options.staggerOrders[id], minStaggerOrder, maxStaggerOrder, 0, 1);
                _vec2[1] = staggerOrderReverse ? 1 - stagger : stagger;
            } else _vec2[1] = count == 1 ? 0 : i / (count - 1);
            (0, $0a0587bd8b0d58e8$export$849e31d725692576).setOrder(dataView, index, _vec2);
            (0, $0a0587bd8b0d58e8$export$849e31d725692576).setMaterial(dataView, index, options.material ? options.material : options.materials ? options.materials[id] : 0);
            (0, $0a0587bd8b0d58e8$export$849e31d725692576).setRounding(dataView, index, options.rounding ? options.rounding * this._boundsScaling : options.roundings ? options.roundings[id] * this._boundsScaling : 0);
            (0, $0a0587bd8b0d58e8$export$849e31d725692576).setSdfBuffer(dataView, index, options.sdfBuffer ? options.sdfBuffer : options.sdfBuffers ? options.sdfBuffers[id] : this._core.config.sdfBuffer);
            (0, $0a0587bd8b0d58e8$export$849e31d725692576).setSdfBorder(dataView, index, options.sdfBorder ? options.sdfBorder : options.sdfBorders ? options.sdfBorders[id] : this._core.config.sdfBorder);
        }
        buffer.update();
        this._core.log.write((0, $4a6417d29706362f$export$243e62d78d3b544d).info, `${this.constructor.name.toLowerCase()} update ${count} ${Math.round(window.performance.now() - start)}ms`);
    }
}
class $05bc96b85bb3a34e$export$3ca73d0a8bf0e96e extends (0, $9f62a2679ad52b29$export$f4f11265faddf354) {
    layout(buffer, ids, options) {
        const start = window.performance.now();
        const isTopToBottom = options.isTopToBottom === undefined ? false : options.isTopToBottom;
        let offset = options.offset === undefined ? 0 : options.offset;
        let count = options.count === undefined ? ids.length : options.count;
        this.minLayoutBoundsX = options.minBoundsX;
        this.minLayoutBoundsY = options.minBoundsY;
        this.minLayoutBoundsZ = options.minBoundsZ;
        this.maxLayoutBoundsX = options.maxBoundsX;
        this.maxLayoutBoundsY = options.maxBoundsY;
        this.maxLayoutBoundsZ = options.maxBoundsZ;
        if (options.sizes) {
            for(let i = 0; i < count; i++){
                if (options.sizes[ids[offset]] > 0) break;
                offset++;
                count--;
            }
            if (count == 0) return;
        }
        const sizeX = this.maxLayoutBoundsX - this.minLayoutBoundsX;
        const sizeY = this.maxLayoutBoundsY - this.minLayoutBoundsY;
        const sizeZ = this.maxLayoutBoundsZ - this.minLayoutBoundsZ;
        const minHeight = this._core.config.minCubifiedTreeMapSlice / sizeY;
        const side = Math.sqrt(sizeX * sizeZ);
        const total = options.sizes ? $05bc96b85bb3a34e$export$ece3d818ad8f3b75.totalSize(ids, options.sizes, offset, offset + count - 1) : count;
        if (!this._positionsX || this._positionsX.length < buffer.length) {
            this._positionsX = new Float32Array(buffer.length);
            this._positionsY = new Float32Array(buffer.length);
            this._positionsZ = new Float32Array(buffer.length);
            this._sizesX = new Float32Array(buffer.length);
            this._sizesY = new Float32Array(buffer.length);
            this._sizesZ = new Float32Array(buffer.length);
        }
        $05bc96b85bb3a34e$export$ece3d818ad8f3b75.cubifiedLayout(ids, options.sizes, this._positionsX, this._positionsY, this._positionsZ, this._sizesX, this._sizesY, this._sizesZ, offset, offset + count - 1, this.minLayoutBoundsX, this.minLayoutBoundsY, this.minLayoutBoundsZ, sizeX, sizeY, sizeZ, side, total, minHeight, isTopToBottom, buffer.lookup);
        this._core.log.write((0, $4a6417d29706362f$export$243e62d78d3b544d).info, `${this.constructor.name.toLowerCase()} layout ${count} ${Math.round(window.performance.now() - start)}ms`);
    }
    update(buffer, ids, options) {
        const start = window.performance.now();
        const offset = options.offset === undefined ? 0 : options.offset;
        const count = options.count === undefined ? ids.length : options.count;
        const dataView = buffer.dataView;
        const _vec2 = (0, $91b0cc4981465964$exports).create();
        const _vec3 = (0, $31054a6c69637582$exports).create();
        const minColor = options.minColor === undefined ? 0 : options.minColor;
        const maxColor = options.maxColor === undefined ? 1 : options.maxColor;
        const minOrder = options.minOrder === undefined ? 0 : options.minOrder;
        const maxOrder = options.maxOrder === undefined ? 1 : options.maxOrder;
        const orderReverse = options.orderReverse === undefined ? false : options.orderReverse;
        const minStaggerOrder = options.minStaggerOrder === undefined ? 0 : options.minStaggerOrder;
        const maxStaggerOrder = options.maxStaggerOrder === undefined ? 1 : options.maxStaggerOrder;
        const staggerOrderReverse = options.staggerOrderReverse === undefined ? false : options.staggerOrderReverse;
        const padding = options.padding === undefined ? 0 : options.padding;
        const paddingZ = options.thickness === undefined ? padding : 0;
        const thickness = options.thickness === undefined ? 1 : options.thickness;
        const reverseX = options.reverseX === undefined ? false : options.reverseX;
        const reverseY = options.reverseY === undefined ? false : options.reverseY;
        const reverseZ = options.reverseZ === undefined ? false : options.reverseZ;
        this._updateModelBounds(options);
        const lookup = buffer.lookup;
        const selection = options.selected && options.selected.size > 0;
        for(let i = 0; i < count; i++){
            const id = ids[i + offset];
            const index = lookup[id];
            let positionX = this._positionsX[index];
            let positionY = this._positionsY[index];
            let positionZ = this._positionsZ[index];
            if (this._isFacetted) {
                if (reverseX) positionX = this.minModelBoundsX + this.minModelBoundsX + this._facetSizeX * (1 + this._facetSpacingX) - positionX;
                if (reverseY) positionY = this.minModelBoundsY + this.minModelBoundsY + this._facetSizeY * (1 + this._facetSpacingY) - positionY;
                if (reverseZ) positionZ = this.minModelBoundsZ + this.minModelBoundsZ + this._facetSizeZ * (1 + this._facetSpacingZ) - positionZ;
                const facetX = options.facetCoordsX ? options.facetCoordsX[id] : 0;
                const facetY = options.facetCoordsY ? options.facetCoordsY[id] : 0;
                const facetZ = options.facetCoordsZ ? options.facetCoordsZ[id] : 0;
                positionX += facetX * this._facetSizeX * (1 + this._facetSpacingX);
                positionY += facetY * this._facetSizeY * (1 + this._facetSpacingY);
                positionZ += facetZ * this._facetSizeZ * (1 + this._facetSpacingZ);
            } else {
                if (reverseX) positionX = this.minModelBoundsX + this.maxModelBoundsX - positionX;
                if (reverseY) positionY = this.minModelBoundsY + this.maxModelBoundsY - positionY;
                if (reverseZ) positionZ = this.minModelBoundsZ + this.maxModelBoundsZ - positionZ;
            }
            _vec3[0] = (positionX - this.modelOriginX) * this._boundsScaling;
            _vec3[1] = (positionY - this.modelOriginY) * this._boundsScaling;
            _vec3[2] = (positionZ - this.modelOriginZ) * this._boundsScaling;
            (0, $0a0587bd8b0d58e8$export$849e31d725692576).setTranslation(dataView, index, _vec3);
            _vec3[0] = Math.max((this._sizesX[index] - padding) * this._boundsScaling, 0);
            _vec3[1] = Math.max((this._sizesY[index] - padding) * this._boundsScaling, 0);
            _vec3[2] = Math.max((this._sizesZ[index] - paddingZ) * this._boundsScaling, 0) * thickness;
            (0, $0a0587bd8b0d58e8$export$849e31d725692576).setScale(dataView, index, _vec3);
            (0, $0a0587bd8b0d58e8$export$849e31d725692576).setRotation(dataView, index, (0, $d4d7bd6cc65a5081$export$a002182e51710d39).QUAT_IDENTITY);
            if (options.colors) {
                const size = 1 / (maxColor - minColor + 1);
                const color = (0, $2d4d1eb6f32f02f2$export$80a8c44b8858d625).normalize(options.colors[id], minColor, maxColor, size / 2, 1 - size / 2);
                (0, $91b0cc4981465964$exports).set(_vec2, color, color);
                (0, $0a0587bd8b0d58e8$export$849e31d725692576).setColor(dataView, index, _vec2);
            } else (0, $0a0587bd8b0d58e8$export$849e31d725692576).setColor(dataView, index, (0, $d4d7bd6cc65a5081$export$a002182e51710d39).VECTOR2_ONE);
            (0, $0a0587bd8b0d58e8$export$849e31d725692576).setIdHover(dataView, index, options.hover ? options.hover[id] : id);
            (0, $0a0587bd8b0d58e8$export$849e31d725692576).setSelected(dataView, index, selection ? options.selected.has(id) ? 1 : -1 : 0);
            if (options.order !== undefined) {
                const order = (0, $2d4d1eb6f32f02f2$export$80a8c44b8858d625).normalize(options.order[id], minOrder, maxOrder, 0, 1);
                _vec2[0] = orderReverse ? 1 - order : order;
            } else _vec2[0] = count == 1 ? 0 : i / (count - 1);
            if (options.staggerOrder !== undefined) _vec2[1] = options.staggerOrder;
            else if (options.staggerOrders) {
                const stagger = (0, $2d4d1eb6f32f02f2$export$80a8c44b8858d625).normalize(options.staggerOrders[id], minStaggerOrder, maxStaggerOrder, 0, 1);
                _vec2[1] = staggerOrderReverse ? 1 - stagger : stagger;
            } else _vec2[1] = count == 1 ? 0 : i / (count - 1);
            (0, $0a0587bd8b0d58e8$export$849e31d725692576).setOrder(dataView, index, _vec2);
            (0, $0a0587bd8b0d58e8$export$849e31d725692576).setMaterial(dataView, index, options.material ? options.material : options.materials ? options.materials[id] : 0);
            (0, $0a0587bd8b0d58e8$export$849e31d725692576).setRounding(dataView, index, options.rounding ? options.rounding * this._boundsScaling : options.roundings ? options.roundings[id] * this._boundsScaling : 0);
        }
        buffer.update();
        this._core.log.write((0, $4a6417d29706362f$export$243e62d78d3b544d).info, `${this.constructor.name.toLowerCase()} update ${count} ${Math.round(window.performance.now() - start)}ms`);
    }
}
class $05bc96b85bb3a34e$export$ece3d818ad8f3b75 {
    static squarifiedLayout(ids, sizes, positionsX, positionsY, sizesX, sizesY, from, to, x, y, width, height, lookup) {
        if (from > to) return;
        if (to - from < 2) {
            $05bc96b85bb3a34e$export$ece3d818ad8f3b75._sliceLayout(ids, sizes, positionsX, positionsY, sizesX, sizesY, from, to, x, y, width, height, lookup);
            return;
        }
        const totalSize = sizes ? $05bc96b85bb3a34e$export$ece3d818ad8f3b75.totalSize(ids, sizes, from, to) : to - from + 1;
        const a = sizes ? sizes[ids[to]] / totalSize : 1 / totalSize;
        let b = a;
        let mid = to;
        if (width < height) {
            while(mid > from){
                const aspect = $05bc96b85bb3a34e$export$ece3d818ad8f3b75._aspect(height, width, a, b);
                const q = sizes ? sizes[ids[mid - 1]] / totalSize : 1 / totalSize;
                if ($05bc96b85bb3a34e$export$ece3d818ad8f3b75._aspect(height, width, a, b + q) > aspect) break;
                mid--;
                b += q;
            }
            $05bc96b85bb3a34e$export$ece3d818ad8f3b75._sliceLayout(ids, sizes, positionsX, positionsY, sizesX, sizesY, mid, to, x, y, width, height * b, lookup);
            $05bc96b85bb3a34e$export$ece3d818ad8f3b75.squarifiedLayout(ids, sizes, positionsX, positionsY, sizesX, sizesY, from, mid - 1, x, y + height * b, width, height * (1 - b), lookup);
        } else {
            while(mid > from){
                const aspect = $05bc96b85bb3a34e$export$ece3d818ad8f3b75._aspect(width, height, a, b);
                const q = sizes ? sizes[ids[mid - 1]] / totalSize : 1 / totalSize;
                if ($05bc96b85bb3a34e$export$ece3d818ad8f3b75._aspect(width, height, a, b + q) > aspect) break;
                mid--;
                b += q;
            }
            $05bc96b85bb3a34e$export$ece3d818ad8f3b75._sliceLayout(ids, sizes, positionsX, positionsY, sizesX, sizesY, mid, to, x, y, width * b, height, lookup);
            $05bc96b85bb3a34e$export$ece3d818ad8f3b75.squarifiedLayout(ids, sizes, positionsX, positionsY, sizesX, sizesY, from, mid - 1, x + width * b, y, width * (1 - b), height, lookup);
        }
    }
    static totalSize(ids, sizes, from, to) {
        let size = 0;
        for(let i = from; i <= to; i++)size += sizes[ids[i]];
        return size;
    }
    static _sliceLayout(ids, sizes, positionsX, positionsY, sizesX, sizesY, from, to, x, y, width, height, lookup) {
        const totalSize = sizes ? $05bc96b85bb3a34e$export$ece3d818ad8f3b75.totalSize(ids, sizes, from, to) : to - from + 1;
        let a = 0;
        for(let i = to; i >= from; i--){
            const id = ids[i];
            const index = lookup[id];
            const b = sizes ? sizes[id] / totalSize : 1 / totalSize;
            if (width > height) {
                sizesY[index] = height;
                sizesX[index] = width * b;
                positionsY[index] = y + height / 2;
                positionsX[index] = x + width * a + width * b / 2;
            } else {
                sizesX[index] = width;
                sizesY[index] = height * b;
                positionsX[index] = x + width / 2;
                positionsY[index] = y + height * a + height * b / 2;
            }
            a += b;
        }
    }
    static _aspect(big, small, a, b) {
        const x = big * b / (small * a / b);
        if (x < 1) return 1 / x;
        return x;
    }
    static cubifiedLayout(ids, sizes, positionsX, positionsY, positionsZ, sizesX, sizesY, sizesZ, from, to, x, y, z, width, height, depth, side, total, minHeight, isTopToBottom, lookup) {
        if (from > to) return;
        let sliceHeight = 0;
        let sliceTotal = 0;
        let previousAspect = 0;
        let mid = to;
        while(mid >= from){
            const itemSize = sizes ? sizes[ids[mid]] : 1;
            sliceTotal += itemSize;
            sliceHeight = height * sliceTotal / total;
            const remainingHeight = height - sliceHeight;
            if (remainingHeight < minHeight) {
                mid = from;
                const totalSize = sizes ? this.totalSize(ids, sizes, mid, to) : to - from + 1;
                sliceHeight = height * totalSize / total;
                break;
            }
            const itemSide = Math.sqrt(itemSize / sliceTotal) * side;
            const aspect = itemSide > sliceHeight ? sliceHeight / itemSide : itemSide / sliceHeight;
            if (aspect < previousAspect || mid == from) break;
            previousAspect = aspect;
            mid--;
        }
        $05bc96b85bb3a34e$export$ece3d818ad8f3b75.squarifiedLayout(ids, sizes, positionsX, positionsZ, sizesX, sizesZ, mid, to, x, z, width, depth, lookup);
        for(let j = mid; j <= to; j++){
            const id = ids[j];
            const index = lookup[id];
            sizesY[index] = Math.max(sliceHeight, 0.01);
            positionsY[index] = isTopToBottom ? positionsY[index] = y + sliceHeight / 2 : y + height - sliceHeight / 2;
        }
        $05bc96b85bb3a34e$export$ece3d818ad8f3b75.cubifiedLayout(ids, sizes, positionsX, positionsY, positionsZ, sizesX, sizesY, sizesZ, from, mid - 1, x, isTopToBottom ? y + sliceHeight : y, z, width, height - sliceHeight, depth, side, total - sliceTotal, minHeight, isTopToBottom, lookup);
    }
}


/*!
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 */ 






class $385fd844fe700a1a$export$84974d344b4becf0 extends (0, $9f62a2679ad52b29$export$f4f11265faddf354) {
    get maxCount() {
        return this._maxCount;
    }
    get levels() {
        return this._levels;
    }
    get binCounts() {
        return this._binCounts;
    }
    getPositionX(index) {
        return this._positionsX[index];
    }
    getPositionY(index) {
        return this._positionsY[index];
    }
    getPositionZ(index) {
        return this._positionsZ[index];
    }
}
class $385fd844fe700a1a$export$694e0d28c7ffc90c extends $385fd844fe700a1a$export$84974d344b4becf0 {
    get maxLevel() {
        return this._maxLevel;
    }
    layout(buffer, ids, options) {
        const start = window.performance.now();
        const offset = options.offset === undefined ? 0 : options.offset;
        const count = options.count === undefined ? ids.length : options.count;
        this._maxLevel = 0;
        const sizeX = options.sizeX == undefined ? 1 : options.sizeX;
        const sizeZ = options.sizeZ == undefined ? 1 : options.sizeZ;
        const spacingX = options.spacingX == undefined ? 0 : options.spacingX;
        const spacingZ = options.spacingZ == undefined ? 0 : options.spacingZ;
        const binsX = options.binsX == undefined ? 1 : options.binsX;
        const binsZ = options.binsZ == undefined ? 1 : options.binsZ;
        this._height = options.height == undefined ? 1 : options.height;
        if (!this._positionsX || this._positionsX.length < buffer.length) {
            this._positionsX = new Float32Array(buffer.length);
            this._positionsY = new Float32Array(buffer.length);
            this._positionsZ = new Float32Array(buffer.length);
            this._levels = new Uint32Array(buffer.length);
        }
        this._binCounts = new Uint32Array(binsX * binsZ);
        let maxBinCount = 0;
        let maxBinLevel = 0;
        let positionX, positionY, positionZ;
        const lookup = buffer.lookup;
        for(let i = 0; i < count; i++){
            const id = ids[i + offset];
            const index = lookup[id];
            const binIdX = options.binIdsX ? options.binIdsX[id] : 0;
            const binIdZ = options.binIdsZ ? options.binIdsZ[id] : 0;
            const binId = binIdX + binIdZ * binsX;
            if (binId > this._binCounts.length - 1) this._core.log.write((0, $4a6417d29706362f$export$243e62d78d3b544d).warn, "bin overflow");
            const binCount = this._binCounts[binId];
            const level = Math.floor(binCount / sizeX / sizeZ);
            this._levels[index] = level;
            const levelCount = binCount - level * sizeX * sizeZ;
            const itemZ = Math.floor(levelCount / sizeX);
            const itemX = levelCount - itemZ * sizeX;
            positionX = spacingX / 2 + binIdX * (sizeX + spacingX) + itemX + 0.5;
            positionY = this._height * (level + 0.5);
            positionZ = spacingZ / 2 + binIdZ * (sizeZ + spacingZ) + itemZ + 0.5;
            this._positionsX[index] = positionX;
            this._positionsY[index] = positionY;
            this._positionsZ[index] = positionZ;
            this._binCounts[binId]++;
            maxBinCount = Math.max(maxBinCount, this._binCounts[binId]);
            maxBinLevel = Math.max(maxBinLevel, level);
        }
        this._maxLevel = maxBinLevel + 1;
        this._maxCount = maxBinCount;
        this.minLayoutBoundsX = 0;
        this.minLayoutBoundsY = 0;
        this.minLayoutBoundsZ = 0;
        this.maxLayoutBoundsX = binsX * (sizeX + spacingX);
        this.maxLayoutBoundsY = this._maxLevel * this._height;
        this.maxLayoutBoundsZ = binsZ * (sizeZ + spacingZ);
        this._updateCumulativeLayoutBounds();
        this._core.log.write((0, $4a6417d29706362f$export$243e62d78d3b544d).info, `${this.constructor.name.toLowerCase()} layout ${count} ${Math.round(window.performance.now() - start)}ms`);
    }
    update(buffer, ids, options) {
        const start = window.performance.now();
        const offset = options.offset === undefined ? 0 : options.offset;
        const count = options.count === undefined ? ids.length : options.count;
        const dataView = buffer.dataView;
        const _vec2 = (0, $91b0cc4981465964$exports).create();
        const _vec3 = (0, $31054a6c69637582$exports).create();
        const _vec4 = (0, $4c4ac78b213a9c07$exports).create();
        const _quat = (0, $39ece26d1239bb77$exports).create();
        const minColor = options.minColor === undefined ? 0 : options.minColor;
        const maxColor = options.maxColor === undefined ? 1 : options.maxColor;
        const minOrder = options.minOrder === undefined ? 0 : options.minOrder;
        const maxOrder = options.maxOrder === undefined ? 1 : options.maxOrder;
        const orderReverse = options.orderReverse === undefined ? false : options.orderReverse;
        const minStaggerOrder = options.minStaggerOrder === undefined ? 0 : options.minStaggerOrder;
        const maxStaggerOrder = options.maxStaggerOrder === undefined ? 1 : options.maxStaggerOrder;
        const staggerOrderReverse = options.staggerOrderReverse === undefined ? false : options.staggerOrderReverse;
        const padding = options.padding === undefined ? 0 : options.padding;
        const thickness = options.thickness === undefined ? 1 - padding : options.thickness;
        const reverseX = options.reverseX === undefined ? false : options.reverseX;
        const reverseY = options.reverseY === undefined ? false : options.reverseY;
        const reverseZ = options.reverseZ === undefined ? false : options.reverseZ;
        this._updateModelBounds(options);
        (0, $39ece26d1239bb77$exports).rotationTo(_quat, this._core.config.identityRotation, (0, $d4d7bd6cc65a5081$export$a002182e51710d39).VECTOR3_UNITY);
        if (options.texCoord) {
            _vec4[0] = options.texCoord[0];
            _vec4[1] = options.texCoord[1];
            _vec4[2] = options.texCoord[2];
            _vec4[3] = options.texCoord[3];
        }
        const scale = (0, $31054a6c69637582$exports).fromValues((1 - padding) * this._boundsScaling, (this._height - padding) * this._boundsScaling, thickness * this._boundsScaling);
        const lookup = buffer.lookup;
        const selection = options.selected && options.selected.size > 0;
        for(let i = 0; i < count; i++){
            const id = ids[i + offset];
            const index = lookup[id];
            let positionX = this._positionsX[index];
            let positionY = this._positionsY[index];
            let positionZ = this._positionsZ[index];
            if (this._isFacetted) {
                if (reverseX) positionX = this.minModelBoundsX + this.minModelBoundsX + this._facetSizeX * (1 + this._facetSpacingX) - positionX;
                if (reverseY) positionY = this.minModelBoundsY + this.minModelBoundsY + this._facetSizeY * (1 + this._facetSpacingY) - positionY;
                if (reverseZ) positionZ = this.minModelBoundsZ + this.minModelBoundsZ + this._facetSizeZ * (1 + this._facetSpacingZ) - positionZ;
                const facetX = options.facetCoordsX ? options.facetCoordsX[id] : 0;
                const facetY = options.facetCoordsY ? options.facetCoordsY[id] : 0;
                const facetZ = options.facetCoordsZ ? options.facetCoordsZ[id] : 0;
                positionX += facetX * this._facetSizeX * (1 + this._facetSpacingX);
                positionY += facetY * this._facetSizeY * (1 + this._facetSpacingY);
                positionZ += facetZ * this._facetSizeZ * (1 + this._facetSpacingZ);
            } else {
                if (reverseX) positionX = this.minModelBoundsX + this.maxModelBoundsX - positionX;
                if (reverseY) positionY = this.minModelBoundsY + this.maxModelBoundsY - positionY;
                if (reverseZ) positionZ = this.minModelBoundsZ + this.maxModelBoundsZ - positionZ;
            }
            _vec3[0] = (positionX - this.modelOriginX) * this._boundsScaling;
            _vec3[1] = (positionY - this.modelOriginY) * this._boundsScaling;
            _vec3[2] = (positionZ - this.modelOriginZ) * this._boundsScaling;
            (0, $0a0587bd8b0d58e8$export$849e31d725692576).setTranslation(dataView, index, _vec3);
            (0, $0a0587bd8b0d58e8$export$849e31d725692576).setScale(dataView, index, scale);
            (0, $0a0587bd8b0d58e8$export$849e31d725692576).setRotation(dataView, index, _quat);
            if (options.colors) {
                const size = 1 / (maxColor - minColor + 1);
                const color = (0, $2d4d1eb6f32f02f2$export$80a8c44b8858d625).normalize(options.colors[id], minColor, maxColor, size / 2, 1 - size / 2);
                (0, $91b0cc4981465964$exports).set(_vec2, color, color);
                (0, $0a0587bd8b0d58e8$export$849e31d725692576).setColor(dataView, index, _vec2);
            } else (0, $0a0587bd8b0d58e8$export$849e31d725692576).setColor(dataView, index, (0, $d4d7bd6cc65a5081$export$a002182e51710d39).VECTOR2_ONE);
            (0, $0a0587bd8b0d58e8$export$849e31d725692576).setIdHover(dataView, index, options.hover ? options.hover[id] : id);
            (0, $0a0587bd8b0d58e8$export$849e31d725692576).setSelected(dataView, index, selection ? options.selected.has(id) ? 1 : -1 : 0);
            if (options.order !== undefined) {
                const order = (0, $2d4d1eb6f32f02f2$export$80a8c44b8858d625).normalize(options.order[id], minOrder, maxOrder, 0, 1);
                _vec2[0] = orderReverse ? 1 - order : order;
            } else _vec2[0] = count == 1 ? 0 : i / (count - 1);
            if (options.staggerOrder !== undefined) _vec2[1] = options.staggerOrder;
            else if (options.staggerOrders) {
                const stagger = (0, $2d4d1eb6f32f02f2$export$80a8c44b8858d625).normalize(options.staggerOrders[id], minStaggerOrder, maxStaggerOrder, 0, 1);
                _vec2[1] = staggerOrderReverse ? 1 - stagger : stagger;
            } else _vec2[1] = count == 1 ? 0 : i / (count - 1);
            (0, $0a0587bd8b0d58e8$export$849e31d725692576).setOrder(dataView, index, _vec2);
            (0, $0a0587bd8b0d58e8$export$849e31d725692576).setMaterial(dataView, index, options.material ? options.material : options.materials ? options.materials[id] : 0);
            (0, $0a0587bd8b0d58e8$export$849e31d725692576).setRounding(dataView, index, options.rounding ? options.rounding * this._boundsScaling : options.roundings ? options.roundings[id] * this._boundsScaling : 0);
            (0, $0a0587bd8b0d58e8$export$849e31d725692576).setSdfBuffer(dataView, index, options.sdfBuffer ? options.sdfBuffer : options.sdfBuffers ? options.sdfBuffers[id] : this._core.config.sdfBuffer);
            (0, $0a0587bd8b0d58e8$export$849e31d725692576).setSdfBorder(dataView, index, options.sdfBorder ? options.sdfBorder : options.sdfBorders ? options.sdfBorders[id] : this._core.config.sdfBorder);
            if (options.texCoords) {
                _vec4[0] = options.texCoords[id * 4];
                _vec4[1] = options.texCoords[id * 4 + 1];
                _vec4[2] = options.texCoords[id * 4 + 2];
                _vec4[3] = options.texCoords[id * 4 + 3];
                (0, $0a0587bd8b0d58e8$export$849e31d725692576).setTexCoord(dataView, index, _vec4);
            } else (0, $0a0587bd8b0d58e8$export$849e31d725692576).setTexCoord(dataView, index, _vec4);
        }
        buffer.update();
        this._core.log.write((0, $4a6417d29706362f$export$243e62d78d3b544d).info, `${this.constructor.name.toLowerCase()} update ${count} ${Math.round(window.performance.now() - start)}ms`);
    }
}
class $385fd844fe700a1a$export$75310880a535fd3b extends $385fd844fe700a1a$export$84974d344b4becf0 {
    get maxTotal() {
        return this._maxTotal;
    }
    get binGroupIds() {
        return this._binGroupIds;
    }
    getSizeX(index) {
        return this._sizesX[index];
    }
    getSizeY(index) {
        return this._sizesY[index];
    }
    getSizeZ(index) {
        return this._sizesZ[index];
    }
    layout(buffer, ids, options) {
        const start = window.performance.now();
        const offset = options.offset === undefined ? 0 : options.offset;
        const count = options.count === undefined ? ids.length : options.count;
        const isNormalized = options.isNormalized === undefined ? false : options.isNormalized;
        const minHeight = options.minHeight === undefined ? 0 : options.minHeight;
        const maxHeight = options.maxHeight === undefined ? 0 : options.maxHeight;
        const isTopToBottom = options.isTopToBottom === undefined ? false : options.isTopToBottom;
        const sizeX = options.sizeX == undefined ? 1 : options.sizeX;
        const sizeZ = options.sizeZ == undefined ? 1 : options.sizeZ;
        const spacingX = options.spacingX == undefined ? 0 : options.spacingX;
        const spacingZ = options.spacingZ == undefined ? 0 : options.spacingZ;
        const binsX = options.binsX == undefined ? 1 : options.binsX;
        const binsZ = options.binsZ == undefined ? 1 : options.binsZ;
        if (!this._positionsX || this._positionsX.length < buffer.length) {
            this._positionsX = new Float32Array(buffer.length);
            this._positionsY = new Float32Array(buffer.length);
            this._positionsZ = new Float32Array(buffer.length);
            this._sizesX = new Float32Array(buffer.length);
            this._sizesY = new Float32Array(buffer.length);
            this._sizesZ = new Float32Array(buffer.length);
            this._binIds = new Uint32Array(buffer.length);
            this._binGroupIds = new Float64Array(buffer.length);
        }
        this._binCounts = new Uint32Array(binsX * binsZ);
        this._binTotals = new Float64Array(binsX * binsZ);
        let maxBinCount = 0;
        let maxBinTotal = 0;
        let height;
        const lookup = buffer.lookup;
        for(let i = 0; i < count; i++){
            const id = ids[i + offset];
            const index = lookup[id];
            const binIdX = options.binIdsX ? options.binIdsX[id] : 0;
            const binIdZ = options.binIdsZ ? options.binIdsZ[id] : 0;
            const binId = binIdX + binIdZ * binsX;
            this._binIds[index] = binId;
            if (binId > this._binCounts.length - 1) this._core.log.write((0, $4a6417d29706362f$export$243e62d78d3b544d).warn, "bin overflow");
            this._binCounts[binId]++;
            maxBinCount = Math.max(maxBinCount, this._binCounts[binId]);
            this._binTotals[binId] += options.sizes ? options.sizes[id] : 1;
            maxBinTotal = Math.max(maxBinTotal, this._binTotals[binId]);
        }
        if (maxHeight - minHeight > 0) height = maxHeight - minHeight;
        else height = Math.ceil(maxBinCount / sizeX / sizeZ);
        if (!this._orderedIds || this._orderedIds.length < buffer.length) this._orderedIds = new Uint32Array(buffer.length);
        let ids2;
        if (options.groupIds || options.sizes) {
            if (count == ids.length) this._ids = new Uint32Array(ids);
            else {
                this._ids = new Uint32Array(count);
                for(let i = 0; i < count; i++)this._ids[i] = ids[offset + i];
            }
            if (options.groupIds && options.sizes) {
                this._ids.sort(function(a, b) {
                    return options.groupIds[a] == options.groupIds[b] ? options.sizes[a] - options.sizes[b] : options.groupIds[a] - options.groupIds[b];
                });
                ids2 = this._ids;
            } else if (options.groupIds) {
                this._ids.sort(function(a, b) {
                    return options.groupIds[a] - options.groupIds[b];
                });
                ids2 = this._ids;
            } else if (options.sizes) {
                this._ids.sort(function(a, b) {
                    return options.sizes[a] - options.sizes[b];
                });
                ids2 = this._ids;
            }
        } else ids2 = ids;
        const binOffsets = new Uint32Array(this._binCounts.length);
        let binOffset = 0;
        for(let i = 0; i < this._binCounts.length; i++){
            const binCount = this._binCounts[i];
            binOffsets[i] = binOffset;
            binOffset += binCount;
        }
        for(let i = 0; i < count; i++){
            const id = ids2[i];
            const index = lookup[id];
            const binId = this._binIds[index];
            binOffset = binOffsets[binId]++;
            this._orderedIds[binOffset + offset] = id;
        }
        const minSliceHeight = this._core.config.minCubifiedTreeMapSlice * height;
        const side = Math.sqrt(sizeX * sizeZ);
        let from = offset;
        let isLastInGroup = false;
        let isLastInBin = false;
        let groupCount = 0;
        let groupTotal = 0;
        let positionY = 0;
        for(let i = 0; i < count; i++){
            const id = this._orderedIds[i + offset];
            const index = lookup[id];
            groupCount++;
            groupTotal += options.sizes ? options.sizes[id] : 1;
            const binId = this._binIds[index];
            const groupId = options.groupIds ? options.groupIds[id] : 0;
            if (i == count - 1) {
                isLastInBin = true;
                isLastInGroup = true;
            } else {
                const nextId = this._orderedIds[i + 1 + offset];
                const nextIndex = lookup[nextId];
                const nextBinId = this._binIds[nextIndex];
                const nextGroupId = options.groupIds ? options.groupIds[nextId] : 0;
                isLastInBin = binId != nextBinId;
                isLastInGroup = groupId != nextGroupId;
            }
            if (isLastInBin || isLastInGroup) {
                const mid = i + offset;
                const binIdX = options.binIdsX ? options.binIdsX[id] : 0;
                const binIdZ = options.binIdsZ ? options.binIdsZ[id] : 0;
                let groupValue, binValue;
                if (options.sizes) {
                    groupValue = groupTotal;
                    binValue = isNormalized ? this._binTotals[binId] : maxBinTotal;
                } else {
                    groupValue = groupCount;
                    binValue = isNormalized ? this._binCounts[binId] : maxBinCount;
                }
                const groupHeight = height * groupValue / binValue;
                if (sizeZ == 1) {
                    const positionX = spacingX / 2 + binIdX * (sizeX + spacingX);
                    (0, $05bc96b85bb3a34e$export$ece3d818ad8f3b75).squarifiedLayout(this._orderedIds, options.sizes, this._positionsX, this._positionsY, this._sizesX, this._sizesY, from, mid, positionX, positionY, sizeX, groupHeight, lookup);
                    const isRightToLeft = true;
                    for(let i = from; i <= mid; i++){
                        const id = this._orderedIds[i];
                        const index = lookup[id];
                        this._sizesZ[index] = sizeZ;
                        this._positionsZ[index] = (binIdZ + 0.5) * (sizeZ + spacingZ);
                        if (isRightToLeft) this._positionsX[index] = positionX + sizeX - this._positionsX[index] + positionX;
                        if (!isTopToBottom) this._positionsY[index] = positionY + groupHeight - this._positionsY[index] + positionY;
                    }
                } else (0, $05bc96b85bb3a34e$export$ece3d818ad8f3b75).cubifiedLayout(this._orderedIds, options.sizes, this._positionsX, this._positionsY, this._positionsZ, this._sizesX, this._sizesY, this._sizesZ, from, mid, spacingX / 2 + binIdX * (sizeX + spacingX), positionY, spacingZ / 2 + binIdZ * (sizeZ + spacingZ), sizeX, groupHeight, sizeZ, side, groupValue, minSliceHeight, isTopToBottom, lookup);
                if (isLastInGroup) {
                    isLastInGroup = false;
                    positionY += groupHeight;
                }
                if (isLastInBin) {
                    isLastInBin = false;
                    positionY = 0;
                }
                groupCount = 0;
                groupTotal = 0;
                from = mid + 1;
            }
        }
        this._maxCount = maxBinCount;
        this._maxTotal = maxBinTotal;
        this.minLayoutBoundsX = 0;
        this.minLayoutBoundsY = 0;
        this.minLayoutBoundsZ = 0;
        this.maxLayoutBoundsX = binsX * (sizeX + spacingX);
        this.maxLayoutBoundsY = height;
        this.maxLayoutBoundsZ = binsZ * (sizeZ + spacingZ);
        this._updateCumulativeLayoutBounds();
        this._core.log.write((0, $4a6417d29706362f$export$243e62d78d3b544d).info, `${this.constructor.name.toLowerCase()} layout ${count} ${Math.round(window.performance.now() - start)}ms`);
    }
    update(buffer, ids, options) {
        const start = window.performance.now();
        const offset = options.offset === undefined ? 0 : options.offset;
        const count = options.count === undefined ? ids.length : options.count;
        const dataView = buffer.dataView;
        const _vec2 = (0, $91b0cc4981465964$exports).create();
        const _vec3 = (0, $31054a6c69637582$exports).create();
        const _quat = (0, $39ece26d1239bb77$exports).create();
        const minColor = options.minColor === undefined ? 0 : options.minColor;
        const maxColor = options.maxColor === undefined ? 1 : options.maxColor;
        const minOrder = options.minOrder === undefined ? 0 : options.minOrder;
        const maxOrder = options.maxOrder === undefined ? 1 : options.maxOrder;
        const orderReverse = options.orderReverse === undefined ? false : options.orderReverse;
        const minStaggerOrder = options.minStaggerOrder === undefined ? 0 : options.minStaggerOrder;
        const maxStaggerOrder = options.maxStaggerOrder === undefined ? 1 : options.maxStaggerOrder;
        const staggerOrderReverse = options.staggerOrderReverse === undefined ? false : options.staggerOrderReverse;
        const padding = options.padding === undefined ? 0 : options.padding;
        const paddingZ = options.thickness === undefined ? padding : 0;
        const thickness = options.thickness === undefined ? 1 : options.thickness;
        const reverseX = options.reverseX === undefined ? false : options.reverseX;
        const reverseY = options.reverseY === undefined ? false : options.reverseY;
        const reverseZ = options.reverseZ === undefined ? false : options.reverseZ;
        this._updateModelBounds(options);
        (0, $39ece26d1239bb77$exports).rotationTo(_quat, this._core.config.identityRotation, (0, $d4d7bd6cc65a5081$export$a002182e51710d39).VECTOR3_UNITY);
        const lookup = buffer.lookup;
        const selection = options.selected && options.selected.size > 0;
        for(let i = 0; i < count; i++){
            const id = ids[i + offset];
            const index = lookup[id];
            let positionX = this._positionsX[index];
            let positionY = this._positionsY[index];
            let positionZ = this._positionsZ[index];
            if (this._isFacetted) {
                if (reverseX) positionX = this.minModelBoundsX + this.minModelBoundsX + this._facetSizeX * (1 + this._facetSpacingX) - positionX;
                if (reverseY) positionY = this.minModelBoundsY + this.minModelBoundsY + this._facetSizeY * (1 + this._facetSpacingY) - positionY;
                if (reverseZ) positionZ = this.minModelBoundsZ + this.minModelBoundsZ + this._facetSizeZ * (1 + this._facetSpacingZ) - positionZ;
                const facetX = options.facetCoordsX ? options.facetCoordsX[id] : 0;
                const facetY = options.facetCoordsY ? options.facetCoordsY[id] : 0;
                const facetZ = options.facetCoordsZ ? options.facetCoordsZ[id] : 0;
                positionX += facetX * this._facetSizeX * (1 + this._facetSpacingX);
                positionY += facetY * this._facetSizeY * (1 + this._facetSpacingY);
                positionZ += facetZ * this._facetSizeZ * (1 + this._facetSpacingZ);
            } else {
                if (reverseX) positionX = this.minModelBoundsX + this.maxModelBoundsX - positionX;
                if (reverseY) positionY = this.minModelBoundsY + this.maxModelBoundsY - positionY;
                if (reverseZ) positionZ = this.minModelBoundsZ + this.maxModelBoundsZ - positionZ;
            }
            _vec3[0] = (positionX - this.modelOriginX) * this._boundsScaling;
            _vec3[1] = (positionY - this.modelOriginY) * this._boundsScaling;
            _vec3[2] = (positionZ - this.modelOriginZ) * this._boundsScaling;
            (0, $0a0587bd8b0d58e8$export$849e31d725692576).setTranslation(dataView, index, _vec3);
            _vec3[0] = Math.max((this._sizesX[index] - padding) * this._boundsScaling, 0);
            _vec3[1] = Math.max((this._sizesY[index] - padding) * this._boundsScaling, 0);
            _vec3[2] = Math.max((this._sizesZ[index] - paddingZ) * this._boundsScaling, 0) * thickness;
            (0, $0a0587bd8b0d58e8$export$849e31d725692576).setScale(dataView, index, _vec3);
            (0, $0a0587bd8b0d58e8$export$849e31d725692576).setRotation(dataView, index, _quat);
            if (options.colors) {
                const size = 1 / (maxColor - minColor + 1);
                const color = (0, $2d4d1eb6f32f02f2$export$80a8c44b8858d625).normalize(options.colors[id], minColor, maxColor, size / 2, 1 - size / 2);
                (0, $91b0cc4981465964$exports).set(_vec2, color, color);
                (0, $0a0587bd8b0d58e8$export$849e31d725692576).setColor(dataView, index, _vec2);
            } else (0, $0a0587bd8b0d58e8$export$849e31d725692576).setColor(dataView, index, (0, $d4d7bd6cc65a5081$export$a002182e51710d39).VECTOR2_ONE);
            (0, $0a0587bd8b0d58e8$export$849e31d725692576).setIdHover(dataView, index, options.hover ? options.hover[id] : id);
            (0, $0a0587bd8b0d58e8$export$849e31d725692576).setSelected(dataView, index, selection ? options.selected.has(id) ? 1 : -1 : 0);
            if (options.order !== undefined) {
                const order = (0, $2d4d1eb6f32f02f2$export$80a8c44b8858d625).normalize(options.order[id], minOrder, maxOrder, 0, 1);
                _vec2[0] = orderReverse ? 1 - order : order;
            } else _vec2[0] = count == 1 ? 0 : i / (count - 1);
            if (options.staggerOrder !== undefined) _vec2[1] = options.staggerOrder;
            else if (options.staggerOrders) {
                const stagger = (0, $2d4d1eb6f32f02f2$export$80a8c44b8858d625).normalize(options.staggerOrders[id], minStaggerOrder, maxStaggerOrder, 0, 1);
                _vec2[1] = staggerOrderReverse ? 1 - stagger : stagger;
            } else _vec2[1] = count == 1 ? 0 : i / (count - 1);
            (0, $0a0587bd8b0d58e8$export$849e31d725692576).setOrder(dataView, index, _vec2);
            (0, $0a0587bd8b0d58e8$export$849e31d725692576).setMaterial(dataView, index, options.material ? options.material : options.materials ? options.materials[id] : 0);
            (0, $0a0587bd8b0d58e8$export$849e31d725692576).setRounding(dataView, index, options.rounding ? options.rounding * this._boundsScaling : options.roundings ? options.roundings[id] * this._boundsScaling : 0);
            (0, $0a0587bd8b0d58e8$export$849e31d725692576).setSdfBuffer(dataView, index, options.sdfBuffer ? options.sdfBuffer : options.sdfBuffers ? options.sdfBuffers[id] : this._core.config.sdfBuffer);
            (0, $0a0587bd8b0d58e8$export$849e31d725692576).setSdfBorder(dataView, index, options.sdfBorder ? options.sdfBorder : options.sdfBorders ? options.sdfBorders[id] : this._core.config.sdfBorder);
        }
        buffer.update();
        this._core.log.write((0, $4a6417d29706362f$export$243e62d78d3b544d).info, `${this.constructor.name.toLowerCase()} update ${ids.length} ${Math.round(window.performance.now() - start)}ms`);
    }
}




/*!
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 */ 







/*!
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 */ /*!
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 */ class $f6a26e80c37065df$export$75b02b7d42a9cc20 {
    constructor(core){}
    loadText(file, completed, failed) {
        const reader = new FileReader();
        reader.onload = (event)=>{
            const text = event.target.result;
            completed(text);
        };
        reader.onerror = (event)=>{
            const error = event.target.error;
            failed(error.message);
        };
        reader.readAsText(file);
    }
    loadImage(file, completed, failed) {
        const image = new Image();
        image.onload = ()=>completed(image);
        image.onerror = (event)=>{
            const error = event.message;
            failed(error);
        };
        const reader = new FileReader();
        reader.onload = (event)=>{
            const text = event.target.result;
            image.src = text;
        };
        reader.onerror = (event)=>{
            const error = event.target.error;
            failed(error.message);
        };
        reader.readAsDataURL(file);
    }
    loadArrayBuffer(file, completed, failed) {
        const reader = new FileReader();
        reader.onload = (event)=>{
            const arrayBuffer = event.target.result;
            completed(arrayBuffer);
        };
        reader.onerror = (event)=>{
            const error = event.target.error;
            failed(error.message);
        };
        reader.readAsArrayBuffer(file);
    }
}


/*!
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 */ class $0c03094fe8bffa8b$export$f2a35cc03612aec1 {
    constructor(core){}
    loadText(url, completed, failed) {
        const request = new XMLHttpRequest();
        request.open("GET", url);
        request.onreadystatechange = ()=>{
            if (request.readyState == XMLHttpRequest.DONE) switch(request.status){
                case 200:
                    completed(request.responseText);
                    break;
                default:
                    failed(request.statusText);
                    break;
            }
        };
        request.send();
    }
    loadImage(url, completed, failed) {
        const image = new Image();
        image.onload = ()=>completed(image);
        image.onerror = (event)=>{
            const error = event.message;
            failed(error);
        };
        image.src = url;
    }
    loadArrayBuffer(url, completed, failed) {
        const request = new XMLHttpRequest();
        request.open("GET", url);
        request.responseType = "arraybuffer";
        request.onreadystatechange = ()=>{
            if (request.readyState == XMLHttpRequest.DONE) switch(request.status){
                case 200:
                    completed(request.response);
                    break;
                default:
                    failed(request.statusText);
                    break;
            }
        };
        request.send();
    }
}




/*!
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 */ 




var $2d9c5cad0d6d7650$exports = {};

$parcel$export($2d9c5cad0d6d7650$exports, "RendererBase", () => $a123db7d2af0bebc$export$30686c90897c890d);
$parcel$export($2d9c5cad0d6d7650$exports, "Basic", () => $124829f55b512dce$exports);
$parcel$export($2d9c5cad0d6d7650$exports, "Advanced", () => $04aa67b4630f0de9$exports);
$parcel$export($2d9c5cad0d6d7650$exports, "RayTraceWebGPU", () => $9824374ee38ba7ca$exports);
/*!
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 */ /*!
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 */ 


/*!
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 */ 





/*!
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 */ class $0a2e9437355c0494$export$caf2f326fb2d2fb4 {
    get imageData() {
        return this._imageData;
    }
    set imageData(value) {
        if (this._imageData != value) {
            this._imageData = value;
            this._changed = true;
        }
    }
    constructor(){
        this._imageData = null;
    }
    copyFrom(atlas) {
        if (atlas.imageData) {
            this._imageData = atlas.imageData;
            this._changed = true;
        } else this.imageData = null;
    }
    update() {}
}
class $0a2e9437355c0494$export$e47fdbcb2ea069e5 extends $0a2e9437355c0494$export$caf2f326fb2d2fb4 {
}


class $96371271bb28b98d$export$c1cecec923d96e5c {
    get isInitialized() {
        return this._isInitialized;
    }
    get ids() {
        return this._ids;
    }
    get dataView() {
        return this._dataView;
    }
    get vertices() {
        return this._vertices;
    }
    get lookup() {
        return this._lookup;
    }
    get length() {
        return this._length;
    }
    get selected() {
        return this._selected;
    }
    constructor(core, ids){
        this._core = core;
        this._ids = ids;
        this._length = ids.length;
        this._vertices = new ArrayBuffer(this._length * (0, $0a0587bd8b0d58e8$export$849e31d725692576).SIZE_BYTES);
        this._dataView = new DataView(this._vertices);
        this._selected = new Set();
        this.from = 0;
        this.to = 1;
        this.unitType = (0, $4a6417d29706362f$export$80d48287646c9e3b).block;
        this._lookup = {};
        for(let i = 0; i < this._length; i++){
            const id = ids[i];
            this._lookup[id] = i;
            (0, $0a0587bd8b0d58e8$export$849e31d725692576).setRotation(this._dataView, i, (0, $d4d7bd6cc65a5081$export$a002182e51710d39).QUAT_IDENTITY);
        }
    }
    createShared() {
        const buffer = Object.create(this);
        buffer._vertices = new ArrayBuffer(buffer._vertices.byteLength);
        buffer._dataView = new DataView(buffer._vertices);
        return buffer;
    }
    copyFrom(buffer) {
        const start = window.performance.now();
        const fromDataView = buffer.dataView;
        const toDataView = this._dataView;
        const lookup = buffer.lookup;
        for(let i = 0; i < this._length; i++){
            const index = lookup[this._ids[i]];
            if (index != null) {
                (0, $0a0587bd8b0d58e8$export$849e31d725692576).copyIdHover(fromDataView, index, toDataView, i);
                (0, $0a0587bd8b0d58e8$export$849e31d725692576).copyTranslation(fromDataView, index, toDataView, i);
                (0, $0a0587bd8b0d58e8$export$849e31d725692576).copyScale(fromDataView, index, toDataView, i);
                (0, $0a0587bd8b0d58e8$export$849e31d725692576).copyRotation(fromDataView, index, toDataView, i);
                (0, $0a0587bd8b0d58e8$export$849e31d725692576).copyColor(fromDataView, index, toDataView, i);
                (0, $0a0587bd8b0d58e8$export$849e31d725692576).copySelected(fromDataView, index, toDataView, i);
                (0, $0a0587bd8b0d58e8$export$849e31d725692576).copyMaterial(fromDataView, index, toDataView, i);
                (0, $0a0587bd8b0d58e8$export$849e31d725692576).copyRounding(fromDataView, index, toDataView, i);
                (0, $0a0587bd8b0d58e8$export$849e31d725692576).copyOrder(fromDataView, index, toDataView, i);
                (0, $0a0587bd8b0d58e8$export$849e31d725692576).copyTexCoord(fromDataView, index, toDataView, i);
                (0, $0a0587bd8b0d58e8$export$849e31d725692576).copyTexture(fromDataView, index, toDataView, i);
                (0, $0a0587bd8b0d58e8$export$849e31d725692576).copySdfBuffer(fromDataView, index, toDataView, i);
                (0, $0a0587bd8b0d58e8$export$849e31d725692576).copySdfBorder(fromDataView, index, toDataView, i);
                (0, $0a0587bd8b0d58e8$export$849e31d725692576).copyParameter1(fromDataView, index, toDataView, i);
                (0, $0a0587bd8b0d58e8$export$849e31d725692576).copyParameter2(fromDataView, index, toDataView, i);
            } else (0, $0a0587bd8b0d58e8$export$849e31d725692576).setRotation(toDataView, i, (0, $d4d7bd6cc65a5081$export$a002182e51710d39).QUAT_IDENTITY);
        }
        this.unitType = buffer.unitType;
        this._selected = buffer.selected;
        this._core.log.write((0, $4a6417d29706362f$export$243e62d78d3b544d).info, `buffer copied ${this._length} ${Math.round(window.performance.now() - start)}ms`);
    }
    update() {}
    updateSelection(options) {
        const start = window.performance.now();
        const ids = options && options.ids ? options.ids : this._ids;
        const offset = options && options.offset !== undefined ? options.offset : 0;
        const count = options && options.count !== undefined ? options.count : ids.length;
        const selection = this._selected.size > 0;
        const dataView = this._dataView;
        for(let i = 0; i < count; i++){
            const id = ids[i + offset];
            const index = this._lookup[id];
            (0, $0a0587bd8b0d58e8$export$849e31d725692576).setSelected(dataView, index, selection ? this._selected.has(id) ? 1 : -1 : 0);
        }
        this.update();
        this._core.log.write((0, $4a6417d29706362f$export$243e62d78d3b544d).info, `buffer update selection ${count} ${Math.round(window.performance.now() - start)}ms`);
    }
}
class $96371271bb28b98d$export$e17d4fc1dafc1240 {
    get pickIdLookup() {
        return this._pickIdLookup;
    }
    get currentBuffer() {
        return this._isBuffer1Current ? this._buffer1 : this._buffer2;
    }
    get previousBuffer() {
        return this._isBuffer1Current ? this._buffer2 : this._buffer1;
    }
    get currentPalette() {
        return this._isBuffer1Current ? this._palette1 : this._palette2;
    }
    get previousPalette() {
        return this._isBuffer1Current ? this._palette2 : this._palette1;
    }
    get currentAtlas() {
        return this._isBuffer1Current ? this._atlas1 : this._atlas2;
    }
    get previousAtlas() {
        return this._isBuffer1Current ? this._atlas2 : this._atlas1;
    }
    get isInitialized() {
        return this._isInitialized;
    }
    get length() {
        return this._length;
    }
    constructor(core, ids, bufferType, paletteType, atlasType){
        this.bufferType = bufferType;
        this.paletteType = paletteType;
        this.atlasType = atlasType;
        this._core = core;
        this._length = ids.length;
        this.id = $96371271bb28b98d$export$e17d4fc1dafc1240._id++;
        this.isVisible = true;
        this.transitionTime = 1;
        this.activeId = -1;
        const start = window.performance.now();
        this._buffer1 = new bufferType(core, ids);
        this._buffer2 = this._buffer1.createShared();
        this._palette1 = new paletteType();
        this._palette2 = new paletteType();
        this._atlas1 = new atlasType();
        this._atlas2 = new atlasType();
        this.isPickingEnabled = true;
        this._pickIdLookup = {};
        const dataView1 = this._buffer1.dataView;
        const dataView2 = this._buffer2.dataView;
        const _vec4 = (0, $4c4ac78b213a9c07$exports).create();
        for(let i = 0; i < this._length; i++){
            const id = ids[i];
            const pickId = (0, $a60d0d861ccf87e8$export$aadd933e49c67c12).nextPickId();
            this._pickIdLookup[pickId] = id;
            (0, $a60d0d861ccf87e8$export$aadd933e49c67c12).encodeNumber(pickId, (0, $4a6417d29706362f$export$6fc3f4da94ff0be0).data, _vec4);
            (0, $0a0587bd8b0d58e8$export$849e31d725692576).setIdColor(dataView1, i, _vec4);
            (0, $0a0587bd8b0d58e8$export$849e31d725692576).setIdColor(dataView2, i, _vec4);
        }
        this._core.log.write((0, $4a6417d29706362f$export$243e62d78d3b544d).info, `transition buffer created ${this._length} ${Math.round(window.performance.now() - start)}ms`);
    }
    swap() {
        this._isBuffer1Current = !this._isBuffer1Current;
    }
    copyFrom(transitionBuffer) {
        const start = window.performance.now();
        this.key = transitionBuffer.key;
        this.isVisible = transitionBuffer.isVisible;
        this.transitionTime = transitionBuffer.transitionTime;
        this.isPickingEnabled = transitionBuffer.isPickingEnabled;
        this.unitType = transitionBuffer.unitType;
        this.activeId = transitionBuffer.activeId;
        this.currentBuffer.copyFrom(transitionBuffer.currentBuffer);
        this.previousBuffer.copyFrom(transitionBuffer.previousBuffer);
        this.currentBuffer.update();
        this.previousBuffer.update();
        this.currentPalette.copyFrom(transitionBuffer.currentPalette);
        this.previousPalette.copyFrom(transitionBuffer.previousPalette);
        this.currentAtlas.copyFrom(transitionBuffer.currentAtlas);
        this.previousAtlas.copyFrom(transitionBuffer.previousAtlas);
        this._core.log.write((0, $4a6417d29706362f$export$243e62d78d3b544d).info, `transition buffer copied ${this._length} ${Math.round(window.performance.now() - start)}ms`);
    }
}
$96371271bb28b98d$export$e17d4fc1dafc1240._id = 1;
class $96371271bb28b98d$export$a143d493d941bafc extends $96371271bb28b98d$export$c1cecec923d96e5c {
    constructor(core, ids){
        super(core, ids);
    }
}
class $96371271bb28b98d$export$76de936b3c1c4170 extends $96371271bb28b98d$export$e17d4fc1dafc1240 {
    constructor(core, ids){
        super(core, ids, $96371271bb28b98d$export$a143d493d941bafc, (0, $548ced3eab978a8c$export$e2fbaa661ec19dbf), (0, $0a2e9437355c0494$export$e47fdbcb2ea069e5));
    }
}




/*!
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 */ 



class $7a3b6a33153aecaf$export$6a68d8f4c3236d92 {
    get vertices() {
        return this._vertices;
    }
    get indices() {
        return this._indices;
    }
    get indexCount() {
        return this._indexCount;
    }
    get isInitialized() {
        return this._isInitialized;
    }
    initialize() {
        let vertexOffset = 0;
        let indexOffset = 0;
        const axisVertices = (0, $c2c30e4dcf8004c5$export$a15f0a83a652dd40).POSITIONS;
        const axisIndices = (0, $c2c30e4dcf8004c5$export$a15f0a83a652dd40).INDICES;
        this._vertices = new ArrayBuffer(3 * (0, $0a0587bd8b0d58e8$export$6597d9a580deb707).SIZE_BYTES * axisVertices.length / (0, $0a0587bd8b0d58e8$export$5b33f080c7f6c861).SIZE);
        const verticesView = new DataView(this._vertices);
        this._indices = new Uint16Array(3 * axisIndices.length + 4);
        const vertexCount = axisVertices.length / (0, $0a0587bd8b0d58e8$export$5b33f080c7f6c861).SIZE;
        const indexCount = axisIndices.length;
        const transform = (0, $1ac1b59392edf35b$exports).create();
        const length = 1;
        const width = 0.01;
        transform[0] = length;
        transform[5] = width;
        transform[10] = width;
        transform[12] = 0.5;
        transform[13] = 0;
        transform[14] = 0;
        this._createAxis(axisVertices, axisIndices, verticesView, this._indices, (0, $d4d7bd6cc65a5081$export$a002182e51710d39).VECTOR3_UNITX, transform, vertexOffset, indexOffset);
        indexOffset += indexCount;
        this._indices[indexOffset++] = axisIndices[indexCount - 1] + vertexOffset;
        vertexOffset += vertexCount;
        this._indices[indexOffset++] = axisIndices[0] + vertexOffset;
        transform[0] = width;
        transform[5] = length;
        transform[10] = width;
        transform[12] = 0;
        transform[13] = 0.5;
        transform[14] = 0;
        this._createAxis(axisVertices, axisIndices, verticesView, this._indices, (0, $d4d7bd6cc65a5081$export$a002182e51710d39).VECTOR3_UNITY, transform, vertexOffset, indexOffset);
        indexOffset += indexCount;
        this._indices[indexOffset++] = axisIndices[indexCount - 1] + vertexOffset;
        vertexOffset += vertexCount;
        this._indices[indexOffset++] = axisIndices[0] + vertexOffset;
        transform[0] = width;
        transform[5] = width;
        transform[10] = length;
        transform[12] = 0;
        transform[13] = 0;
        transform[14] = 0.5;
        this._createAxis(axisVertices, axisIndices, verticesView, this._indices, (0, $d4d7bd6cc65a5081$export$a002182e51710d39).VECTOR3_UNITZ, transform, vertexOffset, indexOffset);
        this._indexCount = this._indices.length;
        this._isInitialized = true;
    }
    update(elapsedTime) {}
    _createAxis(axisVertices, axisIndices, verticesView, indices, color, transform, vertexOffset, indexOffset) {
        const position = (0, $31054a6c69637582$exports).create();
        const vertexCount = axisVertices.length / (0, $0a0587bd8b0d58e8$export$5b33f080c7f6c861).SIZE;
        const indexCount = axisIndices.length;
        for(let i = 0; i < vertexCount; i++){
            (0, $31054a6c69637582$exports).set(position, axisVertices[i * (0, $0a0587bd8b0d58e8$export$5b33f080c7f6c861).SIZE], axisVertices[i * (0, $0a0587bd8b0d58e8$export$5b33f080c7f6c861).SIZE + 1], axisVertices[i * (0, $0a0587bd8b0d58e8$export$5b33f080c7f6c861).SIZE + 2]);
            (0, $31054a6c69637582$exports).transformMat4(position, position, transform);
            (0, $0a0587bd8b0d58e8$export$6597d9a580deb707).setPosition(verticesView, vertexOffset + i, position);
            (0, $0a0587bd8b0d58e8$export$6597d9a580deb707).setColor(verticesView, vertexOffset + i, color);
        }
        for(let i = 0; i < indexCount; i++)indices[indexOffset + i] = axisIndices[i] + vertexOffset;
    }
}





var $a123db7d2af0bebc$var$__awaiter = undefined && undefined.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
            resolve(value);
        });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
            try {
                step(generator.next(value));
            } catch (e) {
                reject(e);
            }
        }
        function rejected(value) {
            try {
                step(generator["throw"](value));
            } catch (e) {
                reject(e);
            }
        }
        function step(result) {
            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
class $a123db7d2af0bebc$export$ecd9923dfd29c8e1 {
    reset() {}
}
class $a123db7d2af0bebc$export$30686c90897c890d {
    get isInitialized() {
        return this._isInitialized;
    }
    get config() {
        return this._config;
    }
    get devicePixelRatio() {
        return this._devicePixelRatio;
    }
    get width() {
        return this._canvas.width;
    }
    set width(value) {
        this._options.width = value;
    }
    get height() {
        return this._canvas.height;
    }
    set height(value) {
        this._options.height = value;
    }
    get webXRReferenceSpace() {
        return this._webXRReferenceSpace;
    }
    get pickedType() {
        return this._pickedType;
    }
    get pickedId() {
        return this._pickedId;
    }
    get isCapturingPickImage() {
        return this._isCapturingPickImage;
    }
    capturePickImage() {
        this._isCapturingPickImage = true;
    }
    get backgroundColor() {
        return this._backgroundColor;
    }
    set backgroundColor(value) {
        if (!(0, $4c4ac78b213a9c07$exports).exactEquals(value, this._backgroundColor)) this._backgroundColor = value;
    }
    get currentAxes() {
        return this._isAxes1Current ? this._axes1 : this._axes2;
    }
    set currentAxes(value) {
        if (this._isAxes1Current) this._axes1 = value;
        else this._axes2 = value;
    }
    get previousAxes() {
        return this._isAxes1Current ? this._axes2 : this._axes1;
    }
    set previousAxes(value) {
        if (this._isAxes1Current) this._axes2 = value;
        else this._axes1 = value;
    }
    swapAxes() {
        this._isAxes1Current = !this._isAxes1Current;
    }
    createCartesian2dAxesVisual(axes) {
        return new (0, $2e2b6f93796e9c8a$export$e784925068633981)(axes);
    }
    createCartesian3dAxesVisual(axes) {
        return new (0, $2e2b6f93796e9c8a$export$e784925068633981)(axes);
    }
    _createDebugAxesVisual(debugAxes) {
        return null;
    }
    createLabelSetVisual(labelSet) {
        return new (0, $715a174735ed4fbb$export$97e93e7019ef67b9)(labelSet);
    }
    createControllerVisual(controller) {
        return new (0, $6c3dd367ac3ca617$export$c6e88a9dc8138322)(controller);
    }
    createTransitionBuffer(ids) {
        return new (0, $96371271bb28b98d$export$76de936b3c1c4170)(this._core, ids);
    }
    createImageVisual(image) {
        return new (0, $f7de7bdc7bccbb25$export$6f251cd327b2ff1)(image);
    }
    createFontVisual(font) {
        return new (0, $f690fa88528736e9$export$e784a6eab4d2d700)(font);
    }
    constructor(options){
        this._options = options;
        this.fonts = {};
    }
    get isWebXRSupported() {
        return false;
    }
    initialize(core) {
        this._core = core;
        this._canvas = document.createElement("canvas");
        const contextmenu = this._options && this._options.contextmenu;
        if (!contextmenu) this._canvas.addEventListener("contextmenu", (e)=>{
            e.preventDefault();
        });
        this._canvas.tabIndex = this._core.container.tabIndex;
        this._canvas.style.display = "block";
        this._canvas.style.touchAction = "none";
        this._core.container.appendChild(this._canvas);
        this._mvMatrices = [
            (0, $1ac1b59392edf35b$exports).create(),
            (0, $1ac1b59392edf35b$exports).create()
        ];
        this.pickPMatrix = (0, $1ac1b59392edf35b$exports).create();
        this.axesVisibility = (0, $4a6417d29706362f$export$7dbc7c2b82487e42).current;
        this._debugAxes = new (0, $7a3b6a33153aecaf$export$6a68d8f4c3236d92)();
        this._debugAxesVisual = this._createDebugAxesVisual(this._debugAxes);
        this.transitionTime = 1;
        this.transitionBuffers = [];
        this.areLabelsVisible = true;
        this.labelSets = [];
        this.controllers = [];
        this.areImagesVisible = true;
        this.images = [];
        this._viewports = [
            new DOMRect(),
            new DOMRect()
        ];
        this.isPickingEnabled = false;
        this._pickedType = (0, $4a6417d29706362f$export$6fc3f4da94ff0be0).none;
        this._pickedId = 0;
        this._lassoMMatrix = (0, $1ac1b59392edf35b$exports).create();
        this._lassoThickness = (0, $91b0cc4981465964$exports).create();
        this._resizeMinimumDelay = -1;
        this._previousResizeWidth = -1;
        this._previousResizeHeight = -1;
    }
    remove() {
        this._core.container.removeChild(this._canvas);
    }
    finalize() {
        this._isInitialized = false;
    }
    setSize(elapsedTime) {
        if (this._options && this._options.width && this._options.height) {
            this._devicePixelRatio = 1;
            this._resizeWidth = this._options.width;
            this._resizeHeight = this._options.height;
        } else {
            this._devicePixelRatio = window.devicePixelRatio || 1;
            this._resizeWidth = this._core.container.clientWidth * devicePixelRatio;
            this._resizeHeight = this._core.container.clientHeight * devicePixelRatio;
        }
        if (this._resizeWidth != this._previousResizeWidth || this._resizeHeight != this._previousResizeHeight) {
            this._previousResizeWidth = this._resizeWidth;
            this._previousResizeHeight = this._resizeHeight;
            this._isResizing = true;
            this._resizeElapsedTime = elapsedTime;
        }
        if (this._isResizing) {
            if (this._resizeElapsedTime > this._resizeMinimumDelay && this._isInitialized) {
                this._isResizing = false;
                this._resizeMinimumDelay = this._core.config.resizeMinimumDelay;
                this._resize(this._resizeWidth, this._resizeHeight);
            } else this._resizeElapsedTime += elapsedTime;
        }
    }
    _resize(width, height) {
        this._canvas.style.width = `${Math.floor(width / this._devicePixelRatio)}px`;
        this._canvas.style.height = `${Math.floor(height / this._devicePixelRatio)}px`;
        width = Math.floor(width);
        height = Math.floor(height);
        this._canvas.width = width;
        this._canvas.height = height;
    }
    update(elapsedTime) {
        for(let i = 0; i < this.transitionBuffers.length; i++){
            const transitionBuffer = this.transitionBuffers[i];
            if (transitionBuffer.isVisible) {
                const previous = transitionBuffer.previousPalette;
                const current = transitionBuffer.currentPalette;
                if (previous) previous.update();
                if (current) current.update();
            }
        }
        for(let i = 0; i < this.transitionBuffers.length; i++){
            const transitionBuffer = this.transitionBuffers[i];
            if (transitionBuffer.isVisible) {
                const previous = transitionBuffer.previousAtlas;
                const current = transitionBuffer.currentAtlas;
                if (previous) previous.update();
                if (current) current.update();
            }
        }
        if (this._core.config.isDebugVisible) {
            if (this._debugAxesVisual) {
                this._debugAxesVisual.mMatrix = this.mMatrix;
                this._debugAxesVisual.vMatrices = this.vMatrices;
                this._debugAxesVisual.pMatrices = this.pMatrices;
                this._debugAxesVisual.viewports = this._viewports;
                this._debugAxesVisual.viewportOffset = this._viewportOffset;
                this._debugAxesVisual.viewportCount = this._viewportCount;
            }
        }
        if (this.areLabelsVisible) for(let i = 0; i < this.labelSets.length; i++){
            const labelSetVisual = this.labelSets[i];
            if (labelSetVisual.isVisible) {
                this.labelSets[i].label.update(elapsedTime);
                labelSetVisual.mMatrix = this.mMatrix;
                labelSetVisual.vMatrices = this.vMatrices;
                labelSetVisual.pMatrices = this.pMatrices;
                labelSetVisual.isPickingEnabled = this.isPickingEnabled;
                labelSetVisual.pickPMatrix = this.pickPMatrix;
                labelSetVisual.pickVMatrix = this.pickVMatrix;
                labelSetVisual.viewports = this._viewports;
                labelSetVisual.viewportOffset = this._viewportOffset;
                labelSetVisual.viewportCount = this._viewportCount;
                labelSetVisual.update(elapsedTime);
            }
        }
        if (this.areImagesVisible) for(let i = 0; i < this.images.length; i++){
            const imageVisual = this.images[i];
            if (imageVisual && imageVisual.isVisible) {
                const image = this.images[i].image;
                image.update(elapsedTime);
                imageVisual.mMatrix = this.mMatrix;
                imageVisual.vMatrices = this.vMatrices;
                imageVisual.pMatrices = this.pMatrices;
                imageVisual.isPickingEnabled = this.isPickingEnabled;
                imageVisual.pickPMatrix = this.pickPMatrix;
                imageVisual.pickVMatrix = this.pickVMatrix;
                imageVisual.viewports = this._viewports;
                imageVisual.viewportOffset = this._viewportOffset;
                imageVisual.viewportCount = this._viewportCount;
                imageVisual.update(elapsedTime);
            }
        }
        for(let i = 0; i < this.controllers.length; i++){
            const controllerVisual = this.controllers[i];
            if (controllerVisual.isVisible) {
                const controller = this.controllers[i].controller;
                controller.update(elapsedTime);
                controllerVisual.vMatrices = this.vMatrices;
                controllerVisual.inverseVMatrices = this.vMatrices;
                controllerVisual.pMatrices = this.pMatrices;
                controllerVisual.viewports = this._viewports;
                controllerVisual.viewportOffset = this._viewportOffset;
                controllerVisual.viewportCount = this._viewportCount;
                controllerVisual.update(elapsedTime);
            }
        }
        const axesVisuals = this.axesVisibility == (0, $4a6417d29706362f$export$7dbc7c2b82487e42).current ? this.currentAxes : this.axesVisibility == (0, $4a6417d29706362f$export$7dbc7c2b82487e42).previous ? this.previousAxes : null;
        if (axesVisuals) for(let i = 0; i < axesVisuals.length; i++){
            const axesVisual = axesVisuals[i];
            if (axesVisual.isVisible) {
                const axes = axesVisual.axes;
                axes.mMatrix = this.mMatrix;
                axes.vMatrix = this.vMatrices[0];
                axes.update(elapsedTime);
                axesVisual.vMatrices = this.vMatrices;
                axesVisual.pMatrices = this.pMatrices;
                axesVisual.isPickingEnabled = this.isPickingEnabled;
                axesVisual.pickPMatrix = this.pickPMatrix;
                axesVisual.pickVMatrix = this.pickVMatrix;
                axesVisual.viewports = this._viewports;
                axesVisual.viewportOffset = this._viewportOffset;
                axesVisual.viewportCount = this._viewportCount;
                axesVisual.update(elapsedTime);
            }
        }
        for(const key in this.fonts){
            const fontVisual = this.fonts[key];
            const font = fontVisual.font;
            font.update();
            fontVisual.update();
        }
    }
    getVertexPosition(position, pickedId) {
        for(let i = 0; i < this.transitionBuffers.length; i++){
            const transitionBuffer = this.transitionBuffers[i];
            const id = transitionBuffer.pickIdLookup[pickedId];
            if (id > -1) {
                const index = transitionBuffer.currentBuffer.lookup[id];
                const dataView = transitionBuffer.currentBuffer.dataView;
                (0, $0a0587bd8b0d58e8$export$849e31d725692576).getTranslation(dataView, index, position);
                break;
            }
        }
    }
    render(elapsedTime, xrFrame) {
        return $a123db7d2af0bebc$var$__awaiter(this, void 0, void 0, function*() {});
    }
    prepare(xrFrame) {}
    initializeWebXR(session) {
        return null;
    }
}


var $124829f55b512dce$exports = {};

$parcel$export($124829f55b512dce$exports, "Main", () => $2a4365468a86449a$export$861edd1ccea2f746);
/*!
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 */ /*!
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 */ 


/*!
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 */ 

class $1216b11de4c14ee0$export$7005c9eb6671414d {
    get isInitialized() {
        return this._isInitialized;
    }
    get vertexBuffer() {
        return this._vertexBuffer;
    }
    get indexBuffer() {
        return this._indexBuffer;
    }
    get indexCount() {
        return this._indexCount;
    }
    initializeContext(gl) {
        const _vec3 = (0, $31054a6c69637582$exports).fromValues(2, 2, 2);
        const _mat4 = (0, $1ac1b59392edf35b$exports).create();
        (0, $1ac1b59392edf35b$exports).fromScaling(_mat4, _vec3);
        const vertices = (0, $3ce6ee188e300946$export$7005c9eb6671414d).positions(_mat4);
        this._vertexBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, this._vertexBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW);
        const indices = (0, $3ce6ee188e300946$export$7005c9eb6671414d).INDICES;
        this._indexBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this._indexBuffer);
        gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, indices, gl.STATIC_DRAW);
        this._indexCount = indices.length;
        this._isInitialized = true;
    }
}


/*!
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 */ 

/*!
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 */ 

class $0ec62dfde3a79455$export$e47fdbcb2ea069e5 extends (0, $0a2e9437355c0494$export$caf2f326fb2d2fb4) {
    get texture() {
        return this._texture;
    }
    get defaultTexture() {
        return this._defaultTexture;
    }
    initializeContext(core, gl) {
        this._gl = gl;
        this._defaultTexture = (0, $a25f5529f6cda489$export$c41e4fcbf45db179).create(gl, 1, 1, gl.RGBA, gl.UNSIGNED_BYTE, gl.NEAREST, new Uint8Array([
            0xff,
            0xff,
            0xff,
            0xff
        ]));
        this._updateTexture();
    }
    update() {
        super.update();
        if (this._changed) {
            this._changed = false;
            this._updateTexture();
        }
    }
    _updateTexture() {
        if (this._imageData) this._texture = (0, $a25f5529f6cda489$export$c41e4fcbf45db179).fromImage(this._gl, this._imageData, false, this._gl.LINEAR);
        else this._texture = null;
    }
}


/*!
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 */ 

class $3e5fc0fd110780c6$export$e2fbaa661ec19dbf extends (0, $548ced3eab978a8c$export$f05ab453e1597580) {
    get texture() {
        return this._texture;
    }
    get defaultTexture() {
        return this._defaultTexture;
    }
    initializeContext(core, gl) {
        this._gl = gl;
        this._defaultTexture = (0, $a25f5529f6cda489$export$c41e4fcbf45db179).create(gl, 1, 1, gl.RGBA, gl.UNSIGNED_BYTE, gl.NEAREST, core.config.paletteColor);
        this._updateTexture();
    }
    update() {
        super.update();
        if (this._changed) {
            this._changed = false;
            this._updateTexture();
        }
    }
    _updateTexture() {
        if (this._colors) {
            const colors = new Uint8Array(this._colors);
            for(let i = 0; i < colors.length; i++)colors[i] = Math.pow(colors[i] / 0xff, 2.2) * 0xff;
            this._texture = (0, $a25f5529f6cda489$export$c41e4fcbf45db179).create(this._gl, this._colors.length / 4, 1, this._gl.RGBA, this._gl.UNSIGNED_BYTE, this._gl.NEAREST, colors);
        } else this._texture = null;
    }
}


class $d5b49779b59f8b97$export$a143d493d941bafc extends (0, $96371271bb28b98d$export$c1cecec923d96e5c) {
    get vertexBuffer() {
        return this._vertexBuffer;
    }
    initializeContext(gl) {
        this._gl = gl;
        this._vertexBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, this._vertexBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, this._vertices, gl.STATIC_DRAW);
        this._isInitialized = true;
    }
    update() {
        if (this._isInitialized) {
            const start = window.performance.now();
            this._gl.bindBuffer(this._gl.ARRAY_BUFFER, this._vertexBuffer);
            this._gl.bufferSubData(this._gl.ARRAY_BUFFER, 0, this._vertices);
            this._core.log.write((0, $4a6417d29706362f$export$243e62d78d3b544d).info, `buffer updated ${this._length} ${Math.round(window.performance.now() - start)}ms`);
        }
    }
}
class $d5b49779b59f8b97$export$76de936b3c1c4170 extends (0, $96371271bb28b98d$export$e17d4fc1dafc1240) {
    constructor(core, ids){
        super(core, ids, $d5b49779b59f8b97$export$a143d493d941bafc, (0, $3e5fc0fd110780c6$export$e2fbaa661ec19dbf), (0, $0ec62dfde3a79455$export$e47fdbcb2ea069e5));
    }
    initializeContext(gl) {
        this._buffer1.initializeContext(gl);
        this._buffer2.initializeContext(gl);
        this._palette1.initializeContext(this._core, gl);
        this._palette2.initializeContext(this._core, gl);
        this._atlas1.initializeContext(this._core, gl);
        this._atlas2.initializeContext(this._core, gl);
        this._isInitialized = true;
    }
}


/*!
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 */ 



class $3a96f4e19473eeaa$export$29cd7b75162a9425 extends (0, $a123db7d2af0bebc$export$ecd9923dfd29c8e1) {
    constructor(){
        super();
        this.reset();
    }
    reset() {
        this.specularIntensity = 0.15;
        this.specularPower = 150;
        this.lightPosition = (0, $31054a6c69637582$exports).fromValues(-0.5, 0.5, 0);
        this.ambient = 0.01;
        const _quat1 = (0, $39ece26d1239bb77$exports).create();
        const _quat2 = (0, $39ece26d1239bb77$exports).create();
        let angle = (0, $a49c65c28e06311e$export$210d3b2db589eb5c).degreesToRadians(15);
        (0, $39ece26d1239bb77$exports).setAxisAngle(_quat1, (0, $d4d7bd6cc65a5081$export$a002182e51710d39).VECTOR3_UNITX, angle);
        (0, $39ece26d1239bb77$exports).multiply(_quat2, _quat1, _quat2);
        angle = (0, $a49c65c28e06311e$export$210d3b2db589eb5c).degreesToRadians(-15);
        (0, $39ece26d1239bb77$exports).setAxisAngle(_quat1, (0, $d4d7bd6cc65a5081$export$a002182e51710d39).VECTOR3_UNITY, angle);
        (0, $39ece26d1239bb77$exports).multiply(_quat2, _quat2, _quat1);
        this.directionToLight = (0, $31054a6c69637582$exports).create();
        (0, $31054a6c69637582$exports).transformQuat(this.directionToLight, (0, $d4d7bd6cc65a5081$export$a002182e51710d39).VECTOR3_UNITZ, _quat2);
        this.halfAngle = (0, $31054a6c69637582$exports).create();
        (0, $31054a6c69637582$exports).add(this.halfAngle, (0, $d4d7bd6cc65a5081$export$a002182e51710d39).VECTOR3_UNITZ, this.directionToLight);
        (0, $31054a6c69637582$exports).normalize(this.halfAngle, this.halfAngle);
        this.isFxaaEnabled = false;
    }
}


/*!
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 */ 

class $5ea895789fc20d6f$export$e9a269813a6315a4 {
    bindFramebuffer(framebuffer) {
        if (this.framebuffer != framebuffer) {
            this.framebuffer = framebuffer;
            this._gl.bindFramebuffer(this._gl.FRAMEBUFFER, framebuffer);
        }
    }
    initializeContext(gl) {
        this._gl = gl;
        this.framebuffer = this._gl.createFramebuffer();
        this.ANGLE_instanced_arrays = gl.getExtension("ANGLE_instanced_arrays");
        this.OES_standard_derivatives = gl.getExtension("OES_standard_derivatives");
        this.EXT_frag_depth = gl.getExtension("EXT_frag_depth");
        this.OES_element_index_uint = gl.getExtension("OES_element_index_uint");
        this.WEBGL_lose_context = gl.getExtension("WEBGL_lose_context");
    }
}
$5ea895789fc20d6f$export$e9a269813a6315a4.glsl = {
    "anaglyph.fragment.fx": "#version 100\n#ifdef GL_FRAGMENT_PRECISION_HIGH\nprecision highp float;\n#else\nprecision mediump float;\n#endif\n#include \"common.include.fx\"\nuniform vec4 uViewport;\nuniform sampler2D uSampler1;\nuniform sampler2D uSampler2;\nconst vec3 LEFT_MASK = vec3(1.0, 0.0, 0.0);\nconst vec3 RIGHT_MASK = vec3(0.0, 1.0, 1.0);\nvoid main() {\nvec2 texCoords = (gl_FragCoord.xy - uViewport.xy) / uViewport.zw;\nvec3 color = LEFT_MASK * dot(texture2D(uSampler1, texCoords).rgb, LUMINANCE);\ncolor += RIGHT_MASK * dot(texture2D(uSampler2, texCoords).rgb, LUMINANCE);\ngl_FragColor = vec4(color, 1.0);\n}\n",
    "color.fragment.fx": "#version 100\n#ifdef GL_FRAGMENT_PRECISION_HIGH\nprecision highp float;\n#else\nprecision mediump float;\n#endif\n#include \"common.include.fx\"\nvarying lowp vec3 vColor;\nvoid main(void)\n{\ngl_FragColor = vec4(pow(vColor, GAMMA), 1.0);\n}\n",
    "color.vertex.fx": "#version 100\nattribute vec3 aPosition;\nattribute lowp vec3 aColor;\nuniform mat4 uMMatrix;\nuniform mat4 uVMatrix;\nuniform mat4 uPMatrix;\nvarying lowp vec3 vColor;\nvoid main(void) {\ngl_Position = uPMatrix * uVMatrix * uMMatrix * vec4(aPosition, 1.0);\nvColor = aColor;\n}\n",
    "lasso.fragment.fx": "#version 100\n#ifdef GL_FRAGMENT_PRECISION_HIGH\nprecision highp float;\n#else\nprecision mediump float;\n#endif\n#include \"common.include.fx\"\nuniform vec3 uColor;\nuniform vec2 uThickness;\nuniform float uDashWidth;\nvarying mediump vec2 vTexCoord;\nvoid main(void)\n{\nvec2 distance = min(vTexCoord, 1.0 - vTexCoord);\nif (distance.x > uThickness.x && distance.y > uThickness.y) {\ndiscard;\n}\nvec2 texCoord = vec2(vTexCoord.x, 1.0 - vTexCoord.y);\nvec2 thickness = uThickness * uDashWidth;\nvec2 b = mod(floor(texCoord / thickness), 2.0);\nif (b.x > 0.0 && texCoord.x < 1.0 - thickness.x) {\ndiscard;\n}\nif (b.y > 0.0 && texCoord.y < 1.0 - thickness.y) {\ndiscard;\n}\ngl_FragColor = vec4(pow(uColor, GAMMA), 1.0);\n}\n",
    "lasso.vertex.fx": "#version 100\nattribute vec3 aPosition;\nattribute mediump vec2 aTexCoord;\nuniform mat4 uMMatrix;\nvarying mediump vec2 vTexCoord;\nvoid main(void) {\ngl_Position = uMMatrix * vec4(aPosition, 1.0);\nvTexCoord = aTexCoord;\n}\n",
    "model.fragment.fx": "#version 100\n#ifdef GL_FRAGMENT_PRECISION_HIGH\nprecision highp float;\n#else\nprecision mediump float;\n#endif\n#include \"common.include.fx\"\nuniform sampler2D uSampler;\nuniform vec3 uDirectionToLight;\nuniform vec3 uHalfAngle;\nuniform float uSpecularPower;\nuniform float uSpecularIntensity;\nvarying mediump vec3 vNormal;\nvarying mediump vec2 vTexCoord;\nvoid main(void)\n{\ngl_FragColor = vec4(pow(texture2D(uSampler, vTexCoord).xyz, GAMMA), 1.0);\nvec3 color = texture2D(uSampler, vTexCoord).xyz;\nfloat ambient = 0.01;\nvec3 normal = normalize(vNormal);\nfloat diffuse = 0.5 * max(dot(uDirectionToLight, normal), 0.0);\nfloat specular = pow(clamp(dot(normal, uHalfAngle), 0.0, 1.0), uSpecularPower) * uSpecularIntensity;\ncolor *= (ambient + diffuse);\ncolor += specular;\ncolor = pow(color, GAMMA);\ngl_FragColor = vec4(color, 1.0);\n}\n",
    "model.vertex.fx": "#version 100\nattribute vec3 aPosition;\nattribute mediump vec3 aNormal;\nattribute mediump vec2 aTexCoord;\nuniform mat4 uMMatrix;\nuniform mat4 uVMatrix;\nuniform mat4 uPMatrix;\nvarying mediump vec3 vNormal;\nvarying mediump vec2 vTexCoord;\nvoid main(void) {\nvTexCoord = aTexCoord;\nmat4 mvMatrix = uVMatrix * uMMatrix;\nvNormal = vec3(mvMatrix * vec4(aNormal, 0.0));\ngl_Position = uPMatrix * mvMatrix * vec4(aPosition, 1.0);\n}\n",
    "pickgrid.fragment.fx": "#version 100\n#ifdef GL_FRAGMENT_PRECISION_HIGH\nprecision highp float;\n#else\nprecision mediump float;\n#endif\n#include \"common.include.fx\"\n#define Derivatives\nuniform bool uPick;\nuniform vec2 uFaceSize;\nuniform vec3 uMajorColor;\nuniform vec3 uMinorColor;\nuniform vec3 uZeroColor;\nuniform float uMajorThickness;\nuniform float uMinorThickness;\nuniform float uZeroThickness;\nuniform vec2 uZero;\nuniform vec2 uMinorGridlines;\nuniform vec3 uDirectionToLight;\nvarying lowp vec4 vColor;\nvarying mediump vec2 vTexCoord;\nvarying mediump vec4 vBounds;\nvarying mediump vec3 vNormal;\n#ifdef Derivatives\n#extension GL_OES_standard_derivatives : enable\n#endif\nvoid main(void) {\nif (uPick)\n{\ngl_FragColor = vColor;\n}\nelse\n{\nvec2 buffer;\n#ifdef Derivatives\nbuffer = fwidth(vTexCoord);\n#else\nbuffer = vec2(0.002);\n#endif\nvec2 distance, thickness, step;\nvec4 color = vColor;\nvec2 width = vBounds.zw - vBounds.xy;\ndistance = (vTexCoord - vBounds.xy) / width;\ndistance = min(abs(distance - floor(uMinorGridlines * distance) / uMinorGridlines), abs(distance - ceil(uMinorGridlines * distance) / uMinorGridlines));\ndistance *= width;\nthickness = vec2(uMinorThickness) / uFaceSize;\nstep = smoothstep(thickness, thickness + buffer, distance);\ncolor.xyz = mix(uMinorColor, color.xyz, min(step.x, step.y));\nthickness = vec2(uMajorThickness) / uFaceSize;\ndistance = min(vTexCoord - vBounds.xy, vBounds.zw - vTexCoord);\nstep = smoothstep(thickness, thickness + buffer, distance);\ncolor.xyz = mix(uMajorColor, color.xyz, min(step.x, step.y));\ndistance = abs(vTexCoord - uZero);\nthickness = vec2(uZeroThickness) / uFaceSize;\nstep = smoothstep(thickness, thickness + buffer, distance);\ncolor.xyz = mix(uZeroColor, color.xyz, min(step.x, step.y));\nfloat diffuse = 0.2 * max(dot(uDirectionToLight, vNormal), 0.0);\nfloat ambient = 0.8;\ncolor.xyz *= (ambient + diffuse);\ncolor.xyz = pow(color.xyz, GAMMA);\ngl_FragColor = color;\n}\n}\n",
    "pickgrid.vertex.fx": "#version 100\nattribute vec3 aPosition;\nattribute lowp vec4 aIdColor;\nattribute mediump vec2 aTexCoord;\nattribute mediump vec3 aNormal;\nattribute mediump vec4 aBounds;\nuniform mat4 uMMatrix;\nuniform mat4 uVMatrix;\nuniform mat4 uPMatrix;\nuniform bool uPick;\nuniform vec4 uPickedIdColor;\nuniform vec3 uBackground;\nuniform vec3 uHighlight;\nvarying lowp vec4 vColor;\nvarying mediump vec2 vTexCoord;\nvarying mediump vec4 vBounds;\nvarying mediump vec3 vNormal;\nvoid main(void) {\nmat4 mvMatrix = uVMatrix * uMMatrix;\nvNormal = normalize(vec3(mvMatrix * vec4(aNormal, 0.0)));\nvTexCoord = aTexCoord;\nvBounds = aBounds;\ngl_Position = uPMatrix * mvMatrix * vec4(aPosition, 1.0);\nif (uPick)\n{\nvColor = aIdColor;\n}\nelse\n{\nvColor = uPickedIdColor == aIdColor ? vec4(uHighlight, 1.0) : vColor = vec4(uBackground, 1.0);\n}\n}\n",
    "sdftext.fragment.fx": "#version 100\n#ifdef GL_FRAGMENT_PRECISION_HIGH\nprecision highp float;\n#else\nprecision mediump float;\n#endif\n#include \"common.include.fx\"\n#define Derivatives\nuniform sampler2D uSampler;\nuniform bool uPick;\nuniform vec3 uColor;\nuniform vec3 uHoverColor;\nuniform float uGamma;\nuniform vec3 uBorderColor;\nuniform float uBuffer;\nuniform float uBorderWidth;\nvarying mediump vec2 vTexCoord;\nvarying lowp vec4 vIdColor;\nvarying lowp float vHover;\n#ifdef Derivatives\n#extension GL_OES_standard_derivatives : enable\n#endif\nvoid main(void) {\nif (uPick) {\ngl_FragColor = vIdColor;\n}\nelse {\nfloat distance = texture2D(uSampler, vTexCoord).r;\nif (distance < uBuffer - uBorderWidth) {\ndiscard;\n}\nfloat gamma;\n#ifdef Derivatives\ngamma = fwidth(distance);\n#else\ngamma = uGamma;\n#endif\nfloat value = smoothstep(uBuffer - gamma, uBuffer + gamma, distance);\ngl_FragColor = vec4(pow(mix(uBorderColor, mix(uColor, uHoverColor, vHover), value), GAMMA), 1.0);\n}\n}\n",
    "sdftext.vertex.fx": "#version 100\nattribute lowp vec4 aIdColor;\nattribute vec3 aPosition;\nattribute mediump vec2 aTexCoord;\nuniform mat4 uMMatrix;\nuniform mat4 uVMatrix;\nuniform mat4 uPMatrix;\nuniform vec4 uPickedIdColor;\nvarying mediump vec2 vTexCoord;\nvarying lowp vec4 vIdColor;\nvarying lowp float vHover;\nvoid main(void) {\ngl_Position = uPMatrix * uVMatrix * uMMatrix * vec4(aPosition, 1.0);\nvTexCoord = aTexCoord;\nvIdColor = aIdColor;\nvHover = uPickedIdColor == aIdColor ? 1.0 : 0.0;\n}\n",
    "simple.vertex.fx": "#version 100\nattribute vec3 aPosition;\nvoid main(void) {\ngl_Position = vec4(aPosition, 1.0);\n}\n",
    "texture.fragment.fx": "#version 100\n#ifdef GL_FRAGMENT_PRECISION_HIGH\nprecision highp float;\n#else\nprecision mediump float;\n#endif\nuniform sampler2D uSampler;\nuniform bool uPick;\nvarying mediump vec2 vTexCoord;\nvoid main(void)\n{\nif (uPick) {\ngl_FragColor = vec4(0.0);\n}\nelse {\ngl_FragColor = vec4(texture2D(uSampler, vTexCoord).xyz, 1.0);\n}\n}\n",
    "texture.vertex.fx": "#version 100\nattribute vec3 aPosition;\nattribute mediump vec3 aNormal;\nattribute mediump vec2 aTexCoord;\nuniform mat4 uMMatrix;\nuniform mat4 uVMatrix;\nuniform mat4 uPMatrix;\nvarying mediump vec3 vNormal;\nvarying mediump vec2 vTexCoord;\nvoid main(void) {\nmat4 mvMatrix = uVMatrix * uMMatrix;\nvNormal = normalize((mvMatrix * vec4(aNormal, 0.0)).xyz);\ngl_Position = uPMatrix * mvMatrix * vec4(aPosition, 1.0);\nvTexCoord = aTexCoord;\n}\n",
    "unitblock.fragment.fx": "#version 100\n#define Derivatives\n#ifdef GL_FRAGMENT_PRECISION_HIGH\nprecision highp float;\n#else\nprecision mediump float;\n#endif\n#include \"common.include.fx\"\nvarying lowp vec4 vIdColor;\nvarying lowp vec2 vVertexColor;\nvarying lowp float vVertexSelected;\nvarying float vAnimation;\nvarying lowp float vHover;\nvarying lowp float vActive;\n#ifdef Derivatives\nvarying vec3 vViewPosition;\n#endif\nuniform sampler2D uSampler;\nuniform sampler2D uPreviousSampler;\nuniform bool uPick;\nuniform vec3 uDirectionToLight;\nuniform vec3 uHalfAngle;\nuniform float uSpecularPower;\nuniform float uSpecularIntensity;\nuniform float uAmbient;\nuniform vec3 uHoverColor;\nuniform vec3 uActiveColor;\nuniform vec3 uSelectedColor;\nuniform float uHighlightMode;\n#ifdef Derivatives\n#extension GL_OES_standard_derivatives : enable\n#endif\nvoid main(void)\n{\nif (uPick)\n{\ngl_FragColor = vIdColor;\n}\nelse\n{\nfloat emissive = 0.0;\nvec3 previousColor = texture2D(uPreviousSampler, vec2(vVertexColor.y, 0.0)).xyz;\nvec3 color = texture2D(uSampler, vec2(vVertexColor.x, 0.0)).xyz;\nif (uHighlightMode < 0.5) {\nemissive = vVertexSelected * 0.5;\nemissive += 1.5 * max(vHover, vActive);\nemissive /= 4.0;\n}\nelse {\npreviousColor = mix(previousColor, vec3(dot(LUMINANCE, previousColor)), max(-vVertexSelected, 0.0));\ncolor = mix(color, vec3(dot(LUMINANCE, color)), max(-vVertexSelected, 0.0));\npreviousColor = mix(previousColor, uSelectedColor, max(vVertexSelected, 0.0));\ncolor = mix(color, uSelectedColor, max(vVertexSelected, 0.0));\npreviousColor = mix(previousColor, uActiveColor, vActive);\ncolor = mix(color, uActiveColor, vActive);\npreviousColor = mix(previousColor, uHoverColor, vHover);\ncolor = mix(color, uHoverColor, vHover);\n}\ncolor = mix(previousColor, color, vAnimation);\nfloat diffuse, specular;\n#ifdef Derivatives\nvec3 normal = normalize(cross(dFdx(vViewPosition), dFdy(vViewPosition)));\ndiffuse = clamp(dot(uDirectionToLight, normal), 0.0, 1.0);\nspecular = pow(clamp(dot(normal, uHalfAngle), 0.0, 1.0), uSpecularPower) * uSpecularIntensity;\n#else\ndiffuse = 1.0;\nspecular = 0.0;\n#endif\ncolor *= (uAmbient + diffuse + emissive);\ncolor += specular;\ncolor = clamp(color, 0.0, 1.0);\ncolor = pow(color, GAMMA);\ngl_FragColor = vec4(color, 1.0);\n}\n}\n",
    "unitblock.vertex.fx": "#version 100\n#include \"quat.include.fx\"\nattribute mediump vec3 aPosition;\nattribute vec3 aTranslation;\nattribute vec3 aPreviousTranslation;\nattribute mediump vec4 aRotation;\nattribute mediump vec4 aPreviousRotation;\nattribute lowp vec2 aColor;\nattribute lowp vec2 aPreviousColor;\nattribute vec3 aScale;\nattribute vec3 aPreviousScale;\nattribute float aId;\nattribute vec2 aOrder;\nattribute lowp float aSelected;\nattribute lowp float aPreviousSelected;\nattribute lowp vec4 aIdColor;\nuniform mat4 uMMatrix;\nuniform mat4 uVMatrix;\nuniform mat4 uPMatrix;\nuniform float uTime;\nuniform float uDuration;\nuniform float uOrderFrom;\nuniform float uOrderTo;\nuniform float uHover;\nuniform float uActive;\n#define Derivatives\nvarying lowp vec4 vIdColor;\nvarying lowp vec2 vVertexColor;\nvarying lowp float vVertexSelected;\nvarying highp float vAnimation;\nvarying lowp float vHover;\nvarying lowp float vActive;\n#ifdef Derivatives\nvarying vec3 vViewPosition;\n#endif\nvoid main(void)\n{\nif (aOrder.x < uOrderFrom || aOrder.x > uOrderTo)\n{\nvIdColor = vec4(0.0);\nvVertexColor = vec2(0.0);\nvVertexSelected = 0.0;\nvAnimation = 0.0;\nvHover = 0.0;\nvActive = 0.0;\ngl_Position = vec4(0.0);\n#ifdef Derivatives\nvViewPosition = vec3(0.0);\n#endif\n}\nelse\n{\nvIdColor = aIdColor;\nfloat staggerOrder = aOrder.y;\nfloat startTime = staggerOrder * (1.0 - uDuration);\nfloat animation = clamp((uTime - startTime) / uDuration, 0.0, 1.0);\nanimation = smoothstep(0.0, 1.0, animation);\nvec3 scale = mix(aPreviousScale, aScale, animation);\nvec3 position = aPosition * scale;\nif (aRotation.w * aPreviousRotation.w != 1.0)\n{\nvec4 quat = slerp(aPreviousRotation, aRotation, animation);\nposition = rotate(position, quat);\n}\nposition += mix(aPreviousTranslation, aTranslation, animation);\nmat4 mvMatrix = uVMatrix * uMMatrix;\n#ifdef Derivatives\nvec4 viewPosition = mvMatrix * vec4(position, 1.0);\nvViewPosition = viewPosition.xyz;\ngl_Position = uPMatrix * viewPosition;\n#else\ngl_Position = uPMatrix * mvMatrix * vec4(position, 1.0);\n#endif\nvVertexColor = aPosition.y < 0.0 ? vec2(aColor.x, aPreviousColor.x) : vec2(aColor.y, aPreviousColor.y);\nvVertexSelected = mix(aPreviousSelected, aSelected, animation);\nvAnimation = animation;\nvHover = uHover == aId ? 1.0 : 0.0;\nvActive = uActive == aId ? 1.0 : 0.0;\n}\n}\n",
    "unitcylinder.fragment.fx": "#version 100\n#define FragDepth\n#ifdef GL_FRAGMENT_PRECISION_HIGH\nprecision highp float;\n#else\nprecision mediump float;\n#endif\n#include \"common.include.fx\"\nvarying lowp vec4 vIdColor;\nvarying lowp vec2 vVertexColor;\nvarying lowp float vVertexSelected;\nvarying float vAnimation;\nvarying lowp float vHover;\nvarying lowp float vActive;\nvarying vec3 vViewPosition;\nvarying vec4 vCircle1;\nvarying vec4 vCircle2;\nuniform sampler2D uSampler;\nuniform sampler2D uPreviousSampler;\nuniform bool uPick;\nuniform vec3 uDirectionToLight;\nuniform vec3 uHalfAngle;\nuniform float uSpecularPower;\nuniform float uSpecularIntensity;\nuniform float uAmbient;\nuniform vec3 uHoverColor;\nuniform vec3 uActiveColor;\nuniform vec3 uSelectedColor;\nuniform float uHighlightMode;\n#ifdef FragDepth\n#extension GL_EXT_frag_depth : enable\n#endif\nfloat dot2(in vec2 v) { return dot(v, v); }\nfloat dot2(in vec3 v) { return dot(v, v); }\nvec4 iCappedCone(in vec3 ro, in vec3 rd,\nin vec3 pa, in vec3 pb,\nin float ra, in float rb)\n{\nvec3 ba = pb - pa;\nvec3 oa = ro - pa;\nvec3 ob = ro - pb;\nfloat m0 = dot(ba, ba);\nfloat m1 = dot(oa, ba);\nfloat m2 = dot(ob, ba);\nfloat m3 = dot(rd, ba);\nif (m1 < 0.0) { if (dot2(oa * m3 - rd * m1) < (ra * ra * m3 * m3)) return vec4(-m1 / m3, -ba * inversesqrt(m0)); }\nelse if (m2 > 0.0) { if (dot2(ob * m3 - rd * m2) < (rb * rb * m3 * m3)) return vec4(-m2 / m3, ba * inversesqrt(m0)); }\nfloat m4 = dot(rd, oa);\nfloat m5 = dot(oa, oa);\nfloat rr = ra - rb;\nfloat hy = m0 + rr * rr;\nfloat k2 = m0 * m0 - m3 * m3 * hy;\nfloat k1 = m0 * m0 * m4 - m1 * m3 * hy + m0 * ra * (rr * m3 * 1.0);\nfloat k0 = m0 * m0 * m5 - m1 * m1 * hy + m0 * ra * (rr * m1 * 2.0 - m0 * ra);\nfloat h = k1 * k1 - k2 * k0;\nif (h < 0.0) return vec4(-1.0);\nfloat t = (-k1 - sqrt(h)) / k2;\nfloat y = m1 + t * m3;\nif (y > 0.0 && y < m0)\n{\nreturn vec4(t, normalize(m0 * (m0 * (oa + t * rd) + rr * ba * ra) - ba * hy * y));\n}\nreturn vec4(-1.0);\n}\nvec4 iRoundedCone(in vec3 ro, in vec3 rd,\nin vec3 pa, in vec3 pb,\nin float ra, in float rb)\n{\nvec3 ba = pb - pa;\nvec3 oa = ro - pa;\nvec3 ob = ro - pb;\nfloat rr = ra - rb;\nfloat m0 = dot(ba, ba);\nfloat m1 = dot(ba, oa);\nfloat m2 = dot(ba, rd);\nfloat m3 = dot(rd, oa);\nfloat m5 = dot(oa, oa);\nfloat m6 = dot(ob, rd);\nfloat m7 = dot(ob, ob);\nfloat d2 = m0 - rr * rr;\nfloat k2 = d2 - m2 * m2;\nfloat k1 = d2 * m3 - m1 * m2 + m2 * rr * ra;\nfloat k0 = d2 * m5 - m1 * m1 + m1 * rr * ra * 2.0 - m0 * ra * ra;\nfloat h = k1 * k1 - k0 * k2;\nif (h < 0.0) return vec4(-1.0);\nfloat t = (-sqrt(h) - k1) / k2;\nfloat y = m1 - ra * rr + t * m2;\nif (y > 0.0 && y < d2)\n{\nreturn vec4(t, normalize(d2 * (oa + t * rd) - ba * y));\n}\nfloat h1 = m3 * m3 - m5 + ra * ra;\nfloat h2 = m6 * m6 - m7 + rb * rb;\nif (max(h1, h2) < 0.0) return vec4(-1.0);\nvec4 r = vec4(1e20);\nif (h1 > 0.0)\n{\nt = -m3 - sqrt(h1);\nr = vec4(t, (oa + t * rd) / ra);\n}\nif (h2 > 0.0)\n{\nt = -m6 - sqrt(h2);\nif (t < r.x)\nr = vec4(t, (ob + t * rd) / rb);\n}\nreturn r;\n}\nvoid main(void)\n{\nvec3 rd = normalize(vViewPosition);\nvec3 ro = vec3(0.0);\nvec4 tnor = iCappedCone(ro, rd, vCircle1.xyz, vCircle2.xyz, vCircle1.w, vCircle2.w);\nfloat t = tnor.x;\nif (t < 0.0)\n{\ndiscard;\n}\nelse\n{\nvec3 viewPosition = rd * t;\n#ifdef FragDepth\nfloat ndcDepth = DEPTH_A + DEPTH_B / viewPosition.z;\ngl_FragDepthEXT = ndcDepth * 0.5 + 0.5;\n#endif\nif (uPick)\n{\ngl_FragColor = vIdColor;\n}\nelse\n{\nfloat emissive = 0.0;\nvec3 previousColor = texture2D(uPreviousSampler, vec2(vVertexColor.y, 0.0)).xyz;\nvec3 color = texture2D(uSampler, vec2(vVertexColor.x, 0.0)).xyz;\nif (uHighlightMode < 0.5) {\nemissive = vVertexSelected * 0.5;\nemissive += 1.5 * max(vHover, vActive);\nemissive /= 4.0;\n}\nelse {\npreviousColor = mix(previousColor, vec3(dot(LUMINANCE, previousColor)), max(-vVertexSelected, 0.0));\ncolor = mix(color, vec3(dot(LUMINANCE, color)), max(-vVertexSelected, 0.0));\npreviousColor = mix(previousColor, uSelectedColor, max(vVertexSelected, 0.0));\ncolor = mix(color, uSelectedColor, max(vVertexSelected, 0.0));\npreviousColor = mix(previousColor, uActiveColor, vActive);\ncolor = mix(color, uActiveColor, vActive);\npreviousColor = mix(previousColor, uHoverColor, vHover);\ncolor = mix(color, uHoverColor, vHover);\n}\ncolor = mix(previousColor, color, vAnimation);\nvec3 normal = tnor.yzw;\nfloat diffuse = clamp(dot(uDirectionToLight, normal), 0.0, 1.0);\nfloat specular = pow(clamp(dot(normal, uHalfAngle), 0.0, 1.0), uSpecularPower) * uSpecularIntensity;\ncolor *= (uAmbient + diffuse + emissive);\ncolor += specular;\ncolor = clamp(color, 0.0, 1.0);\ncolor = pow(color, GAMMA);\ngl_FragColor = vec4(color, 1.0);\n}\n}\n}\n",
    "unitcylinder.vertex.fx": "#version 100\n#include \"common.include.fx\"\n#include \"quat.include.fx\"\nattribute mediump vec3 aPosition;\nattribute vec3 aTranslation;\nattribute vec3 aPreviousTranslation;\nattribute mediump vec4 aRotation;\nattribute mediump vec4 aPreviousRotation;\nattribute lowp vec2 aColor;\nattribute lowp vec2 aPreviousColor;\nattribute vec3 aScale;\nattribute vec3 aPreviousScale;\nattribute float aId;\nattribute vec2 aOrder;\nattribute lowp float aSelected;\nattribute lowp float aPreviousSelected;\nattribute lowp vec4 aIdColor;\nuniform mat4 uMMatrix;\nuniform mat4 uVMatrix;\nuniform mat4 uPMatrix;\nuniform float uTime;\nuniform float uDuration;\nuniform float uOrderFrom;\nuniform float uOrderTo;\nuniform float uHover;\nuniform float uActive;\nuniform vec3 uIdentityRotation;\n#define Derivatives\nvarying lowp vec4 vIdColor;\nvarying lowp vec2 vVertexColor;\nvarying lowp float vVertexSelected;\nvarying highp float vAnimation;\nvarying lowp float vHover;\nvarying lowp float vActive;\nvarying vec3 vViewPosition;\nvarying vec4 vCircle1;\nvarying vec4 vCircle2;\nvoid main(void)\n{\nif (aOrder.x < uOrderFrom || aOrder.x > uOrderTo)\n{\nvIdColor = vec4(0.0);\nvVertexColor = vec2(0.0);\nvVertexSelected = 0.0;\nvAnimation = 0.0;\nvHover = 0.0;\nvActive = 0.0;\nvViewPosition = vec3(0.0);\nvCircle1 = vec4(0.0);\nvCircle2 = vec4(0.0);\ngl_Position = vec4(0.0);\n}\nelse\n{\nvIdColor = aIdColor;\nfloat staggerOrder = aOrder.y;\nfloat startTime = staggerOrder * (1.0 - uDuration);\nfloat animation = clamp((uTime - startTime) / uDuration, 0.0, 1.0);\nanimation = smoothstep(0.0, 1.0, animation);\nvec3 translation = mix(aPreviousTranslation, aTranslation, animation);\nmat4 mvMatrix = uVMatrix * uMMatrix;\nvec3 viewCenter = (mvMatrix * vec4(translation, 1.0)).xyz;\nvec3 scale = mix(aPreviousScale, aScale, animation);\nvec3 position = aPosition;\nposition.xz *= max(scale.x, scale.z);\nposition.y *= scale.y;\nvec3 direction = IDENTITY_ROTATION;\nif (aRotation.w * aPreviousRotation.w != 1.0)\n{\nvec4 quat = slerp(aPreviousRotation, aRotation, animation);\nposition = rotate(position, quat);\ndirection = rotate(direction, quat);\n}\nvec3 viewDirection = (mvMatrix * vec4(direction, 0.0)).xyz;\nvec3 h = viewDirection * scale.y * 0.5;\nfloat r1 = length(viewDirection) * 0.5;\nfloat r2 = r1 * scale.z;\nr1 *= scale.x;\nvCircle1 = vec4(viewCenter - h, r1);\nvCircle2 = vec4(viewCenter + h, r2);\nvec4 viewPosition = mvMatrix * vec4(position + translation, 1.0);\nvViewPosition = viewPosition.xyz;\ngl_Position = uPMatrix * viewPosition;\nvVertexColor = aPosition.y < 0.0 ? vec2(aColor.x, aPreviousColor.x) : vec2(aColor.y, aPreviousColor.y);\nvVertexSelected = mix(aPreviousSelected, aSelected, animation);\nvAnimation = animation;\nvHover = uHover == aId ? 1.0 : 0.0;\nvActive = uActive == aId ? 1.0 : 0.0;\n}\n}\n",
    "unithexprism.fragment.fx": "#version 100\n#define FragDepth\n#ifdef GL_FRAGMENT_PRECISION_HIGH\nprecision highp float;\n#else\nprecision mediump float;\n#endif\n#include \"common.include.fx\"\nvarying lowp vec4 vIdColor;\nvarying lowp vec2 vVertexColor;\nvarying lowp float vVertexSelected;\nvarying float vAnimation;\nvarying lowp float vHover;\nvarying lowp float vActive;\nvarying vec3 vViewPosition;\nvarying vec3 vViewCenter;\nvarying float vRadius;\nvarying float vHeight;\nvarying float vScaling;\nuniform sampler2D uSampler;\nuniform sampler2D uPreviousSampler;\nuniform bool uPick;\nuniform vec3 uDirectionToLight;\nuniform vec3 uHalfAngle;\nuniform float uSpecularPower;\nuniform float uSpecularIntensity;\nuniform float uAmbient;\nuniform vec3 uHoverColor;\nuniform vec3 uActiveColor;\nuniform vec3 uSelectedColor;\nuniform float uHighlightMode;\nuniform mat4 uVMatrix;\n#ifdef FragDepth\n#extension GL_EXT_frag_depth : enable\n#endif\nvec4 iHexPrism( in vec3 ro, in vec3 rd, in float ra, in float he )\n{\nconst vec3 n1 = vec3( 1.0,0.0,0.0);\nconst vec3 n2 = vec3( 0.5,0.0,ROOT_THREE_OVER_TWO);\nconst vec3 n3 = vec3(-0.5,0.0,ROOT_THREE_OVER_TWO);\nconst vec3 n4 = vec3( 0.0,1.0,0.0);\nvec3 t1 = vec3((vec2(ra,-ra)-dot(ro,n1))/dot(rd,n1), 1.0);\nvec3 t2 = vec3((vec2(ra,-ra)-dot(ro,n2))/dot(rd,n2), 1.0);\nvec3 t3 = vec3((vec2(ra,-ra)-dot(ro,n3))/dot(rd,n3), 1.0);\nvec3 t4 = vec3((vec2(he,-he)-dot(ro,n4))/dot(rd,n4), 1.0);\nif( t1.y<t1.x ) t1=vec3(t1.yx,-1.0);\nif( t2.y<t2.x ) t2=vec3(t2.yx,-1.0);\nif( t3.y<t3.x ) t3=vec3(t3.yx,-1.0);\nif( t4.y<t4.x ) t4=vec3(t4.yx,-1.0);\nvec4 tN=vec4(t1.x,t1.z*n1);\nif( t2.x>tN.x ) tN=vec4(t2.x,t2.z*n2);\nif( t3.x>tN.x ) tN=vec4(t3.x,t3.z*n3);\nif( t4.x>tN.x ) tN=vec4(t4.x,t4.z*n4);\nfloat tF = min(min(t1.y,t2.y),min(t3.y,t4.y));\nif( tN.x>tF || tF<0.0) return vec4(-1.0);\nreturn tN;\n}\nvoid main(void)\n{\nvec3 rd = normalize(vViewPosition);\nvec3 ro = -vViewCenter;\nmat3 rot = mat3(uVMatrix);\nvec3 rdd = rd * rot;\nvec3 roo = ro * rot;\nvec4 tnor = iHexPrism(roo, rdd, vRadius * vScaling, vHeight * vScaling);\nfloat t = tnor.x;\nif (t < 0.0)\n{\ndiscard;\n}\nelse\n{\nvec3 viewPosition = rd * t;\n#ifdef FragDepth\nfloat ndcDepth = DEPTH_A + DEPTH_B / viewPosition.z;\ngl_FragDepthEXT = ndcDepth * 0.5 + 0.5;\n#endif\nif (uPick)\n{\ngl_FragColor = vIdColor;\n}\nelse\n{\nfloat emissive = 0.0;\nvec3 previousColor = texture2D(uPreviousSampler, vec2(vVertexColor.y, 0.0)).xyz;\nvec3 color = texture2D(uSampler, vec2(vVertexColor.x, 0.0)).xyz;\nif (uHighlightMode < 0.5) {\nemissive = vVertexSelected * 0.5;\nemissive += 1.5 * max(vHover, vActive);\nemissive /= 4.0;\n}\nelse {\npreviousColor = mix(previousColor, vec3(dot(LUMINANCE, previousColor)), max(-vVertexSelected, 0.0));\ncolor = mix(color, vec3(dot(LUMINANCE, color)), max(-vVertexSelected, 0.0));\npreviousColor = mix(previousColor, uSelectedColor, max(vVertexSelected, 0.0));\ncolor = mix(color, uSelectedColor, max(vVertexSelected, 0.0));\npreviousColor = mix(previousColor, uActiveColor, vActive);\ncolor = mix(color, uActiveColor, vActive);\npreviousColor = mix(previousColor, uHoverColor, vHover);\ncolor = mix(color, uHoverColor, vHover);\n}\ncolor = mix(previousColor, color, vAnimation);\nvec3 normal = rot * tnor.yzw;\nfloat diffuse = clamp(dot(uDirectionToLight, normal), 0.0, 1.0);\nfloat specular = pow(clamp(dot(normal, uHalfAngle), 0.0, 1.0), uSpecularPower) * uSpecularIntensity;\ncolor *= (uAmbient + diffuse + emissive);\ncolor += specular;\ncolor = clamp(color, 0.0, 1.0);\ncolor = pow(color, GAMMA);\ngl_FragColor = vec4(color, 1.0);\n}\n}\n}\n",
    "unithexprism.vertex.fx": "#version 100\n#include \"common.include.fx\"\n#include \"quat.include.fx\"\nattribute mediump vec3 aPosition;\nattribute vec3 aTranslation;\nattribute vec3 aPreviousTranslation;\nattribute mediump vec4 aRotation;\nattribute mediump vec4 aPreviousRotation;\nattribute lowp vec2 aColor;\nattribute lowp vec2 aPreviousColor;\nattribute vec3 aScale;\nattribute vec3 aPreviousScale;\nattribute float aId;\nattribute vec2 aOrder;\nattribute lowp float aSelected;\nattribute lowp float aPreviousSelected;\nattribute lowp vec4 aIdColor;\nuniform mat4 uMMatrix;\nuniform mat4 uVMatrix;\nuniform mat4 uPMatrix;\nuniform float uTime;\nuniform float uDuration;\nuniform float uOrderFrom;\nuniform float uOrderTo;\nuniform float uHover;\nuniform float uActive;\nuniform vec3 uIdentityRotation;\n#define Derivatives\nvarying lowp vec4 vIdColor;\nvarying lowp vec2 vVertexColor;\nvarying lowp float vVertexSelected;\nvarying highp float vAnimation;\nvarying lowp float vHover;\nvarying lowp float vActive;\nvarying vec3 vViewPosition;\nvarying vec3 vViewCenter;\nvarying float vRadius;\nvarying float vHeight;\nvarying float vScaling;\nvoid main(void)\n{\nif (aOrder.x < uOrderFrom || aOrder.x > uOrderTo)\n{\nvIdColor = vec4(0.0);\nvVertexColor = vec2(0.0);\nvVertexSelected = 0.0;\nvAnimation = 0.0;\nvHover = 0.0;\nvActive = 0.0;\nvViewPosition = vec3(0.0);\nvRadius = 0.0;\nvHeight = 0.0;\ngl_Position = vec4(0.0);\n}\nelse\n{\nvIdColor = aIdColor;\nfloat staggerOrder = aOrder.y;\nfloat startTime = staggerOrder * (1.0 - uDuration);\nfloat animation = clamp((uTime - startTime) / uDuration, 0.0, 1.0);\nanimation = smoothstep(0.0, 1.0, animation);\nvec3 translation = mix(aPreviousTranslation, aTranslation, animation);\nmat4 mvMatrix = uVMatrix * uMMatrix;\nvViewCenter = (mvMatrix * vec4(translation, 1.0)).xyz;\nvec3 scale = mix(aPreviousScale, aScale, animation);\nvRadius = scale.x * ROOT_THREE_OVER_TWO;\nvHeight = scale.y;\nvec3 position = aPosition;\nposition.y *= scale.y;\nposition.z *= scale.x;\nposition.x *= scale.x * ROOT_THREE_OVER_TWO;\nvec3 direction = IDENTITY_ROTATION;\nif (aRotation.w * aPreviousRotation.w != 1.0)\n{\nvec4 quat = slerp(aPreviousRotation, aRotation, animation);\nposition = rotate(position, quat);\ndirection = rotate(direction, quat);\n}\nvec3 viewDirection = (mvMatrix * vec4(direction, 0.0)).xyz;\nvec4 viewPosition = mvMatrix * vec4(position + translation, 1.0);\nvViewPosition = viewPosition.xyz;\ngl_Position = uPMatrix * viewPosition;\nvVertexColor = aPosition.y < 0.0 ? vec2(aColor.x, aPreviousColor.x) : vec2(aColor.y, aPreviousColor.y);\nvVertexSelected = mix(aPreviousSelected, aSelected, animation);\nvAnimation = animation;\nvHover = uHover == aId ? 1.0 : 0.0;\nvActive = uActive == aId ? 1.0 : 0.0;\nvScaling = length(uMMatrix[0].xyz) / 2.0;\n}\n}\n",
    "unitsdf.fragment.fx": "#version 100\n#define Derivatives\n#ifdef GL_FRAGMENT_PRECISION_HIGH\nprecision highp float;\n#else\nprecision mediump float;\n#endif\n#include \"common.include.fx\"\nvarying lowp vec4 vIdColor;\nvarying lowp vec2 vVertexColor;\nvarying lowp float vVertexSelected;\nvarying float vAnimation;\nvarying lowp float vHover;\nvarying lowp float vActive;\nvarying mediump vec2 vTexCoord;\nvarying mediump vec2 vPreviousTexCoord;\n#ifdef Derivatives\nvarying vec3 vViewPosition;\n#endif\nuniform sampler2D uSampler;\nuniform sampler2D uPreviousSampler;\nuniform sampler2D uSampler1;\nuniform sampler2D uPreviousSampler1;\nuniform bool uPick;\nuniform vec3 uDirectionToLight;\nuniform vec3 uHalfAngle;\nuniform float uSpecularPower;\nuniform float uSpecularIntensity;\nuniform float uAmbient;\nuniform vec3 uHoverColor;\nuniform vec3 uActiveColor;\nuniform vec3 uSelectedColor;\nuniform float uHighlightMode;\nuniform vec3	 uBackgroundColor;\nuniform float 	 uBuffer;\n#ifdef Derivatives\n#extension GL_OES_standard_derivatives : enable\n#endif\nvoid main(void) {\nfloat distance = mix(texture2D(uPreviousSampler1, vPreviousTexCoord).r, texture2D(uSampler1, vTexCoord).r, vAnimation);\nif (distance < uBuffer) {\ndiscard;\n}\nif (uPick) {\ngl_FragColor = vIdColor;\n}\nelse\n{\nfloat emissive = 0.0;\nvec3 previousColor = texture2D(uPreviousSampler, vec2(vVertexColor.y, 0.0)).xyz;\nvec3 color = texture2D(uSampler, vec2(vVertexColor.x, 0.0)).xyz;\nif (uHighlightMode < 0.5) {\nemissive = vVertexSelected * 0.5;\nemissive += 1.5 * max(vHover, vActive);\nemissive /= 4.0;\n}\nelse {\npreviousColor = mix(previousColor, vec3(dot(LUMINANCE, previousColor)), max(-vVertexSelected, 0.0));\ncolor = mix(color, vec3(dot(LUMINANCE, color)), max(-vVertexSelected, 0.0));\npreviousColor = mix(previousColor, uSelectedColor, max(vVertexSelected, 0.0));\ncolor = mix(color, uSelectedColor, max(vVertexSelected, 0.0));\npreviousColor = mix(previousColor, uActiveColor, vActive);\ncolor = mix(color, uActiveColor, vActive);\npreviousColor = mix(previousColor, uHoverColor, vHover);\ncolor = mix(color, uHoverColor, vHover);\n}\ncolor = mix(previousColor, color, vAnimation);\nfloat diffuse, specular;\n#ifdef Derivatives\nvec3 normal = normalize(cross(dFdx(vViewPosition), dFdy(vViewPosition)));\ndiffuse = clamp(dot(uDirectionToLight, normal), 0.0, 1.0);\nspecular = pow(clamp(dot(normal, uHalfAngle), 0.0, 1.0), uSpecularPower) * uSpecularIntensity;\n#else\ndiffuse = 1.0;\nspecular = 0.0;\n#endif\ncolor *= (uAmbient + diffuse + emissive);\ncolor += specular;\ncolor = clamp(color, 0.0, 1.0);\ncolor = pow(color, GAMMA);\nfloat uGamma = 0.0;\nfloat gamma;\n#ifdef Derivatives\ngamma = fwidth(distance);\n#else\ngamma = uGamma;\n#endif\nfloat value = smoothstep(uBuffer + gamma, uBuffer, distance);\ngl_FragColor = vec4(mix(color, uBackgroundColor, value), 1.0);\n}\n}\n",
    "unitsdf.vertex.fx": "#version 100\n#include \"quat.include.fx\"\nattribute mediump vec3 aPosition;\nattribute vec3 aTranslation;\nattribute vec3 aPreviousTranslation;\nattribute mediump vec4 aRotation;\nattribute mediump vec4 aPreviousRotation;\nattribute mediump vec4 aTexCoord;\nattribute mediump vec4 aPreviousTexCoord;\nattribute lowp vec2 aColor;\nattribute lowp vec2 aPreviousColor;\nattribute vec3 aScale;\nattribute vec3 aPreviousScale;\nattribute float aId;\nattribute vec2 aOrder;\nattribute lowp float aSelected;\nattribute lowp float aPreviousSelected;\nattribute lowp vec4 aIdColor;\nuniform mat4 uMMatrix;\nuniform mat4 uVMatrix;\nuniform mat4 uPMatrix;\nuniform float uTime;\nuniform float uDuration;\nuniform float uOrderFrom;\nuniform float uOrderTo;\nuniform float uHover;\nuniform float uActive;\n#define Derivatives\nvarying lowp vec4 vIdColor;\nvarying lowp vec2 vVertexColor;\nvarying lowp float vVertexSelected;\nvarying highp float vAnimation;\nvarying lowp float vHover;\nvarying lowp float vActive;\nvarying mediump vec2 vTexCoord;\nvarying mediump vec2 vPreviousTexCoord;\n#ifdef Derivatives\nvarying vec3 vViewPosition;\n#endif\nvoid main(void)\n{\nif (aOrder.x < uOrderFrom || aOrder.x > uOrderTo)\n{\nvIdColor = vec4(0.0);\nvVertexColor = vec2(0.0);\nvVertexSelected = 0.0;\nvAnimation = 0.0;\nvHover = 0.0;\nvActive = 0.0;\ngl_Position = vec4(0.0);\n#ifdef Derivatives\nvViewPosition = vec3(0.0);\n#endif\n}\nelse\n{\nvIdColor = aIdColor;\nfloat staggerOrder = aOrder.y;\nfloat startTime = staggerOrder * (1.0 - uDuration);\nfloat animation = clamp((uTime - startTime) / uDuration, 0.0, 1.0);\nanimation = smoothstep(0.0, 1.0, animation);\nvec3 scale = mix(aPreviousScale, aScale, animation);\nvec3 position = aPosition * scale;\nif (aRotation.w * aPreviousRotation.w != 1.0)\n{\nvec4 quat = slerp(aPreviousRotation, aRotation, animation);\nposition = rotate(position, quat);\n}\nposition += mix(aPreviousTranslation, aTranslation, animation);\nmat4 mvMatrix = uVMatrix * uMMatrix;\n#ifdef Derivatives\nvec4 viewPosition = mvMatrix * vec4(position, 1.0);\nvViewPosition = viewPosition.xyz;\ngl_Position = uPMatrix * viewPosition;\n#else\ngl_Position = uPMatrix * mvMatrix * vec4(position, 1.0);\n#endif\nvVertexColor = aPosition.y < 0.0 ? vec2(aColor.x, aPreviousColor.x) : vec2(aColor.y, aPreviousColor.y);\nvVertexSelected = mix(aPreviousSelected, aSelected, animation);\nvAnimation = animation;\nvHover = uHover == aId ? 1.0 : 0.0;\nvActive = uActive == aId ? 1.0 : 0.0;\nvPreviousTexCoord.x = aPosition.x < 0.0 ? aPreviousTexCoord.x : aPreviousTexCoord.z;\nvPreviousTexCoord.y = aPosition.y > 0.0 ? aPreviousTexCoord.y : aPreviousTexCoord.w;\nvTexCoord.x = aPosition.x < 0.0 ? aTexCoord.x : aTexCoord.z;\nvTexCoord.y = aPosition.y > 0.0 ? aTexCoord.y : aTexCoord.w;\n}\n}\n",
    "unitsphere.fragment.fx": "#version 100\n#define FragDepth\n#ifdef GL_FRAGMENT_PRECISION_HIGH\nprecision highp float;\n#else\nprecision mediump float;\n#endif\n#include \"common.include.fx\"\nvarying lowp vec4 vIdColor;\nvarying lowp vec2 vVertexColor;\nvarying lowp float vVertexSelected;\nvarying float vAnimation;\nvarying lowp float vHover;\nvarying lowp float vActive;\nvarying vec3 vViewPosition;\nvarying vec3 vViewCenter;\nvarying mediump float vRadius;\nuniform sampler2D uSampler;\nuniform sampler2D uPreviousSampler;\nuniform bool uPick;\nuniform vec3 uDirectionToLight;\nuniform vec3 uHalfAngle;\nuniform float uSpecularPower;\nuniform float uSpecularIntensity;\nuniform float uAmbient;\nuniform vec3 uHoverColor;\nuniform vec3 uActiveColor;\nuniform vec3 uSelectedColor;\nuniform float uHighlightMode;\n#ifdef FragDepth\n#extension GL_EXT_frag_depth : enable\n#endif\nfloat sphIntersect(in vec3 ro, in vec3 rd, in vec4 sph)\n{\nvec3 oc = ro - sph.xyz;\nfloat b = dot(oc, rd);\nfloat c = dot(oc, oc) - sph.w * sph.w;\nfloat h = b * b - c;\nif (h < 0.0) return -1.0;\nreturn -b - sqrt(h);\n}\nvoid main(void)\n{\nvec3 rd = normalize(vViewPosition);\nvec3 ro = vec3(0.0);\nvec4 s = vec4(vViewCenter, vRadius);\nfloat t = sphIntersect(ro, rd, s);\nif (t < 0.0)\n{\ndiscard;\n}\nelse\n{\nvec3 viewPosition = rd * t;\n#ifdef FragDepth\nfloat ndcDepth = DEPTH_A + DEPTH_B / viewPosition.z;\ngl_FragDepthEXT = ndcDepth * 0.5 + 0.5;\n#endif\nif (uPick)\n{\ngl_FragColor = vIdColor;\n}\nelse\n{\nfloat emissive = 0.0;\nvec3 previousColor = texture2D(uPreviousSampler, vec2(vVertexColor.y, 0.0)).xyz;\nvec3 color = texture2D(uSampler, vec2(vVertexColor.x, 0.0)).xyz;\nif (uHighlightMode < 0.5) {\nemissive = vVertexSelected * 0.5;\nemissive += 1.5 * max(vHover, vActive);\nemissive /= 4.0;\n}\nelse {\npreviousColor = mix(previousColor, vec3(dot(LUMINANCE, previousColor)), max(-vVertexSelected, 0.0));\ncolor = mix(color, vec3(dot(LUMINANCE, color)), max(-vVertexSelected, 0.0));\npreviousColor = mix(previousColor, uSelectedColor, max(vVertexSelected, 0.0));\ncolor = mix(color, uSelectedColor, max(vVertexSelected, 0.0));\npreviousColor = mix(previousColor, uActiveColor, vActive);\ncolor = mix(color, uActiveColor, vActive);\npreviousColor = mix(previousColor, uHoverColor, vHover);\ncolor = mix(color, uHoverColor, vHover);\n}\ncolor = mix(previousColor, color, vAnimation);\nvec3 normal = (viewPosition - vViewCenter) / s.w;\nfloat diffuse = clamp(dot(uDirectionToLight, normal), 0.0, 1.0);\nfloat specular = pow(clamp(dot(normal, uHalfAngle), 0.0, 1.0), uSpecularPower) * uSpecularIntensity;\ncolor *= (uAmbient + diffuse + emissive);\ncolor += specular;\ncolor = clamp(color, 0.0, 1.0);\ncolor = pow(color, GAMMA);\ngl_FragColor = vec4(color, 1.0);\n}\n}\n}\n",
    "unitsphere.vertex.fx": "#version 100\n#include \"common.include.fx\"\nattribute mediump vec3 aPosition;\nattribute vec3 aTranslation;\nattribute vec3 aPreviousTranslation;\nattribute lowp float aColor;\nattribute lowp float aPreviousColor;\nattribute vec3 aScale;\nattribute vec3 aPreviousScale;\nattribute float aId;\nattribute vec2 aOrder;\nattribute lowp float aSelected;\nattribute lowp float aPreviousSelected;\nattribute lowp vec4 aIdColor;\nuniform mat4 uMMatrix;\nuniform mat4 uVMatrix;\nuniform mat4 uPMatrix;\nuniform float uTime;\nuniform float uDuration;\nuniform float uOrderFrom;\nuniform float uOrderTo;\nuniform float uHover;\nuniform float uActive;\nvarying lowp vec4 vIdColor;\nvarying lowp vec2 vVertexColor;\nvarying lowp float vVertexSelected;\nvarying highp float vAnimation;\nvarying lowp float vHover;\nvarying lowp float vActive;\nvarying mediump float vRadius;\nvarying vec3 vViewPosition;\nvarying vec3 vViewCenter;\nvoid main(void)\n{\nif (aOrder.x < uOrderFrom || aOrder.x > uOrderTo)\n{\nvIdColor = vec4(0.0);\nvVertexColor = vec2(0.0);\nvVertexSelected = 0.0;\nvAnimation = 0.0;\nvHover = 0.0;\nvActive = 0.0;\nvViewPosition = vec3(0.0);\nvViewCenter = vec3(0.0);\nvRadius = 0.0;\ngl_Position = vec4(0.0);\n}\nelse\n{\nvIdColor = aIdColor;\nfloat staggerOrder = aOrder.y;\nfloat startTime = staggerOrder * (1.0 - uDuration);\nfloat animation = clamp((uTime - startTime) / uDuration, 0.0, 1.0);\nanimation = smoothstep(0.0, 1.0, animation);\nfloat scale = mix(min(aPreviousScale.x, min(aPreviousScale.y, aPreviousScale.z)), min(aScale.x, min(aScale.y, aScale.z)), animation);\nvec4 translation = vec4(mix(aPreviousTranslation, aTranslation, animation), 1.0);\nmat4 mvMatrix = uVMatrix * uMMatrix;\nvViewCenter = (mvMatrix * translation).xyz;\ntranslation.xyz += aPosition * scale;\nvViewPosition = (mvMatrix * translation).xyz;\ngl_Position = uPMatrix * vec4(vViewPosition, 1.0);\nvVertexColor = vec2(aColor, aPreviousColor);\nvVertexSelected = mix(aPreviousSelected, aSelected, animation);\nvAnimation = animation;\nvHover = uHover == aId ? 1.0 : 0.0;\nvActive = uActive == aId ? 1.0 : 0.0;\nvRadius = distance(vViewPosition, vViewCenter) / ROOT_THREE;\n}\n}\n",
    "common.include.fx": "const float NEAR_PLANE = 0.01;\nconst float FAR_PLANE = 100.0;\nconst float DEPTH_A = 1.0002000200020003;\nconst float DEPTH_B = 0.020002000200020003;\nconst vec3 GAMMA = vec3(0.45454545454545453);\nconst vec3 INV_GAMMA = vec3(2.2);\nconst vec3 LUMINANCE = vec3(0.2126, 0.7152, 0.0722);\nconst float PI = 3.1415926538;\nconst float ROOT_TWO = 1.4142135624;\nconst float ROOT_TWO_OVER_TWO = 0.7071067811865476;\nconst float ROOT_THREE = 1.7320508075688772;\nconst float ROOT_THREE_OVER_TWO = 0.8660254037844386;\nconst vec3 IDENTITY_ROTATION = vec3(0.0, 1.0, 0.0);\nmat3 transpose(in mat3 mat) {\nvec3 i0 = mat[0];\nvec3 i1 = mat[1];\nvec3 i2 = mat[2];\nreturn mat3\n(\nvec3(i0.x, i1.x, i2.x),\nvec3(i0.y, i1.y, i2.y),\nvec3(i0.z, i1.z, i2.z)\n);\n}\n",
    "quat.include.fx": "const float EPSILON = 0.000001;\nmat3 fromQuat(in vec4 q) {\nfloat x = q.x;\nfloat y = q.y;\nfloat z = q.z;\nfloat w = q.w;\nfloat x2 = x + x;\nfloat y2 = y + y;\nfloat z2 = z + z;\nfloat xx = x * x2;\nfloat yx = y * x2;\nfloat yy = y * y2;\nfloat zx = z * x2;\nfloat zy = z * y2;\nfloat zz = z * z2;\nfloat wx = w * x2;\nfloat wy = w * y2;\nfloat wz = w * z2;\nmat3 m;\nm[0][0] = 1.0 - yy - zz;\nm[0][1] = yx - wz;\nm[0][2] = zx + wy;\nm[1][0] = yx + wz;\nm[1][1] = 1.0 - xx - zz;\nm[1][2] = zy - wx;\nm[2][0] = zx - wy;\nm[2][1] = zy + wx;\nm[2][2] = 1.0 - xx - yy;\nreturn m;\n}\nvec3 rotate(in vec3 p, in vec4 q) {\nreturn p + 2.0 * cross(q.xyz, cross(q.xyz, p) + q.w * p);\n}\nvec4 slerp(in vec4 a, in vec4 b, in float t) {\nfloat cosom = dot(a, b);\nif (cosom < 0.0) {\ncosom = -cosom;\nb = -b;\n}\nfloat scale0, scale1;\nif (1.0 - cosom > EPSILON) {\nfloat omega = acos(cosom);\nfloat sinom = sin(omega);\nscale0 = sin((1.0 - t) * omega) / sinom;\nscale1 = sin(t * omega) / sinom;\n}\nelse {\nscale0 = 1.0 - t;\nscale1 = t;\n}\nreturn vec4(scale0 * a + scale1 * b);\n}\n"
};
class $5ea895789fc20d6f$export$59a6ab026766925f {
    get isInitialized() {
        return this._isInitialized;
    }
    get vertexBuffer() {
        return this._vertexBuffer;
    }
    set vertexBuffer(value) {
        if (this._vertexBuffer != value) {
            this._vertexBuffer = value;
            this._haveBuffersChanged = true;
        }
    }
    get indexBuffer() {
        return this._indexBuffer;
    }
    set indexBuffer(value) {
        if (this._indexBuffer != value) {
            this._indexBuffer = value;
            this._haveBuffersChanged = true;
        }
    }
    constructor(core, main){
        this._core = core;
        this._main = main;
    }
    initializeContext(gl) {
        this._gl = gl;
    }
    _createProgram(vs, fs) {
        const program = this._gl.createProgram();
        this._gl.attachShader(program, vs);
        this._gl.attachShader(program, fs);
        this._gl.linkProgram(program);
        if (!this._gl.getProgramParameter(program, this._gl.LINK_STATUS)) this._core.log.write((0, $4a6417d29706362f$export$243e62d78d3b544d).error, this._gl.getProgramInfoLog(program));
        return program;
    }
    _compileShader(source, type) {
        const shader = this._gl.createShader(type);
        this._gl.shaderSource(shader, source);
        this._gl.compileShader(shader);
        if (!this._gl.getShaderParameter(shader, this._gl.COMPILE_STATUS)) this._core.log.write((0, $4a6417d29706362f$export$243e62d78d3b544d).error, this._gl.getShaderInfoLog(shader));
        return shader;
    }
    _removeDirective(shaderSource, directive) {
        const remove = `#define ${directive}`;
        const index = shaderSource.indexOf(remove);
        shaderSource = index == -1 ? shaderSource : shaderSource.substring(0, index) + shaderSource.substring(index + remove.length);
        return shaderSource;
    }
    prepare() {
        if (this._program != this._main.shaderResources.currentProgram) {
            if (this._main.shaderResources.currentShader) this._main.shaderResources.currentShader.disableProgram();
            this.enableProgram(this._program);
            this.updateBuffers();
            this.updateTextures();
        } else {
            if (this._haveBuffersChanged) this.updateBuffers();
            if (this._haveTexturesChanged) this.updateTextures();
        }
    }
    apply() {}
    applyModel() {}
    applyView() {}
    enableProgram(program) {
        this._gl.useProgram(program);
        this._main.shaderResources.currentProgram = program;
        this._main.shaderResources.currentShader = this;
    }
    updateBuffers() {
        this._haveBuffersChanged = false;
    }
    updateTextures() {
        this._haveTexturesChanged = false;
    }
    disableProgram() {
        this._main.shaderResources.currentShader = null;
        this._main.shaderResources.currentProgram = null;
    }
    _shaderFromFile(vsName, fsName, callback) {
        callback(this._includesFromFile($5ea895789fc20d6f$export$e9a269813a6315a4.glsl[vsName]), this._includesFromFile($5ea895789fc20d6f$export$e9a269813a6315a4.glsl[fsName]));
    }
    _shaderFromUrl(vsName, fsName, callback) {
        this._sourceFromUrl(vsName, (vsSource)=>{
            this._includesFromUrl(vsSource, 0, (vsIncSource)=>{
                this._sourceFromUrl(fsName, (fsSource)=>{
                    this._includesFromUrl(fsSource, 0, (fsIncSource)=>{
                        callback(vsIncSource, fsIncSource);
                    });
                });
            });
        });
    }
    _sourceFromUrl(url, callback) {
        const request = new XMLHttpRequest();
        request.open("GET", (0, $a4596fc55355f0e1$export$433e0478e7f6ca93).combine(this._core.config.shaderPath, url));
        request.onreadystatechange = ()=>{
            if (request.readyState == XMLHttpRequest.DONE && request.status == 200) callback(request.responseText);
        };
        request.send();
    }
    _includesFromFile(source) {
        let index = 0;
        do {
            index = source.indexOf("#include", index);
            if (index != -1) {
                const start = source.indexOf("\"", index);
                const end = source.indexOf("\"", start + 1);
                const name = source.substring(start + 1, end);
                const inc = $5ea895789fc20d6f$export$e9a269813a6315a4.glsl[name];
                source = source.substring(0, index) + inc + source.substring(end + 1);
            }
        }while (index != -1);
        return source;
    }
    _includesFromUrl(source, index, callback) {
        index = source.indexOf("#include", index);
        if (index != -1) {
            const start = source.indexOf("\"", index);
            const end = source.indexOf("\"", start + 1);
            const name = source.substring(start + 1, end);
            this._sourceFromUrl((0, $a4596fc55355f0e1$export$433e0478e7f6ca93).combine("inc", name), (include)=>{
                source = source.substring(0, index) + include + source.substring(end + 1);
                this._includesFromUrl(source, index, callback);
            });
        } else callback(source);
    }
}


/*!
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 */ 

class $8c45895df6e4c752$export$892596cec99bc70e extends (0, $5ea895789fc20d6f$export$59a6ab026766925f) {
    initializeContext(gl) {
        super.initializeContext(gl);
        if (this._isLoaded) this._initializeShader(gl, this._vsSource, this._fsSource);
        else this._shaderFromFile("color.vertex.fx", "color.fragment.fx", (vsSource, fsSource)=>{
            this._vsSource = vsSource;
            this._fsSource = fsSource;
            this._isLoaded = true;
            this._initializeShader(gl, vsSource, fsSource);
        });
    }
    _initializeShader(gl, vsSource, fsSource) {
        const vs = this._compileShader(vsSource, gl.VERTEX_SHADER);
        const fs = this._compileShader(fsSource, gl.FRAGMENT_SHADER);
        this._program = this._createProgram(vs, fs);
        this._positionAttribute = gl.getAttribLocation(this._program, "aPosition");
        this._colorAttribute = gl.getAttribLocation(this._program, "aColor");
        this._mMatrixUniform = gl.getUniformLocation(this._program, "uMMatrix");
        this._vMatrixUniform = gl.getUniformLocation(this._program, "uVMatrix");
        this._pMatrixUniform = gl.getUniformLocation(this._program, "uPMatrix");
        this._isInitialized = true;
    }
    apply() {
        this._gl.uniformMatrix4fv(this._mMatrixUniform, false, this.mMatrix);
    }
    applyView() {
        this._gl.uniformMatrix4fv(this._vMatrixUniform, false, this.vMatrix);
        this._gl.uniformMatrix4fv(this._pMatrixUniform, false, this.pMatrix);
    }
    updateBuffers() {
        super.updateBuffers();
        this._gl.bindBuffer(this._gl.ARRAY_BUFFER, this._vertexBuffer);
        this._gl.vertexAttribPointer(this._positionAttribute, 3, this._gl.FLOAT, false, (0, $0a0587bd8b0d58e8$export$6597d9a580deb707).SIZE_BYTES, (0, $0a0587bd8b0d58e8$export$6597d9a580deb707).POSITION_OFFSET_BYTES);
        this._gl.enableVertexAttribArray(this._positionAttribute);
        this._gl.vertexAttribPointer(this._colorAttribute, 3, this._gl.UNSIGNED_BYTE, true, (0, $0a0587bd8b0d58e8$export$6597d9a580deb707).SIZE_BYTES, (0, $0a0587bd8b0d58e8$export$6597d9a580deb707).COLOR_OFFSET_BYTES);
        this._gl.enableVertexAttribArray(this._colorAttribute);
        this._gl.bindBuffer(this._gl.ELEMENT_ARRAY_BUFFER, this._indexBuffer);
    }
}


/*!
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 */ 

class $0bc042355ce24bf2$export$5431306cf43de24a extends (0, $5ea895789fc20d6f$export$59a6ab026766925f) {
    get texture2D() {
        return this._texture2D;
    }
    set texture2D(value) {
        if (this._texture2D != value) {
            this._texture2D = value;
            this._haveTexturesChanged = true;
        }
    }
    initializeContext(gl) {
        super.initializeContext(gl);
        if (this._isLoaded) this._initializeShader(gl, this._vsSource, this._fsSource);
        else this._shaderFromFile("texture.vertex.fx", "texture.fragment.fx", (vsSource, fsSource)=>{
            this._vsSource = vsSource;
            this._fsSource = fsSource;
            this._isLoaded = true;
            this._initializeShader(gl, vsSource, fsSource);
        });
    }
    _initializeShader(gl, vsSource, fsSource) {
        const vs = this._compileShader(vsSource, gl.VERTEX_SHADER);
        const fs = this._compileShader(fsSource, gl.FRAGMENT_SHADER);
        this._program = this._createProgram(vs, fs);
        this._positionAttribute = gl.getAttribLocation(this._program, "aPosition");
        this._texCoordAttribute = gl.getAttribLocation(this._program, "aTexCoord");
        this._normalAttribute = gl.getAttribLocation(this._program, "aNormal");
        this._samplerUniform = gl.getUniformLocation(this._program, "uSampler");
        this._pickUniform = gl.getUniformLocation(this._program, "uPick");
        this._mMatrixUniform = gl.getUniformLocation(this._program, "uMMatrix");
        this._vMatrixUniform = gl.getUniformLocation(this._program, "uVMatrix");
        this._pMatrixUniform = gl.getUniformLocation(this._program, "uPMatrix");
        this._isInitialized = true;
    }
    apply() {
        this._gl.uniformMatrix4fv(this._mMatrixUniform, false, this.mMatrix);
        this._gl.uniform1i(this._samplerUniform, 0);
    }
    applyView() {
        this._gl.uniform1i(this._pickUniform, this.isPickShader ? 1 : 0);
        this._gl.uniformMatrix4fv(this._vMatrixUniform, false, this.vMatrix);
        this._gl.uniformMatrix4fv(this._pMatrixUniform, false, this.pMatrix);
    }
    updateBuffers() {
        super.updateBuffers();
        this._gl.bindBuffer(this._gl.ARRAY_BUFFER, this._vertexBuffer);
        this._gl.vertexAttribPointer(this._positionAttribute, 3, this._gl.FLOAT, false, (0, $0a0587bd8b0d58e8$export$e40add16394b9bff).SIZE_BYTES, (0, $0a0587bd8b0d58e8$export$e40add16394b9bff).POSITION_OFFSET_BYTES);
        this._gl.enableVertexAttribArray(this._positionAttribute);
        this._gl.vertexAttribPointer(this._normalAttribute, 3, this._gl.BYTE, true, (0, $0a0587bd8b0d58e8$export$e40add16394b9bff).SIZE_BYTES, (0, $0a0587bd8b0d58e8$export$e40add16394b9bff).NORMAL_OFFSET_BYTES);
        this._gl.enableVertexAttribArray(this._normalAttribute);
        this._gl.vertexAttribPointer(this._texCoordAttribute, 2, this._gl.UNSIGNED_SHORT, true, (0, $0a0587bd8b0d58e8$export$e40add16394b9bff).SIZE_BYTES, (0, $0a0587bd8b0d58e8$export$e40add16394b9bff).TEX_COORD_OFFSET_BYTES);
        this._gl.enableVertexAttribArray(this._texCoordAttribute);
        this._gl.bindBuffer(this._gl.ELEMENT_ARRAY_BUFFER, this._indexBuffer);
    }
    updateTextures() {
        super.updateTextures();
        this._gl.activeTexture(this._gl.TEXTURE0);
        this._gl.bindTexture(this._gl.TEXTURE_2D, this._texture2D);
    }
}


/*!
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 */ 

class $79f5d05e1849f9e7$export$dc8af347244861ce extends (0, $5ea895789fc20d6f$export$59a6ab026766925f) {
    initializeContext(gl) {
        super.initializeContext(gl);
        if (this._isLoaded) this._initializeShader(gl, this._vsSource, this._fsSource);
        else this._shaderFromFile("lasso.vertex.fx", "lasso.fragment.fx", (vsSource, fsSource)=>{
            this._vsSource = vsSource;
            this._fsSource = fsSource;
            this._isLoaded = true;
            this._initializeShader(gl, vsSource, fsSource);
        });
    }
    _initializeShader(gl, vsSource, fsSource) {
        const vs = this._compileShader(vsSource, gl.VERTEX_SHADER);
        const fs = this._compileShader(fsSource, gl.FRAGMENT_SHADER);
        this._program = this._createProgram(vs, fs);
        this._positionAttribute = gl.getAttribLocation(this._program, "aPosition");
        this._texCoordAttribute = gl.getAttribLocation(this._program, "aTexCoord");
        this._mMatrixUniform = gl.getUniformLocation(this._program, "uMMatrix");
        this._colorUniform = gl.getUniformLocation(this._program, "uColor");
        this._thicknessUniform = gl.getUniformLocation(this._program, "uThickness");
        this._dashWidthUniform = gl.getUniformLocation(this._program, "uDashWidth");
        this._isInitialized = true;
    }
    apply() {
        this._gl.uniform3fv(this._colorUniform, this.color);
        this._gl.uniform1f(this._dashWidthUniform, this.dashWidth);
    }
    applyView() {
        this._gl.uniformMatrix4fv(this._mMatrixUniform, false, this.mMatrix);
        this._gl.uniform2fv(this._thicknessUniform, this.thickness);
    }
    updateBuffers() {
        super.updateBuffers();
        this._gl.bindBuffer(this._gl.ARRAY_BUFFER, this._vertexBuffer);
        this._gl.vertexAttribPointer(this._positionAttribute, 3, this._gl.FLOAT, false, (0, $0a0587bd8b0d58e8$export$538532535e0e8594).SIZE_BYTES, (0, $0a0587bd8b0d58e8$export$538532535e0e8594).POSITION_OFFSET_BYTES);
        this._gl.enableVertexAttribArray(this._positionAttribute);
        this._gl.vertexAttribPointer(this._texCoordAttribute, 2, this._gl.UNSIGNED_SHORT, true, (0, $0a0587bd8b0d58e8$export$538532535e0e8594).SIZE_BYTES, (0, $0a0587bd8b0d58e8$export$538532535e0e8594).TEX_COORD_OFFSET_BYTES);
        this._gl.enableVertexAttribArray(this._texCoordAttribute);
        this._gl.bindBuffer(this._gl.ELEMENT_ARRAY_BUFFER, this._indexBuffer);
    }
}


/*!
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 */ 

class $f3a972bc0ef40bc6$export$a1edc412be3e1841 extends (0, $5ea895789fc20d6f$export$59a6ab026766925f) {
    get texture2D() {
        return this._texture2D;
    }
    set texture2D(value) {
        if (this._texture2D != value) {
            this._texture2D = value;
            this._haveTexturesChanged = true;
        }
    }
    initializeContext(gl) {
        super.initializeContext(gl);
        if (this._isLoaded) this._initializeShader(gl, this._vsSource, this._fsSource);
        else this._shaderFromFile("model.vertex.fx", "model.fragment.fx", (vsSource, fsSource)=>{
            this._vsSource = vsSource;
            this._fsSource = fsSource;
            this._isLoaded = true;
            this._initializeShader(gl, vsSource, fsSource);
        });
    }
    _initializeShader(gl, vsSource, fsSource) {
        const vs = this._compileShader(vsSource, gl.VERTEX_SHADER);
        const fs = this._compileShader(fsSource, gl.FRAGMENT_SHADER);
        this._program = this._createProgram(vs, fs);
        this._positionAttribute = gl.getAttribLocation(this._program, "aPosition");
        this._texCoordAttribute = gl.getAttribLocation(this._program, "aTexCoord");
        this._normalAttribute = gl.getAttribLocation(this._program, "aNormal");
        this._samplerUniform = gl.getUniformLocation(this._program, "uSampler");
        this._mMatrixUniform = gl.getUniformLocation(this._program, "uMMatrix");
        this._vMatrixUniform = gl.getUniformLocation(this._program, "uVMatrix");
        this._pMatrixUniform = gl.getUniformLocation(this._program, "uPMatrix");
        this._directionToLightUniform = gl.getUniformLocation(this._program, "uDirectionToLight");
        this._halfAngleUniform = gl.getUniformLocation(this._program, "uHalfAngle");
        this._specularPowerUniform = gl.getUniformLocation(this._program, "uSpecularPower");
        this._specularIntensityUniform = gl.getUniformLocation(this._program, "uSpecularIntensity");
        this._isInitialized = true;
    }
    apply() {
        this._gl.uniformMatrix4fv(this._mMatrixUniform, false, this.mMatrix);
        this._gl.uniform1i(this._samplerUniform, 0);
        this._gl.uniform1f(this._specularPowerUniform, this.specularPower);
        this._gl.uniform1f(this._specularIntensityUniform, this.specularIntensity);
    }
    applyView() {
        this._gl.uniform3fv(this._directionToLightUniform, this.directionToLight);
        this._gl.uniform3fv(this._halfAngleUniform, this.halfAngle);
        this._gl.uniformMatrix4fv(this._vMatrixUniform, false, this.vMatrix);
        this._gl.uniformMatrix4fv(this._pMatrixUniform, false, this.pMatrix);
    }
    updateBuffers() {
        super.updateBuffers();
        this._gl.bindBuffer(this._gl.ARRAY_BUFFER, this._vertexBuffer);
        this._gl.vertexAttribPointer(this._positionAttribute, 3, this._gl.FLOAT, false, (0, $0a0587bd8b0d58e8$export$e40add16394b9bff).SIZE_BYTES, (0, $0a0587bd8b0d58e8$export$e40add16394b9bff).POSITION_OFFSET_BYTES);
        this._gl.enableVertexAttribArray(this._positionAttribute);
        this._gl.vertexAttribPointer(this._normalAttribute, 3, this._gl.BYTE, true, (0, $0a0587bd8b0d58e8$export$e40add16394b9bff).SIZE_BYTES, (0, $0a0587bd8b0d58e8$export$e40add16394b9bff).NORMAL_OFFSET_BYTES);
        this._gl.enableVertexAttribArray(this._normalAttribute);
        this._gl.vertexAttribPointer(this._texCoordAttribute, 2, this._gl.UNSIGNED_SHORT, true, (0, $0a0587bd8b0d58e8$export$e40add16394b9bff).SIZE_BYTES, (0, $0a0587bd8b0d58e8$export$e40add16394b9bff).TEX_COORD_OFFSET_BYTES);
        this._gl.enableVertexAttribArray(this._texCoordAttribute);
        this._gl.bindBuffer(this._gl.ELEMENT_ARRAY_BUFFER, this._indexBuffer);
    }
    updateTextures() {
        super.updateTextures();
        this._gl.activeTexture(this._gl.TEXTURE0);
        this._gl.bindTexture(this._gl.TEXTURE_2D, this._texture2D);
    }
}


/*!
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 */ 

class $e9174d935ec6042d$export$a3be0de02f08c3be extends (0, $5ea895789fc20d6f$export$59a6ab026766925f) {
    get texture2D() {
        return this._texture2D;
    }
    set texture2D(value) {
        if (this._texture2D != value) {
            this._texture2D = value;
            this._haveTexturesChanged = true;
        }
    }
    initializeContext(gl) {
        super.initializeContext(gl);
        if (this._isLoaded) this._initializeShader(gl, this._vsSource, this._fsSource);
        else this._shaderFromFile("sdftext.vertex.fx", "sdftext.fragment.fx", (vsSource, fsSource)=>{
            if (this._main.shaderResources.OES_standard_derivatives == null) fsSource = this._removeDirective(fsSource, "Derivatives");
            this._vsSource = vsSource;
            this._fsSource = fsSource;
            this._isLoaded = true;
            this._initializeShader(gl, vsSource, fsSource);
        });
    }
    _initializeShader(gl, vsSource, fsSource) {
        const vs = this._compileShader(vsSource, gl.VERTEX_SHADER);
        const fs = this._compileShader(fsSource, gl.FRAGMENT_SHADER);
        this._program = this._createProgram(vs, fs);
        this._idColorAttribute = gl.getAttribLocation(this._program, "aIdColor");
        this._positionAttribute = gl.getAttribLocation(this._program, "aPosition");
        this._texCoordAttribute = gl.getAttribLocation(this._program, "aTexCoord");
        this._samplerUniform = gl.getUniformLocation(this._program, "uSampler");
        this._mMatrixUniform = gl.getUniformLocation(this._program, "uMMatrix");
        this._vMatrixUniform = gl.getUniformLocation(this._program, "uVMatrix");
        this._pMatrixUniform = gl.getUniformLocation(this._program, "uPMatrix");
        this._colorUniform = gl.getUniformLocation(this._program, "uColor");
        this._hoverColorUniform = gl.getUniformLocation(this._program, "uHoverColor");
        this._pickUniform = gl.getUniformLocation(this._program, "uPick");
        this._pickedIdColorUniform = gl.getUniformLocation(this._program, "uPickedIdColor");
        this._borderColorUniform = gl.getUniformLocation(this._program, "uBorderColor");
        this._bufferUniform = gl.getUniformLocation(this._program, "uBuffer");
        this._borderWidthUniform = gl.getUniformLocation(this._program, "uBorderWidth");
        this._gammaUniform = gl.getUniformLocation(this._program, "uGamma");
        this._isInitialized = true;
    }
    apply() {
        this._gl.uniform1i(this._samplerUniform, 0);
        this._gl.uniform3fv(this._colorUniform, this.color);
        this._gl.uniform3fv(this._hoverColorUniform, this.hoverColor);
        this._gl.uniform3fv(this._borderColorUniform, this.borderColor);
        this._gl.uniform1f(this._gammaUniform, this.gamma);
        this._gl.uniform1f(this._bufferUniform, this.buffer);
        this._gl.uniform1f(this._borderWidthUniform, this.borderWidth);
        this._gl.uniform4fv(this._pickedIdColorUniform, this.pickedIdColor);
    }
    applyModel() {
        this._gl.uniformMatrix4fv(this._mMatrixUniform, false, this.mMatrix);
    }
    applyView() {
        this._gl.uniform1i(this._pickUniform, this.isPickShader ? 1 : 0);
        this._gl.uniformMatrix4fv(this._vMatrixUniform, false, this.vMatrix);
        this._gl.uniformMatrix4fv(this._pMatrixUniform, false, this.pMatrix);
    }
    updateBuffers() {
        super.updateBuffers();
        this._gl.bindBuffer(this._gl.ARRAY_BUFFER, this._vertexBuffer);
        this._gl.vertexAttribPointer(this._idColorAttribute, 4, this._gl.UNSIGNED_BYTE, true, (0, $0a0587bd8b0d58e8$export$74c3c25430a16442).SIZE_BYTES, (0, $0a0587bd8b0d58e8$export$74c3c25430a16442).ID_COLOR_OFFSET_BYTES);
        this._gl.enableVertexAttribArray(this._idColorAttribute);
        this._gl.vertexAttribPointer(this._positionAttribute, 3, this._gl.FLOAT, false, (0, $0a0587bd8b0d58e8$export$74c3c25430a16442).SIZE_BYTES, (0, $0a0587bd8b0d58e8$export$74c3c25430a16442).POSITION_OFFSET_BYTES);
        this._gl.enableVertexAttribArray(this._positionAttribute);
        this._gl.vertexAttribPointer(this._texCoordAttribute, 2, this._gl.UNSIGNED_SHORT, true, (0, $0a0587bd8b0d58e8$export$74c3c25430a16442).SIZE_BYTES, (0, $0a0587bd8b0d58e8$export$74c3c25430a16442).TEX_COORD_OFFSET_BYTES);
        this._gl.enableVertexAttribArray(this._texCoordAttribute);
        this._gl.bindBuffer(this._gl.ELEMENT_ARRAY_BUFFER, this._indexBuffer);
    }
    updateTextures() {
        super.updateTextures();
        this._gl.activeTexture(this._gl.TEXTURE0);
        this._gl.bindTexture(this._gl.TEXTURE_2D, this._texture2D);
    }
}


/*!
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 */ 

class $b81993c7a1128963$export$3b812729b68dda3e extends (0, $5ea895789fc20d6f$export$59a6ab026766925f) {
    initializeContext(gl) {
        super.initializeContext(gl);
        if (this._isLoaded) this._initializeShader(gl, this._vsSource, this._fsSource);
        else this._shaderFromFile("pickgrid.vertex.fx", "pickgrid.fragment.fx", (vsSource, fsSource)=>{
            if (this._main.shaderResources.OES_standard_derivatives == null) fsSource = this._removeDirective(fsSource, "Derivatives");
            this._vsSource = vsSource;
            this._fsSource = fsSource;
            this._isLoaded = true;
            this._initializeShader(gl, vsSource, fsSource);
        });
    }
    _initializeShader(gl, vsSource, fsSource) {
        const vs = this._compileShader(vsSource, gl.VERTEX_SHADER);
        const fs = this._compileShader(fsSource, gl.FRAGMENT_SHADER);
        this._program = this._createProgram(vs, fs);
        this._positionAttribute = this._gl.getAttribLocation(this._program, "aPosition");
        this._idColorAttribute = this._gl.getAttribLocation(this._program, "aIdColor");
        this._texCoordAttribute = this._gl.getAttribLocation(this._program, "aTexCoord");
        this._normalAttribute = this._gl.getAttribLocation(this._program, "aNormal");
        this._boundsAttribute = this._gl.getAttribLocation(this._program, "aBounds");
        this._pMatrixUniform = gl.getUniformLocation(this._program, "uPMatrix");
        this._mMatrixUniform = gl.getUniformLocation(this._program, "uMMatrix");
        this._vMatrixUniform = gl.getUniformLocation(this._program, "uVMatrix");
        this._pickUniform = gl.getUniformLocation(this._program, "uPick");
        this._majorColorUniform = gl.getUniformLocation(this._program, "uMajorColor");
        this._minorColorUniform = gl.getUniformLocation(this._program, "uMinorColor");
        this._zeroColorUniform = gl.getUniformLocation(this._program, "uZeroColor");
        this._backgroundUniform = gl.getUniformLocation(this._program, "uBackground");
        this._highlightUniform = gl.getUniformLocation(this._program, "uHighlight");
        this._pickedIdColorUniform = gl.getUniformLocation(this._program, "uPickedIdColor");
        this._faceSizeUniform = gl.getUniformLocation(this._program, "uFaceSize");
        this._majorThicknessUniform = gl.getUniformLocation(this._program, "uMajorThickness");
        this._minorThicknessUniform = gl.getUniformLocation(this._program, "uMinorThickness");
        this._zeroThicknessUniform = gl.getUniformLocation(this._program, "uZeroThickness");
        this._zeroUniform = gl.getUniformLocation(this._program, "uZero");
        this._minorGridlinesUniform = gl.getUniformLocation(this._program, "uMinorGridlines");
        this._directionToLightUniform = gl.getUniformLocation(this._program, "uDirectionToLight");
        this._isInitialized = true;
    }
    apply() {
        this._gl.uniform1f(this._majorThicknessUniform, this.majorThickness);
        this._gl.uniform1f(this._minorThicknessUniform, this.minorThickness);
        this._gl.uniform1f(this._zeroThicknessUniform, this.zeroThickness);
        this._gl.uniform3fv(this._backgroundUniform, this.backgroundColor);
        this._gl.uniform3fv(this._highlightUniform, this.highlightColor);
        this._gl.uniform3fv(this._majorColorUniform, this.majorColor);
        this._gl.uniform3fv(this._minorColorUniform, this.minorColor);
        this._gl.uniform3fv(this._zeroColorUniform, this.zeroColor);
        this._gl.uniform3fv(this._directionToLightUniform, this.directionToLight);
        this._gl.uniform4fv(this._pickedIdColorUniform, this.pickedIdColor);
    }
    applyView() {
        this._gl.uniform1i(this._pickUniform, this.isPickShader ? 1 : 0);
        this._gl.uniformMatrix4fv(this._vMatrixUniform, false, this.vMatrix);
        this._gl.uniformMatrix4fv(this._pMatrixUniform, false, this.pMatrix);
    }
    ApplyFace() {
        this._gl.uniformMatrix4fv(this._mMatrixUniform, false, this.mMatrix);
        this._gl.uniform2f(this._faceSizeUniform, this.faceWidth, this.faceHeight);
        this._gl.uniform2fv(this._zeroUniform, this.zero);
        this._gl.uniform2fv(this._minorGridlinesUniform, this.minorGridlines);
    }
    updateBuffers() {
        super.updateBuffers();
        this._gl.bindBuffer(this._gl.ARRAY_BUFFER, this._vertexBuffer);
        this._gl.vertexAttribPointer(this._positionAttribute, 3, this._gl.FLOAT, false, (0, $0a0587bd8b0d58e8$export$df352805a955aca5).SIZE_BYTES, (0, $0a0587bd8b0d58e8$export$df352805a955aca5).TRANSLATION_OFFSET_BYTES);
        this._gl.enableVertexAttribArray(this._positionAttribute);
        this._gl.vertexAttribPointer(this._normalAttribute, 3, this._gl.BYTE, true, (0, $0a0587bd8b0d58e8$export$df352805a955aca5).SIZE_BYTES, (0, $0a0587bd8b0d58e8$export$df352805a955aca5).NORMAL_OFFSET_BYTES);
        this._gl.enableVertexAttribArray(this._normalAttribute);
        this._gl.vertexAttribPointer(this._texCoordAttribute, 2, this._gl.UNSIGNED_SHORT, true, (0, $0a0587bd8b0d58e8$export$df352805a955aca5).SIZE_BYTES, (0, $0a0587bd8b0d58e8$export$df352805a955aca5).TEX_COORD_OFFSET_BYTES);
        this._gl.enableVertexAttribArray(this._texCoordAttribute);
        this._gl.vertexAttribPointer(this._idColorAttribute, 4, this._gl.UNSIGNED_BYTE, true, (0, $0a0587bd8b0d58e8$export$df352805a955aca5).SIZE_BYTES, (0, $0a0587bd8b0d58e8$export$df352805a955aca5).ID_COLOR_OFFSET_BYTES);
        this._gl.enableVertexAttribArray(this._idColorAttribute);
        this._gl.vertexAttribPointer(this._boundsAttribute, 4, this._gl.UNSIGNED_SHORT, true, (0, $0a0587bd8b0d58e8$export$df352805a955aca5).SIZE_BYTES, (0, $0a0587bd8b0d58e8$export$df352805a955aca5).BOUNDS_OFFSET_BYTES);
        this._gl.enableVertexAttribArray(this._boundsAttribute);
        this._gl.bindBuffer(this._gl.ELEMENT_ARRAY_BUFFER, this._indexBuffer);
    }
}


/*!
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 */ 
/*!
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 */ 



class $46ea8e3175829f45$export$c4c8cc0016dff604 extends (0, $5ea895789fc20d6f$export$59a6ab026766925f) {
    get paletteTexture() {
        return this._paletteTexture;
    }
    set paletteTexture(value) {
        if (this._paletteTexture != value) {
            this._paletteTexture = value;
            this._haveTexturesChanged = true;
        }
    }
    get previousPaletteTexture() {
        return this._previousPaletteTexture;
    }
    set previousPaletteTexture(value) {
        if (this._previousPaletteTexture != value) {
            this._previousPaletteTexture = value;
            this._haveTexturesChanged = true;
        }
    }
    get sdfTexture() {
        return this._sdfTexture;
    }
    set sdfTexture(value) {
        if (this._sdfTexture != value) {
            this._sdfTexture = value;
            this._haveTexturesChanged = true;
        }
    }
    get previousSdfTexture() {
        return this._previousSdfTexture;
    }
    set previousSdfTexture(value) {
        if (this._previousSdfTexture != value) {
            this._previousSdfTexture = value;
            this._haveTexturesChanged = true;
        }
    }
    set instanceBuffer(value) {
        if (this._instanceBuffer != value) {
            this._instanceBuffer = value;
            this._haveBuffersChanged = true;
        }
    }
    set previousInstanceBuffer(value) {
        if (this._previousInstanceBuffer != value) {
            this._previousInstanceBuffer = value;
            this._haveBuffersChanged = true;
        }
    }
    initializeData() {
        this._areBuffersInitialized = false;
    }
    _initializeShader(gl, vsSource, fsSource) {
        const vs = this._compileShader(vsSource, gl.VERTEX_SHADER);
        const fs = this._compileShader(fsSource, gl.FRAGMENT_SHADER);
        this._program = this._createProgram(vs, fs);
        this._positionAttribute = gl.getAttribLocation(this._program, "aPosition");
        this._translationAttribute = gl.getAttribLocation(this._program, "aTranslation");
        this._previousTranslationAttribute = gl.getAttribLocation(this._program, "aPreviousTranslation");
        this._scaleAttribute = gl.getAttribLocation(this._program, "aScale");
        this._previousScaleAttribute = gl.getAttribLocation(this._program, "aPreviousScale");
        this._colorAttribute = gl.getAttribLocation(this._program, "aColor");
        this._previousColorAttribute = gl.getAttribLocation(this._program, "aPreviousColor");
        this._selectedAttribute = gl.getAttribLocation(this._program, "aSelected");
        this._previousSelectedAttribute = gl.getAttribLocation(this._program, "aPreviousSelected");
        this._orderAttribute = gl.getAttribLocation(this._program, "aOrder");
        this._idAttribute = gl.getAttribLocation(this._program, "aId");
        this._idColorAttribute = gl.getAttribLocation(this._program, "aIdColor");
        this._sampler0Uniform = gl.getUniformLocation(this._program, "uSampler");
        this._previousSampler0Uniform = gl.getUniformLocation(this._program, "uPreviousSampler");
        this._mMatrixUniform = gl.getUniformLocation(this._program, "uMMatrix");
        this._vMatrixUniform = gl.getUniformLocation(this._program, "uVMatrix");
        this._pMatrixUniform = gl.getUniformLocation(this._program, "uPMatrix");
        this._timeUniform = gl.getUniformLocation(this._program, "uTime");
        this._durationUniform = gl.getUniformLocation(this._program, "uDuration");
        this._fromOrderUniform = gl.getUniformLocation(this._program, "uOrderFrom");
        this._toOrderUniform = gl.getUniformLocation(this._program, "uOrderTo");
        this._hoverUniform = gl.getUniformLocation(this._program, "uHover");
        this._activeUniform = gl.getUniformLocation(this._program, "uActive");
        this._pickUniform = gl.getUniformLocation(this._program, "uPick");
        this._directionToLightUniform = gl.getUniformLocation(this._program, "uDirectionToLight");
        this._halfAngleUniform = gl.getUniformLocation(this._program, "uHalfAngle");
        this._specularPowerUniform = gl.getUniformLocation(this._program, "uSpecularPower");
        this._specularIntensityUniform = gl.getUniformLocation(this._program, "uSpecularIntensity");
        this._hoverColorUniform = gl.getUniformLocation(this._program, "uHoverColor");
        this._ambientUniform = gl.getUniformLocation(this._program, "uAmbient");
        this._activeColorUniform = gl.getUniformLocation(this._program, "uActiveColor");
        this._selectedColorUniform = gl.getUniformLocation(this._program, "uSelectedColor");
        this._highlightModeUniform = gl.getUniformLocation(this._program, "uHighlightMode");
        const vertices = (0, $c2c30e4dcf8004c5$export$a15f0a83a652dd40).POSITIONS;
        this._vertexBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, this._vertexBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW);
        const indices = (0, $c2c30e4dcf8004c5$export$a15f0a83a652dd40).INDICES;
        this._indexBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this._indexBuffer);
        gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, indices, gl.STATIC_DRAW);
        this.indexCount = indices.length;
    }
    updateBuffers() {
        super.updateBuffers();
        this._gl.bindBuffer(this._gl.ELEMENT_ARRAY_BUFFER, this._indexBuffer);
        this._gl.bindBuffer(this._gl.ARRAY_BUFFER, this._vertexBuffer);
        this._gl.vertexAttribPointer(this._positionAttribute, 3, this._gl.FLOAT, false, 12, 0);
        this._gl.enableVertexAttribArray(this._positionAttribute);
        this._updateCurrentBuffer();
        this._updatePreviousBuffer();
    }
    _updateCurrentBuffer() {
        const ANGLE_instanced_arrays = this._main.shaderResources.ANGLE_instanced_arrays;
        this._gl.bindBuffer(this._gl.ARRAY_BUFFER, this._instanceBuffer);
        this._gl.vertexAttribPointer(this._idAttribute, 1, this._gl.FLOAT, false, (0, $0a0587bd8b0d58e8$export$849e31d725692576).SIZE_BYTES, (0, $0a0587bd8b0d58e8$export$849e31d725692576).ID_HOVER_OFFSET_BYTES);
        ANGLE_instanced_arrays.vertexAttribDivisorANGLE(this._idAttribute, 1);
        this._gl.enableVertexAttribArray(this._idAttribute);
        this._gl.vertexAttribPointer(this._idColorAttribute, 4, this._gl.UNSIGNED_BYTE, true, (0, $0a0587bd8b0d58e8$export$849e31d725692576).SIZE_BYTES, (0, $0a0587bd8b0d58e8$export$849e31d725692576).ID_COLOR_OFFSET_BYTES);
        ANGLE_instanced_arrays.vertexAttribDivisorANGLE(this._idColorAttribute, 1);
        this._gl.enableVertexAttribArray(this._idColorAttribute);
        this._gl.vertexAttribPointer(this._translationAttribute, 3, this._gl.FLOAT, false, (0, $0a0587bd8b0d58e8$export$849e31d725692576).SIZE_BYTES, (0, $0a0587bd8b0d58e8$export$849e31d725692576).TRANSLATION_OFFSET_BYTES);
        ANGLE_instanced_arrays.vertexAttribDivisorANGLE(this._translationAttribute, 1);
        this._gl.enableVertexAttribArray(this._translationAttribute);
        this._gl.vertexAttribPointer(this._scaleAttribute, 3, this._gl.FLOAT, false, (0, $0a0587bd8b0d58e8$export$849e31d725692576).SIZE_BYTES, (0, $0a0587bd8b0d58e8$export$849e31d725692576).SCALE_OFFSET_BYTES);
        ANGLE_instanced_arrays.vertexAttribDivisorANGLE(this._scaleAttribute, 1);
        this._gl.enableVertexAttribArray(this._scaleAttribute);
        this._gl.vertexAttribPointer(this._selectedAttribute, 1, this._gl.BYTE, true, (0, $0a0587bd8b0d58e8$export$849e31d725692576).SIZE_BYTES, (0, $0a0587bd8b0d58e8$export$849e31d725692576).SELECTED_OFFSET_BYTES);
        ANGLE_instanced_arrays.vertexAttribDivisorANGLE(this._selectedAttribute, 1);
        this._gl.enableVertexAttribArray(this._selectedAttribute);
        this._gl.vertexAttribPointer(this._orderAttribute, 2, this._gl.FLOAT, false, (0, $0a0587bd8b0d58e8$export$849e31d725692576).SIZE_BYTES, (0, $0a0587bd8b0d58e8$export$849e31d725692576).ORDER_OFFSET_BYTES);
        ANGLE_instanced_arrays.vertexAttribDivisorANGLE(this._orderAttribute, 1);
        this._gl.enableVertexAttribArray(this._orderAttribute);
    }
    _updatePreviousBuffer() {
        const ANGLE_instanced_arrays = this._main.shaderResources.ANGLE_instanced_arrays;
        if (this._previousInstanceBuffer != this._instanceBuffer) this._gl.bindBuffer(this._gl.ARRAY_BUFFER, this._previousInstanceBuffer);
        this._gl.vertexAttribPointer(this._previousTranslationAttribute, 3, this._gl.FLOAT, false, (0, $0a0587bd8b0d58e8$export$849e31d725692576).SIZE_BYTES, (0, $0a0587bd8b0d58e8$export$849e31d725692576).TRANSLATION_OFFSET_BYTES);
        ANGLE_instanced_arrays.vertexAttribDivisorANGLE(this._previousTranslationAttribute, 1);
        this._gl.enableVertexAttribArray(this._previousTranslationAttribute);
        this._gl.vertexAttribPointer(this._previousScaleAttribute, 3, this._gl.FLOAT, false, (0, $0a0587bd8b0d58e8$export$849e31d725692576).SIZE_BYTES, (0, $0a0587bd8b0d58e8$export$849e31d725692576).SCALE_OFFSET_BYTES);
        ANGLE_instanced_arrays.vertexAttribDivisorANGLE(this._previousScaleAttribute, 1);
        this._gl.enableVertexAttribArray(this._previousScaleAttribute);
        this._gl.vertexAttribPointer(this._previousSelectedAttribute, 1, this._gl.BYTE, true, (0, $0a0587bd8b0d58e8$export$849e31d725692576).SIZE_BYTES, (0, $0a0587bd8b0d58e8$export$849e31d725692576).SELECTED_OFFSET_BYTES);
        ANGLE_instanced_arrays.vertexAttribDivisorANGLE(this._previousSelectedAttribute, 1);
        this._gl.enableVertexAttribArray(this._previousSelectedAttribute);
    }
    apply() {
        this._gl.uniformMatrix4fv(this._mMatrixUniform, false, this.mMatrix);
        this._gl.uniform1f(this._timeUniform, this.time);
        this._gl.uniform1f(this._durationUniform, this.duration);
        this._gl.uniform1f(this._fromOrderUniform, this.rangeMin);
        this._gl.uniform1f(this._toOrderUniform, this.rangeMax);
        this._gl.uniform1i(this._previousSampler0Uniform, 0);
        this._gl.uniform1i(this._sampler0Uniform, 1);
        this._gl.uniform1f(this._specularPowerUniform, this.specularPower);
        this._gl.uniform1f(this._specularIntensityUniform, this.specularIntensity);
        this._gl.uniform1f(this._ambientUniform, this.ambient);
        this._gl.uniform3fv(this._hoverColorUniform, this.hoverColor);
        this._gl.uniform3fv(this._activeColorUniform, this.activeColor);
        this._gl.uniform3fv(this._selectedColorUniform, this.selectedColor);
        this._gl.uniform1f(this._hoverUniform, this.hover);
        this._gl.uniform1f(this._activeUniform, this.active);
        this._gl.uniform1f(this._highlightModeUniform, this.highlightMode == (0, $4a6417d29706362f$export$6b731eb2fd512fe0).luminance ? 0.0 : 1.0);
    }
    applyView() {
        this._gl.uniformMatrix4fv(this._vMatrixUniform, false, this.vMatrix);
        this._gl.uniformMatrix4fv(this._pMatrixUniform, false, this.pMatrix);
        this._gl.uniform3fv(this._directionToLightUniform, this.directionToLight);
        this._gl.uniform3fv(this._halfAngleUniform, this.halfAngle);
        this._gl.uniform1i(this._pickUniform, this.isPickShader ? 1 : 0);
    }
    updateTextures() {
        this._gl.activeTexture(this._gl.TEXTURE0);
        this._gl.bindTexture(this._gl.TEXTURE_2D, this._previousPaletteTexture);
        this._gl.activeTexture(this._gl.TEXTURE1);
        this._gl.bindTexture(this._gl.TEXTURE_2D, this._paletteTexture);
    }
    disableProgram() {
        super.disableProgram();
        const ANGLE_instanced_arrays = this._main.shaderResources.ANGLE_instanced_arrays;
        ANGLE_instanced_arrays.vertexAttribDivisorANGLE(this._translationAttribute, 0);
        ANGLE_instanced_arrays.vertexAttribDivisorANGLE(this._previousTranslationAttribute, 0);
        ANGLE_instanced_arrays.vertexAttribDivisorANGLE(this._scaleAttribute, 0);
        ANGLE_instanced_arrays.vertexAttribDivisorANGLE(this._previousScaleAttribute, 0);
        ANGLE_instanced_arrays.vertexAttribDivisorANGLE(this._colorAttribute, 0);
        ANGLE_instanced_arrays.vertexAttribDivisorANGLE(this._previousColorAttribute, 0);
        ANGLE_instanced_arrays.vertexAttribDivisorANGLE(this._selectedAttribute, 0);
        ANGLE_instanced_arrays.vertexAttribDivisorANGLE(this._previousSelectedAttribute, 0);
        ANGLE_instanced_arrays.vertexAttribDivisorANGLE(this._orderAttribute, 0);
        ANGLE_instanced_arrays.vertexAttribDivisorANGLE(this._idAttribute, 0);
        ANGLE_instanced_arrays.vertexAttribDivisorANGLE(this._idColorAttribute, 0);
    }
}


class $592f874dfaaf58b7$export$b72dd5e86522410a extends (0, $46ea8e3175829f45$export$c4c8cc0016dff604) {
    initializeContext(gl) {
        super.initializeContext(gl);
        if (this._isLoaded) this._initializeShader(gl, this._vsSource, this._fsSource);
        else this._shaderFromFile("unitblock.vertex.fx", "unitblock.fragment.fx", (vsSource, fsSource)=>{
            if (this._main.shaderResources.OES_standard_derivatives == null) {
                vsSource = this._removeDirective(vsSource, "Derivatives");
                fsSource = this._removeDirective(fsSource, "Derivatives");
            }
            this._vsSource = vsSource;
            this._fsSource = fsSource;
            this._isLoaded = true;
            this._initializeShader(gl, vsSource, fsSource);
        });
    }
    _initializeShader(gl, vsSource, fsSource) {
        super._initializeShader(gl, vsSource, fsSource);
        this._rotationAttribute = gl.getAttribLocation(this._program, "aRotation");
        this._previousRotationAttribute = gl.getAttribLocation(this._program, "aPreviousRotation");
        this._isInitialized = true;
    }
    _updateCurrentBuffer() {
        super._updateCurrentBuffer();
        const ANGLE_instanced_arrays = this._main.shaderResources.ANGLE_instanced_arrays;
        this._gl.vertexAttribPointer(this._rotationAttribute, 4, this._gl.FLOAT, false, (0, $0a0587bd8b0d58e8$export$849e31d725692576).SIZE_BYTES, (0, $0a0587bd8b0d58e8$export$849e31d725692576).ROTATION_OFFSET_BYTES);
        ANGLE_instanced_arrays.vertexAttribDivisorANGLE(this._rotationAttribute, 1);
        this._gl.enableVertexAttribArray(this._rotationAttribute);
        this._gl.vertexAttribPointer(this._colorAttribute, 2, this._gl.UNSIGNED_BYTE, true, (0, $0a0587bd8b0d58e8$export$849e31d725692576).SIZE_BYTES, (0, $0a0587bd8b0d58e8$export$849e31d725692576).COLOR_OFFSET_BYTES);
        ANGLE_instanced_arrays.vertexAttribDivisorANGLE(this._colorAttribute, 1);
        this._gl.enableVertexAttribArray(this._colorAttribute);
    }
    _updatePreviousBuffer() {
        super._updatePreviousBuffer();
        const ANGLE_instanced_arrays = this._main.shaderResources.ANGLE_instanced_arrays;
        this._gl.vertexAttribPointer(this._previousRotationAttribute, 4, this._gl.FLOAT, false, (0, $0a0587bd8b0d58e8$export$849e31d725692576).SIZE_BYTES, (0, $0a0587bd8b0d58e8$export$849e31d725692576).ROTATION_OFFSET_BYTES);
        ANGLE_instanced_arrays.vertexAttribDivisorANGLE(this._previousRotationAttribute, 1);
        this._gl.enableVertexAttribArray(this._previousRotationAttribute);
        this._gl.vertexAttribPointer(this._previousColorAttribute, 2, this._gl.UNSIGNED_BYTE, true, (0, $0a0587bd8b0d58e8$export$849e31d725692576).SIZE_BYTES, (0, $0a0587bd8b0d58e8$export$849e31d725692576).COLOR_OFFSET_BYTES);
        ANGLE_instanced_arrays.vertexAttribDivisorANGLE(this._previousColorAttribute, 1);
        this._gl.enableVertexAttribArray(this._previousColorAttribute);
    }
    disableProgram() {
        super.disableProgram();
        const ANGLE_instanced_arrays = this._main.shaderResources.ANGLE_instanced_arrays;
        ANGLE_instanced_arrays.vertexAttribDivisorANGLE(this._rotationAttribute, 0);
        ANGLE_instanced_arrays.vertexAttribDivisorANGLE(this._previousRotationAttribute, 0);
    }
}


/*!
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 */ 

class $8cca1fe874486634$export$427a5e80ce652e7d extends (0, $46ea8e3175829f45$export$c4c8cc0016dff604) {
    initializeContext(gl) {
        super.initializeContext(gl);
        if (this._isLoaded) this._initializeShader(gl, this._vsSource, this._fsSource);
        else this._shaderFromFile("unitsphere.vertex.fx", "unitsphere.fragment.fx", (vsSource, fsSource)=>{
            if (this._main.shaderResources.EXT_frag_depth == null) fsSource = this._removeDirective(fsSource, "FragDepth");
            this._vsSource = vsSource;
            this._fsSource = fsSource;
            this._isLoaded = true;
            this._initializeShader(gl, vsSource, fsSource);
        });
    }
    _initializeShader(gl, vsSource, fsSource) {
        super._initializeShader(gl, vsSource, fsSource);
        this._isInitialized = true;
    }
    _updateCurrentBuffer() {
        super._updateCurrentBuffer();
        const ANGLE_instanced_arrays = this._main.shaderResources.ANGLE_instanced_arrays;
        this._gl.vertexAttribPointer(this._colorAttribute, 1, this._gl.UNSIGNED_BYTE, true, (0, $0a0587bd8b0d58e8$export$849e31d725692576).SIZE_BYTES, (0, $0a0587bd8b0d58e8$export$849e31d725692576).COLOR_OFFSET_BYTES);
        ANGLE_instanced_arrays.vertexAttribDivisorANGLE(this._colorAttribute, 1);
        this._gl.enableVertexAttribArray(this._colorAttribute);
    }
    _updatePreviousBuffer() {
        super._updatePreviousBuffer();
        const ANGLE_instanced_arrays = this._main.shaderResources.ANGLE_instanced_arrays;
        this._gl.vertexAttribPointer(this._previousColorAttribute, 1, this._gl.UNSIGNED_BYTE, true, (0, $0a0587bd8b0d58e8$export$849e31d725692576).SIZE_BYTES, (0, $0a0587bd8b0d58e8$export$849e31d725692576).COLOR_OFFSET_BYTES);
        ANGLE_instanced_arrays.vertexAttribDivisorANGLE(this._previousColorAttribute, 1);
        this._gl.enableVertexAttribArray(this._previousColorAttribute);
    }
}


/*!
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 */ 

class $1876c8aeb7dcd226$export$28e50bed796372f2 extends (0, $46ea8e3175829f45$export$c4c8cc0016dff604) {
    initializeContext(gl) {
        super.initializeContext(gl);
        if (this._isLoaded) this._initializeShader(gl, this._vsSource, this._fsSource);
        else this._shaderFromFile("unitcylinder.vertex.fx", "unitcylinder.fragment.fx", (vsSource, fsSource)=>{
            if (this._main.shaderResources.EXT_frag_depth == null) fsSource = this._removeDirective(fsSource, "FragDepth");
            this._vsSource = vsSource;
            this._fsSource = fsSource;
            this._isLoaded = true;
            this._initializeShader(gl, vsSource, fsSource);
        });
    }
    _initializeShader(gl, vsSource, fsSource) {
        super._initializeShader(gl, vsSource, fsSource);
        this._rotationAttribute = gl.getAttribLocation(this._program, "aRotation");
        this._previousRotationAttribute = gl.getAttribLocation(this._program, "aPreviousRotation");
        this._isInitialized = true;
    }
    _updateCurrentBuffer() {
        super._updateCurrentBuffer();
        const ANGLE_instanced_arrays = this._main.shaderResources.ANGLE_instanced_arrays;
        this._gl.vertexAttribPointer(this._rotationAttribute, 4, this._gl.FLOAT, false, (0, $0a0587bd8b0d58e8$export$849e31d725692576).SIZE_BYTES, (0, $0a0587bd8b0d58e8$export$849e31d725692576).ROTATION_OFFSET_BYTES);
        ANGLE_instanced_arrays.vertexAttribDivisorANGLE(this._rotationAttribute, 1);
        this._gl.enableVertexAttribArray(this._rotationAttribute);
        this._gl.vertexAttribPointer(this._colorAttribute, 2, this._gl.UNSIGNED_BYTE, true, (0, $0a0587bd8b0d58e8$export$849e31d725692576).SIZE_BYTES, (0, $0a0587bd8b0d58e8$export$849e31d725692576).COLOR_OFFSET_BYTES);
        ANGLE_instanced_arrays.vertexAttribDivisorANGLE(this._colorAttribute, 1);
        this._gl.enableVertexAttribArray(this._colorAttribute);
    }
    _updatePreviousBuffer() {
        super._updatePreviousBuffer();
        const ANGLE_instanced_arrays = this._main.shaderResources.ANGLE_instanced_arrays;
        this._gl.vertexAttribPointer(this._previousRotationAttribute, 4, this._gl.FLOAT, false, (0, $0a0587bd8b0d58e8$export$849e31d725692576).SIZE_BYTES, (0, $0a0587bd8b0d58e8$export$849e31d725692576).ROTATION_OFFSET_BYTES);
        ANGLE_instanced_arrays.vertexAttribDivisorANGLE(this._previousRotationAttribute, 1);
        this._gl.enableVertexAttribArray(this._previousRotationAttribute);
        this._gl.vertexAttribPointer(this._previousColorAttribute, 2, this._gl.UNSIGNED_BYTE, true, (0, $0a0587bd8b0d58e8$export$849e31d725692576).SIZE_BYTES, (0, $0a0587bd8b0d58e8$export$849e31d725692576).COLOR_OFFSET_BYTES);
        ANGLE_instanced_arrays.vertexAttribDivisorANGLE(this._previousColorAttribute, 1);
        this._gl.enableVertexAttribArray(this._previousColorAttribute);
    }
    disableProgram() {
        super.disableProgram();
        const ANGLE_instanced_arrays = this._main.shaderResources.ANGLE_instanced_arrays;
        ANGLE_instanced_arrays.vertexAttribDivisorANGLE(this._rotationAttribute, 0);
        ANGLE_instanced_arrays.vertexAttribDivisorANGLE(this._previousRotationAttribute, 0);
    }
}


/*!
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 */ 

class $aa73a9318009cb1a$export$d39efaf3a2b8a5a extends (0, $46ea8e3175829f45$export$c4c8cc0016dff604) {
    initializeContext(gl) {
        super.initializeContext(gl);
        if (this._isLoaded) this._initializeShader(gl, this._vsSource, this._fsSource);
        else this._shaderFromFile("unithexprism.vertex.fx", "unithexprism.fragment.fx", (vsSource, fsSource)=>{
            if (this._main.shaderResources.EXT_frag_depth == null) fsSource = this._removeDirective(fsSource, "FragDepth");
            this._vsSource = vsSource;
            this._fsSource = fsSource;
            this._isLoaded = true;
            this._initializeShader(gl, vsSource, fsSource);
        });
    }
    _initializeShader(gl, vsSource, fsSource) {
        super._initializeShader(gl, vsSource, fsSource);
        this._rotationAttribute = gl.getAttribLocation(this._program, "aRotation");
        this._previousRotationAttribute = gl.getAttribLocation(this._program, "aPreviousRotation");
        this._isInitialized = true;
    }
    _updateCurrentBuffer() {
        super._updateCurrentBuffer();
        const ANGLE_instanced_arrays = this._main.shaderResources.ANGLE_instanced_arrays;
        this._gl.vertexAttribPointer(this._rotationAttribute, 4, this._gl.FLOAT, false, (0, $0a0587bd8b0d58e8$export$849e31d725692576).SIZE_BYTES, (0, $0a0587bd8b0d58e8$export$849e31d725692576).ROTATION_OFFSET_BYTES);
        ANGLE_instanced_arrays.vertexAttribDivisorANGLE(this._rotationAttribute, 1);
        this._gl.enableVertexAttribArray(this._rotationAttribute);
        this._gl.vertexAttribPointer(this._colorAttribute, 2, this._gl.UNSIGNED_BYTE, true, (0, $0a0587bd8b0d58e8$export$849e31d725692576).SIZE_BYTES, (0, $0a0587bd8b0d58e8$export$849e31d725692576).COLOR_OFFSET_BYTES);
        ANGLE_instanced_arrays.vertexAttribDivisorANGLE(this._colorAttribute, 1);
        this._gl.enableVertexAttribArray(this._colorAttribute);
    }
    _updatePreviousBuffer() {
        super._updatePreviousBuffer();
        const ANGLE_instanced_arrays = this._main.shaderResources.ANGLE_instanced_arrays;
        this._gl.vertexAttribPointer(this._previousRotationAttribute, 4, this._gl.FLOAT, false, (0, $0a0587bd8b0d58e8$export$849e31d725692576).SIZE_BYTES, (0, $0a0587bd8b0d58e8$export$849e31d725692576).ROTATION_OFFSET_BYTES);
        ANGLE_instanced_arrays.vertexAttribDivisorANGLE(this._previousRotationAttribute, 1);
        this._gl.enableVertexAttribArray(this._previousRotationAttribute);
        this._gl.vertexAttribPointer(this._previousColorAttribute, 2, this._gl.UNSIGNED_BYTE, true, (0, $0a0587bd8b0d58e8$export$849e31d725692576).SIZE_BYTES, (0, $0a0587bd8b0d58e8$export$849e31d725692576).COLOR_OFFSET_BYTES);
        ANGLE_instanced_arrays.vertexAttribDivisorANGLE(this._previousColorAttribute, 1);
        this._gl.enableVertexAttribArray(this._previousColorAttribute);
    }
    disableProgram() {
        super.disableProgram();
        const ANGLE_instanced_arrays = this._main.shaderResources.ANGLE_instanced_arrays;
        ANGLE_instanced_arrays.vertexAttribDivisorANGLE(this._rotationAttribute, 0);
        ANGLE_instanced_arrays.vertexAttribDivisorANGLE(this._previousRotationAttribute, 0);
    }
}


/*!
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 */ 

class $67534a528c920bae$export$b0bdf50006eaaa7a extends (0, $46ea8e3175829f45$export$c4c8cc0016dff604) {
    initializeContext(gl) {
        super.initializeContext(gl);
        if (this._isLoaded) this._initializeShader(gl, this._vsSource, this._fsSource);
        else this._shaderFromFile("unitsdf.vertex.fx", "unitsdf.fragment.fx", (vsSource, fsSource)=>{
            if (this._main.shaderResources.OES_standard_derivatives == null) {
                vsSource = this._removeDirective(vsSource, "Derivatives");
                fsSource = this._removeDirective(fsSource, "Derivatives");
            }
            this._vsSource = vsSource;
            this._fsSource = fsSource;
            this._isLoaded = true;
            this._initializeShader(gl, vsSource, fsSource);
        });
    }
    _initializeShader(gl, vsSource, fsSource) {
        super._initializeShader(gl, vsSource, fsSource);
        this._rotationAttribute = gl.getAttribLocation(this._program, "aRotation");
        this._previousRotationAttribute = gl.getAttribLocation(this._program, "aPreviousRotation");
        this._texCoordAttribute = gl.getAttribLocation(this._program, "aTexCoord");
        this._previousTexCoordAttribute = gl.getAttribLocation(this._program, "aPreviousTexCoord");
        this._sampler1Uniform = gl.getUniformLocation(this._program, "uSampler1");
        this._previousSampler1Uniform = gl.getUniformLocation(this._program, "uPreviousSampler1");
        this._sdfBufferUniform = gl.getUniformLocation(this._program, "uBuffer");
        this._sdfBackgroundColorUniform = gl.getUniformLocation(this._program, "uBackgroundColor");
        this._isInitialized = true;
    }
    _updateCurrentBuffer() {
        super._updateCurrentBuffer();
        const ANGLE_instanced_arrays = this._main.shaderResources.ANGLE_instanced_arrays;
        this._gl.vertexAttribPointer(this._rotationAttribute, 4, this._gl.FLOAT, false, (0, $0a0587bd8b0d58e8$export$849e31d725692576).SIZE_BYTES, (0, $0a0587bd8b0d58e8$export$849e31d725692576).ROTATION_OFFSET_BYTES);
        ANGLE_instanced_arrays.vertexAttribDivisorANGLE(this._rotationAttribute, 1);
        this._gl.enableVertexAttribArray(this._rotationAttribute);
        this._gl.vertexAttribPointer(this._texCoordAttribute, 4, this._gl.FLOAT, false, (0, $0a0587bd8b0d58e8$export$849e31d725692576).SIZE_BYTES, (0, $0a0587bd8b0d58e8$export$849e31d725692576).TEXCOORD_OFFSET_BYTES);
        ANGLE_instanced_arrays.vertexAttribDivisorANGLE(this._texCoordAttribute, 1);
        this._gl.enableVertexAttribArray(this._texCoordAttribute);
        this._gl.vertexAttribPointer(this._colorAttribute, 2, this._gl.UNSIGNED_BYTE, true, (0, $0a0587bd8b0d58e8$export$849e31d725692576).SIZE_BYTES, (0, $0a0587bd8b0d58e8$export$849e31d725692576).COLOR_OFFSET_BYTES);
        ANGLE_instanced_arrays.vertexAttribDivisorANGLE(this._colorAttribute, 1);
        this._gl.enableVertexAttribArray(this._colorAttribute);
    }
    _updatePreviousBuffer() {
        super._updatePreviousBuffer();
        const ANGLE_instanced_arrays = this._main.shaderResources.ANGLE_instanced_arrays;
        this._gl.vertexAttribPointer(this._previousRotationAttribute, 4, this._gl.FLOAT, false, (0, $0a0587bd8b0d58e8$export$849e31d725692576).SIZE_BYTES, (0, $0a0587bd8b0d58e8$export$849e31d725692576).ROTATION_OFFSET_BYTES);
        ANGLE_instanced_arrays.vertexAttribDivisorANGLE(this._previousRotationAttribute, 1);
        this._gl.enableVertexAttribArray(this._previousRotationAttribute);
        this._gl.vertexAttribPointer(this._previousTexCoordAttribute, 4, this._gl.FLOAT, false, (0, $0a0587bd8b0d58e8$export$849e31d725692576).SIZE_BYTES, (0, $0a0587bd8b0d58e8$export$849e31d725692576).TEXCOORD_OFFSET_BYTES);
        ANGLE_instanced_arrays.vertexAttribDivisorANGLE(this._previousTexCoordAttribute, 1);
        this._gl.enableVertexAttribArray(this._previousTexCoordAttribute);
        this._gl.vertexAttribPointer(this._previousColorAttribute, 2, this._gl.UNSIGNED_BYTE, true, (0, $0a0587bd8b0d58e8$export$849e31d725692576).SIZE_BYTES, (0, $0a0587bd8b0d58e8$export$849e31d725692576).COLOR_OFFSET_BYTES);
        ANGLE_instanced_arrays.vertexAttribDivisorANGLE(this._previousColorAttribute, 1);
        this._gl.enableVertexAttribArray(this._previousColorAttribute);
    }
    apply() {
        super.apply();
        this._gl.uniform1i(this._previousSampler1Uniform, 2);
        this._gl.uniform1i(this._sampler1Uniform, 3);
        this._gl.uniform1f(this._sdfBufferUniform, this.sdfBuffer);
        this._gl.uniform3fv(this._sdfBackgroundColorUniform, this.sdfBackgroundColor);
    }
    updateTextures() {
        super.updateTextures();
        this._gl.activeTexture(this._gl.TEXTURE2);
        this._gl.bindTexture(this._gl.TEXTURE_2D, this._previousSdfTexture);
        this._gl.activeTexture(this._gl.TEXTURE3);
        this._gl.bindTexture(this._gl.TEXTURE_2D, this._sdfTexture);
    }
    disableProgram() {
        super.disableProgram();
        const ANGLE_instanced_arrays = this._main.shaderResources.ANGLE_instanced_arrays;
        ANGLE_instanced_arrays.vertexAttribDivisorANGLE(this._rotationAttribute, 0);
        ANGLE_instanced_arrays.vertexAttribDivisorANGLE(this._previousRotationAttribute, 0);
        ANGLE_instanced_arrays.vertexAttribDivisorANGLE(this._texCoordAttribute, 0);
        ANGLE_instanced_arrays.vertexAttribDivisorANGLE(this._previousTexCoordAttribute, 0);
    }
}


/*!
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 */ 

class $113219cc0f7990e8$export$6a2b78e9604d5b98 extends (0, $5ea895789fc20d6f$export$59a6ab026766925f) {
    get texture2D1() {
        return this._texture2D1;
    }
    set texture2D1(value) {
        if (this._texture2D1 != value) {
            this._texture2D1 = value;
            this._haveTexturesChanged = true;
        }
    }
    get texture2D2() {
        return this._texture2D2;
    }
    set texture2D2(value) {
        if (this._texture2D2 != value) {
            this._texture2D2 = value;
            this._haveTexturesChanged = true;
        }
    }
    initializeContext(gl) {
        super.initializeContext(gl);
        if (this._isLoaded) this._initializeShader(gl, this._vsSource, this._fsSource);
        else this._shaderFromFile("simple.vertex.fx", "anaglyph.fragment.fx", (vsSource, fsSource)=>{
            this._vsSource = vsSource;
            this._fsSource = fsSource;
            this._isLoaded = true;
            this._initializeShader(gl, vsSource, fsSource);
        });
    }
    _initializeShader(gl, vsSource, fsSource) {
        const vs = this._compileShader(vsSource, gl.VERTEX_SHADER);
        const fs = this._compileShader(fsSource, gl.FRAGMENT_SHADER);
        this._program = this._createProgram(vs, fs);
        this._positionAttribute = gl.getAttribLocation(this._program, "aPosition");
        this._viewportUniform = gl.getUniformLocation(this._program, "uViewport");
        this._samplerUniform1 = gl.getUniformLocation(this._program, "uSampler1");
        this._samplerUniform2 = gl.getUniformLocation(this._program, "uSampler2");
        this._isInitialized = true;
    }
    apply() {
        this._gl.uniform4f(this._viewportUniform, this.viewport.x, this.viewport.y, this.viewport.width, this.viewport.height);
        this._gl.uniform1i(this._samplerUniform1, 0);
        this._gl.uniform1i(this._samplerUniform2, 1);
    }
    updateBuffers() {
        super.updateBuffers();
        this._gl.bindBuffer(this._gl.ARRAY_BUFFER, this._vertexBuffer);
        this._gl.vertexAttribPointer(this._positionAttribute, 3, this._gl.FLOAT, false, (0, $0a0587bd8b0d58e8$export$5b33f080c7f6c861).SIZE_BYTES, 0);
        this._gl.enableVertexAttribArray(this._positionAttribute);
        this._gl.bindBuffer(this._gl.ELEMENT_ARRAY_BUFFER, this._indexBuffer);
    }
    updateTextures() {
        super.updateTextures();
        this._gl.activeTexture(this._gl.TEXTURE0);
        this._gl.bindTexture(this._gl.TEXTURE_2D, this._texture2D1);
        this._gl.activeTexture(this._gl.TEXTURE1);
        this._gl.bindTexture(this._gl.TEXTURE_2D, this._texture2D2);
        this._gl.activeTexture(this._gl.TEXTURE2);
    }
}




/*!
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 */ class $71eca2ce7fbde895$export$2d88a2ee0a1b34a {
    get isInitialized() {
        return this._isInitialized && this._main.colorShader.isInitialized;
    }
    constructor(core, main, debugAxes){
        this._main = main;
        this._debugAxes = debugAxes;
        this.isVisible = true;
    }
    initializeContext(gl) {
        if (!this._debugAxes.isInitialized) this._debugAxes.initialize();
        this._gl = gl;
        this._vertexBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, this._vertexBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, this._debugAxes.vertices, gl.STATIC_DRAW);
        this._indexBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this._indexBuffer);
        gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, this._debugAxes.indices, gl.STATIC_DRAW);
        this._isInitialized = true;
    }
    update(elapsedTime) {}
    render(elapsedTime, xrFrame) {
        if (this.isInitialized) {
            const colorShader = this._main.colorShader;
            const shaderResources = this._main.shaderResources;
            colorShader.vertexBuffer = this._vertexBuffer;
            colorShader.indexBuffer = this._indexBuffer;
            colorShader.prepare();
            colorShader.mMatrix = this.mMatrix;
            colorShader.apply();
            for(let i = 0; i < this.viewportCount; i++){
                const viewport = i + this.viewportOffset;
                shaderResources.bindFramebuffer(this.framebuffers[viewport]);
                this._gl.viewport(this.viewports[viewport].x, this.viewports[viewport].y, this.viewports[viewport].width, this.viewports[viewport].height);
                colorShader.vMatrix = this.vMatrices[viewport];
                colorShader.pMatrix = this.pMatrices[viewport];
                colorShader.applyView();
                this._gl.drawElements(this._gl.TRIANGLE_STRIP, this._debugAxes.indexCount, this._gl.UNSIGNED_SHORT, 0);
            }
        }
    }
}


/*!
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 */ /*!
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 */ class $dc98a3a9e3221094$export$ab05abf6f96a5bb1 {
    get isInitialized() {
        return this._isInitialized;
    }
    get axes() {
        return this._axes;
    }
    constructor(core){
        this._core = core;
        this.isVisible = true;
    }
    initializeContext(gl) {
        this._gl = gl;
    }
    update(elapsedTime) {}
    render(elapsedTime, xrFrame) {
        if (this.isInitialized) {
            this._renderGrid();
            this._renderText();
        }
    }
    _renderGrid() {}
    _renderText() {}
}





class $aca0a8f90b5c931c$export$30e3ee7ba3e49080 extends (0, $dc98a3a9e3221094$export$ab05abf6f96a5bb1) {
    get isInitialized() {
        return this._isInitialized && this._main.gridShader.isInitialized && this._main.sdfTextShader.isInitialized && this._main.fonts[this._axes.font.name].isInitialized;
    }
    constructor(core, main, cartesian2dAxes){
        super(core);
        this._main = main;
        this._axes = cartesian2dAxes;
        this._axes.hasChangedCallback = ()=>{
            this._hasChanged = true;
        };
    }
    initializeContext(gl) {
        super.initializeContext(gl);
        const axes = this._axes;
        if (!axes.isInitialized) axes.initialize();
        if (axes.gridVertices) this._createGridBuffers();
        if (axes.textVertices) this._createTextBuffers();
        this._isInitialized = true;
    }
    _createGridBuffers() {
        const axes = this._axes;
        this._gridVertexBuffer = this._gl.createBuffer();
        this._gl.bindBuffer(this._gl.ARRAY_BUFFER, this._gridVertexBuffer);
        this._gl.bufferData(this._gl.ARRAY_BUFFER, axes.gridVertices, this._gl.STATIC_DRAW);
        this._gridIndexBuffer = this._gl.createBuffer();
        this._gl.bindBuffer(this._gl.ELEMENT_ARRAY_BUFFER, this._gridIndexBuffer);
        this._gl.bufferData(this._gl.ELEMENT_ARRAY_BUFFER, axes.gridIndices, this._gl.STATIC_DRAW);
        this._gridBufferSize = axes.gridVertices.byteLength;
        this._core.log.write((0, $4a6417d29706362f$export$243e62d78d3b544d).info, `cartesian2d visual grid buffers created`);
    }
    _createTextBuffers() {
        const axes = this._axes;
        this._textVertexBuffer = this._gl.createBuffer();
        this._gl.bindBuffer(this._gl.ARRAY_BUFFER, this._textVertexBuffer);
        this._gl.bufferData(this._gl.ARRAY_BUFFER, axes.textVertices, this._gl.STATIC_DRAW);
        this._textIndexBuffer = this._gl.createBuffer();
        this._gl.bindBuffer(this._gl.ELEMENT_ARRAY_BUFFER, this._textIndexBuffer);
        this._gl.bufferData(this._gl.ELEMENT_ARRAY_BUFFER, axes.textIndices, this._gl.STATIC_DRAW);
        this._textBufferSize = axes.textVertices.byteLength;
        this._core.log.write((0, $4a6417d29706362f$export$243e62d78d3b544d).info, `cartesian2d visual text buffers created`);
    }
    update(elapsedTime) {
        if (this._hasChanged) {
            this._hasChanged = false;
            const axes = this._axes;
            if (!this._gridVertexBuffer || axes.gridVertices.byteLength > this._gridBufferSize) this._createGridBuffers();
            else {
                this._gl.bindBuffer(this._gl.ARRAY_BUFFER, this._gridVertexBuffer);
                this._gl.bufferSubData(this._gl.ARRAY_BUFFER, 0, axes.gridVertices);
                this._gl.bindBuffer(this._gl.ELEMENT_ARRAY_BUFFER, this._gridIndexBuffer);
                this._gl.bufferSubData(this._gl.ELEMENT_ARRAY_BUFFER, 0, axes.gridIndices);
                this._core.log.write((0, $4a6417d29706362f$export$243e62d78d3b544d).info, `cartesian2d visual grid buffers updated`);
            }
            if (!this._textVertexBuffer || axes.textVertices.byteLength > this._textBufferSize) this._createTextBuffers();
            else {
                this._gl.bindBuffer(this._gl.ARRAY_BUFFER, this._textVertexBuffer);
                this._gl.bufferSubData(this._gl.ARRAY_BUFFER, 0, axes.textVertices);
                this._gl.bindBuffer(this._gl.ELEMENT_ARRAY_BUFFER, this._textIndexBuffer);
                this._gl.bufferSubData(this._gl.ELEMENT_ARRAY_BUFFER, 0, axes.textIndices);
                this._core.log.write((0, $4a6417d29706362f$export$243e62d78d3b544d).info, `cartesian2d visual text buffers updated`);
            }
            this._main.shaderResources.currentProgram = null;
        }
    }
    _renderText() {
        const axes = this._axes;
        const shader = this._main.sdfTextShader;
        const shaderResources = this._main.shaderResources;
        const fontVisual = this._main.fonts[axes.font.name];
        shader.vertexBuffer = this._textVertexBuffer;
        shader.indexBuffer = this._textIndexBuffer;
        shader.texture2D = fontVisual.texture;
        shader.prepare();
        shader.buffer = fontVisual.font.edgeValue / 0xff;
        shader.gamma = axes.gamma;
        shader.borderWidth = axes.textBorderWidth;
        shader.color = axes.textColor || this._core.config.axesTextColor;
        shader.hoverColor = axes.textHoverColor || this._core.config.axesTextHoverColor;
        shader.borderColor = axes.textBorderColor || this._core.config.textBorderColor;
        shader.pickedIdColor = this.pickedIdColor;
        shader.apply();
        let indexCount, indexOffset;
        for(let axisId = 0; axisId < 2; axisId++){
            const orientation = axes.getLabelOrientation(axisId);
            for(let edge = 0; edge < 2; edge++){
                const edgeId = (0, $3ce6ee188e300946$export$7005c9eb6671414d).AXIS_EDGES[axisId][edge];
                if (axes.isEdgeVisible[edgeId]) {
                    if (orientation == (0, $4a6417d29706362f$export$d2304d1f23cf3ace).parallel && axes.getIsLeftToRightHorizontal(edgeId) || orientation == (0, $4a6417d29706362f$export$d2304d1f23cf3ace).perpendicular && axes.getIsLeftToRightVertical(edgeId)) {
                        indexCount = axes.getAxesLeftToRightIndexCount(axisId);
                        indexOffset = axes.getAxesLeftToRightIndexOffset(axisId);
                    } else {
                        indexCount = axes.getAxesRightToLeftIndexCount(axisId);
                        indexOffset = axes.getAxesRightToLeftIndexOffset(axisId);
                    }
                    if (indexCount > 0) {
                        shader.mMatrix = axes.getLabelMMatrix(edgeId);
                        shader.applyModel();
                        shader.isPickShader = false;
                        for(let i = 0; i < this.viewportCount; i++){
                            const viewport = i + this.viewportOffset;
                            shaderResources.bindFramebuffer(this.framebuffers[viewport]);
                            this._gl.viewport(this.viewports[viewport].x, this.viewports[viewport].y, this.viewports[viewport].width, this.viewports[viewport].height);
                            shader.vMatrix = this.vMatrices[viewport];
                            shader.pMatrix = this.pMatrices[viewport];
                            shader.applyView();
                            this._gl.drawElements(this._gl.TRIANGLES, indexCount, this._gl.UNSIGNED_SHORT, indexOffset * 2);
                        }
                        if (this.isPickingEnabled && axes.isLabelPickingEnabled[axisId]) {
                            shader.isPickShader = true;
                            shader.pMatrix = this.pickPMatrix;
                            shader.vMatrix = this.pickVMatrix;
                            shader.applyView();
                            shaderResources.bindFramebuffer(this.pickFramebuffer);
                            this._gl.viewport(0, 0, this._core.config.pickWidth, this._core.config.pickHeight);
                            this._gl.drawElements(this._gl.TRIANGLES, indexCount, this._gl.UNSIGNED_SHORT, indexOffset * 2);
                        }
                    }
                    indexCount = axes.getTitleIndexCount(axisId);
                    if (indexCount > 0) {
                        indexOffset = axes.getTitleIndexOffset(axisId);
                        shader.mMatrix = axes.getTitleMMatrix(edgeId);
                        shader.applyModel();
                        shader.isPickShader = false;
                        for(let i = 0; i < this.viewportCount; i++){
                            const viewport = i + this.viewportOffset;
                            shaderResources.bindFramebuffer(this.framebuffers[viewport]);
                            this._gl.viewport(this.viewports[viewport].x, this.viewports[viewport].y, this.viewports[viewport].width, this.viewports[viewport].height);
                            shader.vMatrix = this.vMatrices[viewport];
                            shader.pMatrix = this.pMatrices[viewport];
                            shader.applyView();
                            this._gl.drawElements(this._gl.TRIANGLES, indexCount, this._gl.UNSIGNED_SHORT, indexOffset * 2);
                        }
                        if (this.isPickingEnabled && axes.isTitlePickingEnabled[axisId]) {
                            shader.isPickShader = true;
                            shader.pMatrix = this.pickPMatrix;
                            shader.vMatrix = this.pickVMatrix;
                            shader.applyView();
                            shaderResources.bindFramebuffer(this.pickFramebuffer);
                            this._gl.viewport(0, 0, this._core.config.pickWidth, this._core.config.pickHeight);
                            this._gl.drawElements(this._gl.TRIANGLES, indexCount, this._gl.UNSIGNED_SHORT, indexOffset * 2);
                        }
                    }
                }
                indexCount = axes.getHeadingIndexCount(axisId);
                if (indexCount > 0 && axes.isHeadingVisible[edgeId]) {
                    indexOffset = axes.getHeadingIndexOffset(axisId);
                    shader.mMatrix = axes.getHeadingMMatrix(edgeId);
                    shader.applyModel();
                    shader.isPickShader = false;
                    for(let i = 0; i < this.viewportCount; i++){
                        const viewport = i + this.viewportOffset;
                        shaderResources.bindFramebuffer(this.framebuffers[viewport]);
                        this._gl.viewport(this.viewports[viewport].x, this.viewports[viewport].y, this.viewports[viewport].width, this.viewports[viewport].height);
                        shader.vMatrix = this.vMatrices[viewport];
                        shader.pMatrix = this.pMatrices[viewport];
                        shader.applyView();
                        this._gl.drawElements(this._gl.TRIANGLES, indexCount, this._gl.UNSIGNED_SHORT, indexOffset * 2);
                    }
                    if (this.isPickingEnabled && axes.isHeadingPickingEnabled[axisId]) {
                        shader.isPickShader = true;
                        shader.pMatrix = this.pickPMatrix;
                        shader.vMatrix = this.pickVMatrix;
                        shader.applyView();
                        shaderResources.bindFramebuffer(this.pickFramebuffer);
                        this._gl.viewport(0, 0, this._core.config.pickWidth, this._core.config.pickHeight);
                        this._gl.drawElements(this._gl.TRIANGLES, indexCount, this._gl.UNSIGNED_SHORT, indexOffset * 2);
                    }
                }
            }
        }
    }
    _renderGrid() {
        const axes = this._axes;
        const gridShader = this._main.gridShader;
        gridShader.vertexBuffer = this._gridVertexBuffer;
        gridShader.indexBuffer = this._gridIndexBuffer;
        gridShader.prepare();
        gridShader.majorThickness = axes.gridMajorThickness;
        gridShader.minorThickness = axes.gridMinorThickness;
        gridShader.zeroThickness = axes.gridZeroThickness;
        gridShader.backgroundColor = axes.gridBackgroundColor || this._core.config.axesGridBackgroundColor;
        gridShader.highlightColor = axes.gridHighlightColor || this._core.config.axesGridHighlightColor;
        gridShader.majorColor = axes.gridMajorColor || this._core.config.axesGridMajorColor;
        gridShader.minorColor = axes.gridMinorColor || this._core.config.axesGridMinorColor;
        gridShader.zeroColor = axes.gridZeroColor || this._core.config.axesGridZeroColor;
        gridShader.pickedIdColor = this.pickedIdColor;
        gridShader.directionToLight = (0, $d4d7bd6cc65a5081$export$a002182e51710d39).VECTOR3_UNITZ;
        gridShader.apply();
        for(let axisId = 0; axisId < 2; axisId++)if (axes.arePickDivisionsVisible[axisId]) {
            const gridTicksScale = axes.getGridTicksScale(axisId);
            const width = gridTicksScale[0];
            const height = gridTicksScale[1];
            gridShader.zero = axes.getGridTicksZero(axisId);
            gridShader.minorGridlines = axes.getGridTicksMinorGridlines(axisId);
            for(let edge = 0; edge < 2; edge++){
                const edgeId = (0, $3ce6ee188e300946$export$7005c9eb6671414d).AXIS_EDGES[axisId][edge];
                if (axes.isEdgeVisible[edgeId]) this._renderGridTicks(axisId, edgeId, width, height);
            }
        }
        this._gl.disable(this._gl.CULL_FACE);
        const size = axes.size;
        const axisId2 = 0;
        const axisId3 = 1;
        const width = size[axisId2];
        const height = size[axisId3];
        gridShader.zero = axes.gridFaceZero;
        gridShader.minorGridlines = axes.gridFaceMinorGridlines;
        for(let face = 0; face < 2; face++){
            const faceId = face;
            if (axes.getIsForwardFace(faceId)) this._renderGridFace(faceId, width, height);
        }
        this._gl.enable(this._gl.CULL_FACE);
    }
    _renderGridTicks(axisId, edgeId, width, height) {
        const axes = this._axes;
        const gridShader = this._main.gridShader;
        const shaderResources = this._main.shaderResources;
        gridShader.mMatrix = axes.getGridTicksMMatrix(edgeId);
        gridShader.faceWidth = width;
        gridShader.faceHeight = height;
        gridShader.ApplyFace();
        gridShader.isPickShader = false;
        for(let i = 0; i < this.viewportCount; i++){
            const viewport = i + this.viewportOffset;
            shaderResources.bindFramebuffer(this.framebuffers[viewport]);
            this._gl.viewport(this.viewports[viewport].x, this.viewports[viewport].y, this.viewports[viewport].width, this.viewports[viewport].height);
            gridShader.vMatrix = this.vMatrices[viewport];
            gridShader.pMatrix = this.pMatrices[viewport];
            gridShader.applyView();
            this._gl.drawElements(this._gl.TRIANGLES, axes.getGridTicksIndexCount(axisId), this._gl.UNSIGNED_SHORT, axes.getGridTicksIndexOffset(axisId) * 2);
        }
        if (this.isPickingEnabled && axes.isDivisionPickingEnabled[axisId]) {
            gridShader.isPickShader = true;
            gridShader.vMatrix = this.pickVMatrix;
            gridShader.pMatrix = this.pickPMatrix;
            gridShader.applyView();
            shaderResources.bindFramebuffer(this.pickFramebuffer);
            this._gl.viewport(0, 0, this._core.config.pickWidth, this._core.config.pickHeight);
            this._gl.drawElements(this._gl.TRIANGLES, this._axes.getGridTicksIndexCount(axisId), this._gl.UNSIGNED_SHORT, this._axes.getGridTicksIndexOffset(axisId) * 2);
        }
    }
    _renderGridFace(faceId, width, height) {
        const axes = this._axes;
        const gridShader = this._main.gridShader;
        const shaderResources = this._main.shaderResources;
        gridShader.mMatrix = axes.getGridFaceMMatrix(faceId);
        gridShader.faceWidth = width;
        gridShader.faceHeight = height;
        gridShader.ApplyFace();
        gridShader.isPickShader = false;
        for(let i = 0; i < this.viewportCount; i++){
            const viewport = i + this.viewportOffset;
            shaderResources.bindFramebuffer(this.framebuffers[viewport]);
            this._gl.viewport(this.viewports[viewport].x, this.viewports[viewport].y, this.viewports[viewport].width, this.viewports[viewport].height);
            gridShader.vMatrix = this.vMatrices[viewport];
            gridShader.pMatrix = this.pMatrices[viewport];
            gridShader.applyView();
            this._gl.drawElements(this._gl.TRIANGLES, axes.getGridFaceIndexCount(faceId), this._gl.UNSIGNED_SHORT, axes.getGridFaceIndexOffset(faceId) * 2);
        }
        if (this.isPickingEnabled && axes.isGridPickingEnabled) {
            gridShader.isPickShader = true;
            gridShader.vMatrix = this.pickVMatrix;
            gridShader.pMatrix = this.pickPMatrix;
            gridShader.applyView();
            shaderResources.bindFramebuffer(this.pickFramebuffer);
            this._gl.viewport(0, 0, this._core.config.pickWidth, this._core.config.pickHeight);
            this._gl.drawElements(this._gl.TRIANGLES, axes.getGridFaceIndexCount(faceId), this._gl.UNSIGNED_SHORT, axes.getGridFaceIndexOffset(faceId) * 2);
        }
    }
}


/*!
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 */ 



class $a7eaec60ae84313c$export$3dc3b91df297f2ee extends (0, $dc98a3a9e3221094$export$ab05abf6f96a5bb1) {
    get isInitialized() {
        return this._isInitialized && this._main.gridShader.isInitialized && this._main.sdfTextShader.isInitialized && this._main.fonts[this._axes.font.name].isInitialized;
    }
    constructor(core, main, cartesian3dAxes){
        super(core);
        this._main = main;
        this._axes = cartesian3dAxes;
        this._axes.hasChangedCallback = ()=>{
            this._hasChanged = true;
        };
    }
    initializeContext(gl) {
        super.initializeContext(gl);
        const axes = this._axes;
        if (!axes.isInitialized) axes.initialize();
        if (axes.gridVertices) this._createGridBuffers();
        if (axes.textVertices) this._createTextBuffers();
        this._isInitialized = true;
    }
    _createGridBuffers() {
        const axes = this._axes;
        this._gridVertexBuffer = this._gl.createBuffer();
        this._gl.bindBuffer(this._gl.ARRAY_BUFFER, this._gridVertexBuffer);
        this._gl.bufferData(this._gl.ARRAY_BUFFER, axes.gridVertices, this._gl.STATIC_DRAW);
        this._gridIndexBuffer = this._gl.createBuffer();
        this._gl.bindBuffer(this._gl.ELEMENT_ARRAY_BUFFER, this._gridIndexBuffer);
        this._gl.bufferData(this._gl.ELEMENT_ARRAY_BUFFER, axes.gridIndices, this._gl.STATIC_DRAW);
        this._gridBufferSize = axes.gridVertices.byteLength;
        this._core.log.write((0, $4a6417d29706362f$export$243e62d78d3b544d).info, `cartesian3d visual grid buffers created`);
    }
    _createTextBuffers() {
        const axes = this._axes;
        this._textVertexBuffer = this._gl.createBuffer();
        this._gl.bindBuffer(this._gl.ARRAY_BUFFER, this._textVertexBuffer);
        this._gl.bufferData(this._gl.ARRAY_BUFFER, axes.textVertices, this._gl.STATIC_DRAW);
        this._textIndexBuffer = this._gl.createBuffer();
        this._gl.bindBuffer(this._gl.ELEMENT_ARRAY_BUFFER, this._textIndexBuffer);
        this._gl.bufferData(this._gl.ELEMENT_ARRAY_BUFFER, axes.textIndices, this._gl.STATIC_DRAW);
        this._textBufferSize = axes.textVertices.byteLength;
        this._core.log.write((0, $4a6417d29706362f$export$243e62d78d3b544d).info, `cartesian3d visual text buffers created`);
    }
    update(elapsedTime) {
        if (this._hasChanged) {
            this._hasChanged = false;
            const axes = this._axes;
            if (!this._gridVertexBuffer || axes.gridVertices.byteLength > this._gridBufferSize) this._createGridBuffers();
            else {
                this._gl.bindBuffer(this._gl.ARRAY_BUFFER, this._gridVertexBuffer);
                this._gl.bufferSubData(this._gl.ARRAY_BUFFER, 0, axes.gridVertices);
                this._gl.bindBuffer(this._gl.ELEMENT_ARRAY_BUFFER, this._gridIndexBuffer);
                this._gl.bufferSubData(this._gl.ELEMENT_ARRAY_BUFFER, 0, axes.gridIndices);
                this._core.log.write((0, $4a6417d29706362f$export$243e62d78d3b544d).info, `cartesian3d visual grid buffers updated`);
            }
            if (!this._textVertexBuffer || axes.textVertices.byteLength > this._textBufferSize) this._createTextBuffers();
            else {
                this._gl.bindBuffer(this._gl.ARRAY_BUFFER, this._textVertexBuffer);
                this._gl.bufferSubData(this._gl.ARRAY_BUFFER, 0, axes.textVertices);
                this._gl.bindBuffer(this._gl.ELEMENT_ARRAY_BUFFER, this._textIndexBuffer);
                this._gl.bufferSubData(this._gl.ELEMENT_ARRAY_BUFFER, 0, axes.textIndices);
                this._core.log.write((0, $4a6417d29706362f$export$243e62d78d3b544d).info, `cartesian3d visual text buffers updated`);
            }
            this._main.shaderResources.currentProgram = null;
        }
    }
    _renderText() {
        const axes = this._axes;
        const shader = this._main.sdfTextShader;
        const shaderResources = this._main.shaderResources;
        const fontVisual = this._main.fonts[axes.font.name];
        shader.vertexBuffer = this._textVertexBuffer;
        shader.indexBuffer = this._textIndexBuffer;
        shader.texture2D = fontVisual.texture;
        shader.prepare();
        shader.buffer = fontVisual.font.edgeValue / 0xff;
        shader.gamma = axes.gamma;
        shader.borderWidth = axes.textBorderWidth;
        shader.color = axes.textColor || this._core.config.axesTextColor;
        shader.hoverColor = axes.textHoverColor || this._core.config.axesTextHoverColor;
        shader.borderColor = axes.textBorderColor || this._core.config.textBorderColor;
        shader.pickedIdColor = this.pickedIdColor;
        shader.apply();
        let indexCount, indexOffset;
        for(let axisId = 0; axisId < 3; axisId++){
            const orientation = axes.getLabelOrientation(axisId);
            for(let edge = 0; edge < 4; edge++){
                const edgeId = (0, $c2c30e4dcf8004c5$export$a15f0a83a652dd40).AXIS_EDGES[axisId][edge];
                if (axes.getIsOutsideEdge(edgeId)) {
                    if (axes.isEdgeVisible[edgeId]) {
                        if (orientation == (0, $4a6417d29706362f$export$d2304d1f23cf3ace).parallel && axes.getIsLeftToRightHorizontal(edgeId) || orientation == (0, $4a6417d29706362f$export$d2304d1f23cf3ace).perpendicular && axes.getIsLeftToRightVertical(edgeId)) {
                            indexCount = axes.getAxesLeftToRightIndexCount(axisId);
                            indexOffset = axes.getAxesLeftToRightIndexOffset(axisId);
                        } else {
                            indexCount = axes.getAxesRightToLeftIndexCount(axisId);
                            indexOffset = axes.getAxesRightToLeftIndexOffset(axisId);
                        }
                        if (indexCount > 0) {
                            shader.mMatrix = axes.getLabelMMatrix(edgeId);
                            shader.applyModel();
                            shader.isPickShader = false;
                            for(let i = 0; i < this.viewportCount; i++){
                                const viewport = i + this.viewportOffset;
                                shaderResources.bindFramebuffer(this.framebuffers[viewport]);
                                this._gl.viewport(this.viewports[viewport].x, this.viewports[viewport].y, this.viewports[viewport].width, this.viewports[viewport].height);
                                shader.vMatrix = this.vMatrices[viewport];
                                shader.pMatrix = this.pMatrices[viewport];
                                shader.applyView();
                                this._gl.drawElements(this._gl.TRIANGLES, indexCount, this._gl.UNSIGNED_SHORT, indexOffset * 2);
                            }
                            if (this.isPickingEnabled && axes.isLabelPickingEnabled[axisId]) {
                                shader.isPickShader = true;
                                shader.pMatrix = this.pickPMatrix;
                                shader.vMatrix = this.pickVMatrix;
                                shader.applyView();
                                shaderResources.bindFramebuffer(this.pickFramebuffer);
                                this._gl.viewport(0, 0, this._core.config.pickWidth, this._core.config.pickHeight);
                                this._gl.drawElements(this._gl.TRIANGLES, indexCount, this._gl.UNSIGNED_SHORT, indexOffset * 2);
                            }
                        }
                        indexCount = axes.getTitleIndexCount(axisId);
                        if (indexCount > 0) {
                            indexOffset = axes.getTitleIndexOffset(axisId);
                            shader.mMatrix = axes.getTitleMMatrix(edgeId);
                            shader.applyModel();
                            shader.isPickShader = false;
                            for(let i = 0; i < this.viewportCount; i++){
                                const viewport = i + this.viewportOffset;
                                shaderResources.bindFramebuffer(this.framebuffers[viewport]);
                                this._gl.viewport(this.viewports[viewport].x, this.viewports[viewport].y, this.viewports[viewport].width, this.viewports[viewport].height);
                                shader.vMatrix = this.vMatrices[viewport];
                                shader.pMatrix = this.pMatrices[viewport];
                                shader.applyView();
                                this._gl.drawElements(this._gl.TRIANGLES, indexCount, this._gl.UNSIGNED_SHORT, indexOffset * 2);
                            }
                            if (this.isPickingEnabled && axes.isTitlePickingEnabled[axisId]) {
                                shader.isPickShader = true;
                                shader.pMatrix = this.pickPMatrix;
                                shader.vMatrix = this.pickVMatrix;
                                shader.applyView();
                                shaderResources.bindFramebuffer(this.pickFramebuffer);
                                this._gl.viewport(0, 0, this._core.config.pickWidth, this._core.config.pickHeight);
                                this._gl.drawElements(this._gl.TRIANGLES, indexCount, this._gl.UNSIGNED_SHORT, indexOffset * 2);
                            }
                        }
                    }
                    indexCount = axes.getHeadingIndexCount(axisId);
                    if (indexCount > 0 && axes.isHeadingVisible[edgeId]) {
                        indexOffset = axes.getHeadingIndexOffset(axisId);
                        shader.mMatrix = axes.getHeadingMMatrix(edgeId);
                        shader.applyModel();
                        shader.isPickShader = false;
                        for(let i = 0; i < this.viewportCount; i++){
                            const viewport = i + this.viewportOffset;
                            shaderResources.bindFramebuffer(this.framebuffers[viewport]);
                            this._gl.viewport(this.viewports[viewport].x, this.viewports[viewport].y, this.viewports[viewport].width, this.viewports[viewport].height);
                            shader.vMatrix = this.vMatrices[viewport];
                            shader.pMatrix = this.pMatrices[viewport];
                            shader.applyView();
                            this._gl.drawElements(this._gl.TRIANGLES, indexCount, this._gl.UNSIGNED_SHORT, indexOffset * 2);
                        }
                        if (this.isPickingEnabled && axes.isHeadingPickingEnabled[axisId]) {
                            shader.isPickShader = true;
                            shader.pMatrix = this.pickPMatrix;
                            shader.vMatrix = this.pickVMatrix;
                            shader.applyView();
                            shaderResources.bindFramebuffer(this.pickFramebuffer);
                            this._gl.viewport(0, 0, this._core.config.pickWidth, this._core.config.pickHeight);
                            this._gl.drawElements(this._gl.TRIANGLES, indexCount, this._gl.UNSIGNED_SHORT, indexOffset * 2);
                        }
                    }
                }
            }
        }
    }
    _renderGrid() {
        const axes = this._axes;
        const gridShader = this._main.gridShader;
        gridShader.vertexBuffer = this._gridVertexBuffer;
        gridShader.indexBuffer = this._gridIndexBuffer;
        gridShader.prepare();
        gridShader.majorThickness = axes.gridMajorThickness;
        gridShader.minorThickness = axes.gridMinorThickness;
        gridShader.zeroThickness = axes.gridZeroThickness;
        gridShader.backgroundColor = axes.gridBackgroundColor || this._core.config.axesGridBackgroundColor;
        gridShader.highlightColor = axes.gridHighlightColor || this._core.config.axesGridHighlightColor;
        gridShader.majorColor = axes.gridMajorColor || this._core.config.axesGridMajorColor;
        gridShader.minorColor = axes.gridMinorColor || this._core.config.axesGridMinorColor;
        gridShader.zeroColor = axes.gridZeroColor || this._core.config.axesGridZeroColor;
        gridShader.pickedIdColor = this.pickedIdColor;
        gridShader.directionToLight = (0, $d4d7bd6cc65a5081$export$a002182e51710d39).VECTOR3_UNITZ;
        gridShader.apply();
        for(let axisId = 0; axisId < 3; axisId++)if (axes.arePickDivisionsVisible[axisId]) {
            const gridTicksScale = axes.getGridTicksScale(axisId);
            const width = gridTicksScale[0];
            const height = gridTicksScale[1];
            gridShader.zero = axes.getGridTicksZero(axisId);
            gridShader.minorGridlines = axes.getGridTicksMinorGridlines(axisId);
            for(let edge = 0; edge < 4; edge++){
                const edgeId = (0, $c2c30e4dcf8004c5$export$a15f0a83a652dd40).AXIS_EDGES[axisId][edge];
                if (axes.getIsOutsideEdge(edgeId) && axes.isEdgeVisible[edgeId]) this._renderGridTicks(axisId, edgeId, width, height);
            }
        }
        this._gl.disable(this._gl.CULL_FACE);
        const size = axes.size;
        for(let axisId = 0; axisId < 3; axisId++)if (axes.areFacesVisible[axisId]) {
            const axisId2 = axisId == 0 ? 1 : 0;
            const axisId3 = axisId == 2 ? 1 : 2;
            const width = size[axisId2];
            const height = size[axisId3];
            gridShader.zero = axes.getGridFaceZero(axisId);
            gridShader.minorGridlines = axes.getGridFaceMinorGridlines(axisId);
            for(let face = 0; face < 2; face++){
                const faceId = (0, $c2c30e4dcf8004c5$export$a15f0a83a652dd40).AXIS_FACES[axisId][face];
                if (axes.getIsForwardFace(faceId) && axes.isFaceVisible[faceId]) this._renderGridFace(faceId, width, height);
            }
        }
        this._gl.enable(this._gl.CULL_FACE);
    }
    _renderGridTicks(axisId, edgeId, width, height) {
        const axes = this._axes;
        const gridShader = this._main.gridShader;
        const shaderResources = this._main.shaderResources;
        gridShader.mMatrix = axes.getGridTicksMMatrix(edgeId);
        gridShader.faceWidth = width;
        gridShader.faceHeight = height;
        gridShader.ApplyFace();
        gridShader.isPickShader = false;
        for(let i = 0; i < this.viewportCount; i++){
            const viewport = i + this.viewportOffset;
            shaderResources.bindFramebuffer(this.framebuffers[viewport]);
            this._gl.viewport(this.viewports[viewport].x, this.viewports[viewport].y, this.viewports[viewport].width, this.viewports[viewport].height);
            gridShader.vMatrix = this.vMatrices[viewport];
            gridShader.pMatrix = this.pMatrices[viewport];
            gridShader.applyView();
            this._gl.drawElements(this._gl.TRIANGLES, axes.getGridTicksIndexCount(axisId), this._gl.UNSIGNED_SHORT, axes.getGridTicksIndexOffset(axisId) * 2);
        }
        if (this.isPickingEnabled && axes.isDivisionPickingEnabled[axisId]) {
            gridShader.isPickShader = true;
            gridShader.vMatrix = this.pickVMatrix;
            gridShader.pMatrix = this.pickPMatrix;
            gridShader.applyView();
            shaderResources.bindFramebuffer(this.pickFramebuffer);
            this._gl.viewport(0, 0, this._core.config.pickWidth, this._core.config.pickHeight);
            this._gl.drawElements(this._gl.TRIANGLES, axes.getGridTicksIndexCount(axisId), this._gl.UNSIGNED_SHORT, axes.getGridTicksIndexOffset(axisId) * 2);
        }
    }
    _renderGridFace(faceId, width, height) {
        const axes = this._axes;
        const gridShader = this._main.gridShader;
        const shaderResources = this._main.shaderResources;
        gridShader.mMatrix = axes.getGridFaceMMatrix(faceId);
        gridShader.faceWidth = width;
        gridShader.faceHeight = height;
        gridShader.ApplyFace();
        gridShader.isPickShader = false;
        for(let i = 0; i < this.viewportCount; i++){
            const viewport = i + this.viewportOffset;
            shaderResources.bindFramebuffer(this.framebuffers[viewport]);
            this._gl.viewport(this.viewports[viewport].x, this.viewports[viewport].y, this.viewports[viewport].width, this.viewports[viewport].height);
            gridShader.vMatrix = this.vMatrices[viewport];
            gridShader.pMatrix = this.pMatrices[viewport];
            gridShader.applyView();
            this._gl.drawElements(this._gl.TRIANGLES, axes.getGridFaceIndexCount(faceId), this._gl.UNSIGNED_SHORT, axes.getGridFaceIndexOffset(faceId) * 2);
        }
        if (this.isPickingEnabled && axes.isGridPickingEnabled) {
            gridShader.isPickShader = true;
            gridShader.vMatrix = this.pickVMatrix;
            gridShader.pMatrix = this.pickPMatrix;
            gridShader.applyView();
            shaderResources.bindFramebuffer(this.pickFramebuffer);
            this._gl.viewport(0, 0, this._core.config.pickWidth, this._core.config.pickHeight);
            this._gl.drawElements(this._gl.TRIANGLES, axes.getGridFaceIndexCount(faceId), this._gl.UNSIGNED_SHORT, axes.getGridFaceIndexOffset(faceId) * 2);
        }
    }
}


/*!
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 */ 


class $1a9dbf3e657aba80$export$c6e88a9dc8138322 {
    get isInitialized() {
        return this._isInitialized && this._modelShader.isInitialized && this._colorShader.isInitialized;
    }
    get controller() {
        return this._controller;
    }
    constructor(core, main, controller){
        this._core = core;
        this._main = main;
        this._mMatrix = (0, $1ac1b59392edf35b$exports).create();
        this._vec3 = (0, $31054a6c69637582$exports).create();
        this._controller = controller;
        this._modelShader = main.modelShader;
        this._colorShader = main.colorShader;
        this.mMatrix = (0, $1ac1b59392edf35b$exports).create();
        this.rayMMatrix = (0, $1ac1b59392edf35b$exports).create();
        this.isVisible = true;
    }
    initializeContext(gl) {
        if (!this._controller.isInitialized) this._controller.initialize();
        this._initialize(gl);
    }
    _initialize(gl) {
        this._gl = gl;
        this.modelTexture = (0, $a25f5529f6cda489$export$c41e4fcbf45db179).fromImage(gl, this._controller.texture, false, gl.LINEAR);
        this._modelVertexBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, this._modelVertexBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, this._controller.vertices, gl.STATIC_DRAW);
        this._modelIndexBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this._modelIndexBuffer);
        gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, this._controller.indices, gl.STATIC_DRAW);
        this._rayVertexBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, this._rayVertexBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, this._controller.rayVertices, gl.STATIC_DRAW);
        this._rayIndexBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this._rayIndexBuffer);
        gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, this._controller.rayIndices, gl.STATIC_DRAW);
        this._isInitialized = true;
    }
    update(elapsedTime) {}
    render(elapsedTime, xrFrame) {
        if (this.isInitialized) {
            this._modelShader.vertexBuffer = this._modelVertexBuffer;
            this._modelShader.indexBuffer = this._modelIndexBuffer;
            this._modelShader.texture2D = this.modelTexture;
            this._modelShader.prepare();
            (0, $1ac1b59392edf35b$exports).multiply(this._mMatrix, this._controller.useRayPose ? this.rayMMatrix : this.mMatrix, this._controller.mMatrix);
            this._modelShader.mMatrix = this._mMatrix;
            this._modelShader.specularPower = 10;
            this._modelShader.specularIntensity = 0.01;
            this._modelShader.apply();
            this._modelShader.applyModel();
            for(let i = 0; i < this.viewportCount; i++){
                const viewport = i + this.viewportOffset;
                this._main.shaderResources.bindFramebuffer(this.framebuffers[viewport]);
                this._gl.viewport(this.viewports[viewport].x, this.viewports[viewport].y, this.viewports[viewport].width, this.viewports[viewport].height);
                this._modelShader.directionToLight = (0, $d4d7bd6cc65a5081$export$a002182e51710d39).VECTOR3_UNITZ;
                this._modelShader.halfAngle = (0, $d4d7bd6cc65a5081$export$a002182e51710d39).VECTOR3_UNITZ;
                this._modelShader.vMatrix = this.vMatrices[viewport];
                this._modelShader.pMatrix = this.pMatrices[viewport];
                this._modelShader.applyView();
                this._gl.drawElements(this._gl.TRIANGLES, this._controller.indexCount, this._gl.UNSIGNED_SHORT, 0);
            }
            if (this.isRayVisible) {
                this._colorShader.vertexBuffer = this._rayVertexBuffer;
                this._colorShader.indexBuffer = this._rayIndexBuffer;
                this._colorShader.prepare();
                (0, $1ac1b59392edf35b$exports).multiply(this._mMatrix, this.rayMMatrix, this._controller.rayMMatrix);
                this._colorShader.mMatrix = this._mMatrix;
                this._colorShader.apply();
                this._colorShader.applyModel();
                for(let i = 0; i < this.viewportCount; i++){
                    const viewport = i + this.viewportOffset;
                    this._main.shaderResources.bindFramebuffer(this.framebuffers[viewport]);
                    this._gl.viewport(this.viewports[viewport].x, this.viewports[viewport].y, this.viewports[viewport].width, this.viewports[viewport].height);
                    this._colorShader.vMatrix = this.vMatrices[viewport];
                    this._colorShader.pMatrix = this.pMatrices[viewport];
                    this._colorShader.applyView();
                    this._gl.drawElements(this._gl.TRIANGLE_STRIP, this._controller.rayIndexCount, this._gl.UNSIGNED_SHORT, 0);
                }
            }
        }
    }
}


/*!
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 */ 

class $0a92364922ad8eff$export$6f251cd327b2ff1 {
    get isInitialized() {
        return this._isInitialized && this._main.textureShader.isInitialized;
    }
    get image() {
        return this._image;
    }
    constructor(core, main, image){
        this._core = core;
        this._main = main;
        this._image = image;
        this._image.hasChangedCallback = ()=>{
            this._hasChanged = true;
        };
        this.mMatrix = (0, $1ac1b59392edf35b$exports).create();
        this.isVisible = true;
    }
    initializeContext(gl) {
        if (!this._image.isInitialized) this._image.initialize();
        this._gl = gl;
        if (this._image.imageData) this.texture = (0, $a25f5529f6cda489$export$c41e4fcbf45db179).fromImage(gl, this._image.imageData, false, gl.LINEAR);
        this._vertexBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, this._vertexBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, this._image.vertices, gl.STATIC_DRAW);
        this._indexBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this._indexBuffer);
        gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, this._image.indices, gl.STATIC_DRAW);
        this._isInitialized = true;
    }
    update(elapsedTime) {
        if (this._hasChanged) {
            this._hasChanged = false;
            this._gl.bindBuffer(this._gl.ARRAY_BUFFER, this._vertexBuffer);
            this._gl.bufferSubData(this._gl.ARRAY_BUFFER, 0, this._image.vertices);
            this._main.shaderResources.currentProgram = null;
        }
    }
    render(elapsedTime, xrFrame) {
        if (this.isInitialized) {
            const textureShader = this._main.textureShader;
            const shaderResources = this._main.shaderResources;
            textureShader.vertexBuffer = this._vertexBuffer;
            textureShader.indexBuffer = this._indexBuffer;
            textureShader.texture2D = this.texture;
            textureShader.prepare();
            textureShader.mMatrix = this.mMatrix;
            textureShader.isPickShader = false;
            textureShader.apply();
            for(let i = 0; i < this.viewportCount; i++){
                const viewport = i + this.viewportOffset;
                shaderResources.bindFramebuffer(this.framebuffers[viewport]);
                this._gl.viewport(this.viewports[viewport].x, this.viewports[viewport].y, this.viewports[viewport].width, this.viewports[viewport].height);
                textureShader.vMatrix = this.vMatrices[viewport];
                textureShader.pMatrix = this.pMatrices[viewport];
                textureShader.applyView();
                this._gl.drawElements(this._gl.TRIANGLES, this._image.indexCount, this._gl.UNSIGNED_SHORT, 0);
            }
            if (this.isPickingEnabled) {
                textureShader.isPickShader = true;
                textureShader.vMatrix = this.pickVMatrix;
                textureShader.pMatrix = this.pickPMatrix;
                textureShader.applyView();
                shaderResources.bindFramebuffer(this.pickFramebuffer);
                this._gl.viewport(0, 0, this._core.config.pickWidth, this._core.config.pickHeight);
                this._gl.drawElements(this._gl.TRIANGLES, this._image.indexCount, this._gl.UNSIGNED_SHORT, 0);
            }
        }
    }
}



/*!
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 */ 
class $89e74fd9966daa2d$var$LabelVisualBase {
    get isInitialized() {
        return this._isInitialized && this._main.sdfTextShader.isInitialized && this._main.fonts[this._label.font.name].isInitialized;
    }
    constructor(core, main, label){
        this._core = core;
        this._main = main;
        this._label = label;
        this._label.hasChangedCallback = ()=>{
            this._hasChanged = true;
        };
        this._mMatrix = (0, $1ac1b59392edf35b$exports).create();
        this.mMatrix = (0, $1ac1b59392edf35b$exports).create();
        this.isVisible = true;
    }
    initializeContext(gl) {
        if (!this._label.isInitialized) this._label.initialize();
        this._gl = gl;
        this._vertexBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, this._vertexBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, this._label.vertices, gl.STATIC_DRAW);
        this._indexBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this._indexBuffer);
        gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, this._label.indices, gl.STATIC_DRAW);
        this._isInitialized = true;
    }
    update(elapsedTime) {
        if (this._hasChanged) {
            this._hasChanged = false;
            this._gl.bindBuffer(this._gl.ARRAY_BUFFER, this._vertexBuffer);
            this._gl.bufferSubData(this._gl.ARRAY_BUFFER, 0, this._label.vertices);
            this._gl.bindBuffer(this._gl.ELEMENT_ARRAY_BUFFER, this._indexBuffer);
            this._gl.bufferSubData(this._gl.ELEMENT_ARRAY_BUFFER, 0, this._label.indices);
            this._main.shaderResources.currentProgram = null;
        }
    }
    render(elapsedTime, xrFrame) {
        if (this.isInitialized) {
            const indexCount = this._label.indexCount;
            if (indexCount > 0) {
                const shader = this._main.sdfTextShader;
                const fontVisual = this._main.fonts[this._label.font.name];
                shader.vertexBuffer = this._vertexBuffer;
                shader.indexBuffer = this._indexBuffer;
                shader.texture2D = fontVisual.texture;
                shader.prepare();
                shader.gamma = this._label.gamma;
                shader.buffer = fontVisual.font.edgeValue / 0xff;
                shader.borderWidth = this._label.borderWidth;
                shader.color = this._label.color || this._core.config.textColor;
                shader.borderColor = this._label.borderColor || this._core.config.textBorderColor;
                shader.hoverColor = this._label.hoverColor || this._core.config.textHoverColor;
                shader.pickedIdColor = this.pickedIdColor;
                shader.apply();
                (0, $1ac1b59392edf35b$exports).multiply(this._mMatrix, this.mMatrix, this._label.mMatrix);
                shader.mMatrix = this._mMatrix;
                shader.applyModel();
                shader.isPickShader = false;
                for(let i = 0; i < this.viewportCount; i++){
                    const viewport = i + this.viewportOffset;
                    this._main.shaderResources.bindFramebuffer(this.framebuffers[viewport]);
                    this._gl.viewport(this.viewports[viewport].x, this.viewports[viewport].y, this.viewports[viewport].width, this.viewports[viewport].height);
                    shader.vMatrix = this.vMatrices[viewport];
                    shader.pMatrix = this.pMatrices[viewport];
                    shader.applyView();
                    this._gl.drawElements(this._gl.TRIANGLES, indexCount, this._gl.UNSIGNED_INT, 0);
                }
                if (this.isPickingEnabled) {
                    shader.isPickShader = true;
                    shader.pMatrix = this.pickPMatrix;
                    shader.vMatrix = this.pickVMatrix;
                    shader.applyView();
                    this._main.shaderResources.bindFramebuffer(this.pickFramebuffer);
                    this._gl.viewport(0, 0, this._core.config.pickWidth, this._core.config.pickHeight);
                    this._gl.drawElements(this._gl.TRIANGLES, indexCount, this._gl.UNSIGNED_INT, 0);
                }
            }
        }
    }
}
class $89e74fd9966daa2d$export$71c7fa1581020e2c extends $89e74fd9966daa2d$var$LabelVisualBase {
    get label() {
        return this._label;
    }
    set text(value) {
        this._label.text = value;
    }
    get text() {
        return this._label.text;
    }
    constructor(core, main, label){
        super(core, main, label);
    }
}
class $89e74fd9966daa2d$export$97e93e7019ef67b9 extends $89e74fd9966daa2d$var$LabelVisualBase {
    get label() {
        return this._label;
    }
    constructor(core, main, label){
        super(core, main, label);
    }
}


/*!
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 */ 

class $504631b62e7a70e2$export$e784a6eab4d2d700 {
    get isInitialized() {
        return this._isInitialized;
    }
    get font() {
        return this._font;
    }
    constructor(core, font){
        this._core = core;
        this._font = font;
        font.hasChangedCallback = ()=>{
            this._hasChanged = true;
        };
    }
    initializeContext(gl) {
        this._gl = gl;
        this._isInitialized = true;
        if (this._font.count > 0) this._hasChanged = true;
    }
    update() {
        if (this._hasChanged && this._isInitialized) {
            this._hasChanged = false;
            this.texture = (0, $a25f5529f6cda489$export$c41e4fcbf45db179).fromImage(this._gl, this._font.atlas.imageData, false, this._gl.LINEAR);
            this._core.log.write((0, $4a6417d29706362f$export$243e62d78d3b544d).info, `${this._font.name} texture updated`);
        }
    }
}


/*!
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 */ 

class $7e67d5ea424e364b$export$dc8af347244861ce {
    get isInitialized() {
        return this._isInitialized;
    }
    get vertexBuffer() {
        return this._vertexBuffer;
    }
    get indexBuffer() {
        return this._indexBuffer;
    }
    get indexCount() {
        return this._indexCount;
    }
    initializeContext(gl) {
        const vertices = (0, $3ce6ee188e300946$export$7005c9eb6671414d).textured((0, $d4d7bd6cc65a5081$export$a002182e51710d39).MAT4_IDENTITY);
        this._vertexBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, this._vertexBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW);
        const indices = (0, $3ce6ee188e300946$export$7005c9eb6671414d).INDICES;
        this._indexBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this._indexBuffer);
        gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, indices, gl.STATIC_DRAW);
        this._indexCount = indices.length;
        this._isInitialized = true;
    }
}


var $2a4365468a86449a$var$__awaiter = undefined && undefined.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
            resolve(value);
        });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
            try {
                step(generator.next(value));
            } catch (e) {
                reject(e);
            }
        }
        function rejected(value) {
            try {
                step(generator["throw"](value));
            } catch (e) {
                reject(e);
            }
        }
        function step(result) {
            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
class $2a4365468a86449a$export$861edd1ccea2f746 extends (0, $a123db7d2af0bebc$export$30686c90897c890d) {
    get shaderResources() {
        return this._shaderResources;
    }
    get colorShader() {
        return this._colorShader;
    }
    get textureShader() {
        return this._textureShader;
    }
    get lassoShader() {
        return this._lassoShader;
    }
    get modelShader() {
        return this._modelShader;
    }
    get sdfTextShader() {
        return this._sdfTextShader;
    }
    get gridShader() {
        return this._gridShader;
    }
    get blockShader() {
        return this._blockShader;
    }
    get sphereShader() {
        return this._sphereShader;
    }
    get cyclinderShader() {
        return this._cylinderShader;
    }
    get hexPrismShader() {
        return this._hexPrismShader;
    }
    get sdfShader() {
        return this._sdfShader;
    }
    get anaglyphShader() {
        return this._anaglyphShader;
    }
    get currentAxes() {
        return this._isAxes1Current ? this._axes1 : this._axes2;
    }
    set currentAxes(value) {
        if (this._isAxes1Current) this._axes1 = value;
        else this._axes2 = value;
    }
    get previousAxes() {
        return this._isAxes1Current ? this._axes2 : this._axes1;
    }
    set previousAxes(value) {
        if (this._isAxes1Current) this._axes2 = value;
        else this._axes1 = value;
    }
    get config() {
        return this._config;
    }
    constructor(options){
        super(options);
        this._config = new (0, $3a96f4e19473eeaa$export$29cd7b75162a9425)();
        this._quad = new (0, $1216b11de4c14ee0$export$7005c9eb6671414d)();
        this._lasso = new (0, $7e67d5ea424e364b$export$dc8af347244861ce)();
        this._pickedPixels = new Uint8Array(4);
        this._pickedIdColor = (0, $4c4ac78b213a9c07$exports).create();
        this._mat3 = (0, $ba3ca37806a2b6fa$exports).create();
        this._directionToCamera = (0, $31054a6c69637582$exports).create();
        this._directionToLight = (0, $31054a6c69637582$exports).create();
        this._halfAngle = (0, $31054a6c69637582$exports).create();
        this._cameraPosition = (0, $31054a6c69637582$exports).create();
        this._modelPosition = (0, $31054a6c69637582$exports).create();
        this.depthEnabled = true;
    }
    get isSupported() {
        return this._createContext(document.createElement("canvas")) !== null;
    }
    get isWebXRSupported() {
        return true;
    }
    initialize(core) {
        super.initialize(core);
        this._shaderResources = new (0, $5ea895789fc20d6f$export$e9a269813a6315a4)();
        this._colorShader = new (0, $8c45895df6e4c752$export$892596cec99bc70e)(this._core, this);
        this._textureShader = new (0, $0bc042355ce24bf2$export$5431306cf43de24a)(this._core, this);
        this._lassoShader = new (0, $79f5d05e1849f9e7$export$dc8af347244861ce)(this._core, this);
        this._modelShader = new (0, $f3a972bc0ef40bc6$export$a1edc412be3e1841)(this._core, this);
        this._sdfTextShader = new (0, $e9174d935ec6042d$export$a3be0de02f08c3be)(this._core, this);
        this._gridShader = new (0, $b81993c7a1128963$export$3b812729b68dda3e)(this._core, this);
        this._anaglyphShader = new (0, $113219cc0f7990e8$export$6a2b78e9604d5b98)(this._core, this);
        this._blockShader = new (0, $592f874dfaaf58b7$export$b72dd5e86522410a)(this._core, this);
        this._sphereShader = new (0, $8cca1fe874486634$export$427a5e80ce652e7d)(this._core, this);
        this._cylinderShader = new (0, $1876c8aeb7dcd226$export$28e50bed796372f2)(this._core, this);
        this._hexPrismShader = new (0, $aa73a9318009cb1a$export$d39efaf3a2b8a5a)(this._core, this);
        this._sdfShader = new (0, $67534a528c920bae$export$b0bdf50006eaaa7a)(this._core, this);
        this._initializeContext(this._createContext(this._canvas));
        this._canvas.addEventListener("webglcontextlost", (event)=>{
            this._core.log.write((0, $4a6417d29706362f$export$243e62d78d3b544d).warn, "WebGL context lost");
            this._isInitialized = false;
            event.preventDefault();
        }, false);
        this._canvas.addEventListener("webglcontextrestored", ()=>{
            this._initializeContext(this._createContext(this._canvas));
            this._isInitialized = true;
            this._core.log.write((0, $4a6417d29706362f$export$243e62d78d3b544d).info, "WebGL context restored");
        }, false);
        this._isInitialized = true;
    }
    _initializeContext(gl) {
        this._gl = gl;
        for(const key in this.fonts){
            const fontVisual = this.fonts[key];
            fontVisual.initializeContext(gl);
        }
        this._shaderResources.initializeContext(this._gl);
        this._colorShader.initializeContext(this._gl);
        this._textureShader.initializeContext(this._gl);
        this._lassoShader.initializeContext(this._gl);
        this._modelShader.initializeContext(this._gl);
        this._sdfTextShader.initializeContext(this._gl);
        this._gridShader.initializeContext(this._gl);
        this._anaglyphShader.initializeContext(this._gl);
        this._blockShader.initializeContext(this._gl);
        this._sphereShader.initializeContext(this._gl);
        this._cylinderShader.initializeContext(this._gl);
        this._hexPrismShader.initializeContext(this._gl);
        this._sdfShader.initializeContext(this._gl);
        this._quad.initializeContext(this._gl);
        this._lasso.initializeContext(this._gl);
        this._debugAxesVisual.initializeContext(this._gl);
        this._framebuffers = [
            null,
            null
        ];
        const texture = (0, $a25f5529f6cda489$export$c41e4fcbf45db179).create(this._gl, this._core.config.pickWidth, this._core.config.pickHeight, this._gl.RGBA, this._gl.UNSIGNED_BYTE, this._gl.LINEAR, null);
        const renderBuffer = this._gl.createRenderbuffer();
        this._gl.bindRenderbuffer(this._gl.RENDERBUFFER, renderBuffer);
        this._gl.renderbufferStorage(this._gl.RENDERBUFFER, this._gl.DEPTH_COMPONENT16, this._core.config.pickWidth, this._core.config.pickHeight);
        const framebuffer = this._gl.createFramebuffer();
        this._shaderResources.bindFramebuffer(framebuffer);
        this._gl.framebufferTexture2D(this._gl.FRAMEBUFFER, this._gl.COLOR_ATTACHMENT0, this._gl.TEXTURE_2D, texture, 0);
        this._gl.framebufferRenderbuffer(this._gl.FRAMEBUFFER, this._gl.DEPTH_ATTACHMENT, this._gl.RENDERBUFFER, renderBuffer);
        this._pickFrameBuffer = framebuffer;
        this._anaglyphTextures = [
            null,
            null
        ];
        this.anaglyphFramebuffers = [
            null,
            null
        ];
        for(let i = 0; i < this.transitionBuffers.length; i++)this.transitionBuffers[i].initializeContext(this._gl);
        if (this._axes1) for(let i = 0; i < this._axes1.length; i++)this._axes1[i].initializeContext(this._gl);
        if (this._axes2) for(let i = 0; i < this._axes2.length; i++)this._axes2[i].initializeContext(this._gl);
        for(let i = 0; i < this.labelSets.length; i++)this.labelSets[i].initializeContext(this._gl);
        for(let i = 0; i < this.images.length; i++)this.images[i].initializeContext(this._gl);
        for(let i = 0; i < this.controllers.length; i++)this.controllers[i].initializeContext(this._gl);
    }
    _resize(width, height) {
        super._resize(width, height);
        for(let i = 0; i < 2; i++){
            const texture = (0, $a25f5529f6cda489$export$c41e4fcbf45db179).create(this._gl, width, height, this._gl.RGBA, this._gl.UNSIGNED_BYTE, this._gl.LINEAR, null);
            const renderBuffer = this._gl.createRenderbuffer();
            this._gl.bindRenderbuffer(this._gl.RENDERBUFFER, renderBuffer);
            this._gl.renderbufferStorage(this._gl.RENDERBUFFER, this._gl.DEPTH_COMPONENT16, width, height);
            const framebuffer = this._gl.createFramebuffer();
            this._shaderResources.bindFramebuffer(framebuffer);
            this._gl.framebufferTexture2D(this._gl.FRAMEBUFFER, this._gl.COLOR_ATTACHMENT0, this._gl.TEXTURE_2D, texture, 0);
            this._gl.framebufferRenderbuffer(this._gl.FRAMEBUFFER, this._gl.DEPTH_ATTACHMENT, this._gl.RENDERBUFFER, renderBuffer);
            this._anaglyphTextures[i] = texture;
            this.anaglyphFramebuffers[i] = framebuffer;
        }
        this._core.log.write((0, $4a6417d29706362f$export$243e62d78d3b544d).info, `buffers resized ${width},${height}`);
    }
    _createContext(canvas) {
        const antialias = this._options ? this._options.antialias === undefined ? true : this._options.antialias : true;
        const preserveDrawingBuffer = this._options ? this._options.preserveDrawingBuffer === undefined ? false : this._options.preserveDrawingBuffer : false;
        return canvas.getContext("webgl", {
            stencil: true,
            alpha: true,
            antialias: antialias,
            preserveDrawingBuffer: preserveDrawingBuffer
        });
    }
    initializeWebXR(session) {
        const promise = new Promise((resolve, reject)=>{
            this._gl.makeXRCompatible().then(()=>{
                session.updateRenderState({
                    baseLayer: new XRWebGLLayer(session, this._gl),
                    depthNear: this._core.config.nearPlane,
                    depthFar: this._core.config.farPlane
                });
                session.requestReferenceSpace('local').then((refSpace)=>{
                    this._webXRReferenceSpace = refSpace;
                    resolve();
                });
            });
        });
        return promise;
    }
    prepare(xrFrame) {
        if (xrFrame) {
            const pose = xrFrame.getViewerPose(this._webXRReferenceSpace);
            if (pose) {
                const glLayer = xrFrame.session.renderState.baseLayer;
                for(let i = 0; i < pose.views.length; i++){
                    const view = pose.views[i];
                    this.vMatrices[i] = view.transform.inverse.matrix;
                    this.inverseVMatrices[i] = view.transform.matrix;
                    (0, $1ac1b59392edf35b$exports).multiply(this._mvMatrices[i], this.vMatrices[i], this.mMatrix);
                    this.mvMatrices[i] = this._mvMatrices[i];
                    this.pMatrices[i] = view.projectionMatrix;
                    const viewport = glLayer.getViewport(view);
                    this._viewports[i].x = viewport.x;
                    this._viewports[i].y = viewport.y;
                    this._viewports[i].width = viewport.width;
                    this._viewports[i].height = viewport.height;
                    this._framebuffers[i] = glLayer.framebuffer;
                }
            }
            this._viewportOffset = 0;
            this._viewportCount = 2;
        } else {
            let viewport;
            switch(this._core.config.stereoMode){
                case (0, $4a6417d29706362f$export$ec20dfa68810b176).none:
                    viewport = this._viewports[0];
                    viewport.x = 0;
                    viewport.y = 0;
                    viewport.width = this._canvas.width;
                    viewport.height = this._canvas.height;
                    this._viewportOffset = 0;
                    this._viewportCount = 1;
                    this._framebuffers[0] = null;
                    break;
                case (0, $4a6417d29706362f$export$ec20dfa68810b176).left:
                    viewport = this._viewports[0];
                    viewport.x = 0;
                    viewport.y = 0;
                    viewport.width = this._canvas.width;
                    viewport.height = this._canvas.height;
                    this._viewportOffset = 0;
                    this._viewportCount = 1;
                    this._framebuffers[0] = null;
                    break;
                case (0, $4a6417d29706362f$export$ec20dfa68810b176).right:
                    viewport = this._viewports[1];
                    viewport.x = 0;
                    viewport.y = 0;
                    viewport.width = this._canvas.width;
                    viewport.height = this._canvas.height;
                    this._viewportOffset = 1;
                    this._viewportCount = 1;
                    this._framebuffers[1] = null;
                    break;
                case (0, $4a6417d29706362f$export$ec20dfa68810b176).anaglyph:
                    viewport = this._viewports[0];
                    viewport.x = 0;
                    viewport.y = 0;
                    viewport.width = this._canvas.width;
                    viewport.height = this._canvas.height;
                    viewport = this._viewports[1];
                    viewport.x = 0;
                    viewport.y = 0;
                    viewport.width = this._canvas.width;
                    viewport.height = this._canvas.height;
                    this._viewportOffset = 0;
                    this._viewportCount = 2;
                    this._framebuffers[0] = this.anaglyphFramebuffers[0];
                    this._framebuffers[1] = this.anaglyphFramebuffers[1];
                    break;
                case (0, $4a6417d29706362f$export$ec20dfa68810b176).split:
                    viewport = this._viewports[0];
                    viewport.x = 0;
                    viewport.y = 0;
                    viewport.width = this._canvas.width / 2;
                    viewport.height = this._canvas.height;
                    viewport = this._viewports[1];
                    viewport.x = this._canvas.width / 2;
                    viewport.y = 0;
                    viewport.width = this._canvas.width / 2;
                    viewport.height = this._canvas.height;
                    this._viewportOffset = 0;
                    this._viewportCount = 2;
                    this._framebuffers[0] = null;
                    this._framebuffers[1] = null;
                    break;
            }
        }
    }
    createTransitionBuffer(ids) {
        const buffer = new (0, $d5b49779b59f8b97$export$76de936b3c1c4170)(this._core, ids);
        buffer.initializeContext(this._gl);
        return buffer;
    }
    createControllerVisual(controller) {
        const visual = new (0, $1a9dbf3e657aba80$export$c6e88a9dc8138322)(this._core, this, controller);
        visual.initializeContext(this._gl);
        return visual;
    }
    createCartesian2dAxesVisual(axes) {
        const visual = new (0, $aca0a8f90b5c931c$export$30e3ee7ba3e49080)(this._core, this, axes);
        visual.initializeContext(this._gl);
        return visual;
    }
    createCartesian3dAxesVisual(axes) {
        const visual = new (0, $a7eaec60ae84313c$export$3dc3b91df297f2ee)(this._core, this, axes);
        visual.initializeContext(this._gl);
        return visual;
    }
    _createDebugAxesVisual(debugAxes) {
        return new (0, $71eca2ce7fbde895$export$2d88a2ee0a1b34a)(this._core, this, debugAxes);
    }
    _createLabelVisual(label) {
        return new (0, $89e74fd9966daa2d$export$71c7fa1581020e2c)(this._core, this, label);
    }
    createLabelSetVisual(labelSet) {
        const visual = new (0, $89e74fd9966daa2d$export$97e93e7019ef67b9)(this._core, this, labelSet);
        visual.initializeContext(this._gl);
        return visual;
    }
    createImageVisual(image) {
        const visual = new (0, $0a92364922ad8eff$export$6f251cd327b2ff1)(this._core, this, image);
        visual.initializeContext(this._gl);
        return visual;
    }
    createFontVisual(font) {
        const visual = new (0, $504631b62e7a70e2$export$e784a6eab4d2d700)(this._core, font);
        visual.initializeContext(this._gl);
        return visual;
    }
    getDataUrl(mimeType) {
        return this._canvas.toDataURL(mimeType);
    }
    render(elapsedTime, xrFrame) {
        return $2a4365468a86449a$var$__awaiter(this, void 0, void 0, function*() {
            if (this.depthEnabled) this._gl.enable(this._gl.DEPTH_TEST);
            else this._gl.disable(this._gl.DEPTH_TEST);
            this._gl.enable(this._gl.CULL_FACE);
            this._gl.disable(this._gl.BLEND);
            if (this.isPickingEnabled) {
                this._shaderResources.bindFramebuffer(this._pickFrameBuffer);
                this._gl.clearColor(0, 0, 0, 0);
                this._gl.clear(this._gl.COLOR_BUFFER_BIT | this._gl.DEPTH_BUFFER_BIT);
            }
            const backgroundColor = this._backgroundColor || this._core.config.backgroundColor;
            this._gl.clearColor(backgroundColor[0], backgroundColor[1], backgroundColor[2], backgroundColor[3]);
            if (xrFrame) {
                const glLayer = xrFrame.session.renderState.baseLayer;
                this._shaderResources.bindFramebuffer(glLayer.framebuffer);
                this._gl.clear(this._gl.COLOR_BUFFER_BIT | this._gl.DEPTH_BUFFER_BIT);
            } else if (this._core.config.stereoMode == (0, $4a6417d29706362f$export$ec20dfa68810b176).anaglyph) {
                for(let i = 0; i < 2; i++){
                    this._shaderResources.bindFramebuffer(this.anaglyphFramebuffers[i]);
                    this._gl.clear(this._gl.COLOR_BUFFER_BIT | this._gl.DEPTH_BUFFER_BIT);
                }
                this._shaderResources.bindFramebuffer(null);
                this._gl.clear(this._gl.COLOR_BUFFER_BIT | this._gl.DEPTH_BUFFER_BIT);
            } else {
                this._shaderResources.bindFramebuffer(null);
                this._gl.clear(this._gl.COLOR_BUFFER_BIT | this._gl.DEPTH_BUFFER_BIT);
            }
            if (this._core.config.isDebugVisible) {
                this._debugAxesVisual.framebuffers = this._framebuffers;
                this._debugAxesVisual.render(elapsedTime, xrFrame);
            }
            const axesVisuals = this.axesVisibility == (0, $4a6417d29706362f$export$7dbc7c2b82487e42).current ? this.currentAxes : this.axesVisibility == (0, $4a6417d29706362f$export$7dbc7c2b82487e42).previous ? this.previousAxes : null;
            if (axesVisuals) for(let i = 0; i < axesVisuals.length; i++){
                const axesVisual = axesVisuals[i];
                if (axesVisual.isVisible) {
                    axesVisual.pickedIdColor = this._pickedIdColor;
                    axesVisual.pickFramebuffer = this._pickFrameBuffer;
                    axesVisual.framebuffers = this._framebuffers;
                    axesVisual.render(elapsedTime, xrFrame);
                }
            }
            for(let i = 0; i < this.transitionBuffers.length; i++){
                const transitionBuffer = this.transitionBuffers[i];
                if (transitionBuffer.isVisible) this._renderTransitionBuffer(xrFrame, transitionBuffer);
            }
            if (this.areLabelsVisible) for(let i = 0; i < this.labelSets.length; i++){
                const labelSetVisual = this.labelSets[i];
                if (labelSetVisual.isVisible) {
                    labelSetVisual.pickedIdColor = this._pickedIdColor;
                    labelSetVisual.pickFramebuffer = this._pickFrameBuffer;
                    labelSetVisual.framebuffers = this._framebuffers;
                    labelSetVisual.render(elapsedTime, xrFrame);
                }
            }
            if (this.areImagesVisible) for(let i = 0; i < this.images.length; i++){
                const imageVisual = this.images[i];
                if (imageVisual.isVisible) {
                    imageVisual.framebuffers = this._framebuffers;
                    imageVisual.pickFramebuffer = this._pickFrameBuffer;
                    imageVisual.isPickingEnabled = this.isPickingEnabled;
                    imageVisual.render(elapsedTime, xrFrame);
                }
            }
            for(let i = 0; i < this.controllers.length; i++){
                const controllerVisual = this.controllers[i];
                if (controllerVisual.isVisible) {
                    controllerVisual.isRayVisible = this.isPickingEnabled;
                    controllerVisual.framebuffers = this._framebuffers;
                    controllerVisual.render(elapsedTime, xrFrame);
                }
            }
            if (this.isPickingEnabled) {
                this._shaderResources.bindFramebuffer(this._pickFrameBuffer);
                this._gl.readPixels(this._core.config.pickWidth / 2, this._core.config.pickHeight / 2, 1, 1, this._gl.RGBA, this._gl.UNSIGNED_BYTE, this._pickedPixels);
                this._pickedType = (0, $a60d0d861ccf87e8$export$aadd933e49c67c12).decodeType(this._pickedPixels);
                (0, $4c4ac78b213a9c07$exports).set(this._pickedIdColor, this._pickedPixels[0] / 0xff, this._pickedPixels[1] / 0xff, this._pickedPixels[2] / 0xff, this._pickedPixels[3] / 0xff);
                this._pickedId = (0, $a60d0d861ccf87e8$export$aadd933e49c67c12).decodeNumber(this._pickedPixels);
                if (this._isCapturingPickImage && this.capturePickImageCallback) {
                    this._isCapturingPickImage = false;
                    const data = new Uint8ClampedArray(this._core.config.pickWidth * this._core.config.pickHeight * 4);
                    this._gl.readPixels(0, 0, this._core.config.pickWidth, this._core.config.pickHeight, this._gl.RGBA, this._gl.UNSIGNED_BYTE, data);
                    for(let i = 0; i < data.length / 4; i++)if (data[i * 4 + 3] == (0, $4a6417d29706362f$export$6fc3f4da94ff0be0).data) data[i * 4 + 3] = 255;
                    else {
                        data[i * 4] = 0;
                        data[i * 4 + 1] = 0;
                        data[i * 4 + 2] = 0;
                        data[i * 4 + 3] = 0;
                    }
                    const length = this._core.config.pickWidth * this._core.config.pickHeight * 4;
                    const row = this._core.config.pickWidth * 4;
                    const end = (this._core.config.pickHeight - 1) * row;
                    const flipped = new Uint8ClampedArray(length);
                    for(let i = 0; i < length; i += row)flipped.set(data.subarray(i, i + row), end - i);
                    this.capturePickImageCallback(flipped, this._core.config.pickWidth, this._core.config.pickHeight);
                }
            } else {
                (0, $4c4ac78b213a9c07$exports).set(this._pickedIdColor, 0, 0, 0, 0);
                this._pickedId = 0;
            }
            if (this.isLassoPicking && this._lassoShader.isInitialized) {
                this._lassoShader.vertexBuffer = this._lasso.vertexBuffer;
                this._lassoShader.indexBuffer = this._lasso.indexBuffer;
                const lassoWidth = this.lassoX1 - this.lassoX0;
                const lassoHeight = this.lassoY1 - this.lassoY0;
                this._lassoShader.prepare();
                this._lassoShader.color = this.lassoColor ? this.lassoColor : this._core.config.lassoColor;
                this._lassoShader.dashWidth = this.lassoDashWidth ? this.lassoDashWidth : this._core.config.lassoDashWidth;
                this._lassoShader.apply();
                const lassoThickness = this.lassoThickness ? this.lassoThickness : this._core.config.lassoThickness;
                for(let i = 0; i < this._viewportCount; i++){
                    const viewportIndex = i + this._viewportOffset;
                    this._shaderResources.bindFramebuffer(this._framebuffers[viewportIndex]);
                    const viewport = this._viewports[viewportIndex];
                    this._gl.viewport(viewport.x, viewport.y, viewport.width, viewport.height);
                    this._lassoMMatrix[0] = lassoWidth * 2 / viewport.width;
                    this._lassoMMatrix[5] = lassoHeight * 2 / viewport.height;
                    this._lassoMMatrix[10] = 1;
                    this._lassoMMatrix[12] = (this.lassoX0 + lassoWidth / 2) / viewport.width * 2 - 1;
                    this._lassoMMatrix[13] = 1 - (this.lassoY0 + lassoHeight / 2) / viewport.height * 2;
                    this._lassoShader.mMatrix = this._lassoMMatrix;
                    (0, $91b0cc4981465964$exports).set(this._lassoThickness, lassoThickness / lassoWidth, lassoThickness / lassoHeight);
                    this._lassoShader.thickness = this._lassoThickness;
                    this._lassoShader.applyView();
                    this._gl.drawElements(this._gl.TRIANGLES, this._lasso.indexCount, this._gl.UNSIGNED_SHORT, 0);
                }
            }
            if (this._core.config.stereoMode == (0, $4a6417d29706362f$export$ec20dfa68810b176).anaglyph && this._anaglyphShader.isInitialized && this._quad.isInitialized) {
                this._shaderResources.bindFramebuffer(null);
                this._gl.viewport(this._viewports[0].x, this._viewports[0].y, this._viewports[0].width, this._viewports[0].height);
                this._anaglyphShader.vertexBuffer = this._quad.vertexBuffer;
                this._anaglyphShader.indexBuffer = this._quad.indexBuffer;
                this._anaglyphShader.texture2D1 = this._anaglyphTextures[0];
                this._anaglyphShader.texture2D2 = this._anaglyphTextures[1];
                this._anaglyphShader.prepare();
                this._anaglyphShader.viewport = this._viewports[0];
                this._anaglyphShader.apply();
                this._gl.drawElements(this._gl.TRIANGLES, this._quad.indexCount, this._gl.UNSIGNED_SHORT, 0);
            }
        });
    }
    _renderTransitionBuffer(xrFrame, transitionBuffer) {
        const currentBuffer = transitionBuffer.currentBuffer;
        const previousBuffer = transitionBuffer.previousBuffer;
        const currentPalette = transitionBuffer.currentPalette;
        const previousPalette = transitionBuffer.previousPalette;
        const currentAtlas = transitionBuffer.currentAtlas;
        const previousAtlas = transitionBuffer.previousAtlas;
        const unitType = transitionBuffer.unitType === undefined ? currentBuffer.unitType : transitionBuffer.unitType;
        const id = currentBuffer.lookup[transitionBuffer.pickIdLookup[this._pickedId]];
        const hoverId = id > -1 ? (0, $0a0587bd8b0d58e8$export$849e31d725692576).getIdHover(currentBuffer.dataView, id) : -1;
        const activeId = transitionBuffer.activeId;
        if (this._blockShader.isInitialized && (unitType == (0, $4a6417d29706362f$export$80d48287646c9e3b).block || unitType == (0, $4a6417d29706362f$export$80d48287646c9e3b).blockSdf || unitType == (0, $4a6417d29706362f$export$80d48287646c9e3b).ringSdf)) {
            this._blockShader.instanceBuffer = currentBuffer.vertexBuffer;
            this._blockShader.previousInstanceBuffer = previousBuffer.vertexBuffer;
            this._blockShader.paletteTexture = currentPalette.texture || currentPalette.defaultTexture;
            this._blockShader.previousPaletteTexture = previousPalette.texture || previousPalette.defaultTexture;
            this._blockShader.prepare();
            this._blockShader.mMatrix = this.mMatrix;
            this._blockShader.time = this.transitionTime;
            this._blockShader.duration = this._core.config.transitionDuration / (this._core.config.transitionDuration + this._core.config.transitionStaggering);
            this._blockShader.rangeMin = 0;
            this._blockShader.rangeMax = transitionBuffer.length - 1;
            this._blockShader.hover = hoverId;
            this._blockShader.active = activeId;
            this._blockShader.selectedColor = this._core.config.selectionColor;
            this._blockShader.hoverColor = this._core.config.hoverColor;
            this._blockShader.activeColor = this._core.config.activeColor;
            this._blockShader.highlightMode = this._core.config.highlightMode;
            this._blockShader.specularPower = this._config.specularPower;
            this._blockShader.specularIntensity = this._config.specularIntensity;
            this._blockShader.ambient = this._config.ambient;
            this._blockShader.apply();
            this._blockShader.isPickShader = false;
            for(let i = 0; i < this._viewportCount; i++){
                const viewport = i + this._viewportOffset;
                this._shaderResources.bindFramebuffer(this._framebuffers[viewport]);
                this._gl.viewport(this._viewports[viewport].x, this._viewports[viewport].y, this._viewports[viewport].width, this._viewports[viewport].height);
                const vMatrix = this.vMatrices[viewport];
                if (xrFrame) {
                    (0, $31054a6c69637582$exports).set(this._modelPosition, this.mMatrix[12], this.mMatrix[13], this.mMatrix[14]);
                    (0, $31054a6c69637582$exports).subtract(this._directionToLight, this._config.lightPosition, this._modelPosition);
                    (0, $31054a6c69637582$exports).normalize(this._directionToLight, this._directionToLight);
                    const inverseVMatrix = this.inverseVMatrices[viewport];
                    (0, $31054a6c69637582$exports).set(this._cameraPosition, inverseVMatrix[12], inverseVMatrix[13], inverseVMatrix[14]);
                    (0, $31054a6c69637582$exports).subtract(this._directionToCamera, this._cameraPosition, this._modelPosition);
                    (0, $31054a6c69637582$exports).normalize(this._directionToCamera, this._directionToCamera);
                    (0, $31054a6c69637582$exports).add(this._halfAngle, this._directionToLight, this._directionToCamera);
                    (0, $31054a6c69637582$exports).normalize(this._halfAngle, this._halfAngle);
                    (0, $ba3ca37806a2b6fa$exports).fromMat4(this._mat3, vMatrix);
                    (0, $31054a6c69637582$exports).transformMat3(this._directionToLight, this._directionToLight, this._mat3);
                    (0, $31054a6c69637582$exports).transformMat3(this._halfAngle, this._halfAngle, this._mat3);
                    this._blockShader.directionToLight = this._directionToLight;
                    this._blockShader.halfAngle = this._halfAngle;
                } else {
                    this._blockShader.directionToLight = this._config.directionToLight;
                    this._blockShader.halfAngle = this._config.halfAngle;
                }
                this._blockShader.vMatrix = vMatrix;
                this._blockShader.pMatrix = this.pMatrices[viewport];
                this._blockShader.applyView();
                this._shaderResources.ANGLE_instanced_arrays.drawElementsInstancedANGLE(this._gl.TRIANGLE_STRIP, this._blockShader.indexCount, this._gl.UNSIGNED_SHORT, 0, transitionBuffer.length);
            }
            if (this.isPickingEnabled && transitionBuffer.isPickingEnabled) {
                this._blockShader.isPickShader = true;
                this._blockShader.pMatrix = this.pickPMatrix;
                this._blockShader.vMatrix = this.pickVMatrix;
                this._blockShader.applyView();
                this._shaderResources.bindFramebuffer(this._pickFrameBuffer);
                this._gl.viewport(0, 0, this._core.config.pickWidth, this._core.config.pickHeight);
                this._shaderResources.ANGLE_instanced_arrays.drawElementsInstancedANGLE(this._gl.TRIANGLE_STRIP, this._blockShader.indexCount, this._gl.UNSIGNED_SHORT, 0, transitionBuffer.length);
            }
        } else if (this._sphereShader.isInitialized && (unitType == (0, $4a6417d29706362f$export$80d48287646c9e3b).sphere || unitType == (0, $4a6417d29706362f$export$80d48287646c9e3b).sphereSdf || unitType == (0, $4a6417d29706362f$export$80d48287646c9e3b).disk)) {
            this._sphereShader.instanceBuffer = currentBuffer.vertexBuffer;
            this._sphereShader.previousInstanceBuffer = previousBuffer.vertexBuffer;
            this._sphereShader.paletteTexture = currentPalette.texture || currentPalette.defaultTexture;
            this._sphereShader.previousPaletteTexture = previousPalette.texture || previousPalette.defaultTexture;
            this._sphereShader.prepare();
            this._sphereShader.mMatrix = this.mMatrix;
            this._sphereShader.time = this.transitionTime;
            this._sphereShader.duration = this._core.config.transitionDuration / (this._core.config.transitionDuration + this._core.config.transitionStaggering);
            this._sphereShader.rangeMin = 0;
            this._sphereShader.rangeMax = transitionBuffer.length - 1;
            this._sphereShader.hover = hoverId;
            this._sphereShader.active = activeId;
            this._sphereShader.selectedColor = this._core.config.selectionColor;
            this._sphereShader.hoverColor = this._core.config.hoverColor;
            this._sphereShader.activeColor = this._core.config.activeColor;
            this._sphereShader.highlightMode = this._core.config.highlightMode;
            this._sphereShader.specularPower = this._config.specularPower;
            this._sphereShader.specularIntensity = this._config.specularIntensity;
            this._sphereShader.ambient = this._config.ambient;
            this._sphereShader.apply();
            this._sphereShader.isPickShader = false;
            for(let i = 0; i < this._viewportCount; i++){
                const viewport = i + this._viewportOffset;
                this._shaderResources.bindFramebuffer(this._framebuffers[viewport]);
                this._gl.viewport(this._viewports[viewport].x, this._viewports[viewport].y, this._viewports[viewport].width, this._viewports[viewport].height);
                const vMatrix = this.vMatrices[viewport];
                if (xrFrame) {
                    (0, $31054a6c69637582$exports).set(this._modelPosition, this.mMatrix[12], this.mMatrix[13], this.mMatrix[14]);
                    (0, $31054a6c69637582$exports).subtract(this._directionToLight, this._config.lightPosition, this._modelPosition);
                    (0, $31054a6c69637582$exports).normalize(this._directionToLight, this._directionToLight);
                    const inverseVMatrix = this.inverseVMatrices[viewport];
                    (0, $31054a6c69637582$exports).set(this._cameraPosition, inverseVMatrix[12], inverseVMatrix[13], inverseVMatrix[14]);
                    (0, $31054a6c69637582$exports).subtract(this._directionToCamera, this._cameraPosition, this._modelPosition);
                    (0, $31054a6c69637582$exports).normalize(this._directionToCamera, this._directionToCamera);
                    (0, $31054a6c69637582$exports).add(this._halfAngle, this._directionToLight, this._directionToCamera);
                    (0, $31054a6c69637582$exports).normalize(this._halfAngle, this._halfAngle);
                    (0, $ba3ca37806a2b6fa$exports).fromMat4(this._mat3, vMatrix);
                    (0, $31054a6c69637582$exports).transformMat3(this._directionToLight, this._directionToLight, this._mat3);
                    (0, $31054a6c69637582$exports).transformMat3(this._halfAngle, this._halfAngle, this._mat3);
                    this._sphereShader.directionToLight = this._directionToLight;
                    this._sphereShader.halfAngle = this._halfAngle;
                } else {
                    this._sphereShader.directionToLight = this._config.directionToLight;
                    this._sphereShader.halfAngle = this._config.halfAngle;
                }
                this._sphereShader.vMatrix = vMatrix;
                this._sphereShader.pMatrix = this.pMatrices[viewport];
                this._sphereShader.applyView();
                this._shaderResources.ANGLE_instanced_arrays.drawElementsInstancedANGLE(this._gl.TRIANGLE_STRIP, this._sphereShader.indexCount, this._gl.UNSIGNED_SHORT, 0, transitionBuffer.length);
            }
            if (this.isPickingEnabled && transitionBuffer.isPickingEnabled) {
                this._sphereShader.isPickShader = true;
                this._sphereShader.pMatrix = this.pickPMatrix;
                this._sphereShader.vMatrix = this.pickVMatrix;
                this._sphereShader.applyView();
                this._shaderResources.bindFramebuffer(this._pickFrameBuffer);
                this._gl.viewport(0, 0, this._core.config.pickWidth, this._core.config.pickHeight);
                this._shaderResources.ANGLE_instanced_arrays.drawElementsInstancedANGLE(this._gl.TRIANGLE_STRIP, this._sphereShader.indexCount, this._gl.UNSIGNED_SHORT, 0, transitionBuffer.length);
            }
        } else if (this._cylinderShader.isInitialized && (unitType == (0, $4a6417d29706362f$export$80d48287646c9e3b).cylinder || unitType == (0, $4a6417d29706362f$export$80d48287646c9e3b).cylinderSdf)) {
            this._cylinderShader.instanceBuffer = currentBuffer.vertexBuffer;
            this._cylinderShader.previousInstanceBuffer = previousBuffer.vertexBuffer;
            this._cylinderShader.paletteTexture = currentPalette.texture || currentPalette.defaultTexture;
            this._cylinderShader.previousPaletteTexture = previousPalette.texture || previousPalette.defaultTexture;
            this._cylinderShader.prepare();
            this._cylinderShader.mMatrix = this.mMatrix;
            this._cylinderShader.time = this.transitionTime;
            this._cylinderShader.duration = this._core.config.transitionDuration / (this._core.config.transitionDuration + this._core.config.transitionStaggering);
            this._cylinderShader.rangeMin = 0;
            this._cylinderShader.rangeMax = transitionBuffer.length - 1;
            this._cylinderShader.hover = hoverId;
            this._cylinderShader.active = activeId;
            this._cylinderShader.selectedColor = this._core.config.selectionColor;
            this._cylinderShader.hoverColor = this._core.config.hoverColor;
            this._cylinderShader.activeColor = this._core.config.activeColor;
            this._cylinderShader.highlightMode = this._core.config.highlightMode;
            this._cylinderShader.specularPower = this._config.specularPower;
            this._cylinderShader.specularIntensity = this._config.specularIntensity;
            this._cylinderShader.ambient = this._config.ambient;
            this._cylinderShader.apply();
            this._cylinderShader.isPickShader = false;
            for(let i = 0; i < this._viewportCount; i++){
                const viewport = i + this._viewportOffset;
                this._shaderResources.bindFramebuffer(this._framebuffers[viewport]);
                this._gl.viewport(this._viewports[viewport].x, this._viewports[viewport].y, this._viewports[viewport].width, this._viewports[viewport].height);
                const vMatrix = this.vMatrices[viewport];
                if (xrFrame) {
                    (0, $31054a6c69637582$exports).set(this._modelPosition, this.mMatrix[12], this.mMatrix[13], this.mMatrix[14]);
                    (0, $31054a6c69637582$exports).subtract(this._directionToLight, this._config.lightPosition, this._modelPosition);
                    (0, $31054a6c69637582$exports).normalize(this._directionToLight, this._directionToLight);
                    const inverseVMatrix = this.inverseVMatrices[viewport];
                    (0, $31054a6c69637582$exports).set(this._cameraPosition, inverseVMatrix[12], inverseVMatrix[13], inverseVMatrix[14]);
                    (0, $31054a6c69637582$exports).subtract(this._directionToCamera, this._cameraPosition, this._modelPosition);
                    (0, $31054a6c69637582$exports).normalize(this._directionToCamera, this._directionToCamera);
                    (0, $31054a6c69637582$exports).add(this._halfAngle, this._directionToLight, this._directionToCamera);
                    (0, $31054a6c69637582$exports).normalize(this._halfAngle, this._halfAngle);
                    (0, $ba3ca37806a2b6fa$exports).fromMat4(this._mat3, vMatrix);
                    (0, $31054a6c69637582$exports).transformMat3(this._directionToLight, this._directionToLight, this._mat3);
                    (0, $31054a6c69637582$exports).transformMat3(this._halfAngle, this._halfAngle, this._mat3);
                    this._cylinderShader.directionToLight = this._directionToLight;
                    this._cylinderShader.halfAngle = this._halfAngle;
                } else {
                    this._cylinderShader.directionToLight = this._config.directionToLight;
                    this._cylinderShader.halfAngle = this._config.halfAngle;
                }
                this._cylinderShader.vMatrix = vMatrix;
                this._cylinderShader.pMatrix = this.pMatrices[viewport];
                this._cylinderShader.applyView();
                this._shaderResources.ANGLE_instanced_arrays.drawElementsInstancedANGLE(this._gl.TRIANGLE_STRIP, this._cylinderShader.indexCount, this._gl.UNSIGNED_SHORT, 0, transitionBuffer.length);
            }
            if (this.isPickingEnabled && transitionBuffer.isPickingEnabled) {
                this._cylinderShader.isPickShader = true;
                this._cylinderShader.pMatrix = this.pickPMatrix;
                this._cylinderShader.vMatrix = this.pickVMatrix;
                this._cylinderShader.applyView();
                this._shaderResources.bindFramebuffer(this._pickFrameBuffer);
                this._gl.viewport(0, 0, this._core.config.pickWidth, this._core.config.pickHeight);
                this._shaderResources.ANGLE_instanced_arrays.drawElementsInstancedANGLE(this._gl.TRIANGLE_STRIP, this._cylinderShader.indexCount, this._gl.UNSIGNED_SHORT, 0, transitionBuffer.length);
            }
        } else if (this._hexPrismShader.isInitialized && (unitType == (0, $4a6417d29706362f$export$80d48287646c9e3b).hexPrism || unitType == (0, $4a6417d29706362f$export$80d48287646c9e3b).hexPrismSdf)) {
            this._hexPrismShader.instanceBuffer = currentBuffer.vertexBuffer;
            this._hexPrismShader.previousInstanceBuffer = previousBuffer.vertexBuffer;
            this._hexPrismShader.paletteTexture = currentPalette.texture || currentPalette.defaultTexture;
            this._hexPrismShader.previousPaletteTexture = previousPalette.texture || previousPalette.defaultTexture;
            this._hexPrismShader.prepare();
            this._hexPrismShader.mMatrix = this.mMatrix;
            this._hexPrismShader.time = this.transitionTime;
            this._hexPrismShader.duration = this._core.config.transitionDuration / (this._core.config.transitionDuration + this._core.config.transitionStaggering);
            this._hexPrismShader.rangeMin = 0;
            this._hexPrismShader.rangeMax = transitionBuffer.length - 1;
            this._hexPrismShader.hover = hoverId;
            this._hexPrismShader.active = activeId;
            this._hexPrismShader.selectedColor = this._core.config.selectionColor;
            this._hexPrismShader.hoverColor = this._core.config.hoverColor;
            this._hexPrismShader.activeColor = this._core.config.activeColor;
            this._hexPrismShader.highlightMode = this._core.config.highlightMode;
            this._hexPrismShader.specularPower = this._config.specularPower;
            this._hexPrismShader.specularIntensity = this._config.specularIntensity;
            this._hexPrismShader.ambient = this._config.ambient;
            this._hexPrismShader.apply();
            this._hexPrismShader.isPickShader = false;
            for(let i = 0; i < this._viewportCount; i++){
                const viewport = i + this._viewportOffset;
                this._shaderResources.bindFramebuffer(this._framebuffers[viewport]);
                this._gl.viewport(this._viewports[viewport].x, this._viewports[viewport].y, this._viewports[viewport].width, this._viewports[viewport].height);
                const vMatrix = this.vMatrices[viewport];
                if (xrFrame) {
                    (0, $31054a6c69637582$exports).set(this._modelPosition, this.mMatrix[12], this.mMatrix[13], this.mMatrix[14]);
                    (0, $31054a6c69637582$exports).subtract(this._directionToLight, this._config.lightPosition, this._modelPosition);
                    (0, $31054a6c69637582$exports).normalize(this._directionToLight, this._directionToLight);
                    const inverseVMatrix = this.inverseVMatrices[viewport];
                    (0, $31054a6c69637582$exports).set(this._cameraPosition, inverseVMatrix[12], inverseVMatrix[13], inverseVMatrix[14]);
                    (0, $31054a6c69637582$exports).subtract(this._directionToCamera, this._cameraPosition, this._modelPosition);
                    (0, $31054a6c69637582$exports).normalize(this._directionToCamera, this._directionToCamera);
                    (0, $31054a6c69637582$exports).add(this._halfAngle, this._directionToLight, this._directionToCamera);
                    (0, $31054a6c69637582$exports).normalize(this._halfAngle, this._halfAngle);
                    (0, $ba3ca37806a2b6fa$exports).fromMat4(this._mat3, vMatrix);
                    (0, $31054a6c69637582$exports).transformMat3(this._directionToLight, this._directionToLight, this._mat3);
                    (0, $31054a6c69637582$exports).transformMat3(this._halfAngle, this._halfAngle, this._mat3);
                    this._hexPrismShader.directionToLight = this._directionToLight;
                    this._hexPrismShader.halfAngle = this._halfAngle;
                } else {
                    this._hexPrismShader.directionToLight = this._config.directionToLight;
                    this._hexPrismShader.halfAngle = this._config.halfAngle;
                }
                this._hexPrismShader.vMatrix = vMatrix;
                this._hexPrismShader.pMatrix = this.pMatrices[viewport];
                this._hexPrismShader.applyView();
                this._shaderResources.ANGLE_instanced_arrays.drawElementsInstancedANGLE(this._gl.TRIANGLE_STRIP, this._hexPrismShader.indexCount, this._gl.UNSIGNED_SHORT, 0, transitionBuffer.length);
            }
            if (this.isPickingEnabled && transitionBuffer.isPickingEnabled) {
                this._hexPrismShader.isPickShader = true;
                this._hexPrismShader.pMatrix = this.pickPMatrix;
                this._hexPrismShader.vMatrix = this.pickVMatrix;
                this._hexPrismShader.applyView();
                this._shaderResources.bindFramebuffer(this._pickFrameBuffer);
                this._gl.viewport(0, 0, this._core.config.pickWidth, this._core.config.pickHeight);
                this._shaderResources.ANGLE_instanced_arrays.drawElementsInstancedANGLE(this._gl.TRIANGLE_STRIP, this._hexPrismShader.indexCount, this._gl.UNSIGNED_SHORT, 0, transitionBuffer.length);
            }
        } else if (this._sdfShader.isInitialized && unitType == (0, $4a6417d29706362f$export$80d48287646c9e3b).sdf) {
            this._sdfShader.instanceBuffer = currentBuffer.vertexBuffer;
            this._sdfShader.previousInstanceBuffer = previousBuffer.vertexBuffer;
            this._sdfShader.paletteTexture = currentPalette.texture || currentPalette.defaultTexture;
            this._sdfShader.previousPaletteTexture = previousPalette.texture || previousPalette.defaultTexture;
            this._sdfShader.sdfTexture = currentAtlas.texture || currentAtlas.defaultTexture;
            this._sdfShader.previousSdfTexture = previousAtlas.texture || previousAtlas.defaultTexture;
            this._sdfShader.prepare();
            this._sdfShader.mMatrix = this.mMatrix;
            this._sdfShader.time = this.transitionTime;
            this._sdfShader.duration = this._core.config.transitionDuration / (this._core.config.transitionDuration + this._core.config.transitionStaggering);
            this._sdfShader.rangeMin = 0;
            this._sdfShader.rangeMax = transitionBuffer.length - 1;
            this._sdfShader.hover = hoverId;
            this._sdfShader.active = activeId;
            this._sdfShader.selectedColor = this._core.config.selectionColor;
            this._sdfShader.hoverColor = this._core.config.hoverColor;
            this._sdfShader.activeColor = this._core.config.activeColor;
            this._sdfShader.highlightMode = this._core.config.highlightMode;
            this._sdfShader.sdfBuffer = (this.sdfBuffer || this._core.config.sdfBuffer) / 0xff;
            this._sdfShader.sdfBackgroundColor = this.sdfBackgroundColor || (0, $31054a6c69637582$exports).fromValues(this._core.config.backgroundColor[0], this._core.config.backgroundColor[1], this._core.config.backgroundColor[2]);
            this._sdfShader.specularPower = this._config.specularPower;
            this._sdfShader.specularIntensity = this._config.specularIntensity;
            this._sdfShader.ambient = this._config.ambient;
            this._sdfShader.apply();
            this._sdfShader.isPickShader = false;
            for(let i = 0; i < this._viewportCount; i++){
                const viewport = i + this._viewportOffset;
                this._shaderResources.bindFramebuffer(this._framebuffers[viewport]);
                this._gl.viewport(this._viewports[viewport].x, this._viewports[viewport].y, this._viewports[viewport].width, this._viewports[viewport].height);
                const vMatrix = this.vMatrices[viewport];
                if (xrFrame) {
                    (0, $31054a6c69637582$exports).set(this._modelPosition, this.mMatrix[12], this.mMatrix[13], this.mMatrix[14]);
                    (0, $31054a6c69637582$exports).subtract(this._directionToLight, this._config.lightPosition, this._modelPosition);
                    (0, $31054a6c69637582$exports).normalize(this._directionToLight, this._directionToLight);
                    const inverseVMatrix = this.inverseVMatrices[viewport];
                    (0, $31054a6c69637582$exports).set(this._cameraPosition, inverseVMatrix[12], inverseVMatrix[13], inverseVMatrix[14]);
                    (0, $31054a6c69637582$exports).subtract(this._directionToCamera, this._cameraPosition, this._modelPosition);
                    (0, $31054a6c69637582$exports).normalize(this._directionToCamera, this._directionToCamera);
                    (0, $31054a6c69637582$exports).add(this._halfAngle, this._directionToLight, this._directionToCamera);
                    (0, $31054a6c69637582$exports).normalize(this._halfAngle, this._halfAngle);
                    (0, $ba3ca37806a2b6fa$exports).fromMat4(this._mat3, vMatrix);
                    (0, $31054a6c69637582$exports).transformMat3(this._directionToLight, this._directionToLight, this._mat3);
                    (0, $31054a6c69637582$exports).transformMat3(this._halfAngle, this._halfAngle, this._mat3);
                    this._sdfShader.directionToLight = this._directionToLight;
                    this._sdfShader.halfAngle = this._halfAngle;
                } else {
                    this._sdfShader.directionToLight = this._config.directionToLight;
                    this._sdfShader.halfAngle = this._config.halfAngle;
                }
                this._sdfShader.vMatrix = vMatrix;
                this._sdfShader.pMatrix = this.pMatrices[viewport];
                this._sdfShader.applyView();
                this._shaderResources.ANGLE_instanced_arrays.drawElementsInstancedANGLE(this._gl.TRIANGLE_STRIP, this._sdfShader.indexCount, this._gl.UNSIGNED_SHORT, 0, transitionBuffer.length);
            }
            if (this.isPickingEnabled && transitionBuffer.isPickingEnabled) {
                this._sdfShader.isPickShader = true;
                this._sdfShader.pMatrix = this.pickPMatrix;
                this._sdfShader.vMatrix = this.pickVMatrix;
                this._sdfShader.applyView();
                this._shaderResources.bindFramebuffer(this._pickFrameBuffer);
                this._gl.viewport(0, 0, this._core.config.pickWidth, this._core.config.pickHeight);
                this._shaderResources.ANGLE_instanced_arrays.drawElementsInstancedANGLE(this._gl.TRIANGLE_STRIP, this._sdfShader.indexCount, this._gl.UNSIGNED_SHORT, 0, transitionBuffer.length);
            }
        }
    }
}




var $04aa67b4630f0de9$exports = {};

$parcel$export($04aa67b4630f0de9$exports, "Main", () => $8e6261810f478ee0$export$861edd1ccea2f746);
/*!
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 */ /*!
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 */ 


/*!
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 */ 

class $046a802c77c0a655$export$7005c9eb6671414d {
    get isInitialized() {
        return this._isInitialized;
    }
    get vertexBuffer() {
        return this._vertexBuffer;
    }
    get indexBuffer() {
        return this._indexBuffer;
    }
    get indexCount() {
        return this._indexCount;
    }
    initializeContext(gl) {
        const _vec3 = (0, $31054a6c69637582$exports).fromValues(2, 2, 2);
        const _mat4 = (0, $1ac1b59392edf35b$exports).create();
        (0, $1ac1b59392edf35b$exports).fromScaling(_mat4, _vec3);
        const vertices = (0, $3ce6ee188e300946$export$7005c9eb6671414d).positions(_mat4);
        this._vertexBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, this._vertexBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW);
        const indices = (0, $3ce6ee188e300946$export$7005c9eb6671414d).INDICES;
        this._indexBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this._indexBuffer);
        gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, indices, gl.STATIC_DRAW);
        this._indexCount = indices.length;
        this._isInitialized = true;
    }
}


/*!
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 */ 

/*!
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 */ 

class $824a46b9fb84be21$export$e47fdbcb2ea069e5 extends (0, $0a2e9437355c0494$export$caf2f326fb2d2fb4) {
    get texture() {
        return this._texture;
    }
    get defaultTexture() {
        return this._defaultTexture;
    }
    initializeContext(core, gl) {
        this._gl = gl;
        this._defaultTexture = (0, $a25f5529f6cda489$export$c41e4fcbf45db179).create(gl, 1, 1, gl.RGBA, gl.UNSIGNED_BYTE, gl.NEAREST, new Uint8Array([
            0xff,
            0xff,
            0xff,
            0xff
        ]));
        this._updateTexture();
    }
    update() {
        super.update();
        if (this._changed) {
            this._changed = false;
            this._updateTexture();
        }
    }
    _updateTexture() {
        if (this._imageData) this._texture = (0, $a25f5529f6cda489$export$c41e4fcbf45db179).fromImage(this._gl, this._imageData, false, this._gl.LINEAR);
        else this._texture = null;
    }
}


/*!
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 */ 

class $8628ce147c13b19d$export$e2fbaa661ec19dbf extends (0, $548ced3eab978a8c$export$f05ab453e1597580) {
    get texture() {
        return this._texture;
    }
    get defaultTexture() {
        return this._defaultTexture;
    }
    initializeContext(core, gl) {
        this._gl = gl;
        this._defaultTexture = (0, $a25f5529f6cda489$export$c41e4fcbf45db179).create(gl, 1, 1, gl.RGBA, gl.UNSIGNED_BYTE, gl.NEAREST, core.config.paletteColor);
        this._updateTexture();
    }
    update() {
        super.update();
        if (this._changed) {
            this._changed = false;
            this._updateTexture();
        }
    }
    _updateTexture() {
        if (this._colors) {
            const colors = new Uint8Array(this._colors);
            for(let i = 0; i < colors.length; i++)colors[i] = Math.pow(colors[i] / 0xff, 2.2) * 0xff;
            this._texture = (0, $a25f5529f6cda489$export$c41e4fcbf45db179).create(this._gl, this._colors.length / 4, 1, this._gl.RGBA, this._gl.UNSIGNED_BYTE, this._gl.NEAREST, colors);
        } else this._texture = null;
    }
}


class $5c168c6596bfbd28$export$a143d493d941bafc extends (0, $96371271bb28b98d$export$c1cecec923d96e5c) {
    get vertexBuffer() {
        return this._vertexBuffer;
    }
    constructor(core, ids){
        super(core, ids);
    }
    initializeContext(gl) {
        this._gl = gl;
        this._vertexBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, this._vertexBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, this._vertices, gl.STATIC_DRAW);
        this._isInitialized = true;
    }
    update() {
        if (this._isInitialized) {
            const start = window.performance.now();
            this._gl.bindBuffer(this._gl.ARRAY_BUFFER, this._vertexBuffer);
            this._gl.bufferSubData(this._gl.ARRAY_BUFFER, 0, this._vertices);
            this._core.log.write((0, $4a6417d29706362f$export$243e62d78d3b544d).info, `buffer updated ${this._length} ${Math.round(window.performance.now() - start)}ms`);
        }
    }
}
class $5c168c6596bfbd28$export$76de936b3c1c4170 extends (0, $96371271bb28b98d$export$e17d4fc1dafc1240) {
    constructor(core, ids){
        super(core, ids, $5c168c6596bfbd28$export$a143d493d941bafc, (0, $8628ce147c13b19d$export$e2fbaa661ec19dbf), (0, $824a46b9fb84be21$export$e47fdbcb2ea069e5));
    }
    initializeContext(gl) {
        this._buffer1.initializeContext(gl);
        this._buffer2.initializeContext(gl);
        this._palette1.initializeContext(this._core, gl);
        this._palette2.initializeContext(this._core, gl);
        this._atlas1.initializeContext(this._core, gl);
        this._atlas2.initializeContext(this._core, gl);
        this._isInitialized = true;
    }
}


/*!
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 */ 



class $115d7df89ed6abb3$export$29cd7b75162a9425 extends (0, $a123db7d2af0bebc$export$ecd9923dfd29c8e1) {
    get keyLightAltitude() {
        return this._keyLightAltitude;
    }
    set keyLightAltitude(value) {
        this._keyLightAltitude = value;
        this._updateLights();
    }
    get keyLightAzimuth() {
        return this._keyLightAzimuth;
    }
    set keyLightAzimuth(value) {
        this._keyLightAzimuth = value;
        this._updateLights();
    }
    get keyLightDistance() {
        return this._keyLightDistance;
    }
    set keyLightDistance(value) {
        this._keyLightDistance = value;
        this._updateLights();
    }
    get fillLight1Altitude() {
        return this._fillLight1Altitude;
    }
    set fillLight1Altitude(value) {
        this._fillLight1Altitude = value;
        this._updateLights();
    }
    get fillLight1Azimuth() {
        return this._fillLight1Azimuth;
    }
    set fillLight1Azimuth(value) {
        this._fillLight1Azimuth = value;
        this._updateLights();
    }
    get fillLight2Altitude() {
        return this._fillLight2Altitude;
    }
    set fillLight2Altitude(value) {
        this._fillLight2Altitude = value;
        this._updateLights();
    }
    get fillLight2Azimuth() {
        return this._fillLight2Azimuth;
    }
    set fillLight2Azimuth(value) {
        this._fillLight2Azimuth = value;
        this._updateLights();
    }
    constructor(){
        super();
        this._rotation = (0, $39ece26d1239bb77$exports).create();
        this.keyLightPosition = (0, $31054a6c69637582$exports).create();
        this.fillLight1Position = (0, $31054a6c69637582$exports).create();
        this.fillLight2Position = (0, $31054a6c69637582$exports).create();
        this.reset();
    }
    _updateLights() {
        this._updateLight(this._keyLightAltitude, this._keyLightAzimuth, this._keyLightDistance, this.keyLightPosition);
        this._updateLight(this._fillLight1Altitude, this._fillLight1Azimuth, 1, this.fillLight1Position);
        this._updateLight(this._fillLight2Altitude, this._fillLight2Azimuth, 1, this.fillLight2Position);
    }
    _updateLight(altitude, azimuth, distance, position) {
        (0, $39ece26d1239bb77$exports).rotateY(this._rotation, (0, $d4d7bd6cc65a5081$export$a002182e51710d39).QUAT_IDENTITY, (0, $a49c65c28e06311e$export$210d3b2db589eb5c).degreesToRadians(azimuth));
        (0, $39ece26d1239bb77$exports).rotateX(this._rotation, this._rotation, (0, $a49c65c28e06311e$export$210d3b2db589eb5c).degreesToRadians(-altitude));
        (0, $31054a6c69637582$exports).transformQuat(position, (0, $d4d7bd6cc65a5081$export$a002182e51710d39).VECTOR3_UNITZ, this._rotation);
        (0, $31054a6c69637582$exports).scale(position, position, distance);
    }
    reset() {
        this.isSsaoEnabled = true;
        this.ssaoWidth = 1024;
        this.ssaoHeight = 1024;
        this.ssaoBlurEnabled = true;
        this.ssaoKernelSize = 8;
        this.ssaoNoiseSize = 4;
        this.ssaoRadius = 0.02;
        this.ssaoPower = 1;
        this.isShadowEnabled = true;
        this.shadowWidth = 1024;
        this.shadowHeight = 1024;
        this.isDofEnabled = false;
        this.dofAutoFocus = true;
        this.dofFocusDistance = 0.5;
        this.dofFocusRange = 0.5;
        this.dofMaxBackgroundBlur = 0.75;
        this.isBloomEnabled = false;
        this.bloomIntensity = 2;
        this.specularIntensity = 0.15;
        this.specularPower = 150;
        this.ambientIntensity = 0.1;
        this.materialIntensity = 0.5;
        this.keyLightIntensity = 1.5;
        this.fillLight1Intensity = 0.25;
        this.fillLight2Intensity = 0.25;
        this._keyLightAltitude = 30;
        this._keyLightAzimuth = -45;
        this._keyLightDistance = 1;
        this._fillLight1Altitude = 30;
        this._fillLight1Azimuth = 45;
        this._fillLight2Altitude = 30;
        this._fillLight2Azimuth = -135;
        this._updateLights();
        this.isFxaaEnabled = false;
    }
}


/*!
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 */ 

class $a9df2cd8c496e87d$export$e9a269813a6315a4 {
    bindFramebuffer(framebuffer) {
        if (this.framebuffer != framebuffer) {
            this.framebuffer = framebuffer;
            this._gl.bindFramebuffer(this._gl.FRAMEBUFFER, framebuffer);
        }
    }
    initializeContext(gl) {
        this._gl = gl;
        this.framebuffer = this._gl.createFramebuffer();
        this.OES_texture_float = gl.getExtension("OES_texture_float");
        this.OES_texture_float_linear = gl.getExtension("OES_texture_float_linear");
        this.WEBGL_lose_context = gl.getExtension("WEBGL_lose_context");
    }
}
$a9df2cd8c496e87d$export$e9a269813a6315a4.glsl = {
    "background.fragment.fx": "#version 300 es\n#ifdef GL_FRAGMENT_PRECISION_HIGH\nprecision highp float;\n#else\nprecision mediump float;\n#endif\n#include \"common.include.fx\"\nuniform vec3 uColor;\nlayout(location = 0) out vec4 myPosition;\nlayout(location = 1) out vec4 myColor;\nlayout(location = 2) out vec4 myNormal;\nvoid main(void)\n{\ngl_FragDepth = 0.99999;\nmyPosition = vec4(0.0, 0.0, -FAR_PLANE, 0.0);\nmyColor = vec4(uColor, 1.0);\nmyNormal = vec4(0.0, 0.0, 1.0, 0.0);\n}\n",
    "box.fragment.fx": "#version 300 es\n#ifdef GL_FRAGMENT_PRECISION_HIGH\nprecision highp float;\n#else\nprecision mediump float;\n#endif\nuniform vec4 uViewport;\nuniform sampler2D uSampler;\nout vec4 myOutputColor;\nvoid main(void)\n{\nvec2 texCoords = (gl_FragCoord.xy - uViewport.xy) / uViewport.zw;\nvec2 texelSize = vec2(1.0) / uViewport.zw;\nfloat result = 0.0;\nfor (int x = -2; x < 2; x++)\n{\nfor (int y = -2; y < 2; y++)\n{\nvec2 offset = vec2(float(x) + 0.5, float(y) + 0.5) * texelSize;\nresult += texture(uSampler, texCoords + offset).r;\n}\n}\nresult /= 16.0;\nmyOutputColor = vec4(vec3(result), 1.0);\n}\n",
    "bright.fragment.fx": "#version 300 es\n#ifdef GL_FRAGMENT_PRECISION_HIGH\nprecision highp float;\n#else\nprecision mediump float;\n#endif\nuniform sampler2D uSampler;\nuniform vec2 uResolution;\nout vec4 myOutputColor;\nvoid main(void)\n{\nvec2 texCoords = gl_FragCoord.xy / uResolution;\nvec4 color = texture(uSampler, texCoords);\nmyOutputColor = vec4(color.rgb * color.a, 1.0);\n}\n",
    "combine.fragment.fx": "#version 300 es\n#ifdef GL_FRAGMENT_PRECISION_HIGH\nprecision highp float;\n#else\nprecision mediump float;\n#endif\nuniform sampler2D uSampler1;\nuniform sampler2D uSampler2;\nuniform sampler2D uSampler3;\nuniform sampler2D uSampler4;\nuniform sampler2D uSampler5;\nuniform vec4 uViewport;\nuniform float uIntensity;\nout vec4 myOutputColor;\nvoid main() {\nvec2 texCoords = (gl_FragCoord.xy - uViewport.xy) / uViewport.zw;\nvec3 bloom =\ntexture(uSampler2, texCoords).rgb +\ntexture(uSampler3, texCoords).rgb +\ntexture(uSampler4, texCoords).rgb +\ntexture(uSampler5, texCoords).rgb;\nbloom *= uIntensity;\nvec3 color = texture(uSampler1, texCoords).rgb;\ncolor += bloom;\nmyOutputColor = vec4(color, 1.0);\n}\n",
    "deferred.fragment.fx": "#version 300 es\n#ifdef GL_FRAGMENT_PRECISION_HIGH\nprecision highp float;\n#else\nprecision mediump float;\n#endif\n#include \"common.include.fx\"\nuniform mat4 uInverseVMatrix;\nuniform mat4 uShadowVMatrix;\nuniform mat4 uShadowPMatrix;\nuniform bool uShadow;\nuniform bool uSsao;\nuniform sampler2D uSampler1;\nuniform sampler2D uSampler2;\nuniform sampler2D uSampler3;\nuniform sampler2D uSampler4;\nuniform sampler2D uSampler5;\nuniform vec4 uViewport;\nuniform vec3 uKeyLightHalfAngle;\nuniform vec3 uDirectionToKeyLight;\nuniform vec3 uDirectionToFillLight1;\nuniform vec3 uDirectionToFillLight2;\nuniform vec2 uShadowMapSize;\nuniform float uKeyLightIntensity;\nuniform float uFillLight1Intensity;\nuniform float uFillLight2Intensity;\nuniform float uSpecularPower;\nuniform float uSpecularIntensity;\nuniform float uAmbientIntensity;\nuniform float uMaterialIntensity;\nout vec4 myOutputColor;\nvoid main(void)\n{\nvec2 texCoords = (gl_FragCoord.xy - uViewport.xy) / uViewport.zw;\nvec4 position = texture(uSampler1, texCoords);\nvec4 color = texture(uSampler2, texCoords);\nvec4 normal = texture(uSampler3, texCoords);\nfloat shadow;\nif (uShadow)\n{\nvec4 positionWorld = uInverseVMatrix * vec4(position.xyz, 1.0);\nvec4 positionShadowView = uShadowVMatrix * positionWorld;\nvec4 positionShadowViewProjection = uShadowPMatrix * positionShadowView;\nvec3 projCoords = positionShadowViewProjection.xyz / positionShadowViewProjection.w;\nprojCoords = projCoords * 0.5 + 0.5;\nfloat minProjCoords = min(projCoords.x, projCoords.y);\nfloat maxProjCoords = max(projCoords.x, projCoords.y);\nif (minProjCoords < 0.0 || maxProjCoords > 1.0)\n{\nshadow = 1.0;\n}\nelse\n{\nfloat currentDepth = projCoords.z;\nfloat bias = 0.0;\nvec2 texelSize = 1.0 / uShadowMapSize;\nfor(int x = -1; x <= 1; ++x)\n{\nfor(int y = -1; y <= 1; ++y)\n{\nfloat pcfDepth = texture(uSampler5, projCoords.xy + vec2(x, y) * texelSize).r;\nshadow += currentDepth - bias > pcfDepth ? 1.0 : 0.0;\n}\n}\nshadow /= 9.0;\nshadow = clamp(1.0 - shadow, 0.0, 1.0);\n}\n}\nelse\n{\nshadow = 1.0;\n}\nfloat ssao = uSsao ? texture(uSampler4, texCoords).r : 1.0;\nfloat diffuseIntensity = clamp(dot(normal.rgb, uDirectionToKeyLight), 0.0, 1.0) * uKeyLightIntensity * shadow;\ndiffuseIntensity += clamp(dot(normal.rgb, uDirectionToFillLight1), 0.0, 1.0) * uFillLight1Intensity * ssao;\ndiffuseIntensity += clamp(dot(normal.rgb, uDirectionToFillLight2), 0.0, 1.0) * uFillLight2Intensity * ssao;\nvec3 diffuse = color.rgb * diffuseIntensity * uMaterialIntensity;\nvec3 ambient = uAmbientIntensity * color.rgb * ssao;\nvec3 emissive = color.w * color.rgb;\nfloat specular = normal.w * clamp(pow(clamp(dot(normal.rgb, uKeyLightHalfAngle), 0.0, 1.0), uSpecularPower) * uSpecularIntensity * uKeyLightIntensity * shadow, 0.0, 1.0);\nvec3 result = min(ambient + diffuse + specular + emissive, 1.0);\nresult = pow(result, GAMMA);\nmyOutputColor = vec4(result, position.w);\n}\n",
    "dofblur.fragment.fx": "#version 300 es\n#ifdef GL_FRAGMENT_PRECISION_HIGH\nprecision highp float;\n#else\nprecision mediump float;\n#endif\nuniform sampler2D uSampler1;\nuniform sampler2D uSampler2;\nuniform vec4 uViewport;\nuniform float uFocusDepth;\nuniform float uNearFocusDepth;\nuniform float uFarFocusDepth;\nuniform float uMaxBackgroundBlur;\nout vec4 myOutputColor;\nfloat circleOfConfusion(in float depth )\n{\nfloat f;\nif (depth < uFocusDepth)\n{\nf = (depth - uFocusDepth) / (uFocusDepth - uNearFocusDepth);\nf = clamp(f, -1.0, 0.0);\n}\nelse\n{\nf = (depth - uFocusDepth) / (uFarFocusDepth - uFocusDepth);\nf = clamp(f, 0.0, uMaxBackgroundBlur);\n}\nreturn f * 0.5 + 0.5;\n}\nvoid main(void)\n{\nvec2 texCoords = gl_FragCoord.xy / uViewport.zw;\nvec4 color = texture(uSampler1, texCoords);\nfloat depth = -texture(uSampler2, texCoords).z;\nfloat coc = circleOfConfusion(depth);\nmyOutputColor = vec4(coc);\n}\n",
    "dofcombine.fragment.fx": "#version 300 es\n#ifdef GL_FRAGMENT_PRECISION_HIGH\nprecision highp float;\n#else\nprecision mediump float;\n#endif\nuniform vec4 uViewport;\nuniform float uFocusDepth;\nuniform float uAperture;\nuniform sampler2D uSampler1;\nuniform sampler2D uSampler2;\nout vec4 myOutputColor;\nconst float MAX_CIRCLE_OF_CONFUSION = 3.0;\nvoid main(void)\n{\nvec2 texCoords = (gl_FragCoord.xy - uViewport.xy) / uViewport.zw;\nvec2 texelSize = vec2(1.0) / uViewport.zw;\nvec2 texelSizeLow = texelSize * 4.0;\nconst int NUM_TAPS = 13;\nvec2 samples[NUM_TAPS];\nsamples[0] = vec2(-0.326212,-0.405810);\nsamples[1] = vec2(-0.840144,-0.073580);\nsamples[2] = vec2(-0.695914, 0.457137);\nsamples[3] = vec2(-0.203345, 0.620716);\nsamples[4] = vec2( 0.962340,-0.194983);\nsamples[5] = vec2( 0.473434,-0.480026);\nsamples[6] = vec2( 0.519456, 0.767022);\nsamples[7] = vec2( 0.185461,-0.893124);\nsamples[8] = vec2( 0.507431, 0.064425);\nsamples[9] = vec2( 0.896420, 0.412458);\nsamples[10] = vec2(-0.321940,-0.932615);\nsamples[11] = vec2(-0.791559,-0.597710);\nsamples[12] = vec2( 0.000000, 0.000000);\nconst float maxCoC = 5.0;\nconst float radiusScale = 0.5;\nvec4 cOut = texture(uSampler1, texCoords);\nfloat coc = texture(uSampler2, texCoords).r;\nfloat centerDepth = coc;\nfloat discRadius = abs(coc * 2.0 - 1.0) * maxCoC;\nfloat discRadiusLow = discRadius * radiusScale;\ncOut = vec4(0.0);\nfloat acc = 0.0;\nfor (int t = 0; t < NUM_TAPS; t++)\n{\nvec2 coordLow = texCoords + (texelSizeLow * samples[t] * discRadiusLow);\nvec2 coordHigh = texCoords + (texelSize * samples[t] * discRadius);\nvec4 tapLow = texture(uSampler1, coordLow);\nvec4 tapHigh = texture(uSampler1, coordHigh);\nfloat cocLow = texture(uSampler2, coordLow).r;\nfloat cocHigh = texture(uSampler2, coordHigh).r;\nfloat tapBlur = abs(cocHigh * 2.0 - 1.0);\nvec4 tap = mix(tapHigh, tapLow, tapBlur);\nfloat cocBlur = mix(cocHigh, cocLow, tapBlur);\ncocBlur = (cocBlur >= centerDepth) ? 1.0 : abs(cocBlur * 2.0 - 1.0);\ncOut += tap * cocBlur;\nacc += cocBlur;\n}\nvec4 result = cOut / acc;\nmyOutputColor = result;\n}\n",
    "downsample.fragment.fx": "#version 300 es\n#ifdef GL_FRAGMENT_PRECISION_HIGH\nprecision highp float;\n#else\nprecision mediump float;\n#endif\nuniform sampler2D uSampler;\nuniform vec4 uViewport;\nout vec4 myOutputColor;\nvoid main(void)\n{\nvec2 texCoords = gl_FragCoord.xy / uViewport.zw;\nmyOutputColor = texture(uSampler, texCoords);\n}\n",
    "fxaa.fragment.fx": "#version 300 es\n#ifdef GL_FRAGMENT_PRECISION_HIGH\nprecision highp float;\n#else\nprecision mediump float;\n#endif\n#include \"common.include.fx\"\nconst float FXAA_SPAN_MAX = 8.0;\nconst float FXAA_REDUCE_MUL = 1.0 / 8.0;\nconst float FXAA_REDUCE_MIN = 1.0 / 128.0;\nuniform sampler2D uSampler;\nuniform vec4 uViewport;\nout vec4 myOutputColor;\nvoid main(void)\n{\nvec2 texCoords = (gl_FragCoord.xy - uViewport.xy) / uViewport.zw;\nvec2 texelSize = vec2(1.0) / uViewport.zw;\nvec3 color = texture(uSampler, texCoords).rgb;\nvec3 colorNW = texture(uSampler, vec2(texCoords.x - texelSize.x, texCoords.y - texelSize.y)).rgb;\nvec3 colorNE = texture(uSampler, vec2(texCoords.x + texelSize.x, texCoords.y - texelSize.y)).rgb;\nvec3 colorSW = texture(uSampler, vec2(texCoords.x - texelSize.x, texCoords.y + texelSize.y)).rgb;\nvec3 colorSE = texture(uSampler, vec2(texCoords.x + texelSize.x, texCoords.y + texelSize.y)).rgb;\nfloat luminance = dot(color, LUMINANCE);\nfloat luminanceNW = dot(colorNW, LUMINANCE);\nfloat luminanceNE = dot(colorNE, LUMINANCE);\nfloat luminanceSW = dot(colorSW, LUMINANCE);\nfloat luminanceSE = dot(colorSE, LUMINANCE);\nfloat luminanceMin = min(luminance, min(min(luminanceNW, luminanceNE), min(luminanceSW, luminanceSE)));\nfloat luminanceMax = max(luminance, max(max(luminanceNW, luminanceNE), max(luminanceSW, luminanceSE)));\nvec2 dir = vec2(luminanceSW + luminanceSE - luminanceNW - luminanceNE, luminanceNW + luminanceSW - luminanceNE - luminanceSE);\nfloat dirReduce = max((luminanceNW + luminanceNE + luminanceSW + luminanceSE) * (0.25 * FXAA_REDUCE_MUL), FXAA_REDUCE_MIN);\nfloat rcpDirMin = 1.0 / (min(abs(dir.x), abs(dir.y)) + dirReduce);\ndir = min(vec2(FXAA_SPAN_MAX, FXAA_SPAN_MAX), max(vec2(-FXAA_SPAN_MAX, -FXAA_SPAN_MAX), dir * rcpDirMin)) * texelSize;\nvec3 colorA = 0.5 * (\ntexture(uSampler, texCoords.xy + dir * (1.0/3.0 - 0.5)).rgb +\ntexture(uSampler, texCoords.xy + dir * (2.0/3.0 - 0.5)).rgb);\nvec3 colorB = colorA * 0.5 + 0.25 * (\ntexture(uSampler, texCoords.xy - dir * 0.5).rgb +\ntexture(uSampler, texCoords.xy + dir * 0.5).rgb);\nluminance = dot(colorB, LUMINANCE);\nif (luminance < luminanceMin || luminance > luminanceMax)\n{\nmyOutputColor = vec4(colorA, 1.0);\n}\nelse\n{\nmyOutputColor = vec4(colorB, 1.0);\n}\n}\n",
    "gaussian.fragment.fx": "#version 300 es\n#ifdef GL_FRAGMENT_PRECISION_HIGH\nprecision highp float;\n#else\nprecision mediump float;\n#endif\nuniform sampler2D uSampler;\nuniform vec2 uResolution;\nuniform bool uHorizontal;\nout vec4 myOutputColor;\nvoid main(void)\n{\nvec2 texCoords = gl_FragCoord.xy / uResolution;\nvec2 texelSize = vec2(1.0) / uResolution;\nconst int NUM_WEIGHTS = 3;\nfloat weights[NUM_WEIGHTS];\nweights[0] = 0.2270270270;\nweights[1] = 0.3162162162;\nweights[2] = 0.0702702703;\nfloat offsets[NUM_WEIGHTS];\noffsets[0] = 0.0;\noffsets[1] = 1.3846153846;\noffsets[2] = 3.2307692308;\nvec3 color = texture(uSampler, texCoords).rgb * weights[0];\nif (uHorizontal)\n{\nfor (int i = 1; i < NUM_WEIGHTS; i++) {\ncolor += texture(uSampler, texCoords + vec2(texelSize.x * offsets[i], 0.0)).rgb * weights[i];\ncolor += texture(uSampler, texCoords - vec2(texelSize.x * offsets[i], 0.0)).rgb * weights[i];\n}\n}\nelse\n{\nfor (int i = 1; i < NUM_WEIGHTS; i++) {\ncolor += texture(uSampler, texCoords + vec2(0.0, texelSize.y * offsets[i])).rgb * weights[i];\ncolor += texture(uSampler, texCoords - vec2(0.0, texelSize.y * offsets[i])).rgb * weights[i];\n}\n}\nmyOutputColor = vec4(color, 1.0);\n}\n",
    "lasso.fragment.fx": "#version 300 es\n#ifdef GL_FRAGMENT_PRECISION_HIGH\nprecision highp float;\n#else\nprecision mediump float;\n#endif\n#include \"common.include.fx\"\nuniform vec3 uColor;\nuniform vec2 uThickness;\nuniform float uDashWidth;\nin mediump vec2 vTexCoord;\nout vec4 myOutputColor;\nvoid main(void)\n{\nvec2 distance = min(vTexCoord, 1.0 - vTexCoord);\nif (distance.x > uThickness.x && distance.y > uThickness.y) {\ndiscard;\n}\nvec2 texCoord = vec2(vTexCoord.x, 1.0 - vTexCoord.y);\nvec2 thickness = uThickness * uDashWidth;\nvec2 b = mod(floor(texCoord / thickness), 2.0);\nif (b.x > 0.0 && texCoord.x < 1.0 - thickness.x) {\ndiscard;\n}\nif (b.y > 0.0 && texCoord.y < 1.0 - thickness.y) {\ndiscard;\n}\nmyOutputColor = vec4(pow(uColor, GAMMA), 1.0);\n}\n",
    "lasso.vertex.fx": "#version 300 es\nin vec3 aPosition;\nin mediump vec2 aTexCoord;\nuniform mat4 uMMatrix;\nout mediump vec2 vTexCoord;\nvoid main(void) {\ngl_Position = uMMatrix * vec4(aPosition, 1.0);\nvTexCoord = aTexCoord;\n}\n",
    "pickgrid.fragment.fx": "#version 300 es\n#ifdef GL_FRAGMENT_PRECISION_HIGH\nprecision highp float;\n#else\nprecision mediump float;\n#endif\n#include \"common.include.fx\"\nuniform bool uPick;\nuniform vec2 uFaceSize;\nuniform vec3 uMajorColor;\nuniform vec3 uMinorColor;\nuniform vec3 uZeroColor;\nuniform float uMajorThickness;\nuniform float uMinorThickness;\nuniform float uZeroThickness;\nuniform vec2 uZero;\nuniform vec2 uMinorGridlines;\nin lowp vec4 vColor;\nin mediump vec2 vTexCoord;\nin mediump vec4 vBounds;\nin mediump vec3 vNormal;\nin vec3 vViewPosition;\nlayout(location = 0) out vec4 myPosition;\nlayout(location = 1) out vec4 myColor;\nlayout(location = 2) out vec4 myNormal;\nvoid main(void) {\nif (uPick)\n{\nmyPosition = vColor;\n}\nelse\n{\nmyPosition.xyz = vViewPosition;\nvec2 buffer = fwidth(vTexCoord);\nvec2 distance, thickness, step;\nvec4 color = vColor;\nvec2 width = vBounds.zw - vBounds.xy;\ndistance = (vTexCoord - vBounds.xy) / width;\ndistance = min(abs(distance - floor(uMinorGridlines * distance) / uMinorGridlines), abs(distance - ceil(uMinorGridlines * distance) / uMinorGridlines));\ndistance *= width;\nthickness = vec2(uMinorThickness) / uFaceSize;\nstep = smoothstep(thickness, thickness + buffer, distance);\ncolor.xyz = mix(uMinorColor, color.xyz, min(step.x, step.y));\nthickness = vec2(uMajorThickness) / uFaceSize;\ndistance = min(vTexCoord - vBounds.xy, vBounds.zw - vTexCoord);\nstep = smoothstep(thickness, thickness + buffer, distance);\ncolor.xyz = mix(uMajorColor, color.xyz, min(step.x, step.y));\ndistance = abs(vTexCoord - uZero);\nthickness = vec2(uZeroThickness) / uFaceSize;\nstep = smoothstep(thickness, thickness + buffer, distance);\ncolor.xyz = mix(uZeroColor, color.xyz, min(step.x, step.y));\nmyColor.w = 0.0;\nmyNormal.xyz = vNormal;\nmyNormal.w = 0.0;\nmyColor.xyz = color.xyz;\n}\n}\n",
    "pickgrid.vertex.fx": "#version 300 es\nin vec3 aPosition;\nin lowp vec4 aIdColor;\nin mediump vec2 aTexCoord;\nin mediump vec3 aNormal;\nin mediump vec4 aBounds;\nuniform mat4 uMMatrix;\nuniform mat4 uVMatrix;\nuniform mat4 uPMatrix;\nuniform bool uPick;\nuniform vec4 uPickedIdColor;\nuniform vec3 uBackground;\nuniform vec3 uHighlight;\nout lowp vec4 vColor;\nout mediump vec2 vTexCoord;\nout mediump vec4 vBounds;\nout mediump vec3 vNormal;\nout vec3 vViewPosition;\nvoid main(void) {\nmat4 mvMatrix = uVMatrix * uMMatrix;\nvNormal = normalize(vec3(mvMatrix * vec4(aNormal, 0.0)));\nvTexCoord = aTexCoord;\nvBounds = aBounds;\nvec4 viewPosition = mvMatrix * vec4(aPosition, 1.0);\nvViewPosition = viewPosition.xyz;\ngl_Position = uPMatrix * viewPosition;\nif (uPick)\n{\nvColor = aIdColor;\n}\nelse\n{\nvColor = uPickedIdColor == aIdColor ? vec4(uHighlight, 1.0) : vColor = vec4(uBackground, 1.0);\n}\n}\n",
    "sdftext.fragment.fx": "#version 300 es\n#ifdef GL_FRAGMENT_PRECISION_HIGH\nprecision highp float;\n#else\nprecision mediump float;\n#endif\nuniform sampler2D uSampler;\nuniform bool uPick;\nuniform vec3 uColor;\nuniform vec3 uHoverColor;\nuniform float uGamma;\nuniform vec3 uBorderColor;\nuniform float uBuffer;\nuniform float uBorderWidth;\nin mediump vec2 vTexCoord;\nin vec3 vViewPosition;\nin vec3 vNormal;\nin lowp vec4 vIdColor;\nin lowp float vHover;\nlayout(location = 0) out vec4 myPosition;\nlayout(location = 1) out vec4 myColor;\nlayout(location = 2) out vec4 myNormal;\nvoid main(void)\n{\nif (uPick) {\nmyPosition = vIdColor;\n}\nelse\n{\nfloat distance = texture(uSampler, vTexCoord).r;\nif (distance < uBuffer - uBorderWidth)\n{\ndiscard;\n}\nfloat gamma = fwidth(distance);\nfloat value = smoothstep(uBuffer - gamma, uBuffer + gamma, distance);\nmyColor.xyz = mix(uBorderColor, mix(uColor, uHoverColor, vHover), value);\nmyPosition.xyz = vViewPosition;\nmyNormal.xyz = vNormal;\nmyColor.w = 1.0;\nmyPosition.w = 0.0;\nmyNormal.w = 0.0;\n}\n}\n",
    "sdftext.vertex.fx": "#version 300 es\nin lowp vec4 aIdColor;\nin vec3 aPosition;\nin mediump vec2 aTexCoord;\nuniform mat4 uMMatrix;\nuniform mat4 uVMatrix;\nuniform mat4 uPMatrix;\nuniform vec4 uPickedIdColor;\nout vec3 vViewPosition;\nout vec3 vNormal;\nout mediump vec2 vTexCoord;\nout lowp vec4 vIdColor;\nout lowp float vHover;\nvoid main(void)\n{\nmat4 mvMatrix = uVMatrix * uMMatrix;\nvNormal = vec3(mvMatrix * vec4(0.0, 0.0, 1.0, 0.0));\nvec4 viewPosition = mvMatrix* vec4(aPosition, 1.0);\nvViewPosition = viewPosition.xyz;\ngl_Position = uPMatrix * viewPosition;\nvTexCoord = aTexCoord;\nvIdColor = aIdColor;\nvHover = uPickedIdColor == aIdColor ? 1.0 : 0.0;\n}\n",
    "simple.vertex.fx": "#version 300 es\nin vec3 aPosition;\nvoid main(void) {\ngl_Position = vec4(aPosition, 1.0);\n}\n",
    "ssao.fragment.fx": "#version 300 es\n#ifdef GL_FRAGMENT_PRECISION_HIGH\nprecision highp float;\n#else\nprecision mediump float;\n#endif\nconst int SSAO_KERNEL_SIZE = 8;\nuniform sampler2D uSampler1;\nuniform sampler2D uSampler2;\nuniform sampler2D uSampler3;\nuniform mat4 uPMatrix;\nuniform vec4 uViewport;\nuniform float uSsaoNoiseSize;\nuniform float uSsaoRadius;\nuniform float uSsaoPower;\nuniform vec3 uSsaoKernel[SSAO_KERNEL_SIZE];\nout vec4 myOutputColor;\nvoid main(void)\n{\nvec2 texCoords = (gl_FragCoord.xy - uViewport.xy) / uViewport.zw;\nvec3 position = texture(uSampler1, texCoords).rgb;\nvec3 normal = texture(uSampler2, texCoords).rgb;\nfloat occlusion = 0.0;\nvec2 noiseScale = uViewport.zw / uSsaoNoiseSize;\nvec3 randomVec = texture(uSampler3, texCoords * noiseScale).rgb;\nvec3 tangent = normalize(randomVec - normal * dot(randomVec, normal));\nvec3 bitangent = cross(normal, tangent);\nmat3 tbn = mat3(tangent, bitangent, normal);\nfor(int i = 0; i < SSAO_KERNEL_SIZE; i++)\n{\nvec3 mySample = tbn * uSsaoKernel[i];\nmySample = position + mySample * uSsaoRadius;\nvec4 offset = vec4(mySample, 1.0);\noffset = uPMatrix * offset;\noffset.xy /= offset.w;\noffset.xy = offset.xy * 0.5 + 0.5;\nfloat sampleDepth = texture(uSampler1, offset.xy).z;\nfloat rangeCheck = abs(position.z - sampleDepth) > uSsaoRadius ? 0.0 : 1.0;\nocclusion += (sampleDepth < mySample.z ? 0.0 : 1.0) * rangeCheck;\n}\nocclusion /= float(SSAO_KERNEL_SIZE);\nocclusion = pow(1.0 - occlusion, uSsaoPower);\nmyOutputColor = vec4(occlusion, 0.0, 0.0, 1.0);\n}\n",
    "texture.fragment.fx": "#version 300 es\n#ifdef GL_FRAGMENT_PRECISION_HIGH\nprecision highp float;\n#else\nprecision mediump float;\n#endif\n#include \"common.include.fx\"\nuniform sampler2D uSampler;\nin mediump vec2 vTexCoord;\nin vec3 vViewPosition;\nin vec3 vNormal;\nlayout(location = 0) out vec4 myPosition;\nlayout(location = 1) out vec4 myColor;\nlayout(location = 2) out vec4 myNormal;\nvoid main(void)\n{\nmyPosition.xyz = vViewPosition;\nmyColor.xyz = pow(texture(uSampler, vTexCoord).xyz, INV_GAMMA);\nmyColor.w = 0.0;\nmyNormal.xyz = vNormal;\nmyNormal.w = 0.0;\n}\n",
    "texture.vertex.fx": "#version 300 es\nin vec3 aPosition;\nin mediump vec3 aNormal;\nin mediump vec2 aTexCoord;\nuniform mat4 uMMatrix;\nuniform mat4 uVMatrix;\nuniform mat4 uPMatrix;\nout vec3 vViewPosition;\nout mediump vec3 vNormal;\nout mediump vec2 vTexCoord;\nvoid main(void)\n{\nmat4 mvMatrix = uVMatrix * uMMatrix;\nvNormal = normalize((mvMatrix * vec4(aNormal, 0.0)).xyz);\nvec4 viewPosition = mvMatrix * vec4(aPosition, 1.0);\nvViewPosition = viewPosition.xyz;\ngl_Position = uPMatrix * viewPosition;\nvTexCoord = aTexCoord;\n}\n",
    "unitblock.fragment.fx": "#version 300 es\n#ifdef GL_FRAGMENT_PRECISION_HIGH\nprecision highp float;\n#else\nprecision mediump float;\n#endif\n#include \"common.include.fx\"\n#include \"intersect.include.fx\"\nin lowp vec4 vIdColor;\nin lowp vec2 vVertexColor;\nin lowp float vVertexSelected;\nin float vAnimation;\nin lowp float vHover;\nin lowp float vActive;\nin mediump vec3 vModelPosition;\nin vec3 vViewPosition;\nuniform sampler2D uSampler;\nuniform sampler2D uPreviousSampler;\nuniform bool uPick;\nlayout(location = 0) out vec4 myPosition;\nlayout(location = 1) out vec4 myColor;\nlayout(location = 2) out vec4 myNormal;\nvoid main(void)\n{\nif (uPick)\n{\nmyPosition = vIdColor;\n}\nelse\n{\nmyPosition.xyz = vViewPosition;\nvec3 previousColor = texture(uPreviousSampler, vec2(vVertexColor.y, 0.0)).xyz;\nvec3 color = texture(uSampler, vec2(vVertexColor.x, 0.0)).xyz;\ncolor = mix(previousColor, color, vAnimation);\nfloat distanceSquared = (0.75 - dot2(vModelPosition)) * 2.0;\nfloat emissive = max(vVertexSelected, 0.0);\nemissive += max(vHover, vActive);\nemissive *= distanceSquared;\nmyColor.w = emissive;\nmyPosition.w = emissive;\nvec3 normal = normalize(cross(dFdx(vViewPosition), dFdy(vViewPosition)));\nmyNormal.xyz = normal;\nfloat specular = 1.0;\nmyNormal.w = specular;\nmyColor.xyz = color;\n}\n}\n",
    "unitblock.vertex.fx": "#version 300 es\n#include \"quat.include.fx\"\nin mediump vec3 aPosition;\nin vec3 aTranslation;\nin vec3 aPreviousTranslation;\nin mediump vec4 aRotation;\nin mediump vec4 aPreviousRotation;\nin lowp vec2 aColor;\nin lowp vec2 aPreviousColor;\nin vec3 aScale;\nin vec3 aPreviousScale;\nin vec2 aOrder;\nin float aId;\nin lowp float aSelected;\nin lowp float aPreviousSelected;\nin lowp vec4 aIdColor;\nuniform mat4 uMMatrix;\nuniform mat4 uVMatrix;\nuniform mat4 uPMatrix;\nuniform float uTime;\nuniform float uDuration;\nuniform float uOrderFrom;\nuniform float uOrderTo;\nuniform float uHover;\nuniform float uActive;\nout lowp vec4 vIdColor;\nout lowp vec2 vVertexColor;\nout lowp float vVertexSelected;\nout highp float vAnimation;\nout lowp float vHover;\nout lowp float vActive;\nout mediump vec3 vModelPosition;\nout vec3 vViewPosition;\nvoid main(void)\n{\nif (aOrder.x < uOrderFrom || aOrder.x > uOrderTo)\n{\nvIdColor = vec4(0.0);\nvVertexColor = vec2(0.0);\nvVertexSelected = 0.0;\nvAnimation = 0.0;\nvHover = 0.0;\nvActive = 0.0;\nvModelPosition = vec3(0.0);\ngl_Position = vec4(0.0);\nvViewPosition = vec3(0.0);\n}\nelse\n{\nvIdColor = aIdColor;\nvModelPosition = aPosition;\nfloat staggerOrder = aOrder.y;\nfloat startTime = staggerOrder * (1.0 - uDuration);\nfloat animation = clamp((uTime - startTime) / uDuration, 0.0, 1.0);\nanimation = smoothstep(0.0, 1.0, animation);\nvec3 scale = mix(aPreviousScale, aScale, animation);\nvec3 position = aPosition * scale;\nif (aRotation.w * aPreviousRotation.w != 1.0)\n{\nvec4 quat = slerp(aPreviousRotation, aRotation, animation);\nposition = rotate(position, quat);\n}\nposition += mix(aPreviousTranslation, aTranslation, animation);\nmat4 mvMatrix = uVMatrix * uMMatrix;\nvec4 viewPosition = mvMatrix * vec4(position, 1.0);\nvViewPosition = viewPosition.xyz;\ngl_Position = uPMatrix * viewPosition;\nvVertexColor = aPosition.y < 0.0 ? vec2(aColor.x, aPreviousColor.x) : vec2(aColor.y, aPreviousColor.y);\nvVertexSelected = mix(aPreviousSelected, aSelected, animation);\nvAnimation = animation;\nvHover = uHover == aId ? 1.0 : 0.0;\nvActive = uActive == aId ? 1.0 : 0.0;\n}\n}\n",
    "unitcylinder.fragment.fx": "#version 300 es\n#ifdef GL_FRAGMENT_PRECISION_HIGH\nprecision highp float;\n#else\nprecision mediump float;\n#endif\n#include \"common.include.fx\"\n#include \"intersect.include.fx\"\nin lowp vec4 vIdColor;\nin lowp vec2 vVertexColor;\nin lowp float vVertexSelected;\nin float vAnimation;\nin lowp float vHover;\nin lowp float vActive;\nin vec3 vViewPosition;\nin vec4 vCircle1;\nin vec4 vCircle2;\nuniform sampler2D uSampler;\nuniform sampler2D uPreviousSampler;\nuniform bool uPick;\nuniform bool uShadow;\nlayout(location = 0) out vec4 myPosition;\nlayout(location = 1) out vec4 myColor;\nlayout(location = 2) out vec4 myNormal;\nvoid main(void)\n{\nvec3 rd = normalize(vViewPosition);\nvec3 ro = vec3(0.0);\nvec4 tnor = iCappedCone(ro, rd, vCircle1.xyz, vCircle2.xyz, vCircle1.w, vCircle2.w, uShadow ? -1.0 : 1.0);\nfloat t = tnor.x;\nif (t < 0.0)\n{\ndiscard;\n}\nvec3 viewPosition = rd * t;\nfloat ndcDepth = DEPTH_A + DEPTH_B / viewPosition.z;\ngl_FragDepth = ndcDepth * 0.5 + 0.5;\nif (uPick)\n{\nmyPosition = vIdColor;\n}\nelse\n{\nmyPosition.xyz = viewPosition;\nvec3 previousColor = texture(uPreviousSampler, vec2(vVertexColor.y, 0.0)).xyz;\nvec3 color = texture(uSampler, vec2(vVertexColor.x, 0.0)).xyz;\ncolor = mix(previousColor, color, vAnimation);\nvec3 normal = tnor.yzw;\nmyNormal.xyz = normal;\nfloat distanceSquared = dot(normal, rd);\ndistanceSquared *= distanceSquared;\nfloat emissive = max(vVertexSelected, 0.0);\nemissive += max(vHover, vActive);\nemissive *= distanceSquared;\nmyColor.w = emissive;\nmyPosition.w = emissive;\nfloat specular = 1.0;\nmyNormal.w = specular;\nmyColor.xyz = color;\n}\n}\n",
    "unitcylinder.vertex.fx": "#version 300 es\n#include \"common.include.fx\"\n#include \"quat.include.fx\"\nin mediump vec3 aPosition;\nin vec3 aTranslation;\nin vec3 aPreviousTranslation;\nin mediump vec4 aRotation;\nin mediump vec4 aPreviousRotation;\nin lowp vec2 aColor;\nin lowp vec2 aPreviousColor;\nin vec3 aScale;\nin vec3 aPreviousScale;\nin float aId;\nin vec2 aOrder;\nin lowp float aSelected;\nin lowp float aPreviousSelected;\nin lowp vec4 aIdColor;\nuniform mat4 uMMatrix;\nuniform mat4 uVMatrix;\nuniform mat4 uPMatrix;\nuniform float uTime;\nuniform float uDuration;\nuniform float uOrderFrom;\nuniform float uOrderTo;\nuniform float uHover;\nuniform float uActive;\nuniform vec3 uIdentityRotation;\nout lowp vec4 vIdColor;\nout lowp vec2 vVertexColor;\nout lowp float vVertexSelected;\nout highp float vAnimation;\nout lowp float vHover;\nout lowp float vActive;\nout vec3 vViewPosition;\nout vec4 vCircle1;\nout vec4 vCircle2;\nvoid main(void)\n{\nif (aOrder.x < uOrderFrom || aOrder.x > uOrderTo)\n{\nvIdColor = vec4(0.0);\nvVertexColor = vec2(0.0);\nvVertexSelected = 0.0;\nvAnimation = 0.0;\nvHover = 0.0;\nvActive = 0.0;\nvViewPosition = vec3(0.0);\nvCircle1 = vec4(0.0);\nvCircle2 = vec4(0.0);\ngl_Position = vec4(0.0);\n}\nelse\n{\nvIdColor = aIdColor;\nfloat staggerOrder = aOrder.y;\nfloat startTime = staggerOrder * (1.0 - uDuration);\nfloat animation = clamp((uTime - startTime) / uDuration, 0.0, 1.0);\nanimation = smoothstep(0.0, 1.0, animation);\nvec3 translation = mix(aPreviousTranslation, aTranslation, animation);\nmat4 mvMatrix = uVMatrix * uMMatrix;\nvec3 viewCenter = (mvMatrix * vec4(translation, 1.0)).xyz;\nvec3 scale = mix(aPreviousScale, aScale, animation);\nvec3 position = aPosition;\nposition.xz *= max(scale.x, scale.z);\nposition.y *= scale.y;\nvec3 direction = IDENTITY_ROTATION;\nif (aRotation.w * aPreviousRotation.w != 1.0)\n{\nvec4 quat = slerp(aPreviousRotation, aRotation, animation);\nposition = rotate(position, quat);\ndirection = rotate(direction, quat);\n}\nvec3 viewDirection = (mvMatrix * vec4(direction, 0.0)).xyz;\nvec3 h = viewDirection * scale.y * 0.5;\nfloat r1 = length(viewDirection) * 0.5;\nfloat r2 = r1 * scale.z;\nr1 *= scale.x;\nvCircle1 = vec4(viewCenter - h, r1);\nvCircle2 = vec4(viewCenter + h, r2);\nvec4 viewPosition = mvMatrix * vec4(position + translation, 1.0);\nvViewPosition = viewPosition.xyz;\ngl_Position = uPMatrix * viewPosition;\nvVertexColor = aPosition.y < 0.0 ? vec2(aColor.x, aPreviousColor.x) : vec2(aColor.y, aPreviousColor.y);\nvVertexSelected = mix(aPreviousSelected, aSelected, animation);\nvAnimation = animation;\nvHover = uHover == aId ? 1.0 : 0.0;\nvActive = uActive == aId ? 1.0 : 0.0;\n}\n}\n",
    "unitsdf.fragment.fx": "#version 300 es\n#ifdef GL_FRAGMENT_PRECISION_HIGH\nprecision highp float;\n#else\nprecision mediump float;\n#endif\n#include \"common.include.fx\"\n#include \"intersect.include.fx\"\nin lowp vec4 vIdColor;\nin lowp vec2 vVertexColor;\nin lowp float vVertexSelected;\nin float vAnimation;\nin lowp float vHover;\nin lowp float vActive;\nin mediump vec2 vTexCoord;\nin mediump vec2 vPreviousTexCoord;\nin mediump vec3 vModelPosition;\nin vec3 vViewPosition;\nuniform sampler2D uSampler;\nuniform sampler2D uPreviousSampler;\nuniform sampler2D uSampler1;\nuniform sampler2D uPreviousSampler1;\nuniform bool uPick;\nlayout(location = 0) out vec4 myPosition;\nlayout(location = 1) out vec4 myColor;\nlayout(location = 2) out vec4 myNormal;\nvoid main(void)\n{\nfloat uBorderWidth = 0.0 / 255.0;\nfloat uBuffer = 192.0 / 255.0;\nvec3 uBorderColor = vec3(1.0, 1.0, 1.0);\nfloat distance = mix(texture(uPreviousSampler1, vPreviousTexCoord).r, texture(uSampler1, vTexCoord).r, vAnimation);\nif (distance < uBuffer - uBorderWidth) {\ndiscard;\n}\nif (uPick)\n{\nmyPosition = vIdColor;\n}\nelse\n{\nmyPosition.xyz = vViewPosition;\nvec3 previousColor = texture(uPreviousSampler, vec2(vVertexColor.y, 0.0)).xyz;\nvec3 color = texture(uSampler, vec2(vVertexColor.x, 0.0)).xyz;\ncolor = mix(previousColor, color, vAnimation);\nfloat distanceSquared = (0.75 - dot2(vModelPosition)) * 2.0;\nfloat emissive = max(vVertexSelected, 0.0);\nemissive += max(vHover, vActive);\nemissive *= distanceSquared;\nmyColor.w = emissive;\nmyPosition.w = emissive;\nvec3 normal = normalize(cross(dFdx(vViewPosition), dFdy(vViewPosition)));\nmyNormal.xyz = normal;\nfloat specular = 1.0;\nmyNormal.w = specular;\nvec3 uBorderColor = vec3(1.0, 1.0, 1.0);\nfloat uGamma = 0.0;\nfloat gamma = fwidth(distance);\nfloat value = smoothstep(uBuffer - gamma, uBuffer + gamma, distance);\nmyColor.xyz = mix(uBorderColor, color, value);\n}\n}\n",
    "unitsdf.vertex.fx": "#version 300 es\n#include \"quat.include.fx\"\nin mediump vec3 aPosition;\nin vec3 aTranslation;\nin vec3 aPreviousTranslation;\nin mediump vec4 aRotation;\nin mediump vec4 aPreviousRotation;\nin mediump vec4 aTexCoord;\nin mediump vec4 aPreviousTexCoord;\nin lowp vec2 aColor;\nin lowp vec2 aPreviousColor;\nin vec3 aScale;\nin vec3 aPreviousScale;\nin vec2 aOrder;\nin float aId;\nin lowp float aSelected;\nin lowp float aPreviousSelected;\nin lowp vec4 aIdColor;\nuniform mat4 uMMatrix;\nuniform mat4 uVMatrix;\nuniform mat4 uPMatrix;\nuniform float uTime;\nuniform float uDuration;\nuniform float uOrderFrom;\nuniform float uOrderTo;\nuniform float uHover;\nuniform float uActive;\nout lowp vec4 vIdColor;\nout lowp vec2 vVertexColor;\nout lowp float vVertexSelected;\nout highp float vAnimation;\nout lowp float vHover;\nout lowp float vActive;\nout mediump vec3 vModelPosition;\nout mediump vec2 vTexCoord;\nout mediump vec2 vPreviousTexCoord;\nout vec3 vViewPosition;\nvoid main(void)\n{\nif (aOrder.x < uOrderFrom || aOrder.x > uOrderTo)\n{\nvIdColor = vec4(0.0);\nvVertexColor = vec2(0.0);\nvVertexSelected = 0.0;\nvAnimation = 0.0;\nvHover = 0.0;\nvActive = 0.0;\nvModelPosition = vec3(0.0);\ngl_Position = vec4(0.0);\nvViewPosition = vec3(0.0);\n}\nelse\n{\nvIdColor = aIdColor;\nvModelPosition = aPosition;\nfloat staggerOrder = aOrder.y;\nfloat startTime = staggerOrder * (1.0 - uDuration);\nfloat animation = clamp((uTime - startTime) / uDuration, 0.0, 1.0);\nanimation = smoothstep(0.0, 1.0, animation);\nvec3 scale = mix(aPreviousScale, aScale, animation);\nvec3 position = aPosition * scale;\nif (aRotation.w * aPreviousRotation.w != 1.0)\n{\nvec4 quat = slerp(aPreviousRotation, aRotation, animation);\nposition = rotate(position, quat);\n}\nposition += mix(aPreviousTranslation, aTranslation, animation);\nmat4 mvMatrix = uVMatrix * uMMatrix;\nvec4 viewPosition = mvMatrix * vec4(position, 1.0);\nvViewPosition = viewPosition.xyz;\ngl_Position = uPMatrix * viewPosition;\nvVertexColor = aPosition.y < 0.0 ? vec2(aColor.x, aPreviousColor.x) : vec2(aColor.y, aPreviousColor.y);\nvVertexSelected = mix(aPreviousSelected, aSelected, animation);\nvAnimation = animation;\nvHover = uHover == aId ? 1.0 : 0.0;\nvActive = uActive == aId ? 1.0 : 0.0;\nvPreviousTexCoord.x = aPosition.x < 0.0 ? aPreviousTexCoord.x : aPreviousTexCoord.z;\nvPreviousTexCoord.y = aPosition.y > 0.0 ? aPreviousTexCoord.y : aPreviousTexCoord.w;\nvTexCoord.x = aPosition.x < 0.0 ? aTexCoord.x : aTexCoord.z;\nvTexCoord.y = aPosition.y > 0.0 ? aTexCoord.y : aTexCoord.w;\n}\n}\n",
    "unitsphere.fragment.fx": "#version 300 es\n#ifdef GL_FRAGMENT_PRECISION_HIGH\nprecision highp float;\n#else\nprecision mediump float;\n#endif\n#include \"common.include.fx\"\n#include \"intersect.include.fx\"\nin lowp vec4 vIdColor;\nin lowp vec2 vVertexColor;\nin lowp float vVertexSelected;\nin float vAnimation;\nin lowp float vHover;\nin lowp float vActive;\nin vec3 vViewPosition;\nin vec3 vViewCenter;\nin mediump float vRadius;\nuniform sampler2D uSampler;\nuniform sampler2D uPreviousSampler;\nuniform bool uPick;\nuniform bool uShadow;\nlayout(location = 0) out vec4 myPosition;\nlayout(location = 1) out vec4 myColor;\nlayout(location = 2) out vec4 myNormal;\nvoid main(void)\n{\nvec3 rd = normalize(vViewPosition);\nvec3 ro = vec3(0.0);\nvec4 s = vec4(vViewCenter, vRadius);\nfloat t = sphIntersect(ro, rd, s, uShadow ? -1.0 : 1.0);\nif (t < 0.0)\n{\ndiscard;\n}\nvec3 viewPosition = rd * t;\nfloat ndcDepth = DEPTH_A + DEPTH_B / viewPosition.z;\ngl_FragDepth = ndcDepth * 0.5 + 0.5;\nif (uPick)\n{\nmyPosition = vIdColor;\n}\nelse\n{\nmyPosition.xyz = viewPosition;\nvec3 previousColor = texture(uPreviousSampler, vec2(vVertexColor.y, 0.0)).xyz;\nvec3 color = texture(uSampler, vec2(vVertexColor.x, 0.0)).xyz;\ncolor = mix(previousColor, color, vAnimation);\nvec3 normal = (viewPosition - vViewCenter) / s.w;\nmyNormal.xyz = normal;\nfloat distanceSquared = dot(normal, rd);\ndistanceSquared *= distanceSquared;\nfloat emissive = max(vVertexSelected, 0.0);\nemissive += max(vHover, vActive);\nemissive *= distanceSquared;\nmyColor.w = emissive;\nmyPosition.w = emissive;\nfloat specular = 1.0;\nmyNormal.w = specular;\nmyColor.xyz = color;\n}\n}\n",
    "unitsphere.vertex.fx": "#version 300 es\n#include \"common.include.fx\"\nin mediump vec3 aPosition;\nin vec3 aTranslation;\nin vec3 aPreviousTranslation;\nin lowp float aColor;\nin lowp float aPreviousColor;\nin vec3 aScale;\nin vec3 aPreviousScale;\nin float aId;\nin vec2 aOrder;\nin lowp float aSelected;\nin lowp float aPreviousSelected;\nin lowp vec4 aIdColor;\nuniform mat4 uMMatrix;\nuniform mat4 uVMatrix;\nuniform mat4 uPMatrix;\nuniform float uTime;\nuniform float uDuration;\nuniform float uOrderFrom;\nuniform float uOrderTo;\nuniform float uHover;\nuniform float uActive;\nout lowp vec4 vIdColor;\nout lowp vec2 vVertexColor;\nout lowp float vVertexSelected;\nout highp float vAnimation;\nout lowp float vHover;\nout lowp float vActive;\nout mediump float vRadius;\nout vec3 vViewPosition;\nout vec3 vViewCenter;\nvoid main(void)\n{\nif (aOrder.x < uOrderFrom || aOrder.x > uOrderTo)\n{\nvIdColor = vec4(0.0);\nvVertexColor = vec2(0.0);\nvVertexSelected = 0.0;\nvAnimation = 0.0;\nvHover = 0.0;\nvActive = 0.0;\nvViewPosition = vec3(0.0);\nvViewCenter = vec3(0.0);\nvRadius = 0.0;\ngl_Position = vec4(0.0);\n}\nelse\n{\nvIdColor = aIdColor;\nfloat staggerOrder = aOrder.y;\nfloat startTime = staggerOrder * (1.0 - uDuration);\nfloat animation = clamp((uTime - startTime) / uDuration, 0.0, 1.0);\nanimation = smoothstep(0.0, 1.0, animation);\nfloat scale = mix(min(aPreviousScale.x, min(aPreviousScale.y, aPreviousScale.z)), min(aScale.x, min(aScale.y, aScale.z)), animation);\nvec3 translation = mix(aPreviousTranslation, aTranslation, animation);\nmat4 mvMatrix = uVMatrix * uMMatrix;\nvViewCenter = (mvMatrix * vec4(translation, 1.0)).xyz;\ntranslation.xyz += aPosition * scale;\nvec4 viewPosition = mvMatrix * vec4(translation, 1.0);\nvViewPosition = viewPosition.xyz;\ngl_Position = uPMatrix * viewPosition;\nvVertexColor = vec2(aColor, aPreviousColor);\nvVertexSelected = mix(aPreviousSelected, aSelected, animation);\nvAnimation = animation;\nvHover = uHover == aId ? 1.0 : 0.0;\nvActive = uActive == aId ? 1.0 : 0.0;\nvRadius = distance(vViewPosition, vViewCenter) / ROOT_THREE;\n}\n}\n",
    "common.include.fx": "const float NEAR_PLANE = 0.01;\nconst float FAR_PLANE = 100.0;\nconst float DEPTH_A = 1.0002000200020003;\nconst float DEPTH_B = 0.020002000200020003;\nconst vec3 GAMMA = vec3(0.45454545454545453);\nconst vec3 INV_GAMMA = vec3(2.2);\nconst vec3 LUMINANCE = vec3(0.2126, 0.7152, 0.0722);\nconst float PI = 3.1415926538;\nconst float ROOT_TWO = 1.4142135624;\nconst float ROOT_TWO_OVER_TWO = 0.7071067811865476;\nconst float ROOT_THREE = 1.7320508075688772;\nconst float ROOT_THREE_OVER_TWO = 0.8660254037844386;\nconst vec3 IDENTITY_ROTATION = vec3(0.0, 1.0, 0.0);\nfloat dot2(in vec2 v) { return dot(v, v); }\nfloat dot2(in vec3 v) { return dot(v, v); }\n",
    "intersect.include.fx": "float sphIntersect( in vec3 ro, in vec3 rd, in vec4 sph, in float shadow)\n{\nvec3 oc = ro - sph.xyz;\nfloat b = dot( oc, rd );\nfloat c = dot( oc, oc ) - sph.w*sph.w;\nfloat h = b*b - c;\nif( h<0.0 ) return -1.0;\nreturn -b - shadow * sqrt( h );\n}\nfloat roundedboxIntersect( in vec3 ro, in vec3 rd, in vec3 size, in float rad )\n{\nvec3 m = 1.0/rd;\nvec3 n = m*ro;\nvec3 k = abs(m)*(size+rad);\nvec3 t1 = -n - k;\nvec3 t2 = -n + k;\nfloat tN = max( max( t1.x, t1.y ), t1.z );\nfloat tF = min( min( t2.x, t2.y ), t2.z );\nif( tN > tF || tF < 0.0) return -1.0;\nfloat t = tN;\nvec3 pos = ro+t*rd;\nvec3 s = sign(pos);\nro *= s;\nrd *= s;\npos *= s;\npos -= size;\npos = max( pos.xyz, pos.yzx );\nif( min(min(pos.x,pos.y),pos.z)<0.0 ) return t;\nvec3 oc = ro - size;\nvec3 dd = rd*rd;\nvec3 oo = oc*oc;\nvec3 od = oc*rd;\nfloat ra2 = rad*rad;\nt = 1e20;\n{\nfloat b = od.x + od.y + od.z;\nfloat c = oo.x + oo.y + oo.z - ra2;\nfloat h = b*b - c;\nif( h>0.0 ) t = -b-sqrt(h);\n}\n{\nfloat a = dd.y + dd.z;\nfloat b = od.y + od.z;\nfloat c = oo.y + oo.z - ra2;\nfloat h = b*b - a*c;\nif( h>0.0 )\n{\nh = (-b-sqrt(h))/a;\nif( h>0.0 && h<t && abs(ro.x+rd.x*h)<size.x ) t = h;\n}\n}\n{\nfloat a = dd.z + dd.x;\nfloat b = od.z + od.x;\nfloat c = oo.z + oo.x - ra2;\nfloat h = b*b - a*c;\nif( h>0.0 )\n{\nh = (-b-sqrt(h))/a;\nif( h>0.0 && h<t && abs(ro.y+rd.y*h)<size.y ) t = h;\n}\n}\n{\nfloat a = dd.x + dd.y;\nfloat b = od.x + od.y;\nfloat c = oo.x + oo.y - ra2;\nfloat h = b*b - a*c;\nif( h>0.0 )\n{\nh = (-b-sqrt(h))/a;\nif( h>0.0 && h<t && abs(ro.z+rd.z*h)<size.z ) t = h;\n}\n}\nif( t>1e19 ) t=-1.0;\nreturn t;\n}\nvec3 roundedboxNormal( in vec3 pos, in vec3 siz, in float rad )\n{\nreturn sign(pos)*normalize(max(abs(pos)-siz,0.0));\n}\nvec4 iCappedCone(in vec3 ro, in vec3 rd,\nin vec3 pa, in vec3 pb,\nin float ra, in float rb, in float shadow)\n{\nvec3 ba = pb - pa;\nvec3 oa = ro - pa;\nvec3 ob = ro - pb;\nfloat m0 = dot(ba, ba);\nfloat m1 = dot(oa, ba);\nfloat m2 = dot(ob, ba);\nfloat m3 = dot(rd, ba);\nif (m1 < 0.0) { if (dot2(oa * m3 - rd * m1) < (ra * ra * m3 * m3)) return vec4(-m1 / m3, -ba * inversesqrt(m0)); }\nelse if (m2 > 0.0) { if (dot2(ob * m3 - rd * m2) < (rb * rb * m3 * m3)) return vec4(-m2 / m3, ba * inversesqrt(m0)); }\nfloat m4 = dot(rd, oa);\nfloat m5 = dot(oa, oa);\nfloat rr = ra - rb;\nfloat hy = m0 + rr * rr;\nfloat k2 = m0 * m0 - m3 * m3 * hy;\nfloat k1 = m0 * m0 * m4 - m1 * m3 * hy + m0 * ra * (rr * m3 * 1.0);\nfloat k0 = m0 * m0 * m5 - m1 * m1 * hy + m0 * ra * (rr * m1 * 2.0 - m0 * ra);\nfloat h = k1 * k1 - k2 * k0;\nif (h < 0.0) return vec4(-1.0);\nfloat t = (-k1 - shadow * sqrt(h)) / k2;\nfloat y = m1 + t * m3;\nif (y > 0.0 && y < m0)\n{\nreturn vec4(t, normalize(m0 * (m0 * (oa + t * rd) + rr * ba * ra) - ba * hy * y));\n}\nreturn vec4(-1.0);\n}\nvec4 iRoundedCone(in vec3 ro, in vec3 rd,\nin vec3 pa, in vec3 pb,\nin float ra, in float rb, in float shadow)\n{\nvec3 ba = pb - pa;\nvec3 oa = ro - pa;\nvec3 ob = ro - pb;\nfloat rr = ra - rb;\nfloat m0 = dot(ba, ba);\nfloat m1 = dot(ba, oa);\nfloat m2 = dot(ba, rd);\nfloat m3 = dot(rd, oa);\nfloat m5 = dot(oa, oa);\nfloat m6 = dot(ob, rd);\nfloat m7 = dot(ob, ob);\nfloat d2 = m0 - rr * rr;\nfloat k2 = d2 - m2 * m2;\nfloat k1 = d2 * m3 - m1 * m2 + m2 * rr * ra;\nfloat k0 = d2 * m5 - m1 * m1 + m1 * rr * ra * 2.0 - m0 * ra * ra;\nfloat h = k1 * k1 - k0 * k2;\nif (h < 0.0) return vec4(-1.0);\nfloat t = (-shadow * sqrt(h) - k1) / k2;\nfloat y = m1 - ra * rr + t * m2;\nif (y > 0.0 && y < d2)\n{\nreturn vec4(t, normalize(d2 * (oa + t * rd) - ba * y));\n}\nfloat h1 = m3 * m3 - m5 + ra * ra;\nfloat h2 = m6 * m6 - m7 + rb * rb;\nif (max(h1, h2) < 0.0) return vec4(-1.0);\nvec4 r = vec4(1e20);\nif (h1 > 0.0)\n{\nt = -m3 - shadow * sqrt( h1 );\nr = vec4(t, (oa + t * rd) / ra);\n}\nif (h2 > 0.0)\n{\nt = -m6 - shadow * sqrt( h2 );\nif (t < r.x)\nr = vec4(t, (ob + t * rd) / rb);\n}\nreturn r;\n}\n",
    "quat.include.fx": "const float EPSILON = 0.000001;\nmat3 fromQuat(in vec4 q) {\nfloat x = q.x;\nfloat y = q.y;\nfloat z = q.z;\nfloat w = q.w;\nfloat x2 = x + x;\nfloat y2 = y + y;\nfloat z2 = z + z;\nfloat xx = x * x2;\nfloat yx = y * x2;\nfloat yy = y * y2;\nfloat zx = z * x2;\nfloat zy = z * y2;\nfloat zz = z * z2;\nfloat wx = w * x2;\nfloat wy = w * y2;\nfloat wz = w * z2;\nmat3 m;\nm[0][0] = 1.0 - yy - zz;\nm[0][1] = yx - wz;\nm[0][2] = zx + wy;\nm[1][0] = yx + wz;\nm[1][1] = 1.0 - xx - zz;\nm[1][2] = zy - wx;\nm[2][0] = zx - wy;\nm[2][1] = zy + wx;\nm[2][2] = 1.0 - xx - yy;\nreturn m;\n}\nvec3 rotate(in vec3 p, in vec4 q) {\nreturn p + 2.0 * cross(q.xyz, cross(q.xyz, p) + q.w * p);\n}\nvec4 slerp(in vec4 a, in vec4 b, in float t) {\nfloat cosom = dot(a, b);\nif (cosom < 0.0) {\ncosom = -cosom;\nb = -b;\n}\nfloat scale0, scale1;\nif (1.0 - cosom > EPSILON) {\nfloat omega = acos(cosom);\nfloat sinom = sin(omega);\nscale0 = sin((1.0 - t) * omega) / sinom;\nscale1 = sin(t * omega) / sinom;\n}\nelse {\nscale0 = 1.0 - t;\nscale1 = t;\n}\nreturn vec4(scale0 * a + scale1 * b);\n}\n"
};
class $a9df2cd8c496e87d$export$59a6ab026766925f {
    get isInitialized() {
        return this._isInitialized;
    }
    get vertexBuffer() {
        return this._vertexBuffer;
    }
    set vertexBuffer(value) {
        if (this._vertexBuffer != value) {
            this._vertexBuffer = value;
            this._haveBuffersChanged = true;
        }
    }
    get indexBuffer() {
        return this._indexBuffer;
    }
    set indexBuffer(value) {
        if (this._indexBuffer != value) {
            this._indexBuffer = value;
            this._haveBuffersChanged = true;
        }
    }
    constructor(core, main){
        this._core = core;
        this._main = main;
    }
    initializeContext(gl) {
        this._gl = gl;
    }
    _createProgram(vs, fs) {
        const program = this._gl.createProgram();
        this._gl.attachShader(program, vs);
        this._gl.attachShader(program, fs);
        this._gl.linkProgram(program);
        if (!this._gl.getProgramParameter(program, this._gl.LINK_STATUS)) this._core.log.write((0, $4a6417d29706362f$export$243e62d78d3b544d).error, this._gl.getProgramInfoLog(program));
        return program;
    }
    _compileShader(source, type) {
        const shader = this._gl.createShader(type);
        this._gl.shaderSource(shader, source);
        this._gl.compileShader(shader);
        if (!this._gl.getShaderParameter(shader, this._gl.COMPILE_STATUS)) this._core.log.write((0, $4a6417d29706362f$export$243e62d78d3b544d).error, this._gl.getShaderInfoLog(shader));
        return shader;
    }
    _removeDirective(shaderSource, directive) {
        const remove = `#define ${directive}`;
        const index = shaderSource.indexOf(remove);
        shaderSource = index == -1 ? shaderSource : shaderSource.substring(0, index) + shaderSource.substring(index + remove.length);
        return shaderSource;
    }
    prepare() {
        if (this._program != this._main.shaderResources.currentProgram) {
            if (this._main.shaderResources.currentShader) this._main.shaderResources.currentShader.disableProgram();
            this.enableProgram(this._program);
            this.updateBuffers();
            this.updateTextures();
        } else {
            if (this._haveBuffersChanged) this.updateBuffers();
            if (this._haveTexturesChanged) this.updateTextures();
        }
    }
    apply() {}
    applyModel() {}
    applyView() {}
    enableProgram(program) {
        this._gl.useProgram(program);
        this._main.shaderResources.currentProgram = program;
        this._main.shaderResources.currentShader = this;
    }
    updateBuffers() {
        this._haveBuffersChanged = false;
    }
    updateTextures() {
        this._haveTexturesChanged = false;
    }
    disableProgram() {
        this._main.shaderResources.currentShader = null;
        this._main.shaderResources.currentProgram = null;
    }
    _shaderFromFile(vsName, fsName, callback) {
        callback(this._includesFromFile($a9df2cd8c496e87d$export$e9a269813a6315a4.glsl[vsName]), this._includesFromFile($a9df2cd8c496e87d$export$e9a269813a6315a4.glsl[fsName]));
    }
    _shaderFromUrl(vsName, fsName, callback) {
        this._sourceFromUrl(vsName, (vsSource)=>{
            this._includesFromUrl(vsSource, 0, (vsIncSource)=>{
                this._sourceFromUrl(fsName, (fsSource)=>{
                    this._includesFromUrl(fsSource, 0, (fsIncSource)=>{
                        callback(vsIncSource, fsIncSource);
                    });
                });
            });
        });
    }
    _sourceFromUrl(url, callback) {
        const request = new XMLHttpRequest();
        request.open("GET", (0, $a4596fc55355f0e1$export$433e0478e7f6ca93).combine(this._core.config.shaderPath, url));
        request.onreadystatechange = ()=>{
            if (request.readyState == XMLHttpRequest.DONE && request.status == 200) callback(request.responseText);
        };
        request.send();
    }
    _includesFromFile(source) {
        let index = 0;
        do {
            index = source.indexOf("#include", index);
            if (index != -1) {
                const start = source.indexOf("\"", index);
                const end = source.indexOf("\"", start + 1);
                const name = source.substring(start + 1, end);
                const inc = $a9df2cd8c496e87d$export$e9a269813a6315a4.glsl[name];
                source = source.substring(0, index) + inc + source.substring(end + 1);
            }
        }while (index != -1);
        return source;
    }
    _includesFromUrl(source, index, callback) {
        index = source.indexOf("#include", index);
        if (index != -1) {
            const start = source.indexOf("\"", index);
            const end = source.indexOf("\"", start + 1);
            const name = source.substring(start + 1, end);
            this._sourceFromUrl((0, $a4596fc55355f0e1$export$433e0478e7f6ca93).combine("inc", name), (include)=>{
                source = source.substring(0, index) + include + source.substring(end + 1);
                this._includesFromUrl(source, index, callback);
            });
        } else callback(source);
    }
}


/*!
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 */ 

class $f429c522f972f41c$export$5431306cf43de24a extends (0, $a9df2cd8c496e87d$export$59a6ab026766925f) {
    get texture2D() {
        return this._texture2D;
    }
    set texture2D(value) {
        if (this._texture2D != value) {
            this._texture2D = value;
            this._haveTexturesChanged = true;
        }
    }
    initializeContext(gl) {
        super.initializeContext(gl);
        if (this._isLoaded) this._initializeShader(gl, this._vsSource, this._fsSource);
        else this._shaderFromFile("texture.vertex.fx", "texture.fragment.fx", (vsSource, fsSource)=>{
            this._vsSource = vsSource;
            this._fsSource = fsSource;
            this._isLoaded = true;
            this._initializeShader(gl, vsSource, fsSource);
        });
    }
    _initializeShader(gl, vsSource, fsSource) {
        const vs = this._compileShader(vsSource, gl.VERTEX_SHADER);
        const fs = this._compileShader(fsSource, gl.FRAGMENT_SHADER);
        this._program = this._createProgram(vs, fs);
        this._positionAttribute = gl.getAttribLocation(this._program, "aPosition");
        this._texCoordAttribute = gl.getAttribLocation(this._program, "aTexCoord");
        this._normalAttribute = gl.getAttribLocation(this._program, "aNormal");
        this._samplerUniform = gl.getUniformLocation(this._program, "uSampler");
        this._mMatrixUniform = gl.getUniformLocation(this._program, "uMMatrix");
        this._vMatrixUniform = gl.getUniformLocation(this._program, "uVMatrix");
        this._pMatrixUniform = gl.getUniformLocation(this._program, "uPMatrix");
        this._isInitialized = true;
    }
    apply() {
        this._gl.uniformMatrix4fv(this._mMatrixUniform, false, this.mMatrix);
        this._gl.uniform1i(this._samplerUniform, 0);
    }
    applyView() {
        this._gl.uniformMatrix4fv(this._vMatrixUniform, false, this.vMatrix);
        this._gl.uniformMatrix4fv(this._pMatrixUniform, false, this.pMatrix);
    }
    updateBuffers() {
        super.updateBuffers();
        this._gl.bindBuffer(this._gl.ARRAY_BUFFER, this._vertexBuffer);
        this._gl.vertexAttribPointer(this._positionAttribute, 3, this._gl.FLOAT, false, (0, $0a0587bd8b0d58e8$export$e40add16394b9bff).SIZE_BYTES, (0, $0a0587bd8b0d58e8$export$e40add16394b9bff).POSITION_OFFSET_BYTES);
        this._gl.enableVertexAttribArray(this._positionAttribute);
        this._gl.vertexAttribPointer(this._normalAttribute, 3, this._gl.BYTE, true, (0, $0a0587bd8b0d58e8$export$e40add16394b9bff).SIZE_BYTES, (0, $0a0587bd8b0d58e8$export$e40add16394b9bff).NORMAL_OFFSET_BYTES);
        this._gl.enableVertexAttribArray(this._normalAttribute);
        this._gl.vertexAttribPointer(this._texCoordAttribute, 2, this._gl.UNSIGNED_SHORT, true, (0, $0a0587bd8b0d58e8$export$e40add16394b9bff).SIZE_BYTES, (0, $0a0587bd8b0d58e8$export$e40add16394b9bff).TEX_COORD_OFFSET_BYTES);
        this._gl.enableVertexAttribArray(this._texCoordAttribute);
        this._gl.bindBuffer(this._gl.ELEMENT_ARRAY_BUFFER, this._indexBuffer);
    }
    updateTextures() {
        super.updateTextures();
        this._gl.activeTexture(this._gl.TEXTURE0);
        this._gl.bindTexture(this._gl.TEXTURE_2D, this._texture2D);
    }
}


/*!
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 */ 

class $07302b7e66b98ad4$export$dc8af347244861ce extends (0, $a9df2cd8c496e87d$export$59a6ab026766925f) {
    initializeContext(gl) {
        super.initializeContext(gl);
        if (this._isLoaded) this._initializeShader(gl, this._vsSource, this._fsSource);
        else this._shaderFromFile("lasso.vertex.fx", "lasso.fragment.fx", (vsSource, fsSource)=>{
            this._vsSource = vsSource;
            this._fsSource = fsSource;
            this._isLoaded = true;
            this._initializeShader(gl, vsSource, fsSource);
        });
    }
    _initializeShader(gl, vsSource, fsSource) {
        const vs = this._compileShader(vsSource, gl.VERTEX_SHADER);
        const fs = this._compileShader(fsSource, gl.FRAGMENT_SHADER);
        this._program = this._createProgram(vs, fs);
        this._positionAttribute = gl.getAttribLocation(this._program, "aPosition");
        this._texCoordAttribute = gl.getAttribLocation(this._program, "aTexCoord");
        this._mMatrixUniform = gl.getUniformLocation(this._program, "uMMatrix");
        this._colorUniform = gl.getUniformLocation(this._program, "uColor");
        this._thicknessUniform = gl.getUniformLocation(this._program, "uThickness");
        this._dashWidthUniform = gl.getUniformLocation(this._program, "uDashWidth");
        this._isInitialized = true;
    }
    apply() {
        this._gl.uniform3fv(this._colorUniform, this.color);
        this._gl.uniform1f(this._dashWidthUniform, this.dashWidth);
    }
    applyView() {
        this._gl.uniformMatrix4fv(this._mMatrixUniform, false, this.mMatrix);
        this._gl.uniform2fv(this._thicknessUniform, this.thickness);
    }
    updateBuffers() {
        super.updateBuffers();
        this._gl.bindBuffer(this._gl.ARRAY_BUFFER, this._vertexBuffer);
        this._gl.vertexAttribPointer(this._positionAttribute, 3, this._gl.FLOAT, false, (0, $0a0587bd8b0d58e8$export$538532535e0e8594).SIZE_BYTES, (0, $0a0587bd8b0d58e8$export$538532535e0e8594).POSITION_OFFSET_BYTES);
        this._gl.enableVertexAttribArray(this._positionAttribute);
        this._gl.vertexAttribPointer(this._texCoordAttribute, 2, this._gl.UNSIGNED_SHORT, true, (0, $0a0587bd8b0d58e8$export$538532535e0e8594).SIZE_BYTES, (0, $0a0587bd8b0d58e8$export$538532535e0e8594).TEX_COORD_OFFSET_BYTES);
        this._gl.enableVertexAttribArray(this._texCoordAttribute);
        this._gl.bindBuffer(this._gl.ELEMENT_ARRAY_BUFFER, this._indexBuffer);
    }
}


/*!
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 */ 

class $5096a2d574b69029$export$a3be0de02f08c3be extends (0, $a9df2cd8c496e87d$export$59a6ab026766925f) {
    get texture2D() {
        return this._texture2D;
    }
    set texture2D(value) {
        if (this._texture2D != value) {
            this._texture2D = value;
            this._haveTexturesChanged = true;
        }
    }
    initializeContext(gl) {
        super.initializeContext(gl);
        if (this._isLoaded) this._initializeShader(gl, this._vsSource, this._fsSource);
        else this._shaderFromFile("sdftext.vertex.fx", "sdftext.fragment.fx", (vsSource, fsSource)=>{
            this._vsSource = vsSource;
            this._fsSource = fsSource;
            this._isLoaded = true;
            this._initializeShader(gl, vsSource, fsSource);
        });
    }
    _initializeShader(gl, vsSource, fsSource) {
        const vs = this._compileShader(vsSource, gl.VERTEX_SHADER);
        const fs = this._compileShader(fsSource, gl.FRAGMENT_SHADER);
        this._program = this._createProgram(vs, fs);
        this._idColorAttribute = gl.getAttribLocation(this._program, "aIdColor");
        this._positionAttribute = gl.getAttribLocation(this._program, "aPosition");
        this._texCoordAttribute = gl.getAttribLocation(this._program, "aTexCoord");
        this._samplerUniform = gl.getUniformLocation(this._program, "uSampler");
        this._mMatrixUniform = gl.getUniformLocation(this._program, "uMMatrix");
        this._vMatrixUniform = gl.getUniformLocation(this._program, "uVMatrix");
        this._pMatrixUniform = gl.getUniformLocation(this._program, "uPMatrix");
        this._colorUniform = gl.getUniformLocation(this._program, "uColor");
        this._hoverColorUniform = gl.getUniformLocation(this._program, "uHoverColor");
        this._pickUniform = gl.getUniformLocation(this._program, "uPick");
        this._pickedIdColorUniform = gl.getUniformLocation(this._program, "uPickedIdColor");
        this._borderColorUniform = gl.getUniformLocation(this._program, "uBorderColor");
        this._bufferUniform = gl.getUniformLocation(this._program, "uBuffer");
        this._borderWidthUniform = gl.getUniformLocation(this._program, "uBorderWidth");
        this._gammaUniform = gl.getUniformLocation(this._program, "uGamma");
        this._isInitialized = true;
    }
    apply() {
        this._gl.uniform1i(this._samplerUniform, 0);
        this._gl.uniform3fv(this._colorUniform, this.color);
        this._gl.uniform3fv(this._hoverColorUniform, this.hoverColor);
        this._gl.uniform3fv(this._borderColorUniform, this.borderColor);
        this._gl.uniform1f(this._gammaUniform, this.gamma);
        this._gl.uniform1f(this._bufferUniform, this.buffer);
        this._gl.uniform1f(this._borderWidthUniform, this.borderWidth);
        this._gl.uniform4fv(this._pickedIdColorUniform, this.pickedIdColor);
    }
    applyModel() {
        this._gl.uniformMatrix4fv(this._mMatrixUniform, false, this.mMatrix);
    }
    applyView() {
        this._gl.uniform1i(this._pickUniform, this.isPickShader ? 1 : 0);
        this._gl.uniformMatrix4fv(this._vMatrixUniform, false, this.vMatrix);
        this._gl.uniformMatrix4fv(this._pMatrixUniform, false, this.pMatrix);
    }
    updateBuffers() {
        super.updateBuffers();
        this._gl.bindBuffer(this._gl.ARRAY_BUFFER, this._vertexBuffer);
        this._gl.vertexAttribPointer(this._idColorAttribute, 4, this._gl.UNSIGNED_BYTE, true, (0, $0a0587bd8b0d58e8$export$74c3c25430a16442).SIZE_BYTES, (0, $0a0587bd8b0d58e8$export$74c3c25430a16442).ID_COLOR_OFFSET_BYTES);
        this._gl.enableVertexAttribArray(this._idColorAttribute);
        this._gl.vertexAttribPointer(this._positionAttribute, 3, this._gl.FLOAT, false, (0, $0a0587bd8b0d58e8$export$74c3c25430a16442).SIZE_BYTES, (0, $0a0587bd8b0d58e8$export$74c3c25430a16442).POSITION_OFFSET_BYTES);
        this._gl.enableVertexAttribArray(this._positionAttribute);
        this._gl.vertexAttribPointer(this._texCoordAttribute, 2, this._gl.UNSIGNED_SHORT, true, (0, $0a0587bd8b0d58e8$export$74c3c25430a16442).SIZE_BYTES, (0, $0a0587bd8b0d58e8$export$74c3c25430a16442).TEX_COORD_OFFSET_BYTES);
        this._gl.enableVertexAttribArray(this._texCoordAttribute);
        this._gl.bindBuffer(this._gl.ELEMENT_ARRAY_BUFFER, this._indexBuffer);
    }
    updateTextures() {
        super.updateTextures();
        this._gl.activeTexture(this._gl.TEXTURE0);
        this._gl.bindTexture(this._gl.TEXTURE_2D, this._texture2D);
    }
}


/*!
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 */ 

class $0d68a84ac7ce9cae$export$3b812729b68dda3e extends (0, $a9df2cd8c496e87d$export$59a6ab026766925f) {
    initializeContext(gl) {
        super.initializeContext(gl);
        if (this._isLoaded) this._initializeShader(gl, this._vsSource, this._fsSource);
        else this._shaderFromFile("pickgrid.vertex.fx", "pickgrid.fragment.fx", (vsSource, fsSource)=>{
            this._vsSource = vsSource;
            this._fsSource = fsSource;
            this._isLoaded = true;
            this._initializeShader(gl, vsSource, fsSource);
        });
    }
    _initializeShader(gl, vsSource, fsSource) {
        const vs = this._compileShader(vsSource, gl.VERTEX_SHADER);
        const fs = this._compileShader(fsSource, gl.FRAGMENT_SHADER);
        this._program = this._createProgram(vs, fs);
        this._positionAttribute = this._gl.getAttribLocation(this._program, "aPosition");
        this._idColorAttribute = this._gl.getAttribLocation(this._program, "aIdColor");
        this._texCoordAttribute = this._gl.getAttribLocation(this._program, "aTexCoord");
        this._normalAttribute = this._gl.getAttribLocation(this._program, "aNormal");
        this._boundsAttribute = this._gl.getAttribLocation(this._program, "aBounds");
        this._pMatrixUniform = gl.getUniformLocation(this._program, "uPMatrix");
        this._mMatrixUniform = gl.getUniformLocation(this._program, "uMMatrix");
        this._vMatrixUniform = gl.getUniformLocation(this._program, "uVMatrix");
        this._pickUniform = gl.getUniformLocation(this._program, "uPick");
        this._majorColorUniform = gl.getUniformLocation(this._program, "uMajorColor");
        this._minorColorUniform = gl.getUniformLocation(this._program, "uMinorColor");
        this._zeroColorUniform = gl.getUniformLocation(this._program, "uZeroColor");
        this._backgroundUniform = gl.getUniformLocation(this._program, "uBackground");
        this._highlightUniform = gl.getUniformLocation(this._program, "uHighlight");
        this._pickedIdColorUniform = gl.getUniformLocation(this._program, "uPickedIdColor");
        this._faceSizeUniform = gl.getUniformLocation(this._program, "uFaceSize");
        this._majorThicknessUniform = gl.getUniformLocation(this._program, "uMajorThickness");
        this._minorThicknessUniform = gl.getUniformLocation(this._program, "uMinorThickness");
        this._zeroThicknessUniform = gl.getUniformLocation(this._program, "uZeroThickness");
        this._zeroUniform = gl.getUniformLocation(this._program, "uZero");
        this._minorGridlinesUniform = gl.getUniformLocation(this._program, "uMinorGridlines");
        this._isInitialized = true;
    }
    apply() {
        this._gl.uniform1f(this._majorThicknessUniform, this.majorThickness);
        this._gl.uniform1f(this._minorThicknessUniform, this.minorThickness);
        this._gl.uniform1f(this._zeroThicknessUniform, this.zeroThickness);
        this._gl.uniform3fv(this._backgroundUniform, this.backgroundColor);
        this._gl.uniform3fv(this._highlightUniform, this.highlightColor);
        this._gl.uniform3fv(this._majorColorUniform, this.majorColor);
        this._gl.uniform3fv(this._minorColorUniform, this.minorColor);
        this._gl.uniform3fv(this._zeroColorUniform, this.zeroColor);
        this._gl.uniform4fv(this._pickedIdColorUniform, this.pickedIdColor);
    }
    applyView() {
        this._gl.uniform1i(this._pickUniform, this.isPickShader ? 1 : 0);
        this._gl.uniformMatrix4fv(this._vMatrixUniform, false, this.vMatrix);
        this._gl.uniformMatrix4fv(this._pMatrixUniform, false, this.pMatrix);
    }
    ApplyFace() {
        this._gl.uniformMatrix4fv(this._mMatrixUniform, false, this.mMatrix);
        this._gl.uniform2f(this._faceSizeUniform, this.faceWidth, this.faceHeight);
        this._gl.uniform2fv(this._zeroUniform, this.zero);
        this._gl.uniform2fv(this._minorGridlinesUniform, this.minorGridlines);
    }
    updateBuffers() {
        super.updateBuffers();
        this._gl.bindBuffer(this._gl.ARRAY_BUFFER, this._vertexBuffer);
        this._gl.vertexAttribPointer(this._positionAttribute, 3, this._gl.FLOAT, false, (0, $0a0587bd8b0d58e8$export$df352805a955aca5).SIZE_BYTES, (0, $0a0587bd8b0d58e8$export$df352805a955aca5).TRANSLATION_OFFSET_BYTES);
        this._gl.enableVertexAttribArray(this._positionAttribute);
        this._gl.vertexAttribPointer(this._normalAttribute, 3, this._gl.BYTE, true, (0, $0a0587bd8b0d58e8$export$df352805a955aca5).SIZE_BYTES, (0, $0a0587bd8b0d58e8$export$df352805a955aca5).NORMAL_OFFSET_BYTES);
        this._gl.enableVertexAttribArray(this._normalAttribute);
        this._gl.vertexAttribPointer(this._texCoordAttribute, 2, this._gl.UNSIGNED_SHORT, true, (0, $0a0587bd8b0d58e8$export$df352805a955aca5).SIZE_BYTES, (0, $0a0587bd8b0d58e8$export$df352805a955aca5).TEX_COORD_OFFSET_BYTES);
        this._gl.enableVertexAttribArray(this._texCoordAttribute);
        this._gl.vertexAttribPointer(this._idColorAttribute, 4, this._gl.UNSIGNED_BYTE, true, (0, $0a0587bd8b0d58e8$export$df352805a955aca5).SIZE_BYTES, (0, $0a0587bd8b0d58e8$export$df352805a955aca5).ID_COLOR_OFFSET_BYTES);
        this._gl.enableVertexAttribArray(this._idColorAttribute);
        this._gl.vertexAttribPointer(this._boundsAttribute, 4, this._gl.UNSIGNED_SHORT, true, (0, $0a0587bd8b0d58e8$export$df352805a955aca5).SIZE_BYTES, (0, $0a0587bd8b0d58e8$export$df352805a955aca5).BOUNDS_OFFSET_BYTES);
        this._gl.enableVertexAttribArray(this._boundsAttribute);
        this._gl.bindBuffer(this._gl.ELEMENT_ARRAY_BUFFER, this._indexBuffer);
    }
}


/*!
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 */ 
/*!
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 */ 


class $aaa12a8ba275f824$export$c4c8cc0016dff604 extends (0, $a9df2cd8c496e87d$export$59a6ab026766925f) {
    get paletteTexture() {
        return this._paletteTexture;
    }
    set paletteTexture(value) {
        if (this._paletteTexture != value) {
            this._paletteTexture = value;
            this._haveTexturesChanged = true;
        }
    }
    get previousPaletteTexture() {
        return this._previousPaletteTexture;
    }
    set previousPaletteTexture(value) {
        if (this._previousPaletteTexture != value) {
            this._previousPaletteTexture = value;
            this._haveTexturesChanged = true;
        }
    }
    get sdfTexture() {
        return this._sdfTexture;
    }
    set sdfTexture(value) {
        if (this._sdfTexture != value) {
            this._sdfTexture = value;
            this._haveTexturesChanged = true;
        }
    }
    get previousSdfTexture() {
        return this._previousSdfTexture;
    }
    set previousSdfTexture(value) {
        if (this._previousSdfTexture != value) {
            this._previousSdfTexture = value;
            this._haveTexturesChanged = true;
        }
    }
    set instanceBuffer(value) {
        if (this._instanceBuffer != value) {
            this._instanceBuffer = value;
            this._haveBuffersChanged = true;
        }
    }
    set previousInstanceBuffer(value) {
        if (this._previousInstanceBuffer != value) {
            this._previousInstanceBuffer = value;
            this._haveBuffersChanged = true;
        }
    }
    initializeData() {
        this._areBuffersInitialized = false;
    }
    _initializeShader(gl, vsSource, fsSource) {
        const vs = this._compileShader(vsSource, gl.VERTEX_SHADER);
        const fs = this._compileShader(fsSource, gl.FRAGMENT_SHADER);
        this._program = this._createProgram(vs, fs);
        this._positionAttribute = gl.getAttribLocation(this._program, "aPosition");
        this._translationAttribute = gl.getAttribLocation(this._program, "aTranslation");
        this._previousTranslationAttribute = gl.getAttribLocation(this._program, "aPreviousTranslation");
        this._scaleAttribute = gl.getAttribLocation(this._program, "aScale");
        this._previousScaleAttribute = gl.getAttribLocation(this._program, "aPreviousScale");
        this._colorAttribute = gl.getAttribLocation(this._program, "aColor");
        this._previousColorAttribute = gl.getAttribLocation(this._program, "aPreviousColor");
        this._selectedAttribute = gl.getAttribLocation(this._program, "aSelected");
        this._previousSelectedAttribute = gl.getAttribLocation(this._program, "aPreviousSelected");
        this._orderAttribute = gl.getAttribLocation(this._program, "aOrder");
        this._idAttribute = gl.getAttribLocation(this._program, "aId");
        this._idColorAttribute = gl.getAttribLocation(this._program, "aIdColor");
        this._sampler0Uniform = gl.getUniformLocation(this._program, "uSampler");
        this._previousSampler0Uniform = gl.getUniformLocation(this._program, "uPreviousSampler");
        this._mMatrixUniform = gl.getUniformLocation(this._program, "uMMatrix");
        this._vMatrixUniform = gl.getUniformLocation(this._program, "uVMatrix");
        this._pMatrixUniform = gl.getUniformLocation(this._program, "uPMatrix");
        this._timeUniform = gl.getUniformLocation(this._program, "uTime");
        this._durationUniform = gl.getUniformLocation(this._program, "uDuration");
        this._fromOrderUniform = gl.getUniformLocation(this._program, "uOrderFrom");
        this._toOrderUniform = gl.getUniformLocation(this._program, "uOrderTo");
        this._hoverUniform = gl.getUniformLocation(this._program, "uHover");
        this._activeUniform = gl.getUniformLocation(this._program, "uActive");
        this._pickUniform = gl.getUniformLocation(this._program, "uPick");
        this._shadowUniform = gl.getUniformLocation(this._program, "uShadow");
        const vertices = (0, $c2c30e4dcf8004c5$export$a15f0a83a652dd40).POSITIONS;
        this._vertexBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, this._vertexBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW);
        const indices = (0, $c2c30e4dcf8004c5$export$a15f0a83a652dd40).INDICES;
        this._indexBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this._indexBuffer);
        gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, indices, gl.STATIC_DRAW);
        this.indexCount = indices.length;
    }
    updateBuffers() {
        super.updateBuffers();
        this._gl.bindBuffer(this._gl.ELEMENT_ARRAY_BUFFER, this._indexBuffer);
        this._gl.bindBuffer(this._gl.ARRAY_BUFFER, this._vertexBuffer);
        this._gl.vertexAttribPointer(this._positionAttribute, 3, this._gl.FLOAT, false, 12, 0);
        this._gl.enableVertexAttribArray(this._positionAttribute);
        this._updateCurrentBuffer();
        this._updatePreviousBuffer();
    }
    _updateCurrentBuffer() {
        this._gl.bindBuffer(this._gl.ARRAY_BUFFER, this._instanceBuffer);
        this._gl.vertexAttribPointer(this._idAttribute, 1, this._gl.FLOAT, false, (0, $0a0587bd8b0d58e8$export$849e31d725692576).SIZE_BYTES, (0, $0a0587bd8b0d58e8$export$849e31d725692576).ID_HOVER_OFFSET_BYTES);
        this._gl.vertexAttribDivisor(this._idAttribute, 1);
        this._gl.enableVertexAttribArray(this._idAttribute);
        this._gl.vertexAttribPointer(this._idColorAttribute, 4, this._gl.UNSIGNED_BYTE, true, (0, $0a0587bd8b0d58e8$export$849e31d725692576).SIZE_BYTES, (0, $0a0587bd8b0d58e8$export$849e31d725692576).ID_COLOR_OFFSET_BYTES);
        this._gl.vertexAttribDivisor(this._idColorAttribute, 1);
        this._gl.enableVertexAttribArray(this._idColorAttribute);
        this._gl.vertexAttribPointer(this._translationAttribute, 3, this._gl.FLOAT, false, (0, $0a0587bd8b0d58e8$export$849e31d725692576).SIZE_BYTES, (0, $0a0587bd8b0d58e8$export$849e31d725692576).TRANSLATION_OFFSET_BYTES);
        this._gl.vertexAttribDivisor(this._translationAttribute, 1);
        this._gl.enableVertexAttribArray(this._translationAttribute);
        this._gl.vertexAttribPointer(this._scaleAttribute, 3, this._gl.FLOAT, false, (0, $0a0587bd8b0d58e8$export$849e31d725692576).SIZE_BYTES, (0, $0a0587bd8b0d58e8$export$849e31d725692576).SCALE_OFFSET_BYTES);
        this._gl.vertexAttribDivisor(this._scaleAttribute, 1);
        this._gl.enableVertexAttribArray(this._scaleAttribute);
        this._gl.vertexAttribPointer(this._selectedAttribute, 1, this._gl.BYTE, true, (0, $0a0587bd8b0d58e8$export$849e31d725692576).SIZE_BYTES, (0, $0a0587bd8b0d58e8$export$849e31d725692576).SELECTED_OFFSET_BYTES);
        this._gl.vertexAttribDivisor(this._selectedAttribute, 1);
        this._gl.enableVertexAttribArray(this._selectedAttribute);
        this._gl.vertexAttribPointer(this._orderAttribute, 2, this._gl.FLOAT, false, (0, $0a0587bd8b0d58e8$export$849e31d725692576).SIZE_BYTES, (0, $0a0587bd8b0d58e8$export$849e31d725692576).ORDER_OFFSET_BYTES);
        this._gl.vertexAttribDivisor(this._orderAttribute, 1);
        this._gl.enableVertexAttribArray(this._orderAttribute);
    }
    _updatePreviousBuffer() {
        if (this._previousInstanceBuffer != this._instanceBuffer) this._gl.bindBuffer(this._gl.ARRAY_BUFFER, this._previousInstanceBuffer);
        this._gl.vertexAttribPointer(this._previousTranslationAttribute, 3, this._gl.FLOAT, false, (0, $0a0587bd8b0d58e8$export$849e31d725692576).SIZE_BYTES, (0, $0a0587bd8b0d58e8$export$849e31d725692576).TRANSLATION_OFFSET_BYTES);
        this._gl.vertexAttribDivisor(this._previousTranslationAttribute, 1);
        this._gl.enableVertexAttribArray(this._previousTranslationAttribute);
        this._gl.vertexAttribPointer(this._previousScaleAttribute, 3, this._gl.FLOAT, false, (0, $0a0587bd8b0d58e8$export$849e31d725692576).SIZE_BYTES, (0, $0a0587bd8b0d58e8$export$849e31d725692576).SCALE_OFFSET_BYTES);
        this._gl.vertexAttribDivisor(this._previousScaleAttribute, 1);
        this._gl.enableVertexAttribArray(this._previousScaleAttribute);
        this._gl.vertexAttribPointer(this._previousSelectedAttribute, 1, this._gl.BYTE, true, (0, $0a0587bd8b0d58e8$export$849e31d725692576).SIZE_BYTES, (0, $0a0587bd8b0d58e8$export$849e31d725692576).SELECTED_OFFSET_BYTES);
        this._gl.vertexAttribDivisor(this._previousSelectedAttribute, 1);
        this._gl.enableVertexAttribArray(this._previousSelectedAttribute);
    }
    apply() {
        this._gl.uniformMatrix4fv(this._mMatrixUniform, false, this.mMatrix);
        this._gl.uniform1f(this._timeUniform, this.time);
        this._gl.uniform1f(this._durationUniform, this.duration);
        this._gl.uniform1f(this._fromOrderUniform, this.rangeMin);
        this._gl.uniform1f(this._toOrderUniform, this.rangeMax);
        this._gl.uniform1i(this._previousSampler0Uniform, 0);
        this._gl.uniform1i(this._sampler0Uniform, 1);
        this._gl.uniform1f(this._hoverUniform, this.hover);
        this._gl.uniform1f(this._activeUniform, this.active);
    }
    applyView() {
        this._gl.uniformMatrix4fv(this._vMatrixUniform, false, this.vMatrix);
        this._gl.uniformMatrix4fv(this._pMatrixUniform, false, this.pMatrix);
        this._gl.uniform1i(this._pickUniform, this.isPickShader ? 1 : 0);
        this._gl.uniform1i(this._shadowUniform, this.isShadowMap ? 1 : 0);
    }
    updateTextures() {
        this._gl.activeTexture(this._gl.TEXTURE0);
        this._gl.bindTexture(this._gl.TEXTURE_2D, this._previousPaletteTexture);
        this._gl.activeTexture(this._gl.TEXTURE1);
        this._gl.bindTexture(this._gl.TEXTURE_2D, this._paletteTexture);
    }
    disableProgram() {
        super.disableProgram();
        this._gl.vertexAttribDivisor(this._translationAttribute, 0);
        this._gl.vertexAttribDivisor(this._previousTranslationAttribute, 0);
        this._gl.vertexAttribDivisor(this._scaleAttribute, 0);
        this._gl.vertexAttribDivisor(this._previousScaleAttribute, 0);
        this._gl.vertexAttribDivisor(this._colorAttribute, 0);
        this._gl.vertexAttribDivisor(this._previousColorAttribute, 0);
        this._gl.vertexAttribDivisor(this._selectedAttribute, 0);
        this._gl.vertexAttribDivisor(this._previousSelectedAttribute, 0);
        this._gl.vertexAttribDivisor(this._orderAttribute, 0);
        this._gl.vertexAttribDivisor(this._idAttribute, 0);
        this._gl.vertexAttribDivisor(this._idColorAttribute, 0);
    }
}


class $10a1c9b35469ca2f$export$b72dd5e86522410a extends (0, $aaa12a8ba275f824$export$c4c8cc0016dff604) {
    initializeContext(gl) {
        super.initializeContext(gl);
        if (this._isLoaded) this._initializeShader(gl, this._vsSource, this._fsSource);
        else this._shaderFromFile("unitblock.vertex.fx", "unitblock.fragment.fx", (vsSource, fsSource)=>{
            this._vsSource = vsSource;
            this._fsSource = fsSource;
            this._isLoaded = true;
            this._initializeShader(gl, vsSource, fsSource);
        });
    }
    _initializeShader(gl, vsSource, fsSource) {
        super._initializeShader(gl, vsSource, fsSource);
        this._rotationAttribute = gl.getAttribLocation(this._program, "aRotation");
        this._previousRotationAttribute = gl.getAttribLocation(this._program, "aPreviousRotation");
        this._isInitialized = true;
    }
    _updateCurrentBuffer() {
        super._updateCurrentBuffer();
        this._gl.vertexAttribPointer(this._rotationAttribute, 4, this._gl.FLOAT, false, (0, $0a0587bd8b0d58e8$export$849e31d725692576).SIZE_BYTES, (0, $0a0587bd8b0d58e8$export$849e31d725692576).ROTATION_OFFSET_BYTES);
        this._gl.vertexAttribDivisor(this._rotationAttribute, 1);
        this._gl.enableVertexAttribArray(this._rotationAttribute);
        this._gl.vertexAttribPointer(this._colorAttribute, 2, this._gl.UNSIGNED_BYTE, true, (0, $0a0587bd8b0d58e8$export$849e31d725692576).SIZE_BYTES, (0, $0a0587bd8b0d58e8$export$849e31d725692576).COLOR_OFFSET_BYTES);
        this._gl.vertexAttribDivisor(this._colorAttribute, 1);
        this._gl.enableVertexAttribArray(this._colorAttribute);
    }
    _updatePreviousBuffer() {
        super._updatePreviousBuffer();
        this._gl.vertexAttribPointer(this._previousRotationAttribute, 4, this._gl.FLOAT, false, (0, $0a0587bd8b0d58e8$export$849e31d725692576).SIZE_BYTES, (0, $0a0587bd8b0d58e8$export$849e31d725692576).ROTATION_OFFSET_BYTES);
        this._gl.vertexAttribDivisor(this._previousRotationAttribute, 1);
        this._gl.enableVertexAttribArray(this._previousRotationAttribute);
        this._gl.vertexAttribPointer(this._previousColorAttribute, 2, this._gl.UNSIGNED_BYTE, true, (0, $0a0587bd8b0d58e8$export$849e31d725692576).SIZE_BYTES, (0, $0a0587bd8b0d58e8$export$849e31d725692576).COLOR_OFFSET_BYTES);
        this._gl.vertexAttribDivisor(this._previousColorAttribute, 1);
        this._gl.enableVertexAttribArray(this._previousColorAttribute);
    }
    disableProgram() {
        super.disableProgram();
        this._gl.vertexAttribDivisor(this._rotationAttribute, 0);
        this._gl.vertexAttribDivisor(this._previousRotationAttribute, 0);
    }
}


/*!
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 */ 

class $8e9c2eab8262cc5c$export$427a5e80ce652e7d extends (0, $aaa12a8ba275f824$export$c4c8cc0016dff604) {
    initializeContext(gl) {
        super.initializeContext(gl);
        if (this._isLoaded) this._initializeShader(gl, this._vsSource, this._fsSource);
        else this._shaderFromFile("unitsphere.vertex.fx", "unitsphere.fragment.fx", (vsSource, fsSource)=>{
            this._vsSource = vsSource;
            this._fsSource = fsSource;
            this._isLoaded = true;
            this._initializeShader(gl, vsSource, fsSource);
        });
    }
    _initializeShader(gl, vsSource, fsSource) {
        super._initializeShader(gl, vsSource, fsSource);
        this._isInitialized = true;
    }
    _updateCurrentBuffer() {
        super._updateCurrentBuffer();
        this._gl.vertexAttribPointer(this._colorAttribute, 1, this._gl.UNSIGNED_BYTE, true, (0, $0a0587bd8b0d58e8$export$849e31d725692576).SIZE_BYTES, (0, $0a0587bd8b0d58e8$export$849e31d725692576).COLOR_OFFSET_BYTES);
        this._gl.vertexAttribDivisor(this._colorAttribute, 1);
        this._gl.enableVertexAttribArray(this._colorAttribute);
    }
    _updatePreviousBuffer() {
        super._updatePreviousBuffer();
        this._gl.vertexAttribPointer(this._previousColorAttribute, 1, this._gl.UNSIGNED_BYTE, true, (0, $0a0587bd8b0d58e8$export$849e31d725692576).SIZE_BYTES, (0, $0a0587bd8b0d58e8$export$849e31d725692576).COLOR_OFFSET_BYTES);
        this._gl.vertexAttribDivisor(this._previousColorAttribute, 1);
        this._gl.enableVertexAttribArray(this._previousColorAttribute);
    }
}


/*!
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 */ 

class $b02a2d0d38a17398$export$28e50bed796372f2 extends (0, $aaa12a8ba275f824$export$c4c8cc0016dff604) {
    initializeContext(gl) {
        super.initializeContext(gl);
        if (this._isLoaded) this._initializeShader(gl, this._vsSource, this._fsSource);
        else this._shaderFromFile("unitcylinder.vertex.fx", "unitcylinder.fragment.fx", (vsSource, fsSource)=>{
            this._vsSource = vsSource;
            this._fsSource = fsSource;
            this._isLoaded = true;
            this._initializeShader(gl, vsSource, fsSource);
        });
    }
    _initializeShader(gl, vsSource, fsSource) {
        super._initializeShader(gl, vsSource, fsSource);
        this._rotationAttribute = gl.getAttribLocation(this._program, "aRotation");
        this._previousRotationAttribute = gl.getAttribLocation(this._program, "aPreviousRotation");
        this._isInitialized = true;
    }
    _updateCurrentBuffer() {
        super._updateCurrentBuffer();
        this._gl.vertexAttribPointer(this._rotationAttribute, 4, this._gl.FLOAT, false, (0, $0a0587bd8b0d58e8$export$849e31d725692576).SIZE_BYTES, (0, $0a0587bd8b0d58e8$export$849e31d725692576).ROTATION_OFFSET_BYTES);
        this._gl.vertexAttribDivisor(this._rotationAttribute, 1);
        this._gl.enableVertexAttribArray(this._rotationAttribute);
        this._gl.vertexAttribPointer(this._colorAttribute, 2, this._gl.UNSIGNED_BYTE, true, (0, $0a0587bd8b0d58e8$export$849e31d725692576).SIZE_BYTES, (0, $0a0587bd8b0d58e8$export$849e31d725692576).COLOR_OFFSET_BYTES);
        this._gl.vertexAttribDivisor(this._colorAttribute, 1);
        this._gl.enableVertexAttribArray(this._colorAttribute);
    }
    _updatePreviousBuffer() {
        super._updatePreviousBuffer();
        this._gl.vertexAttribPointer(this._previousRotationAttribute, 4, this._gl.FLOAT, false, (0, $0a0587bd8b0d58e8$export$849e31d725692576).SIZE_BYTES, (0, $0a0587bd8b0d58e8$export$849e31d725692576).ROTATION_OFFSET_BYTES);
        this._gl.vertexAttribDivisor(this._previousRotationAttribute, 1);
        this._gl.enableVertexAttribArray(this._previousRotationAttribute);
        this._gl.vertexAttribPointer(this._previousColorAttribute, 2, this._gl.UNSIGNED_BYTE, true, (0, $0a0587bd8b0d58e8$export$849e31d725692576).SIZE_BYTES, (0, $0a0587bd8b0d58e8$export$849e31d725692576).COLOR_OFFSET_BYTES);
        this._gl.vertexAttribDivisor(this._previousColorAttribute, 1);
        this._gl.enableVertexAttribArray(this._previousColorAttribute);
    }
    disableProgram() {
        super.disableProgram();
        this._gl.vertexAttribDivisor(this._rotationAttribute, 0);
        this._gl.vertexAttribDivisor(this._previousRotationAttribute, 0);
    }
}


/*!
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 */ 

class $033aeb83f2353e26$export$b0bdf50006eaaa7a extends (0, $aaa12a8ba275f824$export$c4c8cc0016dff604) {
    initializeContext(gl) {
        super.initializeContext(gl);
        if (this._isLoaded) this._initializeShader(gl, this._vsSource, this._fsSource);
        else this._shaderFromFile("unitsdf.vertex.fx", "unitsdf.fragment.fx", (vsSource, fsSource)=>{
            this._vsSource = vsSource;
            this._fsSource = fsSource;
            this._isLoaded = true;
            this._initializeShader(gl, vsSource, fsSource);
        });
    }
    _initializeShader(gl, vsSource, fsSource) {
        super._initializeShader(gl, vsSource, fsSource);
        this._rotationAttribute = gl.getAttribLocation(this._program, "aRotation");
        this._previousRotationAttribute = gl.getAttribLocation(this._program, "aPreviousRotation");
        this._texCoordAttribute = gl.getAttribLocation(this._program, "aTexCoord");
        this._previousTexCoordAttribute = gl.getAttribLocation(this._program, "aPreviousTexCoord");
        this._sampler1Uniform = gl.getUniformLocation(this._program, "uSampler1");
        this._previousSampler1Uniform = gl.getUniformLocation(this._program, "uPreviousSampler1");
        this._isInitialized = true;
    }
    _updateCurrentBuffer() {
        super._updateCurrentBuffer();
        this._gl.vertexAttribPointer(this._rotationAttribute, 4, this._gl.FLOAT, false, (0, $0a0587bd8b0d58e8$export$849e31d725692576).SIZE_BYTES, (0, $0a0587bd8b0d58e8$export$849e31d725692576).ROTATION_OFFSET_BYTES);
        this._gl.vertexAttribDivisor(this._rotationAttribute, 1);
        this._gl.enableVertexAttribArray(this._rotationAttribute);
        this._gl.vertexAttribPointer(this._texCoordAttribute, 4, this._gl.FLOAT, false, (0, $0a0587bd8b0d58e8$export$849e31d725692576).SIZE_BYTES, (0, $0a0587bd8b0d58e8$export$849e31d725692576).TEXCOORD_OFFSET_BYTES);
        this._gl.vertexAttribDivisor(this._texCoordAttribute, 1);
        this._gl.enableVertexAttribArray(this._texCoordAttribute);
        this._gl.vertexAttribPointer(this._colorAttribute, 2, this._gl.UNSIGNED_BYTE, true, (0, $0a0587bd8b0d58e8$export$849e31d725692576).SIZE_BYTES, (0, $0a0587bd8b0d58e8$export$849e31d725692576).COLOR_OFFSET_BYTES);
        this._gl.vertexAttribDivisor(this._colorAttribute, 1);
        this._gl.enableVertexAttribArray(this._colorAttribute);
    }
    _updatePreviousBuffer() {
        super._updatePreviousBuffer();
        this._gl.vertexAttribPointer(this._previousRotationAttribute, 4, this._gl.FLOAT, false, (0, $0a0587bd8b0d58e8$export$849e31d725692576).SIZE_BYTES, (0, $0a0587bd8b0d58e8$export$849e31d725692576).ROTATION_OFFSET_BYTES);
        this._gl.vertexAttribDivisor(this._previousRotationAttribute, 1);
        this._gl.enableVertexAttribArray(this._previousRotationAttribute);
        this._gl.vertexAttribPointer(this._previousTexCoordAttribute, 4, this._gl.FLOAT, false, (0, $0a0587bd8b0d58e8$export$849e31d725692576).SIZE_BYTES, (0, $0a0587bd8b0d58e8$export$849e31d725692576).TEXCOORD_OFFSET_BYTES);
        this._gl.vertexAttribDivisor(this._previousTexCoordAttribute, 1);
        this._gl.enableVertexAttribArray(this._previousTexCoordAttribute);
        this._gl.vertexAttribPointer(this._previousColorAttribute, 2, this._gl.UNSIGNED_BYTE, true, (0, $0a0587bd8b0d58e8$export$849e31d725692576).SIZE_BYTES, (0, $0a0587bd8b0d58e8$export$849e31d725692576).COLOR_OFFSET_BYTES);
        this._gl.vertexAttribDivisor(this._previousColorAttribute, 1);
        this._gl.enableVertexAttribArray(this._previousColorAttribute);
    }
    apply() {
        super.apply();
        this._gl.uniform1i(this._previousSampler1Uniform, 2);
        this._gl.uniform1i(this._sampler1Uniform, 3);
    }
    updateTextures() {
        super.updateTextures();
        this._gl.activeTexture(this._gl.TEXTURE2);
        this._gl.bindTexture(this._gl.TEXTURE_2D, this._previousSdfTexture);
        this._gl.activeTexture(this._gl.TEXTURE3);
        this._gl.bindTexture(this._gl.TEXTURE_2D, this._sdfTexture);
    }
    disableProgram() {
        super.disableProgram();
        this._gl.vertexAttribDivisor(this._rotationAttribute, 0);
        this._gl.vertexAttribDivisor(this._previousRotationAttribute, 0);
        this._gl.vertexAttribDivisor(this._texCoordAttribute, 0);
        this._gl.vertexAttribDivisor(this._previousTexCoordAttribute, 0);
    }
}


/*!
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 */ 


class $f3c682691ac3327e$export$668799e4797757a8 extends (0, $a9df2cd8c496e87d$export$59a6ab026766925f) {
    constructor(core, main){
        super(core, main);
        this._quad = new (0, $046a802c77c0a655$export$7005c9eb6671414d)();
    }
    initializeContext(gl) {
        super.initializeContext(gl);
        this._quad.initializeContext(gl);
        if (this._isLoaded) this._initializeShader(gl, this._vsSource, this._fsSource);
        else this._shaderFromFile("simple.vertex.fx", "background.fragment.fx", (vsSource, fsSource)=>{
            this._vsSource = vsSource;
            this._fsSource = fsSource;
            this._isLoaded = true;
            this._initializeShader(gl, vsSource, fsSource);
        });
    }
    _initializeShader(gl, vsSource, fsSource) {
        const vs = this._compileShader(vsSource, gl.VERTEX_SHADER);
        const fs = this._compileShader(fsSource, gl.FRAGMENT_SHADER);
        this._program = this._createProgram(vs, fs);
        this._positionAttribute = gl.getAttribLocation(this._program, "aPosition");
        this._colorUniform = gl.getUniformLocation(this._program, "uColor");
        this._isInitialized = true;
        this._vao = gl.createVertexArray();
        gl.bindVertexArray(this._vao);
        gl.bindBuffer(gl.ARRAY_BUFFER, this._quad.vertexBuffer);
        gl.vertexAttribPointer(this._positionAttribute, 3, gl.FLOAT, false, (0, $0a0587bd8b0d58e8$export$5b33f080c7f6c861).SIZE_BYTES, 0);
        gl.enableVertexAttribArray(this._positionAttribute);
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this._quad.indexBuffer);
        gl.bindVertexArray(null);
    }
    apply() {
        this._gl.uniform3fv(this._colorUniform, this.color);
    }
    updateBuffers() {
        super.updateBuffers();
        this._gl.bindVertexArray(this._vao);
    }
}


/*!
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 */ 

class $00574d18b13d37d0$export$9aeffd51459d3d9 extends (0, $a9df2cd8c496e87d$export$59a6ab026766925f) {
    get texture2D1() {
        return this._texture2D1;
    }
    set texture2D1(value) {
        if (this._texture2D1 != value) {
            this._texture2D1 = value;
            this._haveTexturesChanged = true;
        }
    }
    get texture2D2() {
        return this._texture2D2;
    }
    set texture2D2(value) {
        if (this._texture2D2 != value) {
            this._texture2D2 = value;
            this._haveTexturesChanged = true;
        }
    }
    get texture2D3() {
        return this._texture2D3;
    }
    set texture2D3(value) {
        if (this._texture2D3 != value) {
            this._texture2D3 = value;
            this._haveTexturesChanged = true;
        }
    }
    initializeContext(gl) {
        super.initializeContext(gl);
        if (this._isLoaded) this._initializeShader(gl, this._vsSource, this._fsSource);
        else this._shaderFromFile("simple.vertex.fx", "ssao.fragment.fx", (vsSource, fsSource)=>{
            this._vsSource = vsSource;
            this._fsSource = fsSource;
            this._isLoaded = true;
            this._initializeShader(gl, vsSource, fsSource);
        });
    }
    _initializeShader(gl, vsSource, fsSource) {
        const vs = this._compileShader(vsSource, gl.VERTEX_SHADER);
        const fs = this._compileShader(fsSource, gl.FRAGMENT_SHADER);
        this._program = this._createProgram(vs, fs);
        this._positionAttribute = gl.getAttribLocation(this._program, "aPosition");
        this._samplerUniform1 = gl.getUniformLocation(this._program, "uSampler1");
        this._samplerUniform2 = gl.getUniformLocation(this._program, "uSampler2");
        this._samplerUniform3 = gl.getUniformLocation(this._program, "uSampler3");
        this._pMatrixUniform = gl.getUniformLocation(this._program, "uPMatrix");
        this._viewportUniform = gl.getUniformLocation(this._program, "uViewport");
        this._ssaoNoiseSizeUniform = gl.getUniformLocation(this._program, "uSsaoNoiseSize");
        this._ssaoRadiusUniform = gl.getUniformLocation(this._program, "uSsaoRadius");
        this._ssaoPowerUniform = gl.getUniformLocation(this._program, "uSsaoPower");
        this._ssaoKernelUniform = gl.getUniformLocation(this._program, "uSsaoKernel");
        this._isInitialized = true;
    }
    apply() {
        this._gl.uniform1i(this._samplerUniform1, 0);
        this._gl.uniform1i(this._samplerUniform2, 1);
        this._gl.uniform1i(this._samplerUniform3, 2);
        this._gl.uniform4f(this._viewportUniform, this.left, this.top, this.width, this.height);
        this._gl.uniform1f(this._ssaoNoiseSizeUniform, this.ssaoNoiseSize);
        this._gl.uniform1f(this._ssaoRadiusUniform, this.ssaoRadius);
        this._gl.uniform1f(this._ssaoPowerUniform, this.ssaoPower);
        this._gl.uniform3fv(this._ssaoKernelUniform, this.ssaoKernel);
    }
    applyView() {
        this._gl.uniformMatrix4fv(this._pMatrixUniform, false, this.pMatrix);
    }
    updateBuffers() {
        super.updateBuffers();
        this._gl.bindBuffer(this._gl.ARRAY_BUFFER, this._vertexBuffer);
        this._gl.vertexAttribPointer(this._positionAttribute, 3, this._gl.FLOAT, false, (0, $0a0587bd8b0d58e8$export$5b33f080c7f6c861).SIZE_BYTES, 0);
        this._gl.enableVertexAttribArray(this._positionAttribute);
        this._gl.bindBuffer(this._gl.ELEMENT_ARRAY_BUFFER, this._indexBuffer);
    }
    updateTextures() {
        super.updateTextures();
        this._gl.activeTexture(this._gl.TEXTURE0);
        this._gl.bindTexture(this._gl.TEXTURE_2D, this._texture2D1);
        this._gl.activeTexture(this._gl.TEXTURE1);
        this._gl.bindTexture(this._gl.TEXTURE_2D, this._texture2D2);
        this._gl.activeTexture(this._gl.TEXTURE2);
        this._gl.bindTexture(this._gl.TEXTURE_2D, this._texture2D3);
    }
}


/*!
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 */ 

class $1f3dda2230720917$export$e71c4d32a2263218 extends (0, $a9df2cd8c496e87d$export$59a6ab026766925f) {
    get texture2D() {
        return this._texture2D;
    }
    set texture2D(value) {
        if (this._texture2D != value) {
            this._texture2D = value;
            this._haveTexturesChanged = true;
        }
    }
    initializeContext(gl) {
        super.initializeContext(gl);
        if (this._isLoaded) this._initializeShader(gl, this._vsSource, this._fsSource);
        else this._shaderFromFile("simple.vertex.fx", "box.fragment.fx", (vsSource, fsSource)=>{
            this._vsSource = vsSource;
            this._fsSource = fsSource;
            this._isLoaded = true;
            this._initializeShader(gl, vsSource, fsSource);
        });
    }
    _initializeShader(gl, vsSource, fsSource) {
        const vs = this._compileShader(vsSource, gl.VERTEX_SHADER);
        const fs = this._compileShader(fsSource, gl.FRAGMENT_SHADER);
        this._program = this._createProgram(vs, fs);
        this._positionAttribute = gl.getAttribLocation(this._program, "aPosition");
        this._samplerUniform = gl.getUniformLocation(this._program, "uSampler");
        this._viewportUniform = gl.getUniformLocation(this._program, "uViewport");
        this._isInitialized = true;
    }
    apply() {
        this._gl.uniform1i(this._samplerUniform, 0);
        this._gl.uniform4f(this._viewportUniform, this.left, this.top, this.width, this.height);
    }
    updateBuffers() {
        super.updateBuffers();
        this._gl.bindBuffer(this._gl.ARRAY_BUFFER, this._vertexBuffer);
        this._gl.vertexAttribPointer(this._positionAttribute, 3, this._gl.FLOAT, false, (0, $0a0587bd8b0d58e8$export$5b33f080c7f6c861).SIZE_BYTES, 0);
        this._gl.enableVertexAttribArray(this._positionAttribute);
        this._gl.bindBuffer(this._gl.ELEMENT_ARRAY_BUFFER, this._indexBuffer);
    }
    updateTextures() {
        super.updateTextures();
        this._gl.activeTexture(this._gl.TEXTURE0);
        this._gl.bindTexture(this._gl.TEXTURE_2D, this._texture2D);
    }
}


/*!
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 */ 


class $190597e9b40588c3$export$85f6557964517f1a extends (0, $a9df2cd8c496e87d$export$59a6ab026766925f) {
    get texture2D1() {
        return this._texture2D1;
    }
    set texture2D1(value) {
        if (this._texture2D1 != value) {
            this._texture2D1 = value;
            this._haveTexturesChanged = true;
        }
    }
    get texture2D2() {
        return this._texture2D2;
    }
    set texture2D2(value) {
        if (this._texture2D2 != value) {
            this._texture2D2 = value;
            this._haveTexturesChanged = true;
        }
    }
    get texture2D3() {
        return this._texture2D3;
    }
    set texture2D3(value) {
        if (this._texture2D3 != value) {
            this._texture2D3 = value;
            this._haveTexturesChanged = true;
        }
    }
    get texture2D4() {
        return this._texture2D4;
    }
    set texture2D4(value) {
        if (this._texture2D4 != value) {
            this._texture2D4 = value;
            this._haveTexturesChanged = true;
        }
    }
    get texture2D5() {
        return this._texture2D5;
    }
    set texture2D5(value) {
        if (this._texture2D5 != value) {
            this._texture2D5 = value;
            this._haveTexturesChanged = true;
        }
    }
    constructor(core, main){
        super(core, main);
        this.directionToKeyLight = (0, $31054a6c69637582$exports).create();
        this.directionToFillLight1 = (0, $31054a6c69637582$exports).create();
        this.directionToFillLight2 = (0, $31054a6c69637582$exports).create();
        this.keyLightHalfAngle = (0, $31054a6c69637582$exports).create();
    }
    initializeContext(gl) {
        super.initializeContext(gl);
        if (this._isLoaded) this._initializeShader(gl, this._vsSource, this._fsSource);
        else this._shaderFromFile("simple.vertex.fx", "deferred.fragment.fx", (vsSource, fsSource)=>{
            this._vsSource = vsSource;
            this._fsSource = fsSource;
            this._isLoaded = true;
            this._initializeShader(gl, vsSource, fsSource);
        });
    }
    _initializeShader(gl, vsSource, fsSource) {
        const vs = this._compileShader(vsSource, gl.VERTEX_SHADER);
        const fs = this._compileShader(fsSource, gl.FRAGMENT_SHADER);
        this._program = this._createProgram(vs, fs);
        this._positionAttribute = gl.getAttribLocation(this._program, "aPosition");
        this._shadowUniform = gl.getUniformLocation(this._program, "uShadow");
        this._ssaoUniform = gl.getUniformLocation(this._program, "uSsao");
        this._inverseVMatrixUniform = gl.getUniformLocation(this._program, "uInverseVMatrix");
        this._shadowVMatrixUniform = gl.getUniformLocation(this._program, "uShadowVMatrix");
        this._shadowPMatrixUniform = gl.getUniformLocation(this._program, "uShadowPMatrix");
        this._samplerUniform1 = gl.getUniformLocation(this._program, "uSampler1");
        this._samplerUniform2 = gl.getUniformLocation(this._program, "uSampler2");
        this._samplerUniform3 = gl.getUniformLocation(this._program, "uSampler3");
        this._samplerUniform4 = gl.getUniformLocation(this._program, "uSampler4");
        this._samplerUniform5 = gl.getUniformLocation(this._program, "uSampler5");
        this._viewportUniform = gl.getUniformLocation(this._program, "uViewport");
        this._shadowMapSizeUniform = gl.getUniformLocation(this._program, "uShadowMapSize");
        this._keyLightHalfAngleUniform = gl.getUniformLocation(this._program, "uKeyLightHalfAngle");
        this._directionToKeyLightUniform = gl.getUniformLocation(this._program, "uDirectionToKeyLight");
        this._directionToFillLight1Uniform = gl.getUniformLocation(this._program, "uDirectionToFillLight1");
        this._directionToFillLight2Uniform = gl.getUniformLocation(this._program, "uDirectionToFillLight2");
        this._keyLightIntensityUniform = gl.getUniformLocation(this._program, "uKeyLightIntensity");
        this._fillLight1IntensityUniform = gl.getUniformLocation(this._program, "uFillLight1Intensity");
        this._fillLight2IntensityUniform = gl.getUniformLocation(this._program, "uFillLight2Intensity");
        this._ambientIntensityUniform = gl.getUniformLocation(this._program, "uAmbientIntensity");
        this._materialIntensityUniform = gl.getUniformLocation(this._program, "uMaterialIntensity");
        this._specularPowerUniform = gl.getUniformLocation(this._program, "uSpecularPower");
        this._specularIntensityUniform = gl.getUniformLocation(this._program, "uSpecularIntensity");
        this._isInitialized = true;
    }
    apply() {
        this._gl.uniform1i(this._shadowUniform, this.isShadowEnabled ? 1 : 0);
        this._gl.uniform1i(this._ssaoUniform, this.isSsaoEnabled ? 1 : 0);
        this._gl.uniformMatrix4fv(this._inverseVMatrixUniform, false, this.inverseVMatrix);
        this._gl.uniformMatrix4fv(this._shadowVMatrixUniform, false, this.shadowVMatrix);
        this._gl.uniformMatrix4fv(this._shadowPMatrixUniform, false, this.shadowPMatrix);
        this._gl.uniform1i(this._samplerUniform1, 0);
        this._gl.uniform1i(this._samplerUniform2, 1);
        this._gl.uniform1i(this._samplerUniform3, 2);
        this._gl.uniform1i(this._samplerUniform4, 3);
        this._gl.uniform1i(this._samplerUniform5, 4);
        this._gl.uniform4f(this._viewportUniform, this.left, this.top, this.width, this.height);
        this._gl.uniform2f(this._shadowMapSizeUniform, this.shadowMapWidth, this.shadowMapHeight);
        this._gl.uniform1f(this._keyLightIntensityUniform, this.keyLightIntensity);
        this._gl.uniform1f(this._fillLight1IntensityUniform, this.fillLight1Intensity);
        this._gl.uniform1f(this._fillLight2IntensityUniform, this.fillLight2Intensity);
        this._gl.uniform1f(this._ambientIntensityUniform, this.ambientIntensity);
        this._gl.uniform1f(this._materialIntensityUniform, this.materialIntensity);
        this._gl.uniform1f(this._specularPowerUniform, this.specularPower);
        this._gl.uniform1f(this._specularIntensityUniform, this.specularIntensity);
        this._gl.uniform3fv(this._directionToKeyLightUniform, this.directionToKeyLight);
        this._gl.uniform3fv(this._directionToFillLight1Uniform, this.directionToFillLight1);
        this._gl.uniform3fv(this._directionToFillLight2Uniform, this.directionToFillLight2);
        this._gl.uniform3fv(this._keyLightHalfAngleUniform, this.keyLightHalfAngle);
    }
    updateBuffers() {
        super.updateBuffers();
        this._gl.bindBuffer(this._gl.ARRAY_BUFFER, this._vertexBuffer);
        this._gl.vertexAttribPointer(this._positionAttribute, 3, this._gl.FLOAT, false, (0, $0a0587bd8b0d58e8$export$5b33f080c7f6c861).SIZE_BYTES, 0);
        this._gl.enableVertexAttribArray(this._positionAttribute);
        this._gl.bindBuffer(this._gl.ELEMENT_ARRAY_BUFFER, this._indexBuffer);
    }
    updateTextures() {
        super.updateTextures();
        this._gl.activeTexture(this._gl.TEXTURE0);
        this._gl.bindTexture(this._gl.TEXTURE_2D, this._texture2D1);
        this._gl.activeTexture(this._gl.TEXTURE1);
        this._gl.bindTexture(this._gl.TEXTURE_2D, this._texture2D2);
        this._gl.activeTexture(this._gl.TEXTURE2);
        this._gl.bindTexture(this._gl.TEXTURE_2D, this._texture2D3);
        this._gl.activeTexture(this._gl.TEXTURE3);
        this._gl.bindTexture(this._gl.TEXTURE_2D, this._texture2D4);
        this._gl.activeTexture(this._gl.TEXTURE4);
        this._gl.bindTexture(this._gl.TEXTURE_2D, this._texture2D5);
    }
}


/*!
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 */ 

class $5b394f278f6c99db$export$42b7cecdce1e9ecc extends (0, $a9df2cd8c496e87d$export$59a6ab026766925f) {
    get texture2D1() {
        return this._texture2D1;
    }
    set texture2D1(value) {
        if (this._texture2D1 != value) {
            this._texture2D1 = value;
            this._haveTexturesChanged = true;
        }
    }
    get texture2D2() {
        return this._texture2D2;
    }
    set texture2D2(value) {
        if (this._texture2D2 != value) {
            this._texture2D2 = value;
            this._haveTexturesChanged = true;
        }
    }
    get texture2D3() {
        return this._texture2D3;
    }
    set texture2D3(value) {
        if (this._texture2D3 != value) {
            this._texture2D3 = value;
            this._haveTexturesChanged = true;
        }
    }
    get texture2D4() {
        return this._texture2D4;
    }
    set texture2D4(value) {
        if (this._texture2D4 != value) {
            this._texture2D4 = value;
            this._haveTexturesChanged = true;
        }
    }
    get texture2D5() {
        return this._texture2D5;
    }
    set texture2D5(value) {
        if (this._texture2D5 != value) {
            this._texture2D5 = value;
            this._haveTexturesChanged = true;
        }
    }
    initializeContext(gl) {
        super.initializeContext(gl);
        if (this._isLoaded) this._initializeShader(gl, this._vsSource, this._fsSource);
        else this._shaderFromFile("simple.vertex.fx", "combine.fragment.fx", (vsSource, fsSource)=>{
            this._vsSource = vsSource;
            this._fsSource = fsSource;
            this._isLoaded = true;
            this._initializeShader(gl, vsSource, fsSource);
        });
    }
    _initializeShader(gl, vsSource, fsSource) {
        const vs = this._compileShader(vsSource, gl.VERTEX_SHADER);
        const fs = this._compileShader(fsSource, gl.FRAGMENT_SHADER);
        this._program = this._createProgram(vs, fs);
        this._positionAttribute = gl.getAttribLocation(this._program, "aPosition");
        this._viewportUniform = gl.getUniformLocation(this._program, "uViewport");
        this._intensityUniform = gl.getUniformLocation(this._program, "uIntensity");
        this._samplerUniform1 = gl.getUniformLocation(this._program, "uSampler1");
        this._samplerUniform2 = gl.getUniformLocation(this._program, "uSampler2");
        this._samplerUniform3 = gl.getUniformLocation(this._program, "uSampler3");
        this._samplerUniform4 = gl.getUniformLocation(this._program, "uSampler4");
        this._samplerUniform5 = gl.getUniformLocation(this._program, "uSampler5");
        this._isInitialized = true;
    }
    apply() {
        this._gl.uniform4f(this._viewportUniform, this.viewport.x, this.viewport.y, this.viewport.width, this.viewport.height);
        this._gl.uniform1f(this._intensityUniform, this.intensity);
        this._gl.uniform1i(this._samplerUniform1, 0);
        this._gl.uniform1i(this._samplerUniform2, 1);
        this._gl.uniform1i(this._samplerUniform3, 2);
        this._gl.uniform1i(this._samplerUniform4, 3);
        this._gl.uniform1i(this._samplerUniform5, 4);
    }
    updateBuffers() {
        super.updateBuffers();
        this._gl.bindBuffer(this._gl.ARRAY_BUFFER, this._vertexBuffer);
        this._gl.vertexAttribPointer(this._positionAttribute, 3, this._gl.FLOAT, false, (0, $0a0587bd8b0d58e8$export$5b33f080c7f6c861).SIZE_BYTES, 0);
        this._gl.enableVertexAttribArray(this._positionAttribute);
        this._gl.bindBuffer(this._gl.ELEMENT_ARRAY_BUFFER, this._indexBuffer);
    }
    updateTextures() {
        super.updateTextures();
        this._gl.activeTexture(this._gl.TEXTURE0);
        this._gl.bindTexture(this._gl.TEXTURE_2D, this._texture2D1);
        this._gl.activeTexture(this._gl.TEXTURE1);
        this._gl.bindTexture(this._gl.TEXTURE_2D, this._texture2D2);
        this._gl.activeTexture(this._gl.TEXTURE2);
        this._gl.bindTexture(this._gl.TEXTURE_2D, this._texture2D3);
        this._gl.activeTexture(this._gl.TEXTURE3);
        this._gl.bindTexture(this._gl.TEXTURE_2D, this._texture2D4);
        this._gl.activeTexture(this._gl.TEXTURE4);
        this._gl.bindTexture(this._gl.TEXTURE_2D, this._texture2D5);
    }
}


/*!
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 */ 

class $3c55280ad494aadd$export$3edb5030712765fa extends (0, $a9df2cd8c496e87d$export$59a6ab026766925f) {
    get texture2D1() {
        return this._texture2D1;
    }
    set texture2D1(value) {
        if (this._texture2D1 != value) {
            this._texture2D1 = value;
            this._haveTexturesChanged = true;
        }
    }
    get texture2D2() {
        return this._texture2D2;
    }
    set texture2D2(value) {
        if (this._texture2D2 != value) {
            this._texture2D2 = value;
            this._haveTexturesChanged = true;
        }
    }
    initializeContext(gl) {
        super.initializeContext(gl);
        if (this._isLoaded) this._initializeShader(gl, this._vsSource, this._fsSource);
        else this._shaderFromFile("simple.vertex.fx", "dofblur.fragment.fx", (vsSource, fsSource)=>{
            this._vsSource = vsSource;
            this._fsSource = fsSource;
            this._isLoaded = true;
            this._initializeShader(gl, vsSource, fsSource);
        });
    }
    _initializeShader(gl, vsSource, fsSource) {
        const vs = this._compileShader(vsSource, gl.VERTEX_SHADER);
        const fs = this._compileShader(fsSource, gl.FRAGMENT_SHADER);
        this._program = this._createProgram(vs, fs);
        this._positionAttribute = gl.getAttribLocation(this._program, "aPosition");
        this._viewportUniform = gl.getUniformLocation(this._program, "uViewport");
        this._focusDepthUniform = gl.getUniformLocation(this._program, "uFocusDepth");
        this._nearFocusDepthUniform = gl.getUniformLocation(this._program, "uNearFocusDepth");
        this._farFocusDepthUniform = gl.getUniformLocation(this._program, "uFarFocusDepth");
        this._maxBackgroundBlurUniform = gl.getUniformLocation(this._program, "uMaxBackgroundBlur");
        this._samplerUniform1 = gl.getUniformLocation(this._program, "uSampler1");
        this._samplerUniform2 = gl.getUniformLocation(this._program, "uSampler2");
        this._isInitialized = true;
    }
    apply() {
        this._gl.uniform4f(this._viewportUniform, this.left, this.top, this.width, this.height);
        this._gl.uniform1f(this._focusDepthUniform, this.focusDepth);
        this._gl.uniform1f(this._nearFocusDepthUniform, this.nearFocusDepth);
        this._gl.uniform1f(this._farFocusDepthUniform, this.farFocusDepth);
        this._gl.uniform1f(this._maxBackgroundBlurUniform, this.maxBackgroundBlur);
        this._gl.uniform1i(this._samplerUniform1, 0);
        this._gl.uniform1i(this._samplerUniform2, 1);
    }
    updateBuffers() {
        super.updateBuffers();
        super.updateBuffers();
        this._gl.bindBuffer(this._gl.ARRAY_BUFFER, this._vertexBuffer);
        this._gl.vertexAttribPointer(this._positionAttribute, 3, this._gl.FLOAT, false, (0, $0a0587bd8b0d58e8$export$5b33f080c7f6c861).SIZE_BYTES, 0);
        this._gl.enableVertexAttribArray(this._positionAttribute);
        this._gl.bindBuffer(this._gl.ELEMENT_ARRAY_BUFFER, this._indexBuffer);
    }
    updateTextures() {
        super.updateTextures();
        this._gl.activeTexture(this._gl.TEXTURE0);
        this._gl.bindTexture(this._gl.TEXTURE_2D, this._texture2D1);
        this._gl.activeTexture(this._gl.TEXTURE1);
        this._gl.bindTexture(this._gl.TEXTURE_2D, this._texture2D2);
    }
}


/*!
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 */ 

class $903b38bcb9c6df3c$export$fce67a054bb06d73 extends (0, $a9df2cd8c496e87d$export$59a6ab026766925f) {
    get texture2D() {
        return this._texture2D;
    }
    set texture2D(value) {
        if (this._texture2D != value) {
            this._texture2D = value;
            this._haveTexturesChanged = true;
        }
    }
    initializeContext(gl) {
        super.initializeContext(gl);
        if (this._isLoaded) this._initializeShader(gl, this._vsSource, this._fsSource);
        else this._shaderFromFile("simple.vertex.fx", "downsample.fragment.fx", (vsSource, fsSource)=>{
            this._vsSource = vsSource;
            this._fsSource = fsSource;
            this._isLoaded = true;
            this._initializeShader(gl, vsSource, fsSource);
        });
    }
    _initializeShader(gl, vsSource, fsSource) {
        const vs = this._compileShader(vsSource, gl.VERTEX_SHADER);
        const fs = this._compileShader(fsSource, gl.FRAGMENT_SHADER);
        this._program = this._createProgram(vs, fs);
        this._positionAttribute = gl.getAttribLocation(this._program, "aPosition");
        this._viewportUniform = gl.getUniformLocation(this._program, "uViewport");
        this._samplerUniform = gl.getUniformLocation(this._program, "uSampler");
        this._isInitialized = true;
    }
    apply() {
        this._gl.uniform4f(this._viewportUniform, this.left, this.top, this.width, this.height);
        this._gl.uniform1i(this._samplerUniform, 0);
    }
    updateBuffers() {
        super.updateBuffers();
        super.updateBuffers();
        this._gl.bindBuffer(this._gl.ARRAY_BUFFER, this._vertexBuffer);
        this._gl.vertexAttribPointer(this._positionAttribute, 3, this._gl.FLOAT, false, (0, $0a0587bd8b0d58e8$export$5b33f080c7f6c861).SIZE_BYTES, 0);
        this._gl.enableVertexAttribArray(this._positionAttribute);
        this._gl.bindBuffer(this._gl.ELEMENT_ARRAY_BUFFER, this._indexBuffer);
    }
    updateTextures() {
        super.updateTextures();
        this._gl.activeTexture(this._gl.TEXTURE0);
        this._gl.bindTexture(this._gl.TEXTURE_2D, this._texture2D);
    }
}


/*!
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 */ 

class $1f52e628cc3ed829$export$2cae02e4a50f2cda extends (0, $a9df2cd8c496e87d$export$59a6ab026766925f) {
    get texture2D() {
        return this._texture2D;
    }
    set texture2D(value) {
        if (this._texture2D != value) {
            this._texture2D = value;
            this._haveTexturesChanged = true;
        }
    }
    initializeContext(gl) {
        super.initializeContext(gl);
        if (this._isLoaded) this._initializeShader(gl, this._vsSource, this._fsSource);
        else this._shaderFromFile("simple.vertex.fx", "gaussian.fragment.fx", (vsSource, fsSource)=>{
            this._vsSource = vsSource;
            this._fsSource = fsSource;
            this._isLoaded = true;
            this._initializeShader(gl, vsSource, fsSource);
        });
    }
    _initializeShader(gl, vsSource, fsSource) {
        const vs = this._compileShader(vsSource, gl.VERTEX_SHADER);
        const fs = this._compileShader(fsSource, gl.FRAGMENT_SHADER);
        this._program = this._createProgram(vs, fs);
        this._positionAttribute = gl.getAttribLocation(this._program, "aPosition");
        this._samplerUniform = gl.getUniformLocation(this._program, "uSampler");
        this._resolutionUniform = gl.getUniformLocation(this._program, "uResolution");
        this._horizontalUniform = gl.getUniformLocation(this._program, "uHorizontal");
        this._isInitialized = true;
    }
    apply() {
        this._gl.uniform1i(this._samplerUniform, 0);
        this._gl.uniform2f(this._resolutionUniform, this.width, this.height);
        this._gl.uniform1i(this._horizontalUniform, this.horizontal ? 1 : 0);
    }
    updateBuffers() {
        super.updateBuffers();
        super.updateBuffers();
        this._gl.bindBuffer(this._gl.ARRAY_BUFFER, this._vertexBuffer);
        this._gl.vertexAttribPointer(this._positionAttribute, 3, this._gl.FLOAT, false, (0, $0a0587bd8b0d58e8$export$5b33f080c7f6c861).SIZE_BYTES, 0);
        this._gl.enableVertexAttribArray(this._positionAttribute);
        this._gl.bindBuffer(this._gl.ELEMENT_ARRAY_BUFFER, this._indexBuffer);
    }
    updateTextures() {
        super.updateTextures();
        this._gl.activeTexture(this._gl.TEXTURE0);
        this._gl.bindTexture(this._gl.TEXTURE_2D, this._texture2D);
    }
}


/*!
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 */ 

class $096272391683d440$export$ff3d2a706a946a2 extends (0, $a9df2cd8c496e87d$export$59a6ab026766925f) {
    get texture2D1() {
        return this._texture2D1;
    }
    set texture2D1(value) {
        if (this._texture2D1 != value) {
            this._texture2D1 = value;
            this._haveTexturesChanged = true;
        }
    }
    get texture2D2() {
        return this._texture2D2;
    }
    set texture2D2(value) {
        if (this._texture2D2 != value) {
            this._texture2D2 = value;
            this._haveTexturesChanged = true;
        }
    }
    get texture2D3() {
        return this._texture2D3;
    }
    set texture2D3(value) {
        if (this._texture2D3 != value) {
            this._texture2D3 = value;
            this._haveTexturesChanged = true;
        }
    }
    initializeContext(gl) {
        super.initializeContext(gl);
        if (this._isLoaded) this._initializeShader(gl, this._vsSource, this._fsSource);
        else this._shaderFromFile("simple.vertex.fx", "dofcombine.fragment.fx", (vsSource, fsSource)=>{
            this._vsSource = vsSource;
            this._fsSource = fsSource;
            this._isLoaded = true;
            this._initializeShader(gl, vsSource, fsSource);
        });
    }
    _initializeShader(gl, vsSource, fsSource) {
        const vs = this._compileShader(vsSource, gl.VERTEX_SHADER);
        const fs = this._compileShader(fsSource, gl.FRAGMENT_SHADER);
        this._program = this._createProgram(vs, fs);
        this._positionAttribute = gl.getAttribLocation(this._program, "aPosition");
        this._viewportUniform = gl.getUniformLocation(this._program, "uViewport");
        this._focusDepthUniform = gl.getUniformLocation(this._program, "uFocusDepth");
        this._apertureUniform = gl.getUniformLocation(this._program, "uAperture");
        this._samplerUniform1 = gl.getUniformLocation(this._program, "uSampler1");
        this._samplerUniform2 = gl.getUniformLocation(this._program, "uSampler2");
        this._samplerUniform3 = gl.getUniformLocation(this._program, "uSampler3");
        this._isInitialized = true;
    }
    apply() {
        this._gl.uniform4f(this._viewportUniform, this.left, this.top, this.width, this.height);
        this._gl.uniform1f(this._focusDepthUniform, this.focusDepth);
        this._gl.uniform1f(this._apertureUniform, this.aperture);
        this._gl.uniform1i(this._samplerUniform1, 0);
        this._gl.uniform1i(this._samplerUniform2, 1);
        this._gl.uniform1i(this._samplerUniform3, 2);
    }
    updateBuffers() {
        super.updateBuffers();
        super.updateBuffers();
        this._gl.bindBuffer(this._gl.ARRAY_BUFFER, this._vertexBuffer);
        this._gl.vertexAttribPointer(this._positionAttribute, 3, this._gl.FLOAT, false, (0, $0a0587bd8b0d58e8$export$5b33f080c7f6c861).SIZE_BYTES, 0);
        this._gl.enableVertexAttribArray(this._positionAttribute);
        this._gl.bindBuffer(this._gl.ELEMENT_ARRAY_BUFFER, this._indexBuffer);
    }
    updateTextures() {
        super.updateTextures();
        this._gl.activeTexture(this._gl.TEXTURE0);
        this._gl.bindTexture(this._gl.TEXTURE_2D, this._texture2D1);
        this._gl.activeTexture(this._gl.TEXTURE1);
        this._gl.bindTexture(this._gl.TEXTURE_2D, this._texture2D2);
        this._gl.activeTexture(this._gl.TEXTURE2);
        this._gl.bindTexture(this._gl.TEXTURE_2D, this._texture2D3);
    }
}


/*!
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 */ 

class $ca1e5eb7e900b291$export$9a81f906983b6bc8 extends (0, $a9df2cd8c496e87d$export$59a6ab026766925f) {
    get texture2D() {
        return this._texture2D;
    }
    set texture2D(value) {
        if (this._texture2D != value) {
            this._texture2D = value;
            this._haveTexturesChanged = true;
        }
    }
    initializeContext(gl) {
        super.initializeContext(gl);
        if (this._isLoaded) this._initializeShader(gl, this._vsSource, this._fsSource);
        else this._shaderFromFile("simple.vertex.fx", "fxaa.fragment.fx", (vsSource, fsSource)=>{
            this._vsSource = vsSource;
            this._fsSource = fsSource;
            this._isLoaded = true;
            this._initializeShader(gl, vsSource, fsSource);
        });
    }
    _initializeShader(gl, vsSource, fsSource) {
        const vs = this._compileShader(vsSource, gl.VERTEX_SHADER);
        const fs = this._compileShader(fsSource, gl.FRAGMENT_SHADER);
        this._program = this._createProgram(vs, fs);
        this._positionAttribute = gl.getAttribLocation(this._program, "aPosition");
        this._viewportUniform = gl.getUniformLocation(this._program, "uViewport");
        this._samplerUniform = gl.getUniformLocation(this._program, "uSampler");
        this._isInitialized = true;
    }
    apply() {
        this._gl.uniform4f(this._viewportUniform, this.left, this.top, this.width, this.height);
        this._gl.uniform1i(this._samplerUniform, 0);
    }
    updateBuffers() {
        super.updateBuffers();
        super.updateBuffers();
        this._gl.bindBuffer(this._gl.ARRAY_BUFFER, this._vertexBuffer);
        this._gl.vertexAttribPointer(this._positionAttribute, 3, this._gl.FLOAT, false, (0, $0a0587bd8b0d58e8$export$5b33f080c7f6c861).SIZE_BYTES, 0);
        this._gl.enableVertexAttribArray(this._positionAttribute);
        this._gl.bindBuffer(this._gl.ELEMENT_ARRAY_BUFFER, this._indexBuffer);
    }
    updateTextures() {
        super.updateTextures();
        this._gl.activeTexture(this._gl.TEXTURE0);
        this._gl.bindTexture(this._gl.TEXTURE_2D, this._texture2D);
    }
}


/*!
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 */ 

class $4aa6b658ca80a4c6$export$2898c0abb0413fac extends (0, $a9df2cd8c496e87d$export$59a6ab026766925f) {
    get texture2D() {
        return this._texture2D;
    }
    set texture2D(value) {
        if (this._texture2D != value) {
            this._texture2D = value;
            this._haveTexturesChanged = true;
        }
    }
    initializeContext(gl) {
        super.initializeContext(gl);
        if (this._isLoaded) this._initializeShader(gl, this._vsSource, this._fsSource);
        else this._shaderFromFile("simple.vertex.fx", "bright.fragment.fx", (vsSource, fsSource)=>{
            this._vsSource = vsSource;
            this._fsSource = fsSource;
            this._isLoaded = true;
            this._initializeShader(gl, vsSource, fsSource);
        });
    }
    _initializeShader(gl, vsSource, fsSource) {
        const vs = this._compileShader(vsSource, gl.VERTEX_SHADER);
        const fs = this._compileShader(fsSource, gl.FRAGMENT_SHADER);
        this._program = this._createProgram(vs, fs);
        this._positionAttribute = gl.getAttribLocation(this._program, "aPosition");
        this._samplerUniform = gl.getUniformLocation(this._program, "uSampler");
        this._resolutionUniform = gl.getUniformLocation(this._program, "uResolution");
        this._isInitialized = true;
    }
    apply() {
        this._gl.uniform1i(this._samplerUniform, 0);
        this._gl.uniform2f(this._resolutionUniform, this.width, this.height);
    }
    updateBuffers() {
        super.updateBuffers();
        super.updateBuffers();
        this._gl.bindBuffer(this._gl.ARRAY_BUFFER, this._vertexBuffer);
        this._gl.vertexAttribPointer(this._positionAttribute, 3, this._gl.FLOAT, false, (0, $0a0587bd8b0d58e8$export$5b33f080c7f6c861).SIZE_BYTES, 0);
        this._gl.enableVertexAttribArray(this._positionAttribute);
        this._gl.bindBuffer(this._gl.ELEMENT_ARRAY_BUFFER, this._indexBuffer);
    }
    updateTextures() {
        super.updateTextures();
        this._gl.activeTexture(this._gl.TEXTURE0);
        this._gl.bindTexture(this._gl.TEXTURE_2D, this._texture2D);
    }
}




/*!
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 */ /*!
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 */ class $cf1768f087a3e016$export$ab05abf6f96a5bb1 {
    get isInitialized() {
        return this._isInitialized;
    }
    get axes() {
        return this._axes;
    }
    constructor(core){
        this._core = core;
        this.isVisible = true;
    }
    initializeContext(gl) {
        this._gl = gl;
    }
    update(elapsedTime) {}
    render(elapsedTime, xrFrame) {
        if (this.isInitialized) {
            this._renderGrid();
            this._renderText();
        }
    }
    _renderGrid() {}
    _renderText() {}
}




class $e9fa83a8cf03e87c$export$30e3ee7ba3e49080 extends (0, $cf1768f087a3e016$export$ab05abf6f96a5bb1) {
    get isInitialized() {
        return this._isInitialized && this._main.gridShader.isInitialized && this._main.sdfTextShader.isInitialized && this._main.fonts[this._axes.font.name].isInitialized;
    }
    constructor(core, main, cartesian2dAxes){
        super(core);
        this._main = main;
        this._axes = cartesian2dAxes;
        this._axes.hasChangedCallback = ()=>{
            this._hasChanged = true;
        };
    }
    initializeContext(gl) {
        super.initializeContext(gl);
        const axes = this._axes;
        if (!axes.isInitialized) axes.initialize();
        if (axes.gridVertices) this._createGridBuffers();
        if (axes.textVertices) this._createTextBuffers();
        this._isInitialized = true;
    }
    _createGridBuffers() {
        const axes = this._axes;
        this._gridVertexBuffer = this._gl.createBuffer();
        this._gl.bindBuffer(this._gl.ARRAY_BUFFER, this._gridVertexBuffer);
        this._gl.bufferData(this._gl.ARRAY_BUFFER, axes.gridVertices, this._gl.STATIC_DRAW);
        this._gridIndexBuffer = this._gl.createBuffer();
        this._gl.bindBuffer(this._gl.ELEMENT_ARRAY_BUFFER, this._gridIndexBuffer);
        this._gl.bufferData(this._gl.ELEMENT_ARRAY_BUFFER, axes.gridIndices, this._gl.STATIC_DRAW);
        this._gridBufferSize = axes.gridVertices.byteLength;
        this._core.log.write((0, $4a6417d29706362f$export$243e62d78d3b544d).info, `cartesian2d visual grid buffers created`);
    }
    _createTextBuffers() {
        const axes = this._axes;
        this._textVertexBuffer = this._gl.createBuffer();
        this._gl.bindBuffer(this._gl.ARRAY_BUFFER, this._textVertexBuffer);
        this._gl.bufferData(this._gl.ARRAY_BUFFER, axes.textVertices, this._gl.STATIC_DRAW);
        this._textIndexBuffer = this._gl.createBuffer();
        this._gl.bindBuffer(this._gl.ELEMENT_ARRAY_BUFFER, this._textIndexBuffer);
        this._gl.bufferData(this._gl.ELEMENT_ARRAY_BUFFER, axes.textIndices, this._gl.STATIC_DRAW);
        this._textBufferSize = axes.textVertices.byteLength;
        this._core.log.write((0, $4a6417d29706362f$export$243e62d78d3b544d).info, `cartesian2d visual text buffers created`);
    }
    update(elapsedTime) {
        if (this._hasChanged) {
            this._hasChanged = false;
            const axes = this._axes;
            if (!this._gridVertexBuffer || axes.gridVertices.byteLength > this._gridBufferSize) this._createGridBuffers();
            else {
                this._gl.bindBuffer(this._gl.ARRAY_BUFFER, this._gridVertexBuffer);
                this._gl.bufferSubData(this._gl.ARRAY_BUFFER, 0, axes.gridVertices);
                this._gl.bindBuffer(this._gl.ELEMENT_ARRAY_BUFFER, this._gridIndexBuffer);
                this._gl.bufferSubData(this._gl.ELEMENT_ARRAY_BUFFER, 0, axes.gridIndices);
                this._core.log.write((0, $4a6417d29706362f$export$243e62d78d3b544d).info, `cartesian2d visual grid buffers updated`);
            }
            if (!this._textVertexBuffer || axes.textVertices.byteLength > this._textBufferSize) this._createTextBuffers();
            else {
                this._gl.bindBuffer(this._gl.ARRAY_BUFFER, this._textVertexBuffer);
                this._gl.bufferSubData(this._gl.ARRAY_BUFFER, 0, axes.textVertices);
                this._gl.bindBuffer(this._gl.ELEMENT_ARRAY_BUFFER, this._textIndexBuffer);
                this._gl.bufferSubData(this._gl.ELEMENT_ARRAY_BUFFER, 0, axes.textIndices);
                this._core.log.write((0, $4a6417d29706362f$export$243e62d78d3b544d).info, `cartesian2d visual text buffers updated`);
            }
            this._main.shaderResources.currentProgram = null;
        }
    }
    _renderText() {
        const shader = this._main.sdfTextShader;
        const shaderResources = this._main.shaderResources;
        const axes = this._axes;
        const fontVisual = this._main.fonts[axes.font.name];
        shader.vertexBuffer = this._textVertexBuffer;
        shader.indexBuffer = this._textIndexBuffer;
        shader.texture2D = fontVisual.texture;
        shader.prepare();
        shader.buffer = fontVisual.font.edgeValue / 0xff;
        shader.gamma = axes.gamma;
        shader.borderWidth = axes.textBorderWidth;
        shader.color = axes.textColor || this._core.config.axesTextColor;
        shader.hoverColor = axes.textHoverColor || this._core.config.axesTextHoverColor;
        shader.borderColor = axes.textBorderColor || this._core.config.textBorderColor;
        shader.pickedIdColor = this.pickedIdColor;
        shader.apply();
        let indexCount, indexOffset;
        for(let axisId = 0; axisId < 2; axisId++){
            const orientation = axes.getLabelOrientation(axisId);
            for(let edge = 0; edge < 2; edge++){
                const edgeId = (0, $3ce6ee188e300946$export$7005c9eb6671414d).AXIS_EDGES[axisId][edge];
                if (axes.isEdgeVisible[edgeId]) {
                    if (orientation == (0, $4a6417d29706362f$export$d2304d1f23cf3ace).parallel && axes.getIsLeftToRightHorizontal(edgeId) || orientation == (0, $4a6417d29706362f$export$d2304d1f23cf3ace).perpendicular && axes.getIsLeftToRightVertical(edgeId)) {
                        indexCount = axes.getAxesLeftToRightIndexCount(axisId);
                        indexOffset = axes.getAxesLeftToRightIndexOffset(axisId);
                    } else {
                        indexCount = axes.getAxesRightToLeftIndexCount(axisId);
                        indexOffset = axes.getAxesRightToLeftIndexOffset(axisId);
                    }
                    if (indexCount > 0) {
                        shader.mMatrix = axes.getLabelMMatrix(edgeId);
                        shader.applyModel();
                        shader.isPickShader = false;
                        shaderResources.bindFramebuffer(this.geometryFramebuffer);
                        for(let i = 0; i < this.viewportCount; i++){
                            const viewport = i + this.viewportOffset;
                            this._gl.viewport(this.viewports[viewport].x, this.viewports[viewport].y, this.viewports[viewport].width, this.viewports[viewport].height);
                            shader.vMatrix = this.vMatrices[viewport];
                            shader.pMatrix = this.pMatrices[viewport];
                            shader.applyView();
                            this._gl.drawElements(this._gl.TRIANGLES, indexCount, this._gl.UNSIGNED_SHORT, indexOffset * 2);
                        }
                        if (this.isPickingEnabled && axes.isLabelPickingEnabled[axisId]) {
                            shader.isPickShader = true;
                            shader.pMatrix = this.pickPMatrix;
                            shader.vMatrix = this.pickVMatrix;
                            shader.applyView();
                            shaderResources.bindFramebuffer(this.pickFramebuffer);
                            this._gl.viewport(0, 0, this._core.config.pickWidth, this._core.config.pickHeight);
                            this._gl.drawElements(this._gl.TRIANGLES, indexCount, this._gl.UNSIGNED_SHORT, indexOffset * 2);
                        }
                    }
                    indexCount = axes.getTitleIndexCount(axisId);
                    if (indexCount > 0) {
                        indexOffset = axes.getTitleIndexOffset(axisId);
                        shader.mMatrix = axes.getTitleMMatrix(edgeId);
                        shader.applyModel();
                        shader.isPickShader = false;
                        shaderResources.bindFramebuffer(this.geometryFramebuffer);
                        for(let i = 0; i < this.viewportCount; i++){
                            const viewport = i + this.viewportOffset;
                            this._gl.viewport(this.viewports[viewport].x, this.viewports[viewport].y, this.viewports[viewport].width, this.viewports[viewport].height);
                            shader.vMatrix = this.vMatrices[viewport];
                            shader.pMatrix = this.pMatrices[viewport];
                            shader.applyView();
                            this._gl.drawElements(this._gl.TRIANGLES, indexCount, this._gl.UNSIGNED_SHORT, indexOffset * 2);
                        }
                        if (this.isPickingEnabled && axes.isTitlePickingEnabled[axisId]) {
                            shader.isPickShader = true;
                            shader.pMatrix = this.pickPMatrix;
                            shader.vMatrix = this.pickVMatrix;
                            shader.applyView();
                            shaderResources.bindFramebuffer(this.pickFramebuffer);
                            this._gl.viewport(0, 0, this._core.config.pickWidth, this._core.config.pickHeight);
                            this._gl.drawElements(this._gl.TRIANGLES, indexCount, this._gl.UNSIGNED_SHORT, indexOffset * 2);
                        }
                    }
                }
                indexCount = axes.getHeadingIndexCount(axisId);
                if (indexCount > 0 && axes.isHeadingVisible[edgeId]) {
                    indexOffset = axes.getHeadingIndexOffset(axisId);
                    shader.mMatrix = axes.getHeadingMMatrix(edgeId);
                    shader.applyModel();
                    shader.isPickShader = false;
                    shaderResources.bindFramebuffer(this.geometryFramebuffer);
                    for(let i = 0; i < this.viewportCount; i++){
                        const viewport = i + this.viewportOffset;
                        this._gl.viewport(this.viewports[viewport].x, this.viewports[viewport].y, this.viewports[viewport].width, this.viewports[viewport].height);
                        shader.vMatrix = this.vMatrices[viewport];
                        shader.pMatrix = this.pMatrices[viewport];
                        shader.applyView();
                        this._gl.drawElements(this._gl.TRIANGLES, indexCount, this._gl.UNSIGNED_SHORT, indexOffset * 2);
                    }
                    if (this.isPickingEnabled && axes.isHeadingPickingEnabled[axisId]) {
                        shader.isPickShader = true;
                        shader.pMatrix = this.pickPMatrix;
                        shader.vMatrix = this.pickVMatrix;
                        shader.applyView();
                        shaderResources.bindFramebuffer(this.pickFramebuffer);
                        this._gl.viewport(0, 0, this._core.config.pickWidth, this._core.config.pickHeight);
                        this._gl.drawElements(this._gl.TRIANGLES, indexCount, this._gl.UNSIGNED_SHORT, indexOffset * 2);
                    }
                }
            }
        }
    }
    _renderGrid() {
        const gridShader = this._main.gridShader;
        const axes = this._axes;
        gridShader.vertexBuffer = this._gridVertexBuffer;
        gridShader.indexBuffer = this._gridIndexBuffer;
        gridShader.prepare();
        gridShader.majorThickness = axes.gridMajorThickness;
        gridShader.minorThickness = axes.gridMinorThickness;
        gridShader.zeroThickness = axes.gridZeroThickness;
        gridShader.backgroundColor = axes.gridBackgroundColor || this._core.config.axesGridBackgroundColor;
        gridShader.highlightColor = axes.gridHighlightColor || this._core.config.axesGridHighlightColor;
        gridShader.majorColor = axes.gridMajorColor || this._core.config.axesGridMajorColor;
        gridShader.minorColor = axes.gridMinorColor || this._core.config.axesGridMinorColor;
        gridShader.zeroColor = axes.gridZeroColor || this._core.config.axesGridZeroColor;
        gridShader.pickedIdColor = this.pickedIdColor;
        gridShader.apply();
        for(let axisId = 0; axisId < 2; axisId++)if (axes.arePickDivisionsVisible[axisId]) {
            const gridTicksScale = axes.getGridTicksScale(axisId);
            const width = gridTicksScale[0];
            const height = gridTicksScale[1];
            gridShader.zero = axes.getGridTicksZero(axisId);
            gridShader.minorGridlines = axes.getGridTicksMinorGridlines(axisId);
            for(let edge = 0; edge < 2; edge++){
                const edgeId = (0, $3ce6ee188e300946$export$7005c9eb6671414d).AXIS_EDGES[axisId][edge];
                if (axes.isEdgeVisible[edgeId]) this._renderGridTicks(axisId, edgeId, width, height);
            }
        }
        this._gl.disable(this._gl.CULL_FACE);
        const size = axes.size;
        const axisId2 = 0;
        const axisId3 = 1;
        const width = size[axisId2];
        const height = size[axisId3];
        gridShader.zero = axes.gridFaceZero;
        gridShader.minorGridlines = axes.gridFaceMinorGridlines;
        for(let face = 0; face < 2; face++){
            const faceId = face;
            if (axes.getIsForwardFace(faceId)) this._renderGridFace(faceId, width, height);
        }
        this._gl.enable(this._gl.CULL_FACE);
    }
    _renderGridTicks(axisId, edgeId, width, height) {
        const gridShader = this._main.gridShader;
        const shaderResources = this._main.shaderResources;
        const axes = this._axes;
        gridShader.mMatrix = axes.getGridTicksMMatrix(edgeId);
        gridShader.faceWidth = width;
        gridShader.faceHeight = height;
        gridShader.ApplyFace();
        gridShader.isPickShader = false;
        shaderResources.bindFramebuffer(this.geometryFramebuffer);
        for(let i = 0; i < this.viewportCount; i++){
            const viewport = i + this.viewportOffset;
            this._gl.viewport(this.viewports[viewport].x, this.viewports[viewport].y, this.viewports[viewport].width, this.viewports[viewport].height);
            gridShader.vMatrix = this.vMatrices[viewport];
            gridShader.pMatrix = this.pMatrices[viewport];
            gridShader.applyView();
            this._gl.drawElements(this._gl.TRIANGLES, axes.getGridTicksIndexCount(axisId), this._gl.UNSIGNED_SHORT, axes.getGridTicksIndexOffset(axisId) * 2);
        }
        if (this.isPickingEnabled && axes.isDivisionPickingEnabled[axisId]) {
            gridShader.isPickShader = true;
            gridShader.vMatrix = this.pickVMatrix;
            gridShader.pMatrix = this.pickPMatrix;
            gridShader.applyView();
            shaderResources.bindFramebuffer(this.pickFramebuffer);
            this._gl.viewport(0, 0, this._core.config.pickWidth, this._core.config.pickHeight);
            this._gl.drawElements(this._gl.TRIANGLES, axes.getGridTicksIndexCount(axisId), this._gl.UNSIGNED_SHORT, axes.getGridTicksIndexOffset(axisId) * 2);
        }
    }
    _renderGridFace(faceId, width, height) {
        const gridShader = this._main.gridShader;
        const shaderResources = this._main.shaderResources;
        const axes = this._axes;
        gridShader.mMatrix = axes.getGridFaceMMatrix(faceId);
        gridShader.faceWidth = width;
        gridShader.faceHeight = height;
        gridShader.ApplyFace();
        gridShader.isPickShader = false;
        shaderResources.bindFramebuffer(this.geometryFramebuffer);
        for(let i = 0; i < this.viewportCount; i++){
            const viewport = i + this.viewportOffset;
            this._gl.viewport(this.viewports[viewport].x, this.viewports[viewport].y, this.viewports[viewport].width, this.viewports[viewport].height);
            gridShader.vMatrix = this.vMatrices[viewport];
            gridShader.pMatrix = this.pMatrices[viewport];
            gridShader.applyView();
            this._gl.drawElements(this._gl.TRIANGLES, axes.getGridFaceIndexCount(faceId), this._gl.UNSIGNED_SHORT, axes.getGridFaceIndexOffset(faceId) * 2);
        }
        if (this.isPickingEnabled && axes.isGridPickingEnabled) {
            gridShader.isPickShader = true;
            gridShader.vMatrix = this.pickVMatrix;
            gridShader.pMatrix = this.pickPMatrix;
            gridShader.applyView();
            shaderResources.bindFramebuffer(this.pickFramebuffer);
            this._gl.viewport(0, 0, this._core.config.pickWidth, this._core.config.pickHeight);
            this._gl.drawElements(this._gl.TRIANGLES, axes.getGridFaceIndexCount(faceId), this._gl.UNSIGNED_SHORT, axes.getGridFaceIndexOffset(faceId) * 2);
        }
    }
}


/*!
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 */ 


class $e3e392e891911753$export$3dc3b91df297f2ee extends (0, $cf1768f087a3e016$export$ab05abf6f96a5bb1) {
    get isInitialized() {
        return this._isInitialized && this._main.gridShader.isInitialized && this._main.sdfTextShader.isInitialized && this._main.fonts[this._axes.font.name].isInitialized;
    }
    constructor(core, main, cartesian3dAxes){
        super(core);
        this._main = main;
        this._axes = cartesian3dAxes;
        this._axes.hasChangedCallback = ()=>{
            this._hasChanged = true;
        };
    }
    initializeContext(gl) {
        super.initializeContext(gl);
        const axes = this._axes;
        if (!axes.isInitialized) axes.initialize();
        if (axes.gridVertices) this._createGridBuffers();
        if (axes.textVertices) this._createTextBuffers();
        this._isInitialized = true;
    }
    _createGridBuffers() {
        const axes = this._axes;
        this._gridVertexBuffer = this._gl.createBuffer();
        this._gl.bindBuffer(this._gl.ARRAY_BUFFER, this._gridVertexBuffer);
        this._gl.bufferData(this._gl.ARRAY_BUFFER, axes.gridVertices, this._gl.STATIC_DRAW);
        this._gridIndexBuffer = this._gl.createBuffer();
        this._gl.bindBuffer(this._gl.ELEMENT_ARRAY_BUFFER, this._gridIndexBuffer);
        this._gl.bufferData(this._gl.ELEMENT_ARRAY_BUFFER, axes.gridIndices, this._gl.STATIC_DRAW);
        this._gridBufferSize = axes.gridVertices.byteLength;
        this._core.log.write((0, $4a6417d29706362f$export$243e62d78d3b544d).info, `cartesian3d visual grid buffers created`);
    }
    _createTextBuffers() {
        const axes = this._axes;
        this._textVertexBuffer = this._gl.createBuffer();
        this._gl.bindBuffer(this._gl.ARRAY_BUFFER, this._textVertexBuffer);
        this._gl.bufferData(this._gl.ARRAY_BUFFER, axes.textVertices, this._gl.STATIC_DRAW);
        this._textIndexBuffer = this._gl.createBuffer();
        this._gl.bindBuffer(this._gl.ELEMENT_ARRAY_BUFFER, this._textIndexBuffer);
        this._gl.bufferData(this._gl.ELEMENT_ARRAY_BUFFER, axes.textIndices, this._gl.STATIC_DRAW);
        this._textBufferSize = axes.textVertices.byteLength;
        this._core.log.write((0, $4a6417d29706362f$export$243e62d78d3b544d).info, `cartesian3d visual text buffers created`);
    }
    update(elapsedTime) {
        if (this._hasChanged) {
            this._hasChanged = false;
            const axes = this._axes;
            if (!this._gridVertexBuffer || axes.gridVertices.byteLength > this._gridBufferSize) this._createGridBuffers();
            else {
                this._gl.bindBuffer(this._gl.ARRAY_BUFFER, this._gridVertexBuffer);
                this._gl.bufferSubData(this._gl.ARRAY_BUFFER, 0, axes.gridVertices);
                this._gl.bindBuffer(this._gl.ELEMENT_ARRAY_BUFFER, this._gridIndexBuffer);
                this._gl.bufferSubData(this._gl.ELEMENT_ARRAY_BUFFER, 0, axes.gridIndices);
                this._core.log.write((0, $4a6417d29706362f$export$243e62d78d3b544d).info, `cartesian3d visual grid buffers updated`);
            }
            if (!this._textVertexBuffer || axes.textVertices.byteLength > this._textBufferSize) this._createTextBuffers();
            else {
                this._gl.bindBuffer(this._gl.ARRAY_BUFFER, this._textVertexBuffer);
                this._gl.bufferSubData(this._gl.ARRAY_BUFFER, 0, axes.textVertices);
                this._gl.bindBuffer(this._gl.ELEMENT_ARRAY_BUFFER, this._textIndexBuffer);
                this._gl.bufferSubData(this._gl.ELEMENT_ARRAY_BUFFER, 0, axes.textIndices);
                this._core.log.write((0, $4a6417d29706362f$export$243e62d78d3b544d).info, `cartesian3d visual text buffers updated`);
            }
            this._main.shaderResources.currentProgram = null;
        }
    }
    _renderText() {
        const axes = this._axes;
        const shader = this._main.sdfTextShader;
        const shaderResources = this._main.shaderResources;
        const fontVisual = this._main.fonts[axes.font.name];
        shader.vertexBuffer = this._textVertexBuffer;
        shader.indexBuffer = this._textIndexBuffer;
        shader.texture2D = fontVisual.texture;
        shader.prepare();
        shader.buffer = fontVisual.font.edgeValue / 0xff;
        shader.gamma = axes.gamma;
        shader.borderWidth = axes.textBorderWidth;
        shader.color = axes.textColor || this._core.config.axesTextColor;
        shader.hoverColor = axes.textHoverColor || this._core.config.axesTextHoverColor;
        shader.borderColor = axes.textBorderColor || this._core.config.textBorderColor;
        shader.pickedIdColor = this.pickedIdColor;
        shader.apply();
        let indexCount, indexOffset;
        for(let axisId = 0; axisId < 3; axisId++){
            const orientation = axes.getLabelOrientation(axisId);
            for(let edge = 0; edge < 4; edge++){
                const edgeId = (0, $c2c30e4dcf8004c5$export$a15f0a83a652dd40).AXIS_EDGES[axisId][edge];
                if (axes.getIsOutsideEdge(edgeId)) {
                    if (axes.isEdgeVisible[edgeId]) {
                        if (orientation == (0, $4a6417d29706362f$export$d2304d1f23cf3ace).parallel && axes.getIsLeftToRightHorizontal(edgeId) || orientation == (0, $4a6417d29706362f$export$d2304d1f23cf3ace).perpendicular && axes.getIsLeftToRightVertical(edgeId)) {
                            indexCount = axes.getAxesLeftToRightIndexCount(axisId);
                            indexOffset = axes.getAxesLeftToRightIndexOffset(axisId);
                        } else {
                            indexCount = axes.getAxesRightToLeftIndexCount(axisId);
                            indexOffset = axes.getAxesRightToLeftIndexOffset(axisId);
                        }
                        if (indexCount > 0) {
                            shader.mMatrix = axes.getLabelMMatrix(edgeId);
                            shader.applyModel();
                            shader.isPickShader = false;
                            shaderResources.bindFramebuffer(this.geometryFramebuffer);
                            for(let i = 0; i < this.viewportCount; i++){
                                const viewport = i + this.viewportOffset;
                                this._gl.viewport(this.viewports[viewport].x, this.viewports[viewport].y, this.viewports[viewport].width, this.viewports[viewport].height);
                                shader.vMatrix = this.vMatrices[viewport];
                                shader.pMatrix = this.pMatrices[viewport];
                                shader.applyView();
                                this._gl.drawElements(this._gl.TRIANGLES, indexCount, this._gl.UNSIGNED_SHORT, indexOffset * 2);
                            }
                            if (this.isPickingEnabled && axes.isLabelPickingEnabled[axisId]) {
                                shader.isPickShader = true;
                                shader.pMatrix = this.pickPMatrix;
                                shader.vMatrix = this.pickVMatrix;
                                shader.applyView();
                                shaderResources.bindFramebuffer(this.pickFramebuffer);
                                this._gl.viewport(0, 0, this._core.config.pickWidth, this._core.config.pickHeight);
                                this._gl.drawElements(this._gl.TRIANGLES, indexCount, this._gl.UNSIGNED_SHORT, indexOffset * 2);
                            }
                        }
                        indexCount = axes.getTitleIndexCount(axisId);
                        if (indexCount > 0) {
                            indexOffset = axes.getTitleIndexOffset(axisId);
                            shader.mMatrix = axes.getTitleMMatrix(edgeId);
                            shader.applyModel();
                            shader.isPickShader = false;
                            shaderResources.bindFramebuffer(this.geometryFramebuffer);
                            for(let i = 0; i < this.viewportCount; i++){
                                const viewport = i + this.viewportOffset;
                                this._gl.viewport(this.viewports[viewport].x, this.viewports[viewport].y, this.viewports[viewport].width, this.viewports[viewport].height);
                                shader.vMatrix = this.vMatrices[viewport];
                                shader.pMatrix = this.pMatrices[viewport];
                                shader.applyView();
                                this._gl.drawElements(this._gl.TRIANGLES, indexCount, this._gl.UNSIGNED_SHORT, indexOffset * 2);
                            }
                            if (this.isPickingEnabled && axes.isTitlePickingEnabled[axisId]) {
                                shader.isPickShader = true;
                                shader.pMatrix = this.pickPMatrix;
                                shader.vMatrix = this.pickVMatrix;
                                shader.applyView();
                                shaderResources.bindFramebuffer(this.pickFramebuffer);
                                this._gl.viewport(0, 0, this._core.config.pickWidth, this._core.config.pickHeight);
                                this._gl.drawElements(this._gl.TRIANGLES, indexCount, this._gl.UNSIGNED_SHORT, indexOffset * 2);
                            }
                        }
                    }
                    indexCount = axes.getHeadingIndexCount(axisId);
                    if (indexCount > 0 && axes.isHeadingVisible[edgeId]) {
                        indexOffset = axes.getHeadingIndexOffset(axisId);
                        shader.mMatrix = axes.getHeadingMMatrix(edgeId);
                        shader.applyModel();
                        shader.isPickShader = false;
                        shaderResources.bindFramebuffer(this.geometryFramebuffer);
                        for(let i = 0; i < this.viewportCount; i++){
                            const viewport = i + this.viewportOffset;
                            this._gl.viewport(this.viewports[viewport].x, this.viewports[viewport].y, this.viewports[viewport].width, this.viewports[viewport].height);
                            shader.vMatrix = this.vMatrices[viewport];
                            shader.pMatrix = this.pMatrices[viewport];
                            shader.applyView();
                            this._gl.drawElements(this._gl.TRIANGLES, indexCount, this._gl.UNSIGNED_SHORT, indexOffset * 2);
                        }
                        if (this.isPickingEnabled && axes.isHeadingPickingEnabled[axisId]) {
                            shader.isPickShader = true;
                            shader.pMatrix = this.pickPMatrix;
                            shader.vMatrix = this.pickVMatrix;
                            shader.applyView();
                            shaderResources.bindFramebuffer(this.pickFramebuffer);
                            this._gl.viewport(0, 0, this._core.config.pickWidth, this._core.config.pickHeight);
                            this._gl.drawElements(this._gl.TRIANGLES, indexCount, this._gl.UNSIGNED_SHORT, indexOffset * 2);
                        }
                    }
                }
            }
        }
    }
    _renderGrid() {
        const axes = this._axes;
        const gridShader = this._main.gridShader;
        gridShader.vertexBuffer = this._gridVertexBuffer;
        gridShader.indexBuffer = this._gridIndexBuffer;
        gridShader.prepare();
        gridShader.majorThickness = axes.gridMajorThickness;
        gridShader.minorThickness = axes.gridMinorThickness;
        gridShader.zeroThickness = axes.gridZeroThickness;
        gridShader.backgroundColor = axes.gridBackgroundColor || this._core.config.axesGridBackgroundColor;
        gridShader.highlightColor = axes.gridHighlightColor || this._core.config.axesGridHighlightColor;
        gridShader.majorColor = axes.gridMajorColor || this._core.config.axesGridMajorColor;
        gridShader.minorColor = axes.gridMinorColor || this._core.config.axesGridMinorColor;
        gridShader.zeroColor = axes.gridZeroColor || this._core.config.axesGridZeroColor;
        gridShader.pickedIdColor = this.pickedIdColor;
        gridShader.apply();
        for(let axisId = 0; axisId < 3; axisId++)if (axes.arePickDivisionsVisible[axisId]) {
            const gridTicksScale = axes.getGridTicksScale(axisId);
            const width = gridTicksScale[0];
            const height = gridTicksScale[1];
            gridShader.zero = axes.getGridTicksZero(axisId);
            gridShader.minorGridlines = axes.getGridTicksMinorGridlines(axisId);
            for(let edge = 0; edge < 4; edge++){
                const edgeId = (0, $c2c30e4dcf8004c5$export$a15f0a83a652dd40).AXIS_EDGES[axisId][edge];
                if (axes.getIsOutsideEdge(edgeId) && axes.isEdgeVisible[edgeId]) this._renderGridTicks(axisId, edgeId, width, height);
            }
        }
        this._gl.disable(this._gl.CULL_FACE);
        const size = axes.size;
        for(let axisId = 0; axisId < 3; axisId++)if (axes.areFacesVisible[axisId]) {
            const axisId2 = axisId == 0 ? 1 : 0;
            const axisId3 = axisId == 2 ? 1 : 2;
            const width = size[axisId2];
            const height = size[axisId3];
            gridShader.zero = axes.getGridFaceZero(axisId);
            gridShader.minorGridlines = axes.getGridFaceMinorGridlines(axisId);
            for(let face = 0; face < 2; face++){
                const faceId = (0, $c2c30e4dcf8004c5$export$a15f0a83a652dd40).AXIS_FACES[axisId][face];
                if (axes.getIsForwardFace(faceId) && axes.isFaceVisible[faceId]) this._renderGridFace(faceId, width, height);
            }
        }
        this._gl.enable(this._gl.CULL_FACE);
    }
    _renderGridTicks(axisId, edgeId, width, height) {
        const axes = this._axes;
        const gridShader = this._main.gridShader;
        const shaderResources = this._main.shaderResources;
        gridShader.mMatrix = axes.getGridTicksMMatrix(edgeId);
        gridShader.faceWidth = width;
        gridShader.faceHeight = height;
        gridShader.ApplyFace();
        gridShader.isPickShader = false;
        shaderResources.bindFramebuffer(this.geometryFramebuffer);
        for(let i = 0; i < this.viewportCount; i++){
            const viewport = i + this.viewportOffset;
            this._gl.viewport(this.viewports[viewport].x, this.viewports[viewport].y, this.viewports[viewport].width, this.viewports[viewport].height);
            gridShader.vMatrix = this.vMatrices[viewport];
            gridShader.pMatrix = this.pMatrices[viewport];
            gridShader.applyView();
            this._gl.drawElements(this._gl.TRIANGLES, axes.getGridTicksIndexCount(axisId), this._gl.UNSIGNED_SHORT, axes.getGridTicksIndexOffset(axisId) * 2);
        }
        if (this.isPickingEnabled && axes.isDivisionPickingEnabled[axisId]) {
            gridShader.isPickShader = true;
            gridShader.vMatrix = this.pickVMatrix;
            gridShader.pMatrix = this.pickPMatrix;
            gridShader.applyView();
            shaderResources.bindFramebuffer(this.pickFramebuffer);
            this._gl.viewport(0, 0, this._core.config.pickWidth, this._core.config.pickHeight);
            this._gl.drawElements(this._gl.TRIANGLES, axes.getGridTicksIndexCount(axisId), this._gl.UNSIGNED_SHORT, axes.getGridTicksIndexOffset(axisId) * 2);
        }
    }
    _renderGridFace(faceId, width, height) {
        const axes = this._axes;
        const gridShader = this._main.gridShader;
        const shaderResources = this._main.shaderResources;
        gridShader.mMatrix = axes.getGridFaceMMatrix(faceId);
        gridShader.faceWidth = width;
        gridShader.faceHeight = height;
        gridShader.ApplyFace();
        gridShader.isPickShader = false;
        shaderResources.bindFramebuffer(this.geometryFramebuffer);
        for(let i = 0; i < this.viewportCount; i++){
            const viewport = i + this.viewportOffset;
            this._gl.viewport(this.viewports[viewport].x, this.viewports[viewport].y, this.viewports[viewport].width, this.viewports[viewport].height);
            gridShader.vMatrix = this.vMatrices[viewport];
            gridShader.pMatrix = this.pMatrices[viewport];
            gridShader.applyView();
            this._gl.drawElements(this._gl.TRIANGLES, axes.getGridFaceIndexCount(faceId), this._gl.UNSIGNED_SHORT, axes.getGridFaceIndexOffset(faceId) * 2);
        }
        if (this.isPickingEnabled && axes.isGridPickingEnabled) {
            gridShader.isPickShader = true;
            gridShader.vMatrix = this.pickVMatrix;
            gridShader.pMatrix = this.pickPMatrix;
            gridShader.applyView();
            shaderResources.bindFramebuffer(this.pickFramebuffer);
            this._gl.viewport(0, 0, this._core.config.pickWidth, this._core.config.pickHeight);
            this._gl.drawElements(this._gl.TRIANGLES, axes.getGridFaceIndexCount(faceId), this._gl.UNSIGNED_SHORT, axes.getGridFaceIndexOffset(faceId) * 2);
        }
    }
}


/*!
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 */ 

class $24cf6d98e6e0d82f$export$e784a6eab4d2d700 {
    get isInitialized() {
        return this._isInitialized;
    }
    get font() {
        return this._font;
    }
    constructor(core, font){
        this._core = core;
        this._font = font;
        font.hasChangedCallback = ()=>{
            this._hasChanged = true;
        };
    }
    initializeContext(gl) {
        this._gl = gl;
        this._isInitialized = true;
        if (this._font.count > 0) this._hasChanged = true;
    }
    update() {
        if (this._hasChanged && this._isInitialized) {
            this._hasChanged = false;
            this.texture = (0, $a25f5529f6cda489$export$c41e4fcbf45db179).fromImage(this._gl, this._font.atlas.imageData, false, this._gl.LINEAR);
            this._core.log.write((0, $4a6417d29706362f$export$243e62d78d3b544d).info, `${this._font.name} texture updated`);
        }
    }
}






/*!
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 */ 
class $de477c17b1036dd4$var$LabelVisualBase {
    get isInitialized() {
        return this._isInitialized && this._main.sdfTextShader.isInitialized && this._main.fonts[this._label.font.name].isInitialized;
    }
    constructor(core, main, label){
        this._core = core;
        this._main = main;
        this._label = label;
        this._label.hasChangedCallback = ()=>{
            this._hasChanged = true;
        };
        this._mMatrix = (0, $1ac1b59392edf35b$exports).create();
        this.mMatrix = (0, $1ac1b59392edf35b$exports).create();
        this.isVisible = true;
    }
    initializeContext(gl) {
        if (!this._label.isInitialized) this._label.initialize();
        this._gl = gl;
        this._vertexBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, this._vertexBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, this._label.vertices, gl.STATIC_DRAW);
        this._indexBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this._indexBuffer);
        gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, this._label.indices, gl.STATIC_DRAW);
        this._isInitialized = true;
    }
    update(elapsedTime) {
        if (this._hasChanged) {
            this._hasChanged = false;
            this._gl.bindBuffer(this._gl.ARRAY_BUFFER, this._vertexBuffer);
            this._gl.bufferSubData(this._gl.ARRAY_BUFFER, 0, this._label.vertices);
            this._gl.bindBuffer(this._gl.ELEMENT_ARRAY_BUFFER, this._indexBuffer);
            this._gl.bufferSubData(this._gl.ELEMENT_ARRAY_BUFFER, 0, this._label.indices);
        }
    }
    render(elapsedTime, xrFrame) {
        if (this.isInitialized) {
            const indexCount = this._label.indexCount;
            if (indexCount > 0) {
                const shader = this._main.sdfTextShader;
                const fontVisual = this._main.fonts[this._label.font.name];
                shader.vertexBuffer = this._vertexBuffer;
                shader.indexBuffer = this._indexBuffer;
                shader.texture2D = fontVisual.texture;
                shader.prepare();
                shader.gamma = this._label.gamma;
                shader.buffer = fontVisual.font.edgeValue / 0xff;
                shader.borderWidth = this._label.borderWidth;
                shader.color = this._label.color || this._core.config.textColor;
                shader.borderColor = this._label.borderColor || this._core.config.textBorderColor;
                shader.hoverColor = this._label.hoverColor || this._core.config.textHoverColor;
                shader.pickedIdColor = this.pickedIdColor;
                shader.apply();
                (0, $1ac1b59392edf35b$exports).multiply(this._mMatrix, this.mMatrix, this._label.mMatrix);
                shader.mMatrix = this._mMatrix;
                shader.applyModel();
                shader.isPickShader = false;
                this._main.shaderResources.bindFramebuffer(this.geometryFramebuffer);
                for(let i = 0; i < this.viewportCount; i++){
                    const viewport = i + this.viewportOffset;
                    this._gl.viewport(this.viewports[viewport].x, this.viewports[viewport].y, this.viewports[viewport].width, this.viewports[viewport].height);
                    shader.vMatrix = this.vMatrices[viewport];
                    shader.pMatrix = this.pMatrices[viewport];
                    shader.applyView();
                    this._gl.drawElements(this._gl.TRIANGLES, indexCount, this._gl.UNSIGNED_SHORT, 0);
                }
                if (this.isPickingEnabled) {
                    shader.isPickShader = true;
                    shader.pMatrix = this.pickPMatrix;
                    shader.vMatrix = this.pickVMatrix;
                    shader.applyView();
                    this._main.shaderResources.bindFramebuffer(this.pickFramebuffer);
                    this._gl.viewport(0, 0, this._core.config.pickWidth, this._core.config.pickHeight);
                    this._gl.drawElements(this._gl.TRIANGLES, indexCount, this._gl.UNSIGNED_SHORT, 0);
                }
            }
        }
    }
}
class $de477c17b1036dd4$export$71c7fa1581020e2c extends $de477c17b1036dd4$var$LabelVisualBase {
    get label() {
        return this._label;
    }
    set text(value) {
        this._label.text = value;
    }
    get text() {
        return this._label.text;
    }
    constructor(core, main, label){
        super(core, main, label);
    }
}
class $de477c17b1036dd4$export$97e93e7019ef67b9 extends $de477c17b1036dd4$var$LabelVisualBase {
    get label() {
        return this._label;
    }
    constructor(core, main, label){
        super(core, main, label);
    }
}


/*!
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 */ 

class $8a9611d4c44522de$export$6f251cd327b2ff1 {
    get isInitialized() {
        return this._isInitialized && this._main.textureShader.isInitialized;
    }
    get image() {
        return this._image;
    }
    constructor(core, main, image){
        this._core = core;
        this._main = main;
        this._image = image;
        this._image.hasChangedCallback = ()=>{
            this._hasChanged = true;
        };
        this.mMatrix = (0, $1ac1b59392edf35b$exports).create();
        this.isVisible = true;
    }
    initializeContext(gl) {
        if (!this._image.isInitialized) this._image.initialize();
        this._gl = gl;
        if (this._image.imageData) this.texture = (0, $a25f5529f6cda489$export$c41e4fcbf45db179).fromImage(gl, this._image.imageData, false, gl.LINEAR);
        this._vertexBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, this._vertexBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, this._image.vertices, gl.STATIC_DRAW);
        this._indexBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this._indexBuffer);
        gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, this._image.indices, gl.STATIC_DRAW);
        this._isInitialized = true;
    }
    update(elapsedTime) {
        if (this._hasChanged) {
            this._hasChanged = false;
            this._gl.bindBuffer(this._gl.ARRAY_BUFFER, this._vertexBuffer);
            this._gl.bufferSubData(this._gl.ARRAY_BUFFER, 0, this._image.vertices);
            this._main.shaderResources.currentProgram = null;
        }
    }
    render(elapsedTime, xrFrame) {
        if (this.isInitialized) {
            const textureShader = this._main.textureShader;
            textureShader.vertexBuffer = this._vertexBuffer;
            textureShader.indexBuffer = this._indexBuffer;
            textureShader.texture2D = this.texture;
            textureShader.prepare();
            textureShader.mMatrix = this.mMatrix;
            textureShader.apply();
            this._main.shaderResources.bindFramebuffer(this.geometryFramebuffer);
            for(let i = 0; i < this.viewportCount; i++){
                const viewport = i + this.viewportOffset;
                this._gl.viewport(this.viewports[viewport].x, this.viewports[viewport].y, this.viewports[viewport].width, this.viewports[viewport].height);
                textureShader.vMatrix = this.vMatrices[viewport];
                textureShader.pMatrix = this.pMatrices[viewport];
                textureShader.applyView();
                this._gl.drawElements(this._gl.TRIANGLES, this._image.indexCount, this._gl.UNSIGNED_SHORT, 0);
            }
        }
    }
}


/*!
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 */ 

class $16ac0b4583f1f008$export$dc8af347244861ce {
    get isInitialized() {
        return this._isInitialized;
    }
    get vertexBuffer() {
        return this._vertexBuffer;
    }
    get indexBuffer() {
        return this._indexBuffer;
    }
    get indexCount() {
        return this._indexCount;
    }
    initializeContext(gl) {
        const vertices = (0, $3ce6ee188e300946$export$7005c9eb6671414d).textured((0, $d4d7bd6cc65a5081$export$a002182e51710d39).MAT4_IDENTITY);
        this._vertexBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, this._vertexBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW);
        const indices = (0, $3ce6ee188e300946$export$7005c9eb6671414d).INDICES;
        this._indexBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this._indexBuffer);
        gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, indices, gl.STATIC_DRAW);
        this._indexCount = indices.length;
        this._isInitialized = true;
    }
}


var $8e6261810f478ee0$var$__awaiter = undefined && undefined.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
            resolve(value);
        });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
            try {
                step(generator.next(value));
            } catch (e) {
                reject(e);
            }
        }
        function rejected(value) {
            try {
                step(generator["throw"](value));
            } catch (e) {
                reject(e);
            }
        }
        function step(result) {
            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
class $8e6261810f478ee0$export$861edd1ccea2f746 extends (0, $a123db7d2af0bebc$export$30686c90897c890d) {
    get shaderResources() {
        return this._shaderResources;
    }
    get textureShader() {
        return this._textureShader;
    }
    get lassoShader() {
        return this._lassoShader;
    }
    get sdfTextShader() {
        return this._sdfTextShader;
    }
    get gridShader() {
        return this._gridShader;
    }
    get blockShader() {
        return this._blockShader;
    }
    get sphereShader() {
        return this._sphereShader;
    }
    get cyclinderShader() {
        return this._cylinderShader;
    }
    get sdfShader() {
        return this._sdfShader;
    }
    get currentAxes() {
        return this._isAxes1Current ? this._axes1 : this._axes2;
    }
    set currentAxes(value) {
        if (this._isAxes1Current) this._axes1 = value;
        else this._axes2 = value;
    }
    get previousAxes() {
        return this._isAxes1Current ? this._axes2 : this._axes1;
    }
    set previousAxes(value) {
        if (this._isAxes1Current) this._axes2 = value;
        else this._axes1 = value;
    }
    get config() {
        return this._config;
    }
    constructor(options){
        super(options);
        this._config = new (0, $115d7df89ed6abb3$export$29cd7b75162a9425)();
        this._quad = new (0, $046a802c77c0a655$export$7005c9eb6671414d)();
        this._lasso = new (0, $16ac0b4583f1f008$export$dc8af347244861ce)();
        this._pickedPixels = new Uint8Array(4);
        this._pickedIdColor = (0, $4c4ac78b213a9c07$exports).create();
        this._position = (0, $31054a6c69637582$exports).create();
        this._direction = (0, $31054a6c69637582$exports).create();
        this._cameraRotation = (0, $ba3ca37806a2b6fa$exports).create();
        this._cameraPosition = (0, $31054a6c69637582$exports).create();
        this._modelPosition = (0, $31054a6c69637582$exports).create();
        this._modelManipulationOrigin = (0, $31054a6c69637582$exports).create();
        this._shadowVMatrix = (0, $1ac1b59392edf35b$exports).create();
        this._shadowPMatrix = (0, $1ac1b59392edf35b$exports).create();
    }
    get isSupported() {
        return this._createContext(document.createElement("canvas")) !== null;
    }
    initialize(core) {
        super.initialize(core);
        this._shaderResources = new (0, $a9df2cd8c496e87d$export$e9a269813a6315a4)();
        this._textureShader = new (0, $f429c522f972f41c$export$5431306cf43de24a)(core, this);
        this._lassoShader = new (0, $07302b7e66b98ad4$export$dc8af347244861ce)(core, this);
        this._sdfTextShader = new (0, $5096a2d574b69029$export$a3be0de02f08c3be)(core, this);
        this._gridShader = new (0, $0d68a84ac7ce9cae$export$3b812729b68dda3e)(core, this);
        this._blockShader = new (0, $10a1c9b35469ca2f$export$b72dd5e86522410a)(core, this);
        this._sphereShader = new (0, $8e9c2eab8262cc5c$export$427a5e80ce652e7d)(core, this);
        this._cylinderShader = new (0, $b02a2d0d38a17398$export$28e50bed796372f2)(core, this);
        this._sdfShader = new (0, $033aeb83f2353e26$export$b0bdf50006eaaa7a)(core, this);
        this._backgroundShader = new (0, $f3c682691ac3327e$export$668799e4797757a8)(core, this);
        this._ssaoShader = new (0, $00574d18b13d37d0$export$9aeffd51459d3d9)(core, this);
        this._boxShader = new (0, $1f3dda2230720917$export$e71c4d32a2263218)(core, this);
        this._deferredShader = new (0, $190597e9b40588c3$export$85f6557964517f1a)(core, this);
        this._combineShader = new (0, $5b394f278f6c99db$export$42b7cecdce1e9ecc)(core, this);
        this._dofBlurShader = new (0, $3c55280ad494aadd$export$3edb5030712765fa)(core, this);
        this._downsampleShader = new (0, $903b38bcb9c6df3c$export$fce67a054bb06d73)(core, this);
        this._gaussianShader = new (0, $1f52e628cc3ed829$export$2cae02e4a50f2cda)(core, this);
        this._dofCombineShader = new (0, $096272391683d440$export$ff3d2a706a946a2)(core, this);
        this._fxaaShader = new (0, $ca1e5eb7e900b291$export$9a81f906983b6bc8)(core, this);
        this._brightPassShader = new (0, $4aa6b658ca80a4c6$export$2898c0abb0413fac)(core, this);
        this._initializeContext(this._createContext(this._canvas));
        this._canvas.addEventListener("webglcontextlost", (event)=>{
            this._core.log.write((0, $4a6417d29706362f$export$243e62d78d3b544d).warn, "WebGL context lost");
            event.preventDefault();
        }, false);
        this._canvas.addEventListener("webglcontextrestored", ()=>{
            this._initializeContext(this._createContext(this._canvas));
            this._core.log.write((0, $4a6417d29706362f$export$243e62d78d3b544d).info, "WebGL context restored");
        }, false);
        this._isInitialized = true;
    }
    _initializeContext(gl) {
        this._gl = gl;
        for(const key in this.fonts){
            const fontVisual = this.fonts[key];
            fontVisual.initializeContext(gl);
        }
        this._ssaoSampleKernel = new Float32Array(this._config.ssaoKernelSize * 3);
        const random = new (0, $2d4d1eb6f32f02f2$export$b8e288c3467acb0e)(0);
        const _vec3 = (0, $31054a6c69637582$exports).create();
        for(let i = 0; i < this._config.ssaoKernelSize; i++){
            _vec3[0] = random.nextFloat() * 2 - 1;
            _vec3[1] = random.nextFloat() * 2 - 1;
            _vec3[2] = random.nextFloat();
            (0, $31054a6c69637582$exports).normalize(_vec3, _vec3);
            (0, $31054a6c69637582$exports).scale(_vec3, _vec3, random.nextFloat());
            let scale = i / this._config.ssaoKernelSize;
            scale = (0, $2d4d1eb6f32f02f2$export$80a8c44b8858d625).lerp(0.1, 1, scale * scale);
            (0, $31054a6c69637582$exports).scale(_vec3, _vec3, scale);
            this._ssaoSampleKernel[i * 3] = _vec3[0];
            this._ssaoSampleKernel[i * 3 + 1] = _vec3[1];
            this._ssaoSampleKernel[i * 3 + 2] = _vec3[2];
        }
        const noise = new Float32Array(this._config.ssaoNoiseSize * this._config.ssaoNoiseSize * 4);
        _vec3[2] = 0;
        for(let i = 0; i < this._config.ssaoNoiseSize * this._config.ssaoNoiseSize; i++){
            _vec3[0] = random.nextFloat() * 2 - 1;
            _vec3[1] = random.nextFloat() * 2 - 1;
            (0, $31054a6c69637582$exports).normalize(_vec3, _vec3);
            noise[i * 4] = _vec3[0];
            noise[i * 4 + 1] = _vec3[1];
        }
        this._ssaoNoiseTexture = this._gl.createTexture();
        this._gl.bindTexture(this._gl.TEXTURE_2D, this._ssaoNoiseTexture);
        this._gl.texParameteri(this._gl.TEXTURE_2D, this._gl.TEXTURE_WRAP_S, this._gl.REPEAT);
        this._gl.texParameteri(this._gl.TEXTURE_2D, this._gl.TEXTURE_WRAP_T, this._gl.REPEAT);
        this._gl.texParameteri(this._gl.TEXTURE_2D, this._gl.TEXTURE_MIN_FILTER, this._gl.NEAREST);
        this._gl.texParameteri(this._gl.TEXTURE_2D, this._gl.TEXTURE_MAG_FILTER, this._gl.NEAREST);
        this._gl.texImage2D(this._gl.TEXTURE_2D, 0, this._gl.RGBA32F, this._config.ssaoNoiseSize, this._config.ssaoNoiseSize, 0, this._gl.RGBA, this._gl.FLOAT, noise);
        this._ssaoWidth = -1;
        this._ssaoHeight = -1;
        this._shadowWidth = -1;
        this._shadowHeight = -1;
        this._shaderResources.initializeContext(this._gl);
        this._textureShader.initializeContext(this._gl);
        this._lassoShader.initializeContext(this._gl);
        this._sdfTextShader.initializeContext(this._gl);
        this._gridShader.initializeContext(this._gl);
        this._blockShader.initializeContext(this._gl);
        this._sphereShader.initializeContext(this._gl);
        this._cylinderShader.initializeContext(this._gl);
        this._sdfShader.initializeContext(this._gl);
        this._backgroundShader.initializeContext(this._gl);
        this._ssaoShader.initializeContext(this._gl);
        this._boxShader.initializeContext(this._gl);
        this._deferredShader.initializeContext(this._gl);
        this._combineShader.initializeContext(this._gl);
        this._dofBlurShader.initializeContext(this._gl);
        this._downsampleShader.initializeContext(this._gl);
        this._gaussianShader.initializeContext(this._gl);
        this._dofCombineShader.initializeContext(this._gl);
        this._fxaaShader.initializeContext(this._gl);
        this._brightPassShader.initializeContext(this._gl);
        this._quad.initializeContext(this._gl);
        this._lasso.initializeContext(this._gl);
        this._framebuffers = [
            null,
            null
        ];
        const texture = (0, $a25f5529f6cda489$export$c41e4fcbf45db179).create(this._gl, this._core.config.pickWidth, this._core.config.pickHeight, this._gl.RGBA, this._gl.UNSIGNED_BYTE, this._gl.LINEAR, null);
        const renderBuffer = this._gl.createRenderbuffer();
        this._gl.bindRenderbuffer(this._gl.RENDERBUFFER, renderBuffer);
        this._gl.renderbufferStorage(this._gl.RENDERBUFFER, this._gl.DEPTH_COMPONENT24, this._core.config.pickWidth, this._core.config.pickHeight);
        const framebuffer = this._gl.createFramebuffer();
        this._shaderResources.bindFramebuffer(framebuffer);
        this._gl.framebufferTexture2D(this._gl.FRAMEBUFFER, this._gl.COLOR_ATTACHMENT0, this._gl.TEXTURE_2D, texture, 0);
        this._gl.framebufferRenderbuffer(this._gl.FRAMEBUFFER, this._gl.DEPTH_ATTACHMENT, this._gl.RENDERBUFFER, renderBuffer);
        this._pickFrameBuffer = framebuffer;
        for(let i = 0; i < this.transitionBuffers.length; i++)this.transitionBuffers[i].initializeContext(this._gl);
        if (this._axes1) for(let i = 0; i < this._axes1.length; i++)this._axes1[i].initializeContext(this._gl);
        if (this._axes2) for(let i = 0; i < this._axes2.length; i++)this._axes2[i].initializeContext(this._gl);
        for(let i = 0; i < this.labelSets.length; i++)this.labelSets[i].initializeContext(this._gl);
        for(let i = 0; i < this.images.length; i++)this.images[i].initializeContext(this._gl);
    }
    _resize(width, height) {
        super._resize(width, height);
        this._positionTexture = (0, $a25f5529f6cda489$export$c41e4fcbf45db179).create(this._gl, width, height, this._gl.RGBA, this._gl.FLOAT, this._gl.NEAREST, null, this._gl.RGBA32F);
        this._colorTexture = (0, $a25f5529f6cda489$export$c41e4fcbf45db179).create(this._gl, width, height, this._gl.RGBA, this._gl.FLOAT, this._gl.LINEAR, null, this._gl.RGBA32F);
        this._normalTexture = (0, $a25f5529f6cda489$export$c41e4fcbf45db179).create(this._gl, width, height, this._gl.RGBA, this._gl.FLOAT, this._gl.LINEAR, null, this._gl.RGBA32F);
        this._geometryFrameBuffer = this._gl.createFramebuffer();
        this._shaderResources.bindFramebuffer(this._geometryFrameBuffer);
        this._gl.framebufferTexture2D(this._gl.FRAMEBUFFER, this._gl.COLOR_ATTACHMENT0, this._gl.TEXTURE_2D, this._positionTexture, 0);
        this._gl.framebufferTexture2D(this._gl.FRAMEBUFFER, this._gl.COLOR_ATTACHMENT1, this._gl.TEXTURE_2D, this._colorTexture, 0);
        this._gl.framebufferTexture2D(this._gl.FRAMEBUFFER, this._gl.COLOR_ATTACHMENT2, this._gl.TEXTURE_2D, this._normalTexture, 0);
        const renderBuffer = this._gl.createRenderbuffer();
        this._gl.bindRenderbuffer(this._gl.RENDERBUFFER, renderBuffer);
        this._gl.renderbufferStorage(this._gl.RENDERBUFFER, this._gl.DEPTH_COMPONENT24, width, height);
        this._gl.framebufferRenderbuffer(this._gl.FRAMEBUFFER, this._gl.DEPTH_ATTACHMENT, this._gl.RENDERBUFFER, renderBuffer);
        this._gl.drawBuffers([
            this._gl.COLOR_ATTACHMENT0,
            this._gl.COLOR_ATTACHMENT1,
            this._gl.COLOR_ATTACHMENT2
        ]);
        this._postProcessTexture1 = (0, $a25f5529f6cda489$export$c41e4fcbf45db179).create(this._gl, width, height, this._gl.RGBA, this._gl.FLOAT, this._gl.LINEAR, null, this._gl.RGBA32F);
        this._postProcessDepthTexture = (0, $a25f5529f6cda489$export$c41e4fcbf45db179).create(this._gl, width, height, this._gl.DEPTH_COMPONENT, this._gl.UNSIGNED_INT, this._gl.NEAREST, null, this._gl.DEPTH_COMPONENT24);
        this._postProcessFrameBuffer1 = this._gl.createFramebuffer();
        this._gl.bindFramebuffer(this._gl.FRAMEBUFFER, this._postProcessFrameBuffer1);
        this._gl.framebufferTexture2D(this._gl.FRAMEBUFFER, this._gl.COLOR_ATTACHMENT0, this._gl.TEXTURE_2D, this._postProcessTexture1, 0);
        this._gl.framebufferTexture2D(this._gl.FRAMEBUFFER, this._gl.DEPTH_ATTACHMENT, this._gl.TEXTURE_2D, this._postProcessDepthTexture, 0);
        this._postProcessTexture2 = (0, $a25f5529f6cda489$export$c41e4fcbf45db179).create(this._gl, width, height, this._gl.RGBA, this._gl.FLOAT, this._gl.LINEAR, null, this._gl.RGBA32F);
        this._postProcessFrameBuffer2 = this._gl.createFramebuffer();
        this._gl.bindFramebuffer(this._gl.FRAMEBUFFER, this._postProcessFrameBuffer2);
        this._gl.framebufferTexture2D(this._gl.FRAMEBUFFER, this._gl.COLOR_ATTACHMENT0, this._gl.TEXTURE_2D, this._postProcessTexture2, 0);
        this._postProcessDofTexture = (0, $a25f5529f6cda489$export$c41e4fcbf45db179).create(this._gl, width, height, this._gl.RED, this._gl.FLOAT, this._gl.LINEAR, null, this._gl.R32F);
        this._postProcessDofFrameBuffer = this._gl.createFramebuffer();
        this._gl.bindFramebuffer(this._gl.FRAMEBUFFER, this._postProcessDofFrameBuffer);
        this._gl.framebufferTexture2D(this._gl.FRAMEBUFFER, this._gl.COLOR_ATTACHMENT0, this._gl.TEXTURE_2D, this._postProcessDofTexture, 0);
        const widthHalf = Math.round(width / 2);
        const heightHalf = Math.round(height / 2);
        this._postProcessHalfTexture1 = (0, $a25f5529f6cda489$export$c41e4fcbf45db179).create(this._gl, widthHalf, heightHalf, this._gl.RGBA, this._gl.FLOAT, this._gl.LINEAR, null, this._gl.RGBA32F);
        this._postProcessHalfFrameBuffer1 = this._gl.createFramebuffer();
        this._gl.bindFramebuffer(this._gl.FRAMEBUFFER, this._postProcessHalfFrameBuffer1);
        this._gl.framebufferTexture2D(this._gl.FRAMEBUFFER, this._gl.COLOR_ATTACHMENT0, this._gl.TEXTURE_2D, this._postProcessHalfTexture1, 0);
        this._postProcessHalfTexture2 = (0, $a25f5529f6cda489$export$c41e4fcbf45db179).create(this._gl, widthHalf, heightHalf, this._gl.RGBA, this._gl.FLOAT, this._gl.LINEAR, null, this._gl.RGBA32F);
        this._postProcessHalfFrameBuffer2 = this._gl.createFramebuffer();
        this._gl.bindFramebuffer(this._gl.FRAMEBUFFER, this._postProcessHalfFrameBuffer2);
        this._gl.framebufferTexture2D(this._gl.FRAMEBUFFER, this._gl.COLOR_ATTACHMENT0, this._gl.TEXTURE_2D, this._postProcessHalfTexture2, 0);
        const widthQuarter = Math.round(widthHalf / 2);
        const heightQuarter = Math.round(heightHalf / 2);
        this._postProcessQuarterTexture1 = (0, $a25f5529f6cda489$export$c41e4fcbf45db179).create(this._gl, widthQuarter, heightQuarter, this._gl.RGBA, this._gl.FLOAT, this._gl.LINEAR, null, this._gl.RGBA32F);
        this._postProcessQuarterFrameBuffer1 = this._gl.createFramebuffer();
        this._gl.bindFramebuffer(this._gl.FRAMEBUFFER, this._postProcessQuarterFrameBuffer1);
        this._gl.framebufferTexture2D(this._gl.FRAMEBUFFER, this._gl.COLOR_ATTACHMENT0, this._gl.TEXTURE_2D, this._postProcessQuarterTexture1, 0);
        this._postProcessQuarterTexture2 = (0, $a25f5529f6cda489$export$c41e4fcbf45db179).create(this._gl, widthQuarter, heightQuarter, this._gl.RGBA, this._gl.FLOAT, this._gl.LINEAR, null, this._gl.RGBA32F);
        this._postProcessQuarterFrameBuffer2 = this._gl.createFramebuffer();
        this._gl.bindFramebuffer(this._gl.FRAMEBUFFER, this._postProcessQuarterFrameBuffer2);
        this._gl.framebufferTexture2D(this._gl.FRAMEBUFFER, this._gl.COLOR_ATTACHMENT0, this._gl.TEXTURE_2D, this._postProcessQuarterTexture2, 0);
        const widthEighth = Math.round(widthQuarter / 2);
        const heightEighth = Math.round(heightQuarter / 2);
        this._postProcessEighthTexture1 = (0, $a25f5529f6cda489$export$c41e4fcbf45db179).create(this._gl, widthEighth, heightEighth, this._gl.RGBA, this._gl.FLOAT, this._gl.LINEAR, null, this._gl.RGBA32F);
        this._postProcessEighthFrameBuffer1 = this._gl.createFramebuffer();
        this._gl.bindFramebuffer(this._gl.FRAMEBUFFER, this._postProcessEighthFrameBuffer1);
        this._gl.framebufferTexture2D(this._gl.FRAMEBUFFER, this._gl.COLOR_ATTACHMENT0, this._gl.TEXTURE_2D, this._postProcessEighthTexture1, 0);
        this._postProcessEighthTexture2 = (0, $a25f5529f6cda489$export$c41e4fcbf45db179).create(this._gl, widthEighth, heightEighth, this._gl.RGBA, this._gl.FLOAT, this._gl.LINEAR, null, this._gl.RGBA32F);
        this._postProcessEighthFrameBuffer2 = this._gl.createFramebuffer();
        this._gl.bindFramebuffer(this._gl.FRAMEBUFFER, this._postProcessEighthFrameBuffer2);
        this._gl.framebufferTexture2D(this._gl.FRAMEBUFFER, this._gl.COLOR_ATTACHMENT0, this._gl.TEXTURE_2D, this._postProcessEighthTexture2, 0);
        const widthSixteenth = Math.round(widthEighth / 2);
        const hgeightSixteenth = Math.round(heightEighth / 2);
        this._postProcessSixteenthTexture1 = (0, $a25f5529f6cda489$export$c41e4fcbf45db179).create(this._gl, widthSixteenth, hgeightSixteenth, this._gl.RGBA, this._gl.FLOAT, this._gl.LINEAR, null, this._gl.RGBA32F);
        this._postProcessSixteenthFrameBuffer1 = this._gl.createFramebuffer();
        this._gl.bindFramebuffer(this._gl.FRAMEBUFFER, this._postProcessSixteenthFrameBuffer1);
        this._gl.framebufferTexture2D(this._gl.FRAMEBUFFER, this._gl.COLOR_ATTACHMENT0, this._gl.TEXTURE_2D, this._postProcessSixteenthTexture1, 0);
        this._postProcessSixteenthTexture2 = (0, $a25f5529f6cda489$export$c41e4fcbf45db179).create(this._gl, widthSixteenth, hgeightSixteenth, this._gl.RGBA, this._gl.FLOAT, this._gl.LINEAR, null, this._gl.RGBA32F);
        this._postProcessSixteenthFrameBuffer2 = this._gl.createFramebuffer();
        this._gl.bindFramebuffer(this._gl.FRAMEBUFFER, this._postProcessSixteenthFrameBuffer2);
        this._gl.framebufferTexture2D(this._gl.FRAMEBUFFER, this._gl.COLOR_ATTACHMENT0, this._gl.TEXTURE_2D, this._postProcessSixteenthTexture2, 0);
        this._core.log.write((0, $4a6417d29706362f$export$243e62d78d3b544d).info, `buffers resized ${width},${height}`);
    }
    _createContext(canvas) {
        let supported = false;
        const preserveDrawingBuffer = this._options ? this._options.preserveDrawingBuffer === undefined ? false : this._options.preserveDrawingBuffer : false;
        const options = {
            stencil: true,
            alpha: false,
            antialias: false,
            preserveDrawingBuffer: preserveDrawingBuffer
        };
        const gl = canvas.getContext("webgl2", options);
        if (gl) {
            const OES_texture_float_linear = gl.getExtension("OES_texture_float_linear");
            const EXT_color_buffer_float = gl.getExtension("EXT_color_buffer_float");
            if (OES_texture_float_linear && EXT_color_buffer_float && gl.MAX_DRAW_BUFFERS > 3) {
                const texture = (0, $a25f5529f6cda489$export$c41e4fcbf45db179).create(gl, 1, 1, gl.RGBA, gl.FLOAT, gl.LINEAR, null, gl.RGBA32F);
                const framebuffer = gl.createFramebuffer();
                gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer);
                gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture, 0);
                const status = gl.checkFramebufferStatus(gl.FRAMEBUFFER);
                if (status == gl.FRAMEBUFFER_COMPLETE) supported = true;
                gl.bindTexture(gl.TEXTURE_2D, null);
            }
        }
        return supported ? gl : null;
    }
    prepare() {
        let viewport;
        switch(this._core.config.stereoMode){
            case (0, $4a6417d29706362f$export$ec20dfa68810b176).none:
                viewport = this._viewports[0];
                viewport.x = 0;
                viewport.y = 0;
                viewport.width = this._canvas.width;
                viewport.height = this._canvas.height;
                this._viewportOffset = 0;
                this._viewportCount = 1;
                break;
            case (0, $4a6417d29706362f$export$ec20dfa68810b176).left:
                viewport = this._viewports[0];
                viewport.x = 0;
                viewport.y = 0;
                viewport.width = this._canvas.width;
                viewport.height = this._canvas.height;
                this._viewportOffset = 0;
                this._viewportCount = 1;
                break;
            case (0, $4a6417d29706362f$export$ec20dfa68810b176).right:
                viewport = this._viewports[1];
                viewport.x = 0;
                viewport.y = 0;
                viewport.width = this._canvas.width;
                viewport.height = this._canvas.height;
                this._viewportOffset = 1;
                this._viewportCount = 1;
                break;
        }
    }
    createTransitionBuffer(ids) {
        const buffer = new (0, $5c168c6596bfbd28$export$76de936b3c1c4170)(this._core, ids);
        buffer.initializeContext(this._gl);
        return buffer;
    }
    createCartesian2dAxesVisual(axes) {
        const visual = new (0, $e9fa83a8cf03e87c$export$30e3ee7ba3e49080)(this._core, this, axes);
        visual.initializeContext(this._gl);
        return visual;
    }
    createCartesian3dAxesVisual(axes) {
        const visual = new (0, $e3e392e891911753$export$3dc3b91df297f2ee)(this._core, this, axes);
        visual.initializeContext(this._gl);
        return visual;
    }
    _createLabelVisual(label) {
        return new (0, $de477c17b1036dd4$export$71c7fa1581020e2c)(this._core, this, label);
    }
    createLabelSetVisual(labelSet) {
        const visual = new (0, $de477c17b1036dd4$export$97e93e7019ef67b9)(this._core, this, labelSet);
        visual.initializeContext(this._gl);
        return visual;
    }
    createImageVisual(image) {
        const visual = new (0, $8a9611d4c44522de$export$6f251cd327b2ff1)(this._core, this, image);
        visual.initializeContext(this._gl);
        return visual;
    }
    createFontVisual(font) {
        const visual = new (0, $24cf6d98e6e0d82f$export$e784a6eab4d2d700)(this._core, font);
        visual.initializeContext(this._gl);
        return visual;
    }
    getDataUrl(mimeType) {
        return this._canvas.toDataURL(mimeType);
    }
    update(elapsedTime) {
        super.update(elapsedTime);
        if (this._shadowWidth != this._config.shadowWidth || this._shadowHeight != this._config.shadowHeight) {
            this._shadowWidth = this._config.shadowWidth;
            this._shadowHeight = this._config.shadowHeight;
            this._shadowColorTexture = (0, $a25f5529f6cda489$export$c41e4fcbf45db179).create(this._gl, this._config.shadowWidth, this._config.shadowHeight, this._gl.RGBA, this._gl.UNSIGNED_BYTE, this._gl.LINEAR, null);
            this._shadowDepthTexture = (0, $a25f5529f6cda489$export$c41e4fcbf45db179).create(this._gl, this._config.shadowWidth, this._config.shadowHeight, this._gl.DEPTH_COMPONENT, this._gl.UNSIGNED_INT, this._gl.NEAREST, null, this._gl.DEPTH_COMPONENT24);
            this._shadowFrameBuffer = this._gl.createFramebuffer();
            this._gl.bindFramebuffer(this._gl.FRAMEBUFFER, this._shadowFrameBuffer);
            this._gl.framebufferTexture2D(this._gl.FRAMEBUFFER, this._gl.COLOR_ATTACHMENT0, this._gl.TEXTURE_2D, this._shadowColorTexture, 0);
            this._gl.framebufferTexture2D(this._gl.FRAMEBUFFER, this._gl.DEPTH_ATTACHMENT, this._gl.TEXTURE_2D, this._shadowDepthTexture, 0);
            this._core.log.write((0, $4a6417d29706362f$export$243e62d78d3b544d).info, `shadow map resized ${this._shadowWidth},${this._shadowHeight}`);
        }
        if (this._ssaoWidth != this._config.ssaoWidth || this._ssaoHeight != this._config.ssaoHeight) {
            this._ssaoWidth = this._config.ssaoWidth;
            this._ssaoHeight = this._config.ssaoHeight;
            this._ssaoTexture1 = (0, $a25f5529f6cda489$export$c41e4fcbf45db179).create(this._gl, this._config.ssaoWidth, this._config.ssaoHeight, this._gl.RED, this._gl.UNSIGNED_BYTE, this._gl.LINEAR, null, this._gl.R8);
            this._ssaoFrameBuffer1 = this._gl.createFramebuffer();
            this._gl.bindFramebuffer(this._gl.FRAMEBUFFER, this._ssaoFrameBuffer1);
            this._gl.framebufferTexture2D(this._gl.FRAMEBUFFER, this._gl.COLOR_ATTACHMENT0, this._gl.TEXTURE_2D, this._ssaoTexture1, 0);
            this._ssaoTexture2 = (0, $a25f5529f6cda489$export$c41e4fcbf45db179).create(this._gl, this._config.ssaoWidth, this._config.ssaoHeight, this._gl.RED, this._gl.UNSIGNED_BYTE, this._gl.LINEAR, null, this._gl.R8);
            this._ssaoFrameBuffer2 = this._gl.createFramebuffer();
            this._gl.bindFramebuffer(this._gl.FRAMEBUFFER, this._ssaoFrameBuffer2);
            this._gl.framebufferTexture2D(this._gl.FRAMEBUFFER, this._gl.COLOR_ATTACHMENT0, this._gl.TEXTURE_2D, this._ssaoTexture2, 0);
            this._core.log.write((0, $4a6417d29706362f$export$243e62d78d3b544d).info, `ssao map resized ${this._ssaoWidth},${this._ssaoHeight}`);
        }
        if (this._config.isDofEnabled && this._config.dofAutoFocus) {
            this._core.getModelManipulationOrigin(this._modelManipulationOrigin);
            this._core.getModelPosition(this._modelPosition);
            (0, $31054a6c69637582$exports).add(this._position, this._modelManipulationOrigin, this._modelPosition);
            this._core.camera.getPosition(this._cameraPosition);
            (0, $31054a6c69637582$exports).subtract(this._position, this._position, this._cameraPosition);
            const distance = -this._position[2];
            const amount = Math.min(elapsedTime * this._core.config.focusSmoothing, 1);
            this._config.dofFocusDistance = (0, $2d4d1eb6f32f02f2$export$80a8c44b8858d625).lerp(this._config.dofFocusDistance, distance, amount);
        }
    }
    render(elapsedTime) {
        return $8e6261810f478ee0$var$__awaiter(this, void 0, void 0, function*() {
            this._gl.enable(this._gl.DEPTH_TEST);
            this._gl.enable(this._gl.CULL_FACE);
            this._gl.cullFace(this._gl.BACK);
            this._gl.disable(this._gl.BLEND);
            if (this.isPickingEnabled) {
                this._shaderResources.bindFramebuffer(this._pickFrameBuffer);
                this._gl.clearColor(0, 0, 0, 0);
                this._gl.clear(this._gl.COLOR_BUFFER_BIT | this._gl.DEPTH_BUFFER_BIT);
            }
            this._shaderResources.bindFramebuffer(this._geometryFrameBuffer);
            const backgroundColor = this._backgroundColor || this._core.config.backgroundColor;
            this._gl.clearColor(backgroundColor[0], backgroundColor[1], backgroundColor[2], 1);
            this._gl.clear(this._gl.COLOR_BUFFER_BIT | this._gl.DEPTH_BUFFER_BIT | this._gl.STENCIL_BUFFER_BIT);
            if (this.config.isShadowEnabled) {
                this._shaderResources.bindFramebuffer(this._shadowFrameBuffer);
                this._gl.clear(this._gl.DEPTH_BUFFER_BIT);
                (0, $1ac1b59392edf35b$exports).perspective(this._shadowPMatrix, (0, $a49c65c28e06311e$export$210d3b2db589eb5c).degreesToRadians(30), this._config.shadowWidth / this._config.shadowHeight, this._core.config.nearPlane, this._core.config.farPlane);
                (0, $31054a6c69637582$exports).set(this._modelPosition, this.mMatrix[12], this.mMatrix[13], this.mMatrix[14]);
                (0, $ba3ca37806a2b6fa$exports).fromMat4(this._cameraRotation, this.inverseVMatrices[0]);
                (0, $31054a6c69637582$exports).transformMat3(this._position, this._config.keyLightPosition, this._cameraRotation);
                (0, $31054a6c69637582$exports).add(this._position, this._position, this._modelPosition);
                (0, $1ac1b59392edf35b$exports).lookAt(this._shadowVMatrix, this._position, this._modelPosition, (0, $d4d7bd6cc65a5081$export$a002182e51710d39).VECTOR3_UNITY);
            }
            for(let i = 0; i < this.transitionBuffers.length; i++){
                const transitionBuffer = this.transitionBuffers[i];
                if (transitionBuffer.isVisible) this._renderTransitionBuffer(transitionBuffer);
            }
            const axesVisuals = this.axesVisibility == (0, $4a6417d29706362f$export$7dbc7c2b82487e42).current ? this.currentAxes : this.axesVisibility == (0, $4a6417d29706362f$export$7dbc7c2b82487e42).previous ? this.previousAxes : null;
            if (axesVisuals) for(let i = 0; i < axesVisuals.length; i++){
                const axesVisual = axesVisuals[i];
                if (axesVisual.isVisible) {
                    axesVisual.pickedIdColor = this._pickedIdColor;
                    axesVisual.pickFramebuffer = this._pickFrameBuffer;
                    axesVisual.geometryFramebuffer = this._geometryFrameBuffer;
                    axesVisual.render(elapsedTime);
                }
            }
            if (this.areLabelsVisible) for(let i = 0; i < this.labelSets.length; i++){
                const labelSetVisual = this.labelSets[i];
                if (labelSetVisual.isVisible) {
                    labelSetVisual.pickedIdColor = this._pickedIdColor;
                    labelSetVisual.pickFramebuffer = this._pickFrameBuffer;
                    labelSetVisual.geometryFramebuffer = this._geometryFrameBuffer;
                    labelSetVisual.render(elapsedTime);
                }
            }
            if (this.areImagesVisible) for(let i = 0; i < this.images.length; i++){
                const imageVisual = this.images[i];
                if (imageVisual.isVisible) {
                    imageVisual.geometryFramebuffer = this._geometryFrameBuffer;
                    imageVisual.render(elapsedTime);
                }
            }
            if (this._backgroundShader.isInitialized) {
                this._backgroundShader.prepare();
                this._backgroundShader.color = (0, $31054a6c69637582$exports).fromValues(this._core.config.backgroundColor[0], this._core.config.backgroundColor[1], this._core.config.backgroundColor[2]);
                this._backgroundShader.apply();
                this._shaderResources.bindFramebuffer(this._geometryFrameBuffer);
                for(let i = 0; i < this._viewportCount; i++){
                    const viewport = i + this._viewportOffset;
                    this._gl.viewport(this._viewports[viewport].x, this._viewports[viewport].y, this._viewports[viewport].width, this._viewports[viewport].height);
                    this._gl.drawElements(this._gl.TRIANGLES, this._quad.indexCount, this._gl.UNSIGNED_SHORT, 0);
                }
                this._gl.bindVertexArray(null);
            }
            if (this.isPickingEnabled) {
                this._shaderResources.bindFramebuffer(this._pickFrameBuffer);
                this._gl.readPixels(this._core.config.pickWidth / 2, this._core.config.pickHeight / 2, 1, 1, this._gl.RGBA, this._gl.UNSIGNED_BYTE, this._pickedPixels);
                this._pickedType = (0, $a60d0d861ccf87e8$export$aadd933e49c67c12).decodeType(this._pickedPixels);
                (0, $4c4ac78b213a9c07$exports).set(this._pickedIdColor, this._pickedPixels[0] / 0xff, this._pickedPixels[1] / 0xff, this._pickedPixels[2] / 0xff, this._pickedPixels[3] / 0xff);
                this._pickedId = (0, $a60d0d861ccf87e8$export$aadd933e49c67c12).decodeNumber(this._pickedPixels);
            } else {
                (0, $4c4ac78b213a9c07$exports).set(this._pickedIdColor, 0, 0, 0, 0);
                this._pickedId = 0;
            }
            if (this.transitionBuffers.length > 0 && this._quad.isInitialized) {
                const viewport = this._viewportOffset;
                this._postProcess(this.vMatrices[viewport], this.inverseVMatrices[viewport], this.pMatrices[viewport], this._viewports[viewport]);
            }
            if (this.isLassoPicking && this._lassoShader.isInitialized) {
                this._lassoShader.vertexBuffer = this._lasso.vertexBuffer;
                this._lassoShader.indexBuffer = this._lasso.indexBuffer;
                const lassoWidth = this.lassoX1 - this.lassoX0;
                const lassoHeight = this.lassoY1 - this.lassoY0;
                this._lassoShader.prepare();
                this._lassoShader.color = this.lassoColor ? this.lassoColor : this._core.config.lassoColor;
                this._lassoShader.dashWidth = this.lassoDashWidth ? this.lassoDashWidth : this._core.config.lassoDashWidth;
                this._lassoShader.apply();
                const lassoThickness = this.lassoThickness ? this.lassoThickness : this._core.config.lassoThickness;
                for(let i = 0; i < this._viewportCount; i++){
                    const viewportIndex = i + this._viewportOffset;
                    this._shaderResources.bindFramebuffer(this._framebuffers[viewportIndex]);
                    const viewport = this._viewports[viewportIndex];
                    this._gl.viewport(viewport.x, viewport.y, viewport.width, viewport.height);
                    this._lassoMMatrix[0] = lassoWidth * 2 / viewport.width;
                    this._lassoMMatrix[5] = lassoHeight * 2 / viewport.height;
                    this._lassoMMatrix[10] = 1;
                    this._lassoMMatrix[12] = (this.lassoX0 + lassoWidth / 2) / viewport.width * 2 - 1;
                    this._lassoMMatrix[13] = 1 - (this.lassoY0 + lassoHeight / 2) / viewport.height * 2;
                    this._lassoShader.mMatrix = this._lassoMMatrix;
                    (0, $91b0cc4981465964$exports).set(this._lassoThickness, lassoThickness / lassoWidth, lassoThickness / lassoHeight);
                    this._lassoShader.thickness = this._lassoThickness;
                    this._lassoShader.applyView();
                    this._gl.drawElements(this._gl.TRIANGLES, this._lasso.indexCount, this._gl.UNSIGNED_SHORT, 0);
                }
            }
        });
    }
    _renderTransitionBuffer(transitionBuffer) {
        const currentBuffer = transitionBuffer.currentBuffer;
        const previousBuffer = transitionBuffer.previousBuffer;
        const currentPalette = transitionBuffer.currentPalette;
        const previousPalette = transitionBuffer.previousPalette;
        const currentAtlas = transitionBuffer.currentAtlas;
        const previousAtlas = transitionBuffer.previousAtlas;
        const unitType = transitionBuffer.unitType === undefined ? currentBuffer.unitType : transitionBuffer.unitType;
        const id = currentBuffer.lookup[transitionBuffer.pickIdLookup[this._pickedId]];
        const hoverId = id > -1 ? (0, $0a0587bd8b0d58e8$export$849e31d725692576).getIdHover(currentBuffer.dataView, id) : -1;
        const activeId = transitionBuffer.activeId;
        if (this._blockShader.isInitialized && (unitType == (0, $4a6417d29706362f$export$80d48287646c9e3b).block || unitType == (0, $4a6417d29706362f$export$80d48287646c9e3b).blockSdf)) {
            this._blockShader.instanceBuffer = currentBuffer.vertexBuffer;
            this._blockShader.previousInstanceBuffer = previousBuffer.vertexBuffer;
            this._blockShader.paletteTexture = currentPalette.texture || currentPalette.defaultTexture;
            this._blockShader.previousPaletteTexture = previousPalette.texture || previousPalette.defaultTexture;
            this._blockShader.prepare();
            this._blockShader.mMatrix = this.mMatrix;
            this._blockShader.time = this.transitionTime;
            this._blockShader.duration = this._core.config.transitionDuration / (this._core.config.transitionDuration + this._core.config.transitionStaggering);
            this._blockShader.rangeMin = currentBuffer.from;
            this._blockShader.rangeMax = currentBuffer.to;
            this._blockShader.hover = hoverId;
            this._blockShader.active = activeId;
            this._blockShader.specularPower = this._config.specularPower;
            this._blockShader.specularIntensity = this._config.specularIntensity;
            this._blockShader.apply();
            this._blockShader.isPickShader = false;
            this._blockShader.isShadowMap = false;
            this._shaderResources.bindFramebuffer(this._geometryFrameBuffer);
            for(let i = 0; i < this._viewportCount; i++){
                const viewport = i + this._viewportOffset;
                this._gl.viewport(this._viewports[viewport].x, this._viewports[viewport].y, this._viewports[viewport].width, this._viewports[viewport].height);
                this._blockShader.vMatrix = this.vMatrices[viewport];
                this._blockShader.pMatrix = this.pMatrices[viewport];
                this._blockShader.applyView();
                this._gl.drawElementsInstanced(this._gl.TRIANGLE_STRIP, this._blockShader.indexCount, this._gl.UNSIGNED_SHORT, 0, transitionBuffer.length);
            }
            if (this._config.isShadowEnabled) {
                this._shaderResources.bindFramebuffer(this._shadowFrameBuffer);
                this._gl.viewport(0, 0, this._config.shadowWidth, this._config.shadowHeight);
                this._gl.cullFace(this._gl.FRONT);
                this._blockShader.isPickShader = false;
                this._blockShader.isShadowMap = true;
                this._blockShader.vMatrix = this._shadowVMatrix;
                this._blockShader.pMatrix = this._shadowPMatrix;
                this._blockShader.applyView();
                this._gl.drawElementsInstanced(this._gl.TRIANGLE_STRIP, this._blockShader.indexCount, this._gl.UNSIGNED_SHORT, 0, transitionBuffer.length);
                this._gl.colorMask(true, true, true, true);
                this._gl.cullFace(this._gl.BACK);
            }
            if (this.isPickingEnabled) {
                this._blockShader.isPickShader = true;
                this._blockShader.isShadowMap = false;
                this._blockShader.pMatrix = this.pickPMatrix;
                this._blockShader.vMatrix = this.pickVMatrix;
                this._blockShader.applyView();
                this._shaderResources.bindFramebuffer(this._pickFrameBuffer);
                this._gl.viewport(0, 0, this._core.config.pickWidth, this._core.config.pickHeight);
                this._gl.drawElementsInstanced(this._gl.TRIANGLE_STRIP, this._blockShader.indexCount, this._gl.UNSIGNED_SHORT, 0, transitionBuffer.length);
            }
        } else if (this._sphereShader.isInitialized && (unitType == (0, $4a6417d29706362f$export$80d48287646c9e3b).sphere || unitType == (0, $4a6417d29706362f$export$80d48287646c9e3b).sphereSdf)) {
            this._sphereShader.instanceBuffer = currentBuffer.vertexBuffer;
            this._sphereShader.previousInstanceBuffer = previousBuffer.vertexBuffer;
            this._sphereShader.paletteTexture = currentPalette.texture || currentPalette.defaultTexture;
            this._sphereShader.previousPaletteTexture = previousPalette.texture || previousPalette.defaultTexture;
            this._sphereShader.prepare();
            this._sphereShader.mMatrix = this.mMatrix;
            this._sphereShader.time = this.transitionTime;
            this._sphereShader.duration = this._core.config.transitionDuration / (this._core.config.transitionDuration + this._core.config.transitionStaggering);
            this._sphereShader.rangeMin = currentBuffer.from;
            this._sphereShader.rangeMax = currentBuffer.to;
            this._sphereShader.hover = hoverId;
            this._sphereShader.active = activeId;
            this._sphereShader.specularPower = this._config.specularPower;
            this._sphereShader.specularIntensity = this._config.specularIntensity;
            this._sphereShader.apply();
            this._sphereShader.isPickShader = false;
            this._sphereShader.isShadowMap = false;
            this._shaderResources.bindFramebuffer(this._geometryFrameBuffer);
            for(let i = 0; i < this._viewportCount; i++){
                const viewport = i + this._viewportOffset;
                this._gl.viewport(this._viewports[viewport].x, this._viewports[viewport].y, this._viewports[viewport].width, this._viewports[viewport].height);
                this._sphereShader.vMatrix = this.vMatrices[viewport];
                this._sphereShader.pMatrix = this.pMatrices[viewport];
                this._sphereShader.applyView();
                this._gl.drawElementsInstanced(this._gl.TRIANGLE_STRIP, this._sphereShader.indexCount, this._gl.UNSIGNED_SHORT, 0, transitionBuffer.length);
            }
            if (this._config.isShadowEnabled) {
                this._shaderResources.bindFramebuffer(this._shadowFrameBuffer);
                this._gl.viewport(0, 0, this._config.shadowWidth, this._config.shadowHeight);
                this._sphereShader.isPickShader = false;
                this._sphereShader.isShadowMap = true;
                this._sphereShader.vMatrix = this._shadowVMatrix;
                this._sphereShader.pMatrix = this._shadowPMatrix;
                this._sphereShader.applyView();
                this._gl.drawElementsInstanced(this._gl.TRIANGLE_STRIP, this._sphereShader.indexCount, this._gl.UNSIGNED_SHORT, 0, transitionBuffer.length);
                this._gl.colorMask(true, true, true, true);
            }
            if (this.isPickingEnabled) {
                this._sphereShader.isPickShader = true;
                this._sphereShader.isShadowMap = false;
                this._sphereShader.pMatrix = this.pickPMatrix;
                this._sphereShader.vMatrix = this.pickVMatrix;
                this._sphereShader.applyView();
                this._shaderResources.bindFramebuffer(this._pickFrameBuffer);
                this._gl.viewport(0, 0, this._core.config.pickWidth, this._core.config.pickHeight);
                this._gl.drawElementsInstanced(this._gl.TRIANGLE_STRIP, this._sphereShader.indexCount, this._gl.UNSIGNED_SHORT, 0, transitionBuffer.length);
            }
        } else if (this._cylinderShader.isInitialized && (unitType == (0, $4a6417d29706362f$export$80d48287646c9e3b).cylinder || unitType == (0, $4a6417d29706362f$export$80d48287646c9e3b).cylinderSdf)) {
            this._cylinderShader.instanceBuffer = currentBuffer.vertexBuffer;
            this._cylinderShader.previousInstanceBuffer = previousBuffer.vertexBuffer;
            this._cylinderShader.paletteTexture = currentPalette.texture || currentPalette.defaultTexture;
            this._cylinderShader.previousPaletteTexture = previousPalette.texture || previousPalette.defaultTexture;
            this._cylinderShader.prepare();
            this._cylinderShader.mMatrix = this.mMatrix;
            this._cylinderShader.time = this.transitionTime;
            this._cylinderShader.duration = this._core.config.transitionDuration / (this._core.config.transitionDuration + this._core.config.transitionStaggering);
            this._cylinderShader.rangeMin = currentBuffer.from;
            this._cylinderShader.rangeMax = currentBuffer.to;
            this._cylinderShader.hover = hoverId;
            this._cylinderShader.active = activeId;
            this._cylinderShader.specularPower = this._config.specularPower;
            this._cylinderShader.specularIntensity = this._config.specularIntensity;
            this._cylinderShader.apply();
            this._cylinderShader.isPickShader = false;
            this._cylinderShader.isShadowMap = false;
            this._shaderResources.bindFramebuffer(this._geometryFrameBuffer);
            for(let i = 0; i < this._viewportCount; i++){
                const viewport = i + this._viewportOffset;
                this._gl.viewport(this._viewports[viewport].x, this._viewports[viewport].y, this._viewports[viewport].width, this._viewports[viewport].height);
                this._cylinderShader.vMatrix = this.vMatrices[viewport];
                this._cylinderShader.pMatrix = this.pMatrices[viewport];
                this._cylinderShader.applyView();
                this._gl.drawElementsInstanced(this._gl.TRIANGLE_STRIP, this._cylinderShader.indexCount, this._gl.UNSIGNED_SHORT, 0, transitionBuffer.length);
            }
            if (this._config.isShadowEnabled) {
                this._shaderResources.bindFramebuffer(this._shadowFrameBuffer);
                this._gl.viewport(0, 0, this._config.shadowWidth, this._config.shadowHeight);
                this._cylinderShader.isPickShader = false;
                this._cylinderShader.isShadowMap = true;
                this._cylinderShader.vMatrix = this._shadowVMatrix;
                this._cylinderShader.pMatrix = this._shadowPMatrix;
                this._cylinderShader.applyView();
                this._gl.drawElementsInstanced(this._gl.TRIANGLE_STRIP, this._cylinderShader.indexCount, this._gl.UNSIGNED_SHORT, 0, transitionBuffer.length);
                this._gl.colorMask(true, true, true, true);
            }
            if (this.isPickingEnabled) {
                this._cylinderShader.isPickShader = true;
                this._cylinderShader.isShadowMap = false;
                this._cylinderShader.pMatrix = this.pickPMatrix;
                this._cylinderShader.vMatrix = this.pickVMatrix;
                this._cylinderShader.applyView();
                this._shaderResources.bindFramebuffer(this._pickFrameBuffer);
                this._gl.viewport(0, 0, this._core.config.pickWidth, this._core.config.pickHeight);
                this._gl.drawElementsInstanced(this._gl.TRIANGLE_STRIP, this._cylinderShader.indexCount, this._gl.UNSIGNED_SHORT, 0, transitionBuffer.length);
            }
        } else if (this._sdfShader.isInitialized && unitType == (0, $4a6417d29706362f$export$80d48287646c9e3b).sdf) {
            this._sdfShader.instanceBuffer = currentBuffer.vertexBuffer;
            this._sdfShader.previousInstanceBuffer = previousBuffer.vertexBuffer;
            this._sdfShader.paletteTexture = currentPalette.texture || currentPalette.defaultTexture;
            this._sdfShader.previousPaletteTexture = previousPalette.texture || previousPalette.defaultTexture;
            this._sdfShader.sdfTexture = currentAtlas.texture || currentAtlas.defaultTexture;
            this._sdfShader.previousSdfTexture = previousAtlas.texture || previousAtlas.defaultTexture;
            this._sdfShader.prepare();
            this._sdfShader.mMatrix = this.mMatrix;
            this._sdfShader.time = this.transitionTime;
            this._sdfShader.duration = this._core.config.transitionDuration / (this._core.config.transitionDuration + this._core.config.transitionStaggering);
            this._sdfShader.rangeMin = currentBuffer.from;
            this._sdfShader.rangeMax = currentBuffer.to;
            this._sdfShader.hover = hoverId;
            this._sdfShader.active = activeId;
            this._sdfShader.specularPower = this._config.specularPower;
            this._sdfShader.specularIntensity = this._config.specularIntensity;
            this._sdfShader.apply();
            this._sdfShader.isPickShader = false;
            this._sdfShader.isShadowMap = false;
            this._shaderResources.bindFramebuffer(this._geometryFrameBuffer);
            for(let i = 0; i < this._viewportCount; i++){
                const viewport = i + this._viewportOffset;
                this._gl.viewport(this._viewports[viewport].x, this._viewports[viewport].y, this._viewports[viewport].width, this._viewports[viewport].height);
                this._sdfShader.vMatrix = this.vMatrices[viewport];
                this._sdfShader.pMatrix = this.pMatrices[viewport];
                this._sdfShader.applyView();
                this._gl.drawElementsInstanced(this._gl.TRIANGLE_STRIP, this._sdfShader.indexCount, this._gl.UNSIGNED_SHORT, 0, transitionBuffer.length);
            }
            if (this._config.isShadowEnabled) {
                this._shaderResources.bindFramebuffer(this._shadowFrameBuffer);
                this._gl.viewport(0, 0, this._config.shadowWidth, this._config.shadowHeight);
                this._gl.cullFace(this._gl.FRONT);
                this._sdfShader.isPickShader = false;
                this._sdfShader.isShadowMap = true;
                this._sdfShader.vMatrix = this._shadowVMatrix;
                this._sdfShader.pMatrix = this._shadowPMatrix;
                this._sdfShader.applyView();
                this._gl.drawElementsInstanced(this._gl.TRIANGLE_STRIP, this._sdfShader.indexCount, this._gl.UNSIGNED_SHORT, 0, transitionBuffer.length);
                this._gl.colorMask(true, true, true, true);
                this._gl.cullFace(this._gl.BACK);
            }
            if (this.isPickingEnabled) {
                this._sdfShader.isPickShader = true;
                this._sdfShader.isShadowMap = false;
                this._sdfShader.pMatrix = this.pickPMatrix;
                this._sdfShader.vMatrix = this.pickVMatrix;
                this._sdfShader.applyView();
                this._shaderResources.bindFramebuffer(this._pickFrameBuffer);
                this._gl.viewport(0, 0, this._core.config.pickWidth, this._core.config.pickHeight);
                this._gl.drawElementsInstanced(this._gl.TRIANGLE_STRIP, this._sdfShader.indexCount, this._gl.UNSIGNED_SHORT, 0, transitionBuffer.length);
            }
        }
    }
    _postProcess(vMatrix, inverseVMatrix, pMatrix, viewport) {
        if (this._deferredShader.isInitialized) {
            this._gl.disable(this._gl.DEPTH_TEST);
            let ssaoTexture;
            if (this._config.isSsaoEnabled && this._ssaoShader.isInitialized) {
                this._gl.viewport(0, 0, this._config.ssaoWidth, this._config.ssaoHeight);
                ssaoTexture = this._ssaoTexture1;
                this._shaderResources.bindFramebuffer(this._ssaoFrameBuffer1);
                this._ssaoShader.vertexBuffer = this._quad.vertexBuffer;
                this._ssaoShader.indexBuffer = this._quad.indexBuffer;
                this._ssaoShader.texture2D1 = this._positionTexture;
                this._ssaoShader.texture2D2 = this._normalTexture;
                this._ssaoShader.texture2D3 = this._ssaoNoiseTexture;
                this._ssaoShader.prepare();
                this._ssaoShader.pMatrix = pMatrix;
                this._ssaoShader.ssaoNoiseSize = this._config.ssaoNoiseSize;
                this._ssaoShader.ssaoRadius = this._config.ssaoRadius;
                this._ssaoShader.ssaoPower = this._config.ssaoPower;
                this._ssaoShader.ssaoKernel = this._ssaoSampleKernel;
                this._ssaoShader.left = 0;
                this._ssaoShader.top = 0;
                this._ssaoShader.width = this._config.ssaoWidth;
                this._ssaoShader.height = this._config.ssaoHeight;
                this._ssaoShader.apply();
                this._ssaoShader.applyView();
                this._gl.drawElements(this._gl.TRIANGLES, this._quad.indexCount, this._gl.UNSIGNED_SHORT, 0);
                if (this._config.ssaoBlurEnabled && this._boxShader.isInitialized) {
                    ssaoTexture = this._ssaoTexture2;
                    this._shaderResources.bindFramebuffer(this._ssaoFrameBuffer2);
                    this._boxShader.vertexBuffer = this._quad.vertexBuffer;
                    this._boxShader.indexBuffer = this._quad.indexBuffer;
                    this._boxShader.texture2D = this._ssaoTexture1;
                    this._boxShader.prepare();
                    this._boxShader.left = 0;
                    this._boxShader.top = 0;
                    this._boxShader.width = this._config.ssaoWidth;
                    this._boxShader.height = this._config.ssaoHeight;
                    this._boxShader.apply();
                    this._boxShader.applyView();
                    this._gl.drawElements(this._gl.TRIANGLES, this._quad.indexCount, this._gl.UNSIGNED_SHORT, 0);
                }
            }
            this._gl.viewport(viewport.left, viewport.top, viewport.width, viewport.height);
            let postProcessFrameBuffer = this._postProcessFrameBuffer1;
            this._shaderResources.bindFramebuffer(postProcessFrameBuffer);
            this._deferredShader.vertexBuffer = this._quad.vertexBuffer;
            this._deferredShader.indexBuffer = this._quad.indexBuffer;
            this._deferredShader.texture2D1 = this._positionTexture;
            this._deferredShader.texture2D2 = this._colorTexture;
            this._deferredShader.texture2D3 = this._normalTexture;
            this._deferredShader.texture2D4 = this._config.isSsaoEnabled ? ssaoTexture : null;
            this._deferredShader.texture2D5 = this._shadowDepthTexture;
            this._gl.texParameteri(this._gl.TEXTURE_2D, this._gl.TEXTURE_WRAP_S, this._gl.CLAMP_TO_EDGE);
            this._gl.texParameteri(this._gl.TEXTURE_2D, this._gl.TEXTURE_WRAP_T, this._gl.CLAMP_TO_EDGE);
            this._deferredShader.prepare();
            this._deferredShader.isShadowEnabled = this._config.isShadowEnabled;
            this._deferredShader.isSsaoEnabled = this._config.isSsaoEnabled;
            this._deferredShader.inverseVMatrix = inverseVMatrix;
            this._deferredShader.shadowVMatrix = this._shadowVMatrix;
            this._deferredShader.shadowPMatrix = this._shadowPMatrix;
            this._deferredShader.vMatrix = vMatrix;
            this._deferredShader.keyLightIntensity = this._config.keyLightIntensity;
            this._deferredShader.fillLight1Intensity = this._config.fillLight1Intensity;
            this._deferredShader.fillLight2Intensity = this._config.fillLight2Intensity;
            this._core.camera.getPosition(this._cameraPosition);
            (0, $ba3ca37806a2b6fa$exports).fromMat4(this._cameraRotation, vMatrix);
            (0, $31054a6c69637582$exports).set(this._position, this.mMatrix[12], this.mMatrix[13], this.mMatrix[14]);
            (0, $31054a6c69637582$exports).normalize(this._deferredShader.directionToKeyLight, this._config.keyLightPosition);
            (0, $31054a6c69637582$exports).subtract(this._direction, this._cameraPosition, this._position);
            (0, $31054a6c69637582$exports).normalize(this._direction, this._direction);
            (0, $31054a6c69637582$exports).add(this._deferredShader.keyLightHalfAngle, this._direction, this._deferredShader.directionToKeyLight);
            (0, $31054a6c69637582$exports).normalize(this._deferredShader.keyLightHalfAngle, this._deferredShader.keyLightHalfAngle);
            (0, $31054a6c69637582$exports).copy(this._deferredShader.directionToFillLight1, this._config.fillLight1Position);
            (0, $31054a6c69637582$exports).copy(this._deferredShader.directionToFillLight2, this._config.fillLight2Position);
            this._deferredShader.left = viewport.left;
            this._deferredShader.top = viewport.top;
            this._deferredShader.width = viewport.width;
            this._deferredShader.height = viewport.height;
            this._deferredShader.shadowMapWidth = this._config.shadowWidth;
            this._deferredShader.shadowMapHeight = this._config.shadowHeight;
            this._deferredShader.ambientIntensity = this._config.ambientIntensity;
            this._deferredShader.materialIntensity = this._config.materialIntensity;
            this._deferredShader.specularPower = this._config.specularPower;
            this._deferredShader.specularIntensity = this._config.specularIntensity;
            this._deferredShader.apply();
            this._gl.drawElements(this._gl.TRIANGLES, this._quad.indexCount, this._gl.UNSIGNED_SHORT, 0);
            const widthHalf = Math.round(viewport.width / 2);
            const heightHalf = Math.round(viewport.height / 2);
            const widthQuarter = Math.round(widthHalf / 2);
            const heightQuarter = Math.round(heightHalf / 2);
            const widthEighth = Math.round(widthQuarter / 2);
            const heightEighth = Math.round(heightQuarter / 2);
            const widthSixteenth = Math.round(widthEighth / 2);
            const heightSixteenth = Math.round(heightEighth / 2);
            if (this._config.isDofEnabled && this._dofBlurShader.isInitialized && this._dofCombineShader.isInitialized) {
                this._gl.bindFramebuffer(this._gl.FRAMEBUFFER, this._postProcessDofFrameBuffer);
                this._dofBlurShader.vertexBuffer = this._quad.vertexBuffer;
                this._dofBlurShader.indexBuffer = this._quad.indexBuffer;
                this._dofBlurShader.texture2D1 = postProcessFrameBuffer == this._postProcessFrameBuffer1 ? this._postProcessTexture2 : this._postProcessTexture1;
                this._dofBlurShader.texture2D2 = this._positionTexture;
                this._dofBlurShader.prepare();
                this._dofBlurShader.focusDepth = this._config.dofFocusDistance;
                this._dofBlurShader.nearFocusDepth = this._config.dofFocusDistance - this._config.dofFocusRange / 2;
                this._dofBlurShader.farFocusDepth = this._config.dofFocusDistance + this._config.dofFocusRange / 2;
                this._dofBlurShader.maxBackgroundBlur = this._config.dofMaxBackgroundBlur;
                this._dofBlurShader.left = viewport.left;
                this._dofBlurShader.top = viewport.top;
                this._dofBlurShader.width = viewport.width;
                this._dofBlurShader.height = viewport.height;
                this._dofBlurShader.apply();
                this._gl.drawElements(this._gl.TRIANGLES, this._quad.indexCount, this._gl.UNSIGNED_SHORT, 0);
                postProcessFrameBuffer = postProcessFrameBuffer == this._postProcessFrameBuffer1 ? this._postProcessFrameBuffer2 : this._postProcessFrameBuffer1;
                this._gl.bindFramebuffer(this._gl.FRAMEBUFFER, postProcessFrameBuffer);
                this._dofCombineShader.vertexBuffer = this._quad.vertexBuffer;
                this._dofCombineShader.indexBuffer = this._quad.indexBuffer;
                this._dofCombineShader.texture2D1 = postProcessFrameBuffer == this._postProcessFrameBuffer1 ? this._postProcessTexture2 : this._postProcessTexture1;
                this._dofCombineShader.texture2D2 = this._postProcessDofTexture;
                this._dofCombineShader.prepare();
                this._dofCombineShader.focusDepth = this._config.dofFocusDistance;
                this._dofCombineShader.left = viewport.left;
                this._dofCombineShader.top = viewport.top;
                this._dofCombineShader.width = viewport.width;
                this._dofCombineShader.height = viewport.height;
                this._dofCombineShader.apply();
                this._gl.drawElements(this._gl.TRIANGLES, this._quad.indexCount, this._gl.UNSIGNED_SHORT, 0);
            }
            if (this._config.isBloomEnabled && this._brightPassShader.isInitialized && this._gaussianShader.isInitialized) {
                this._gl.bindFramebuffer(this._gl.FRAMEBUFFER, this._postProcessHalfFrameBuffer1);
                this._brightPassShader.vertexBuffer = this._quad.vertexBuffer;
                this._brightPassShader.indexBuffer = this._quad.indexBuffer;
                this._brightPassShader.texture2D = postProcessFrameBuffer == this._postProcessFrameBuffer1 ? this._postProcessTexture1 : this._postProcessTexture2;
                this._brightPassShader.prepare();
                this._brightPassShader.width = widthHalf;
                this._brightPassShader.height = heightHalf;
                this._brightPassShader.apply();
                this._gl.drawElements(this._gl.TRIANGLES, this._quad.indexCount, this._gl.UNSIGNED_SHORT, 0);
                this._gl.bindFramebuffer(this._gl.FRAMEBUFFER, this._postProcessQuarterFrameBuffer1);
                this._brightPassShader.vertexBuffer = this._quad.vertexBuffer;
                this._brightPassShader.indexBuffer = this._quad.indexBuffer;
                this._brightPassShader.texture2D = this._postProcessHalfTexture1;
                this._brightPassShader.prepare();
                this._brightPassShader.width = widthQuarter;
                this._brightPassShader.height = heightQuarter;
                this._brightPassShader.apply();
                this._gl.drawElements(this._gl.TRIANGLES, this._quad.indexCount, this._gl.UNSIGNED_SHORT, 0);
                this._gl.bindFramebuffer(this._gl.FRAMEBUFFER, this._postProcessEighthFrameBuffer1);
                this._brightPassShader.vertexBuffer = this._quad.vertexBuffer;
                this._brightPassShader.indexBuffer = this._quad.indexBuffer;
                this._brightPassShader.texture2D = this._postProcessQuarterTexture1;
                this._brightPassShader.prepare();
                this._brightPassShader.width = widthEighth;
                this._brightPassShader.height = heightEighth;
                this._brightPassShader.apply();
                this._gl.drawElements(this._gl.TRIANGLES, this._quad.indexCount, this._gl.UNSIGNED_SHORT, 0);
                this._gl.bindFramebuffer(this._gl.FRAMEBUFFER, this._postProcessSixteenthFrameBuffer1);
                this._brightPassShader.vertexBuffer = this._quad.vertexBuffer;
                this._brightPassShader.indexBuffer = this._quad.indexBuffer;
                this._brightPassShader.texture2D = this._postProcessEighthTexture1;
                this._brightPassShader.prepare();
                this._brightPassShader.width = widthSixteenth;
                this._brightPassShader.height = heightSixteenth;
                this._brightPassShader.apply();
                this._gl.drawElements(this._gl.TRIANGLES, this._quad.indexCount, this._gl.UNSIGNED_SHORT, 0);
                this._gl.bindFramebuffer(this._gl.FRAMEBUFFER, this._postProcessHalfFrameBuffer2);
                this._gaussianShader.vertexBuffer = this._quad.vertexBuffer;
                this._gaussianShader.indexBuffer = this._quad.indexBuffer;
                this._gaussianShader.texture2D = this._postProcessHalfTexture1;
                this._gaussianShader.prepare();
                this._gaussianShader.width = widthHalf;
                this._gaussianShader.height = heightHalf;
                this._gaussianShader.horizontal = true;
                this._gaussianShader.apply();
                this._gl.drawElements(this._gl.TRIANGLES, this._quad.indexCount, this._gl.UNSIGNED_SHORT, 0);
                this._gl.bindFramebuffer(this._gl.FRAMEBUFFER, this._postProcessHalfFrameBuffer1);
                this._gaussianShader.texture2D = this._postProcessHalfTexture2;
                this._gaussianShader.prepare();
                this._gaussianShader.horizontal = false;
                this._gaussianShader.apply();
                this._gl.drawElements(this._gl.TRIANGLES, this._quad.indexCount, this._gl.UNSIGNED_SHORT, 0);
                this._gl.bindFramebuffer(this._gl.FRAMEBUFFER, this._postProcessQuarterFrameBuffer2);
                this._gaussianShader.vertexBuffer = this._quad.vertexBuffer;
                this._gaussianShader.indexBuffer = this._quad.indexBuffer;
                this._gaussianShader.texture2D = this._postProcessQuarterTexture1;
                this._gaussianShader.prepare();
                this._gaussianShader.width = widthQuarter;
                this._gaussianShader.height = heightQuarter;
                this._gaussianShader.horizontal = true;
                this._gaussianShader.apply();
                this._gl.drawElements(this._gl.TRIANGLES, this._quad.indexCount, this._gl.UNSIGNED_SHORT, 0);
                this._gl.bindFramebuffer(this._gl.FRAMEBUFFER, this._postProcessQuarterFrameBuffer1);
                this._gaussianShader.texture2D = this._postProcessQuarterTexture2;
                this._gaussianShader.prepare();
                this._gaussianShader.horizontal = false;
                this._gaussianShader.apply();
                this._gl.drawElements(this._gl.TRIANGLES, this._quad.indexCount, this._gl.UNSIGNED_SHORT, 0);
                this._gl.bindFramebuffer(this._gl.FRAMEBUFFER, this._postProcessEighthFrameBuffer2);
                this._gaussianShader.vertexBuffer = this._quad.vertexBuffer;
                this._gaussianShader.indexBuffer = this._quad.indexBuffer;
                this._gaussianShader.texture2D = this._postProcessEighthTexture1;
                this._gaussianShader.prepare();
                this._gaussianShader.width = widthEighth;
                this._gaussianShader.height = heightEighth;
                this._gaussianShader.horizontal = true;
                this._gaussianShader.apply();
                this._gl.drawElements(this._gl.TRIANGLES, this._quad.indexCount, this._gl.UNSIGNED_SHORT, 0);
                this._gl.bindFramebuffer(this._gl.FRAMEBUFFER, this._postProcessEighthFrameBuffer1);
                this._gaussianShader.texture2D = this._postProcessEighthTexture2;
                this._gaussianShader.prepare();
                this._gaussianShader.horizontal = false;
                this._gaussianShader.apply();
                this._gl.drawElements(this._gl.TRIANGLES, this._quad.indexCount, this._gl.UNSIGNED_SHORT, 0);
                this._gl.bindFramebuffer(this._gl.FRAMEBUFFER, this._postProcessSixteenthFrameBuffer2);
                this._gaussianShader.vertexBuffer = this._quad.vertexBuffer;
                this._gaussianShader.indexBuffer = this._quad.indexBuffer;
                this._gaussianShader.texture2D = this._postProcessSixteenthTexture1;
                this._gaussianShader.prepare();
                this._gaussianShader.width = widthSixteenth;
                this._gaussianShader.height = heightSixteenth;
                this._gaussianShader.horizontal = true;
                this._gaussianShader.apply();
                this._gl.drawElements(this._gl.TRIANGLES, this._quad.indexCount, this._gl.UNSIGNED_SHORT, 0);
                this._gl.bindFramebuffer(this._gl.FRAMEBUFFER, this._postProcessSixteenthFrameBuffer1);
                this._gaussianShader.texture2D = this._postProcessSixteenthTexture2;
                this._gaussianShader.prepare();
                this._gaussianShader.horizontal = false;
                this._gaussianShader.apply();
                this._gl.drawElements(this._gl.TRIANGLES, this._quad.indexCount, this._gl.UNSIGNED_SHORT, 0);
            }
            if (this._config.isFxaaEnabled && this._fxaaShader.isInitialized) {
                postProcessFrameBuffer = postProcessFrameBuffer == this._postProcessFrameBuffer1 ? this._postProcessFrameBuffer2 : this._postProcessFrameBuffer1;
                this._gl.bindFramebuffer(this._gl.FRAMEBUFFER, postProcessFrameBuffer);
                this._fxaaShader.vertexBuffer = this._quad.vertexBuffer;
                this._fxaaShader.indexBuffer = this._quad.indexBuffer;
                this._fxaaShader.texture2D = postProcessFrameBuffer == this._postProcessFrameBuffer1 ? this._postProcessTexture2 : this._postProcessTexture1;
                this._fxaaShader.prepare();
                this._fxaaShader.left = viewport.left;
                this._fxaaShader.top = viewport.top;
                this._fxaaShader.width = viewport.width;
                this._fxaaShader.height = viewport.height;
                this._fxaaShader.apply();
                this._gl.drawElements(this._gl.TRIANGLES, this._quad.indexCount, this._gl.UNSIGNED_SHORT, 0);
            }
            this._shaderResources.bindFramebuffer(null);
            this._gl.clear(this._gl.COLOR_BUFFER_BIT | this._gl.DEPTH_BUFFER_BIT);
            this._gl.viewport(viewport.x, viewport.y, viewport.width, viewport.height);
            this._combineShader.vertexBuffer = this._quad.vertexBuffer;
            this._combineShader.indexBuffer = this._quad.indexBuffer;
            this._combineShader.texture2D1 = postProcessFrameBuffer == this._postProcessFrameBuffer1 ? this._postProcessTexture1 : this._postProcessTexture2;
            if (this._config.isBloomEnabled) {
                this._combineShader.texture2D2 = this._postProcessHalfTexture1;
                this._combineShader.texture2D3 = this._postProcessQuarterTexture1;
                this._combineShader.texture2D4 = this._postProcessEighthTexture1;
                this._combineShader.texture2D5 = this._postProcessSixteenthTexture1;
            } else {
                this._combineShader.texture2D2 = null;
                this._combineShader.texture2D3 = null;
                this._combineShader.texture2D4 = null;
                this._combineShader.texture2D5 = null;
            }
            this._combineShader.prepare();
            this._combineShader.viewport = viewport;
            this._combineShader.intensity = this._config.bloomIntensity;
            this._combineShader.apply();
            this._gl.drawElements(this._gl.TRIANGLES, this._quad.indexCount, this._gl.UNSIGNED_SHORT, 0);
        }
    }
}




var $9824374ee38ba7ca$exports = {};

$parcel$export($9824374ee38ba7ca$exports, "Main", () => $d5ed11dd11fe7749$export$861edd1ccea2f746);
$parcel$export($9824374ee38ba7ca$exports, "Material", () => $62116d012d21b949$export$a2d8b23205c25948);
$parcel$export($9824374ee38ba7ca$exports, "MetalMaterial", () => $62116d012d21b949$export$bd17d4a4be11a968);
$parcel$export($9824374ee38ba7ca$exports, "GlossyMaterial", () => $62116d012d21b949$export$5e39c2cd3ef82349);
$parcel$export($9824374ee38ba7ca$exports, "VarnishMaterial", () => $62116d012d21b949$export$1af23049b2ba0aa3);
$parcel$export($9824374ee38ba7ca$exports, "LambertianMaterial", () => $62116d012d21b949$export$61026b7fc8ee0236);
$parcel$export($9824374ee38ba7ca$exports, "DielectricMaterial", () => $62116d012d21b949$export$9578dd56c4cc3fb4);
$parcel$export($9824374ee38ba7ca$exports, "DiffuseLightMaterial", () => $62116d012d21b949$export$5ea5fb140816887a);
$parcel$export($9824374ee38ba7ca$exports, "IsotropicMaterial", () => $62116d012d21b949$export$87cc275e72e16d48);
$parcel$export($9824374ee38ba7ca$exports, "Texture", () => $6060da1e598714a9$export$5431306cf43de24a);
$parcel$export($9824374ee38ba7ca$exports, "SolidColorTexture", () => $6060da1e598714a9$export$b696913510b740d6);
$parcel$export($9824374ee38ba7ca$exports, "ImageTexture", () => $6060da1e598714a9$export$3ad126b3fdb68b5e);
$parcel$export($9824374ee38ba7ca$exports, "CheckerTexture", () => $6060da1e598714a9$export$510d156fb224ecac);
$parcel$export($9824374ee38ba7ca$exports, "GridTexture", () => $6060da1e598714a9$export$121882bab8adda73);
$parcel$export($9824374ee38ba7ca$exports, "Light", () => $1596feb7c9451159$export$6ecadb6ed240d696);
$parcel$export($9824374ee38ba7ca$exports, "SphereLight", () => $1596feb7c9451159$export$f6705b6c922d7219);
$parcel$export($9824374ee38ba7ca$exports, "RectLight", () => $1596feb7c9451159$export$1f9284d52f5c21ca);
$parcel$export($9824374ee38ba7ca$exports, "Ground", () => $6fc486c90d5a34f3$export$c6957adcf93c393f);
$parcel$export($9824374ee38ba7ca$exports, "Constants", () => $ca7af8634961ee25$export$a002182e51710d39);
/*!
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 */ /*!
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 */ 


/*!
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 */ 

/*!
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 */ 
const $62116d012d21b949$export$bd062416169c6728 = {
    lambertian: 0,
    metal: 1,
    dielectric: 2,
    glossy: 3,
    diffuseLight: 4,
    isotropic: 5,
    varnish: 6
};
class $62116d012d21b949$export$673ddcc6bf213111 extends Float32Array {
    constructor(count){
        super(count * $62116d012d21b949$export$673ddcc6bf213111.SIZE);
        this.TYPE_OFFSET = 0;
        this.FUZZ_OFFSET = 1;
        this.REFRACTIVE_INDEX_OFFSET = 2;
        this.TEXTURE_ID_OFFSET = 3;
        this.COLOR_OFFSET = 4;
        this.GLOSSINESS_OFFSET = 7;
        this.ID_COLOR_OFFSET = 8;
        this.DENSITY_OFFSET = 12;
    }
    getType(index) {
        return this[$62116d012d21b949$export$673ddcc6bf213111.SIZE * index + this.TYPE_OFFSET];
    }
    setType(index, value) {
        this[$62116d012d21b949$export$673ddcc6bf213111.SIZE * index + this.TYPE_OFFSET] = value;
    }
    getFuzz(index) {
        return this[$62116d012d21b949$export$673ddcc6bf213111.SIZE * index + this.FUZZ_OFFSET];
    }
    setFuzz(index, value) {
        this[$62116d012d21b949$export$673ddcc6bf213111.SIZE * index + this.FUZZ_OFFSET] = value;
    }
    getRefractiveIndex(index) {
        return this[$62116d012d21b949$export$673ddcc6bf213111.SIZE * index + this.REFRACTIVE_INDEX_OFFSET];
    }
    setRefractiveIndex(index, value) {
        this[$62116d012d21b949$export$673ddcc6bf213111.SIZE * index + this.REFRACTIVE_INDEX_OFFSET] = value;
    }
    getTextureId(index) {
        return this[$62116d012d21b949$export$673ddcc6bf213111.SIZE * index + this.TEXTURE_ID_OFFSET];
    }
    setTextureId(index, value) {
        this[$62116d012d21b949$export$673ddcc6bf213111.SIZE * index + this.TEXTURE_ID_OFFSET] = value;
    }
    getColor(index, value) {
        const offset = $62116d012d21b949$export$673ddcc6bf213111.SIZE * index + this.COLOR_OFFSET;
        (0, $31054a6c69637582$exports).set(value, this[offset], this[offset + 1], this[offset + 2]);
    }
    setColor(index, value) {
        const offset = $62116d012d21b949$export$673ddcc6bf213111.SIZE * index + this.COLOR_OFFSET;
        this[offset] = value[0];
        this[offset + 1] = value[1];
        this[offset + 2] = value[2];
    }
    getGlossiness(index) {
        return this[$62116d012d21b949$export$673ddcc6bf213111.SIZE * index + this.GLOSSINESS_OFFSET];
    }
    setGlossiness(index, value) {
        this[$62116d012d21b949$export$673ddcc6bf213111.SIZE * index + this.GLOSSINESS_OFFSET] = value;
    }
    getDensity(index) {
        return this[$62116d012d21b949$export$673ddcc6bf213111.SIZE * index + this.DENSITY_OFFSET];
    }
    setDensity(index, value) {
        this[$62116d012d21b949$export$673ddcc6bf213111.SIZE * index + this.DENSITY_OFFSET] = value;
    }
    getIdColor(index, value) {
        const offset = $62116d012d21b949$export$673ddcc6bf213111.SIZE * index + this.ID_COLOR_OFFSET;
        (0, $4c4ac78b213a9c07$exports).set(value, this[offset], this[offset + 1], this[offset + 2], this[offset + 3]);
    }
    setIdColor(index, value) {
        const offset = $62116d012d21b949$export$673ddcc6bf213111.SIZE * index + this.ID_COLOR_OFFSET;
        this[offset] = value[0];
        this[offset + 1] = value[1];
        this[offset + 2] = value[2];
        this[offset + 3] = value[3];
    }
}
$62116d012d21b949$export$673ddcc6bf213111.SIZE = 16;
class $62116d012d21b949$export$a2d8b23205c25948 {
    get texture() {
        return this._texture;
    }
    get idColor() {
        return this._idColor;
    }
    constructor(options){
        this._idColor = options.idColor || (0, $4c4ac78b213a9c07$exports).fromValues(0, 0, 0, 0);
    }
    toBuffer(buffer, index, textureId) {}
}
class $62116d012d21b949$export$61026b7fc8ee0236 extends $62116d012d21b949$export$a2d8b23205c25948 {
    constructor(options){
        super(options);
        this._texture = options.texture;
    }
    toBuffer(buffer, index, textureId) {
        buffer.setType(index, $62116d012d21b949$export$bd062416169c6728.lambertian);
        buffer.setIdColor(index, this.idColor);
        buffer.setTextureId(index, textureId);
    }
}
class $62116d012d21b949$export$bd17d4a4be11a968 extends $62116d012d21b949$export$a2d8b23205c25948 {
    constructor(options){
        super(options);
        this.fuzz = options.fuzz !== undefined ? options.fuzz : 0;
        this._texture = options.texture;
    }
    toBuffer(buffer, index, textureId) {
        buffer.setType(index, $62116d012d21b949$export$bd062416169c6728.metal);
        buffer.setIdColor(index, this.idColor);
        buffer.setFuzz(index, this.fuzz);
        buffer.setTextureId(index, textureId);
    }
}
class $62116d012d21b949$export$9578dd56c4cc3fb4 extends $62116d012d21b949$export$a2d8b23205c25948 {
    constructor(options){
        super(options);
        this.fuzz = options && options.fuzz !== undefined ? options.fuzz : 0;
        this.refractiveIndex = options && options.refractiveIndex !== undefined ? options.refractiveIndex : 1.5;
        this.glossiness = options && options.glossiness !== undefined ? options.glossiness : 1;
        this.color = options && options.color || (0, $31054a6c69637582$exports).fromValues(1, 1, 1);
        this.density = options && options.density !== undefined ? options.density : 1;
    }
    toBuffer(buffer, index, textureId) {
        buffer.setType(index, $62116d012d21b949$export$bd062416169c6728.dielectric);
        buffer.setIdColor(index, this.idColor);
        buffer.setRefractiveIndex(index, this.refractiveIndex);
        buffer.setFuzz(index, this.fuzz);
        buffer.setGlossiness(index, this.glossiness);
        buffer.setColor(index, (0, $31054a6c69637582$exports).fromValues(-Math.log(this.color[0]) * this.density, -Math.log(this.color[1]) * this.density, -Math.log(this.color[2]) * this.density));
    }
}
class $62116d012d21b949$export$5ea5fb140816887a extends $62116d012d21b949$export$a2d8b23205c25948 {
    constructor(options){
        super(options);
        this.color = options && options.color || (0, $31054a6c69637582$exports).fromValues(1, 1, 1);
    }
    toBuffer(buffer, index, textureId) {
        buffer.setType(index, $62116d012d21b949$export$bd062416169c6728.diffuseLight);
        buffer.setIdColor(index, this.idColor);
        buffer.setColor(index, this.color);
    }
}
class $62116d012d21b949$export$5e39c2cd3ef82349 extends $62116d012d21b949$export$a2d8b23205c25948 {
    constructor(options){
        super(options);
        this._texture = options.texture;
        this.fuzz = options.fuzz !== undefined ? options.fuzz : 0;
        this.refractiveIndex = options.refractiveIndex !== undefined ? options.refractiveIndex : 1.5;
        this.glossiness = options.glossiness !== undefined ? options.glossiness : 1;
    }
    toBuffer(buffer, index, textureId) {
        buffer.setType(index, $62116d012d21b949$export$bd062416169c6728.glossy);
        buffer.setIdColor(index, this.idColor);
        buffer.setFuzz(index, this.fuzz);
        buffer.setGlossiness(index, this.glossiness);
        buffer.setRefractiveIndex(index, this.refractiveIndex);
        buffer.setTextureId(index, textureId);
    }
}
class $62116d012d21b949$export$87cc275e72e16d48 extends $62116d012d21b949$export$a2d8b23205c25948 {
    constructor(options){
        super(options);
        this.density = options.density;
        this.color = options.color;
    }
    toBuffer(buffer, index, textureId) {
        buffer.setType(index, $62116d012d21b949$export$bd062416169c6728.isotropic);
        buffer.setIdColor(index, this.idColor);
        buffer.setDensity(index, this.density);
        buffer.setColor(index, this.color);
    }
}
class $62116d012d21b949$export$1af23049b2ba0aa3 extends $62116d012d21b949$export$a2d8b23205c25948 {
    constructor(options){
        super(options);
        this.fuzz = options && options.fuzz !== undefined ? options.fuzz : 0;
        this.refractiveIndex = options && options.refractiveIndex !== undefined ? options.refractiveIndex : 1.5;
        this.glossiness = options && options.glossiness !== undefined ? options.glossiness : 1;
    }
    toBuffer(buffer, index, textureId) {
        buffer.setType(index, $62116d012d21b949$export$bd062416169c6728.varnish);
        buffer.setIdColor(index, this.idColor);
        buffer.setFuzz(index, this.fuzz);
        buffer.setGlossiness(index, this.glossiness);
        buffer.setRefractiveIndex(index, this.refractiveIndex);
    }
}


/*!
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 */ 

const $6060da1e598714a9$export$8490d66844ef9609 = {
    none: 0,
    solidColor: 1,
    image: 2,
    sdfText: 3,
    checker: 4,
    grid: 5
};
class $6060da1e598714a9$export$6aa93a36bc90f68e extends Float32Array {
    constructor(count){
        super(count * $6060da1e598714a9$export$6aa93a36bc90f68e.SIZE);
        this.COLOR0_OFFSET = 0;
        this.TYPE_OFFSET = 3;
        this.COLOR1_OFFSET = 4;
        this.SIZE0_OFFSET = 8;
        this.SIZE1_OFFSET = 12;
        this.CLIP_OFFSET = 16;
        this.OFFSET_OFFSET = 20;
    }
    getType(index) {
        return this[$6060da1e598714a9$export$6aa93a36bc90f68e.SIZE * index + this.TYPE_OFFSET];
    }
    setType(index, value) {
        this[$6060da1e598714a9$export$6aa93a36bc90f68e.SIZE * index + this.TYPE_OFFSET] = value;
    }
    getColor0(index, value) {
        const offset = $6060da1e598714a9$export$6aa93a36bc90f68e.SIZE * index + this.COLOR0_OFFSET;
        (0, $31054a6c69637582$exports).set(value, this[offset], this[offset + 1], this[offset + 2]);
    }
    setColor0(index, value) {
        const offset = $6060da1e598714a9$export$6aa93a36bc90f68e.SIZE * index + this.COLOR0_OFFSET;
        this[offset] = value[0];
        this[offset + 1] = value[1];
        this[offset + 2] = value[2];
    }
    getColor1(index, value) {
        const offset = $6060da1e598714a9$export$6aa93a36bc90f68e.SIZE * index + this.COLOR1_OFFSET;
        (0, $31054a6c69637582$exports).set(value, this[offset], this[offset + 1], this[offset + 2]);
    }
    setColor1(index, value) {
        const offset = $6060da1e598714a9$export$6aa93a36bc90f68e.SIZE * index + this.COLOR1_OFFSET;
        this[offset] = value[0];
        this[offset + 1] = value[1];
        this[offset + 2] = value[2];
    }
    getSize0(index, value) {
        const offset = $6060da1e598714a9$export$6aa93a36bc90f68e.SIZE * index + this.SIZE0_OFFSET;
        (0, $4c4ac78b213a9c07$exports).set(value, this[offset], this[offset + 1], this[offset + 2], this[offset + 3]);
    }
    setSize0(index, value) {
        const offset = $6060da1e598714a9$export$6aa93a36bc90f68e.SIZE * index + this.SIZE0_OFFSET;
        this[offset] = value[0];
        this[offset + 1] = value[1];
        this[offset + 2] = value[2];
        this[offset + 3] = value[3];
    }
    getSize1(index, value) {
        const offset = $6060da1e598714a9$export$6aa93a36bc90f68e.SIZE * index + this.SIZE1_OFFSET;
        (0, $4c4ac78b213a9c07$exports).set(value, this[offset], this[offset + 1], this[offset + 2], this[offset + 3]);
    }
    setSize1(index, value) {
        const offset = $6060da1e598714a9$export$6aa93a36bc90f68e.SIZE * index + this.SIZE1_OFFSET;
        this[offset] = value[0];
        this[offset + 1] = value[1];
        this[offset + 2] = value[2];
        this[offset + 3] = value[3];
    }
    getClip(index, value) {
        const offset = $6060da1e598714a9$export$6aa93a36bc90f68e.SIZE * index + this.CLIP_OFFSET;
        (0, $4c4ac78b213a9c07$exports).set(value, this[offset], this[offset + 1], this[offset + 2], this[offset + 3]);
    }
    setClip(index, value) {
        const offset = $6060da1e598714a9$export$6aa93a36bc90f68e.SIZE * index + this.CLIP_OFFSET;
        this[offset] = value[0];
        this[offset + 1] = value[1];
        this[offset + 2] = value[2];
        this[offset + 3] = value[3];
    }
    getOffset(index, value) {
        const offset = $6060da1e598714a9$export$6aa93a36bc90f68e.SIZE * index + this.OFFSET_OFFSET;
        (0, $91b0cc4981465964$exports).set(value, this[offset], this[offset + 1]);
    }
    setOffset(index, value) {
        const offset = $6060da1e598714a9$export$6aa93a36bc90f68e.SIZE * index + this.OFFSET_OFFSET;
        this[offset] = value[0];
        this[offset + 1] = value[1];
    }
}
$6060da1e598714a9$export$6aa93a36bc90f68e.SIZE = 24;
class $6060da1e598714a9$export$5431306cf43de24a {
}
class $6060da1e598714a9$export$b696913510b740d6 extends $6060da1e598714a9$export$5431306cf43de24a {
    constructor(options){
        super();
        this.color = options.color;
        this.borderColor = options.borderColor || (0, $d4d7bd6cc65a5081$export$a002182e51710d39).VECTOR3_ONE;
        this._color = (0, $31054a6c69637582$exports).fromValues(Math.pow(this.color[0], 2.2), Math.pow(this.color[1], 2.2), Math.pow(this.color[2], 2.2));
        this._borderColor = (0, $31054a6c69637582$exports).fromValues(Math.pow(this.borderColor[0], 2.2), Math.pow(this.borderColor[1], 2.2), Math.pow(this.borderColor[2], 2.2));
    }
    toBuffer(buffer, index) {
        buffer.setType(index, $6060da1e598714a9$export$8490d66844ef9609.solidColor);
        buffer.setColor0(index, this._color);
        buffer.setColor1(index, this._borderColor);
    }
}
class $6060da1e598714a9$export$3ad126b3fdb68b5e extends $6060da1e598714a9$export$5431306cf43de24a {
    constructor(options){
        super();
        this.image = options.image;
    }
    toBuffer(buffer, index) {
        buffer.setType(index, $6060da1e598714a9$export$8490d66844ef9609.image);
    }
}
class $6060da1e598714a9$export$510d156fb224ecac extends $6060da1e598714a9$export$5431306cf43de24a {
    constructor(options){
        super();
        this.color0 = options.color0;
        this.color1 = options.color1;
        this.size = options.size;
        this.offset = options.offset || (0, $d4d7bd6cc65a5081$export$a002182e51710d39).VECTOR2_ZERO;
        this._color0 = (0, $31054a6c69637582$exports).fromValues(Math.pow(this.color0[0], 2.2), Math.pow(this.color0[1], 2.2), Math.pow(this.color0[2], 2.2));
        this._color1 = (0, $31054a6c69637582$exports).fromValues(Math.pow(this.color1[0], 2.2), Math.pow(this.color1[1], 2.2), Math.pow(this.color1[2], 2.2));
    }
    toBuffer(buffer, index) {
        buffer.setType(index, $6060da1e598714a9$export$8490d66844ef9609.checker);
        buffer.setColor0(index, this._color0);
        buffer.setColor1(index, this._color1);
        buffer.setSize0(index, (0, $4c4ac78b213a9c07$exports).fromValues(this.size[0], this.size[1], 0, 0));
        buffer.setOffset(index, this.offset);
    }
}
class $6060da1e598714a9$export$121882bab8adda73 extends $6060da1e598714a9$export$5431306cf43de24a {
    constructor(options){
        super();
        this.color0 = options.color0;
        this.color1 = options.color1;
        this.size = options.size;
        this.minorSize = options.minorSize;
        this.thickness = options.thickness;
        this.minorThickness = options.minorThickness;
        this.offset = options.offset || (0, $d4d7bd6cc65a5081$export$a002182e51710d39).VECTOR2_ZERO;
        this.clip = options.clip || (0, $4c4ac78b213a9c07$exports).fromValues(0, 0, 1, 1);
        this._color0 = (0, $31054a6c69637582$exports).fromValues(Math.pow(this.color0[0], 2.2), Math.pow(this.color0[1], 2.2), Math.pow(this.color0[2], 2.2));
        this._color1 = (0, $31054a6c69637582$exports).fromValues(Math.pow(this.color1[0], 2.2), Math.pow(this.color1[1], 2.2), Math.pow(this.color1[2], 2.2));
    }
    toBuffer(buffer, index) {
        buffer.setType(index, $6060da1e598714a9$export$8490d66844ef9609.grid);
        buffer.setColor0(index, this._color0);
        buffer.setColor1(index, this._color1);
        buffer.setSize0(index, (0, $4c4ac78b213a9c07$exports).fromValues(this.size[0], this.size[1], this.minorSize[0], this.minorSize[1]));
        buffer.setSize1(index, (0, $4c4ac78b213a9c07$exports).fromValues(this.thickness[0], this.thickness[1], this.minorThickness[0], this.minorThickness[1]));
        buffer.setOffset(index, this.offset);
        buffer.setClip(index, this.clip);
    }
}


class $cdd30208cd147f64$export$29cd7b75162a9425 extends (0, $a123db7d2af0bebc$export$ecd9923dfd29c8e1) {
    constructor(){
        super();
        this.reset();
    }
    standardLightingOptions(options) {
        const azimuthOffset = options && options.azimuthOffset ? options.azimuthOffset : this.lightingAzimuthOffset;
        const altitude = options && options.altitude ? options.altitude : this.lightingAltitude;
        const size = options && options.size ? options.size : this.lightingSize;
        const distance = options && options.distance ? options.distance : this.lightingDistance;
        return [
            {
                azimuth: -45 + azimuthOffset,
                altitude: altitude,
                distance: distance,
                size: (0, $91b0cc4981465964$exports).fromValues(size, size),
                yaw: -45 + azimuthOffset,
                pitch: altitude,
                color: (0, $31054a6c69637582$exports).fromValues(10, 10, 10)
            },
            {
                azimuth: 45 + azimuthOffset,
                altitude: altitude,
                distance: distance,
                size: (0, $91b0cc4981465964$exports).fromValues(size, size),
                yaw: 45 + azimuthOffset,
                pitch: altitude,
                color: (0, $31054a6c69637582$exports).fromValues(1, 1, 1)
            },
            {
                azimuth: -135 + azimuthOffset,
                altitude: altitude,
                distance: distance,
                size: (0, $91b0cc4981465964$exports).fromValues(size, size),
                yaw: -135 + azimuthOffset,
                pitch: altitude,
                color: (0, $31054a6c69637582$exports).fromValues(1, 1, 1)
            }
        ];
    }
    reset() {
        this.aperture = 0;
        this.exposure = 1;
        this.maxSamplesPerPixel = 10000;
        this.shutterSpeed = 0;
        this.raysPerFrame = 1;
        this.maxPrimsInNode = 1;
        this.defaultMaterial = new (0, $62116d012d21b949$export$61026b7fc8ee0236)({
            texture: new (0, $6060da1e598714a9$export$b696913510b740d6)({
                color: (0, $31054a6c69637582$exports).fromValues(0.5, 0.5, 0.5)
            })
        });
        this.defaultTextMaterial = new (0, $62116d012d21b949$export$61026b7fc8ee0236)({
            texture: new (0, $6060da1e598714a9$export$b696913510b740d6)({
                color: (0, $31054a6c69637582$exports).fromValues(1, 1, 1)
            })
        });
        this.groundSize = (0, $91b0cc4981465964$exports).fromValues(10, 10);
        this.backgroundColor = (0, $4c4ac78b213a9c07$exports).fromValues(0, 0, 0, 1);
        this.lightingAzimuthOffset = 0;
        this.lightingAltitude = 30;
        this.lightingSize = 0.5;
        this.lightingDistance = 1.5;
        this.autoDepth = true;
        this.minDepth = 1;
        this.maxDepth = 10;
        this.edgeDepth = 0.01;
        this.edgeNormal = 0.025;
    }
}


/*!
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 */ 


/*!
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 */ 

class $f858a5fa67a435f5$export$8ec70f2db73b49aa {
    get min() {
        return this._min;
    }
    get max() {
        return this._max;
    }
    constructor(){
        this._min = (0, $31054a6c69637582$exports).fromValues(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE);
        this._max = (0, $31054a6c69637582$exports).fromValues(-Number.MAX_VALUE, -Number.MAX_VALUE, -Number.MAX_VALUE);
    }
    centroid(centroid) {
        centroid[0] = (this._min[0] + this._max[0]) / 2;
        centroid[1] = (this._min[1] + this._max[1]) / 2;
        centroid[2] = (this._min[2] + this._max[2]) / 2;
    }
    size(size) {
        size[0] = this._max[0] - this._min[0];
        size[1] = this._max[1] - this._min[1];
        size[2] = this._max[2] - this._min[2];
    }
    offset(point, normalized) {
        normalized[0] = (point[0] - this._min[0]) / (this._max[0] - this._min[0]);
        normalized[1] = (point[1] - this._min[1]) / (this._max[1] - this._min[1]);
        normalized[2] = (point[2] - this._min[2]) / (this._max[2] - this._min[2]);
    }
    unionBounds(bounds) {
        (0, $31054a6c69637582$exports).min(this._min, this._min, bounds.min);
        (0, $31054a6c69637582$exports).max(this._max, this._max, bounds.max);
    }
    unionPoint(point) {
        (0, $31054a6c69637582$exports).min(this._min, this._min, point);
        (0, $31054a6c69637582$exports).max(this._max, this._max, point);
    }
    maximumExtent() {
        const dx = this._max[0] - this._min[0];
        const dy = this._max[1] - this._min[1];
        const dz = this._max[2] - this._min[2];
        if (dx > dy && dx > dz) return 0;
        else if (dy > dz) return 1;
        return 2;
    }
    surfaceArea() {
        const dx = this._max[0] - this._min[0];
        const dy = this._max[1] - this._min[1];
        const dz = this._max[2] - this._min[2];
        return 2 * (dx * dy + dx * dz + dy * dz);
    }
    rotate(rotation) {
        const sizeX = this._max[0] - this._min[0];
        const sizeY = this._max[1] - this._min[1];
        const sizeZ = this._max[2] - this._min[2];
        const min = (0, $31054a6c69637582$exports).fromValues(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE);
        const max = (0, $31054a6c69637582$exports).fromValues(-Number.MAX_VALUE, -Number.MAX_VALUE, -Number.MAX_VALUE);
        const position = (0, $31054a6c69637582$exports).create();
        const vertices = (0, $c2c30e4dcf8004c5$export$a15f0a83a652dd40).POSITIONS;
        for(let i = 0; i < 8; i++){
            (0, $31054a6c69637582$exports).set(position, vertices[i * 3] * sizeX, vertices[i * 3 + 1] * sizeY, vertices[i * 3 + 2] * sizeZ);
            (0, $31054a6c69637582$exports).transformQuat(position, position, rotation);
            (0, $31054a6c69637582$exports).min(min, min, position);
            (0, $31054a6c69637582$exports).max(max, max, position);
        }
        (0, $31054a6c69637582$exports).copy(this._min, min);
        (0, $31054a6c69637582$exports).copy(this._max, max);
    }
    fromCylinder(pa, pb, radius) {
        const a = (0, $31054a6c69637582$exports).create();
        (0, $31054a6c69637582$exports).subtract(a, pb, pa);
        const aa = (0, $31054a6c69637582$exports).dot(a, a);
        const ex = radius * Math.sqrt(1 - a[0] * a[0] / aa);
        const ey = radius * Math.sqrt(1 - a[1] * a[1] / aa);
        const ez = radius * Math.sqrt(1 - a[2] * a[2] / aa);
        this._min[0] = Math.min(pa[0] - ex, pb[0] - ex);
        this._min[1] = Math.min(pa[1] - ey, pb[1] - ey);
        this._min[2] = Math.min(pa[2] - ez, pb[2] - ez);
        this._max[0] = Math.max(pa[0] + ex, pb[0] + ex);
        this._max[1] = Math.max(pa[1] + ey, pb[1] + ey);
        this._max[2] = Math.max(pa[2] + ez, pb[2] + ez);
    }
}


const $66964bfc3ddbcb4c$export$8daabe80e4a041 = {
    sphere: 0,
    box: 1,
    cylinder: 2,
    hexPrism: 3,
    rotatedBox: 4,
    xyRect: 5,
    xzRect: 6,
    yzRect: 7,
    rotatedXyRect: 8,
    fontXyRect: 9,
    rotatedFontXyRect: 10,
    boxSdf: 11,
    cylinderSdf: 12,
    hexPrismSdf: 13,
    constantMedium: 14,
    sdfXyRect: 15,
    rotatedSdfXyRect: 16,
    rotatedBoxSdf: 17,
    xYDisk: 18,
    rotatedXyDisk: 19,
    ringSdf: 20,
    rotatedRingSdf: 21
};
class $66964bfc3ddbcb4c$export$1337e9dd34ffc243 extends Float32Array {
    constructor(count){
        super(count * $66964bfc3ddbcb4c$export$1337e9dd34ffc243.SIZE);
        this.CENTER0_OFFSET = 0;
        this.TYPE_OFFSET = 3;
        this.SIZE0_OFFSET = 4;
        this.MATERIAL_ID_OFFSET = 7;
        this.ROTATION0_OFFSET = 8;
        this.ROTATION1_OFFSET = 12;
        this.TEXCOORD0_OFFSET = 16;
        this.TEXCOORD1_OFFSET = 18;
        this.CENTER1_OFFSET = 20;
        this.ROUNDING_OFFSET = 23;
        this.SIZE1_OFFSET = 24;
        this.BOUNDARY_TYPE_OFFSET = 27;
        this.TIME0_OFFSET = 28;
        this.TIME1_OFFSET = 29;
        this.TEX_ID_OFFSET = 30;
        this.SDF_BUFFER_OFFSET = 31;
        this.SDF_BORDER_OFFSET = 32;
        this.PARAMETER_1_OFFSET = 33;
        this.PARAMETER_2_OFFSET = 34;
    }
    getType(index) {
        return this[$66964bfc3ddbcb4c$export$1337e9dd34ffc243.SIZE * index + this.TYPE_OFFSET];
    }
    setType(index, value) {
        this[$66964bfc3ddbcb4c$export$1337e9dd34ffc243.SIZE * index + this.TYPE_OFFSET] = value;
    }
    getCenter0(index, value) {
        const offset = $66964bfc3ddbcb4c$export$1337e9dd34ffc243.SIZE * index + this.CENTER0_OFFSET;
        (0, $31054a6c69637582$exports).set(value, this[offset], this[offset + 1], this[offset + 2]);
    }
    setCenter0(index, value) {
        const offset = $66964bfc3ddbcb4c$export$1337e9dd34ffc243.SIZE * index + this.CENTER0_OFFSET;
        this[offset] = value[0];
        this[offset + 1] = value[1];
        this[offset + 2] = value[2];
    }
    getCenter1(index, value) {
        const offset = $66964bfc3ddbcb4c$export$1337e9dd34ffc243.SIZE * index + this.CENTER1_OFFSET;
        (0, $31054a6c69637582$exports).set(value, this[offset], this[offset + 1], this[offset + 2]);
    }
    setCenter1(index, value) {
        const offset = $66964bfc3ddbcb4c$export$1337e9dd34ffc243.SIZE * index + this.CENTER1_OFFSET;
        this[offset] = value[0];
        this[offset + 1] = value[1];
        this[offset + 2] = value[2];
    }
    getTime0(index) {
        return this[$66964bfc3ddbcb4c$export$1337e9dd34ffc243.SIZE * index + this.TIME0_OFFSET];
    }
    setTime0(index, value) {
        this[$66964bfc3ddbcb4c$export$1337e9dd34ffc243.SIZE * index + this.TIME0_OFFSET] = value;
    }
    getTime1(index) {
        return this[$66964bfc3ddbcb4c$export$1337e9dd34ffc243.SIZE * index + this.TIME1_OFFSET];
    }
    setTime1(index, value) {
        this[$66964bfc3ddbcb4c$export$1337e9dd34ffc243.SIZE * index + this.TIME1_OFFSET] = value;
    }
    getSize0(index, value) {
        const offset = $66964bfc3ddbcb4c$export$1337e9dd34ffc243.SIZE * index + this.SIZE0_OFFSET;
        (0, $31054a6c69637582$exports).set(value, this[offset], this[offset + 1], this[offset + 2]);
    }
    setSize0(index, value) {
        const offset = $66964bfc3ddbcb4c$export$1337e9dd34ffc243.SIZE * index + this.SIZE0_OFFSET;
        this[offset] = value[0];
        this[offset + 1] = value[1];
        this[offset + 2] = value[2];
    }
    getSize1(index, value) {
        const offset = $66964bfc3ddbcb4c$export$1337e9dd34ffc243.SIZE * index + this.SIZE1_OFFSET;
        (0, $31054a6c69637582$exports).set(value, this[offset], this[offset + 1], this[offset + 2]);
    }
    setSize1(index, value) {
        const offset = $66964bfc3ddbcb4c$export$1337e9dd34ffc243.SIZE * index + this.SIZE1_OFFSET;
        this[offset] = value[0];
        this[offset + 1] = value[1];
        this[offset + 2] = value[2];
    }
    getMaterialId(index) {
        return this[$66964bfc3ddbcb4c$export$1337e9dd34ffc243.SIZE * index + this.MATERIAL_ID_OFFSET];
    }
    setMaterialId(index, value) {
        this[$66964bfc3ddbcb4c$export$1337e9dd34ffc243.SIZE * index + this.MATERIAL_ID_OFFSET] = value;
    }
    getRotation0(index, value) {
        const offset = $66964bfc3ddbcb4c$export$1337e9dd34ffc243.SIZE * index + this.ROTATION0_OFFSET;
        (0, $39ece26d1239bb77$exports).set(value, this[offset], this[offset + 1], this[offset + 2], this[offset + 3]);
    }
    setRotation0(index, value) {
        const offset = $66964bfc3ddbcb4c$export$1337e9dd34ffc243.SIZE * index + this.ROTATION0_OFFSET;
        this[offset] = value[0];
        this[offset + 1] = value[1];
        this[offset + 2] = value[2];
        this[offset + 3] = value[3];
    }
    getRotation1(index, value) {
        const offset = $66964bfc3ddbcb4c$export$1337e9dd34ffc243.SIZE * index + this.ROTATION1_OFFSET;
        (0, $39ece26d1239bb77$exports).set(value, this[offset], this[offset + 1], this[offset + 2], this[offset + 3]);
    }
    setRotation1(index, value) {
        const offset = $66964bfc3ddbcb4c$export$1337e9dd34ffc243.SIZE * index + this.ROTATION1_OFFSET;
        this[offset] = value[0];
        this[offset + 1] = value[1];
        this[offset + 2] = value[2];
        this[offset + 3] = value[3];
    }
    getTexCoord0(index, value) {
        const offset = $66964bfc3ddbcb4c$export$1337e9dd34ffc243.SIZE * index + this.TEXCOORD0_OFFSET;
        (0, $91b0cc4981465964$exports).set(value, this[offset], this[offset + 1]);
    }
    setTexCoord0(index, value) {
        const offset = $66964bfc3ddbcb4c$export$1337e9dd34ffc243.SIZE * index + this.TEXCOORD0_OFFSET;
        this[offset] = value[0];
        this[offset + 1] = value[1];
    }
    getTexCoord1(index, value) {
        const offset = $66964bfc3ddbcb4c$export$1337e9dd34ffc243.SIZE * index + this.TEXCOORD1_OFFSET;
        (0, $91b0cc4981465964$exports).set(value, this[offset], this[offset + 1]);
    }
    setTexCoord1(index, value) {
        const offset = $66964bfc3ddbcb4c$export$1337e9dd34ffc243.SIZE * index + this.TEXCOORD1_OFFSET;
        this[offset] = value[0];
        this[offset + 1] = value[1];
    }
    getRounding(index) {
        return this[$66964bfc3ddbcb4c$export$1337e9dd34ffc243.SIZE * index + this.ROUNDING_OFFSET];
    }
    setRounding(index, value) {
        this[$66964bfc3ddbcb4c$export$1337e9dd34ffc243.SIZE * index + this.ROUNDING_OFFSET] = value;
    }
    getParameter1(index) {
        return this[$66964bfc3ddbcb4c$export$1337e9dd34ffc243.SIZE * index + this.PARAMETER_1_OFFSET];
    }
    setParameter1(index, value) {
        this[$66964bfc3ddbcb4c$export$1337e9dd34ffc243.SIZE * index + this.PARAMETER_1_OFFSET] = value;
    }
    getParameter2(index) {
        return this[$66964bfc3ddbcb4c$export$1337e9dd34ffc243.SIZE * index + this.PARAMETER_2_OFFSET];
    }
    setParameter2(index, value) {
        this[$66964bfc3ddbcb4c$export$1337e9dd34ffc243.SIZE * index + this.PARAMETER_2_OFFSET] = value;
    }
    getBoundaryType(index) {
        return this[$66964bfc3ddbcb4c$export$1337e9dd34ffc243.SIZE * index + this.BOUNDARY_TYPE_OFFSET];
    }
    setBoundaryType(index, value) {
        this[$66964bfc3ddbcb4c$export$1337e9dd34ffc243.SIZE * index + this.BOUNDARY_TYPE_OFFSET] = value;
    }
    getTexId(index) {
        return this[$66964bfc3ddbcb4c$export$1337e9dd34ffc243.SIZE * index + this.TEX_ID_OFFSET];
    }
    setTexId(index, value) {
        this[$66964bfc3ddbcb4c$export$1337e9dd34ffc243.SIZE * index + this.TEX_ID_OFFSET] = value;
    }
    getSdfBuffer(index) {
        return this[$66964bfc3ddbcb4c$export$1337e9dd34ffc243.SIZE * index + this.SDF_BUFFER_OFFSET];
    }
    setSdfBuffer(index, value) {
        this[$66964bfc3ddbcb4c$export$1337e9dd34ffc243.SIZE * index + this.SDF_BUFFER_OFFSET] = value;
    }
    getSdfBorder(index) {
        return this[$66964bfc3ddbcb4c$export$1337e9dd34ffc243.SIZE * index + this.SDF_BORDER_OFFSET];
    }
    setSdfBorder(index, value) {
        this[$66964bfc3ddbcb4c$export$1337e9dd34ffc243.SIZE * index + this.SDF_BORDER_OFFSET] = value;
    }
}
$66964bfc3ddbcb4c$export$1337e9dd34ffc243.SIZE = 36;
class $66964bfc3ddbcb4c$export$cb7224ab7735b16e {
    get center0() {
        return this._center0;
    }
    get center1() {
        return this._center1;
    }
    get time0() {
        return this._time0;
    }
    get time1() {
        return this._time1;
    }
    get material() {
        return this._material;
    }
    set material(material) {
        this._material = material;
    }
    get bounds() {
        return this._bounds;
    }
    get offset0() {
        return this._offset0;
    }
    get offset1() {
        return this._offset1;
    }
    constructor(options){
        this._center0 = options.center0;
        this._center1 = options.center1;
        this._time0 = options.time0;
        this._time1 = options.time1;
        this._material = options.material;
        this._bounds = new (0, $f858a5fa67a435f5$export$8ec70f2db73b49aa)();
        this._offset0 = (0, $31054a6c69637582$exports).create();
        this._offset1 = (0, $31054a6c69637582$exports).create();
    }
    toBuffer(buffer, index, materialId) {
        buffer.setCenter0(index, this._center0);
        buffer.setCenter1(index, this._center1);
        buffer.setTime0(index, this._time0);
        buffer.setTime1(index, this._time1);
        buffer.setMaterialId(index, materialId);
    }
}
class $66964bfc3ddbcb4c$export$f44a85073ff35bb extends $66964bfc3ddbcb4c$export$cb7224ab7735b16e {
    get radius() {
        return this._radius;
    }
    constructor(options){
        super(options);
        this._radius = options.radius;
        const min = this._bounds.min;
        const max = this._bounds.max;
        min[0] = Math.min(this._center0[0] - this._radius, this._center1[0] - this._radius);
        max[0] = Math.max(this._center0[0] + this._radius, this._center1[0] + this._radius);
        min[1] = Math.min(this._center0[1] - this._radius, this._center1[1] - this._radius);
        max[1] = Math.max(this._center0[1] + this._radius, this._center1[1] + this._radius);
        min[2] = Math.min(this._center0[2] - this._radius, this._center1[2] - this._radius);
        max[2] = Math.max(this._center0[2] + this._radius, this._center1[2] + this._radius);
    }
    toBuffer(buffer, index, materialId) {
        super.toBuffer(buffer, index, materialId);
        buffer.setType(index, $66964bfc3ddbcb4c$export$8daabe80e4a041.sphere);
        buffer.setSize0(index, (0, $31054a6c69637582$exports).fromValues(this._radius, this._radius, this._radius));
    }
}
class $66964bfc3ddbcb4c$export$3f7e8ab42d22375 extends $66964bfc3ddbcb4c$export$cb7224ab7735b16e {
    get texCoord0() {
        return this._texCoord0;
    }
    get texCoord1() {
        return this._texCoord1;
    }
    constructor(options){
        super(options);
        this._thickness = 0.00001;
        this._radius0 = options.radius0;
        this._radius1 = options.radius1;
        this._texCoord0 = options.texCoord0;
        this._texCoord1 = options.texCoord1;
        const min = this._bounds.min;
        const max = this._bounds.max;
        min[0] = Math.min(this._center0[0] - this._radius0, this._center1[0] - this._radius1);
        max[0] = Math.max(this._center0[0] + this._radius0, this._center1[0] + this._radius1);
        min[1] = Math.min(this._center0[1] - this._radius0, this._center1[1] - this._radius1);
        max[1] = Math.max(this._center0[1] + this._radius0, this._center1[1] + this._radius1);
        min[2] = Math.min(this._center0[2] - this._thickness, this._center1[2] - this._thickness);
        max[2] = Math.max(this._center0[2] + this._thickness, this._center1[2] + this._thickness);
    }
    toBuffer(buffer, index, materialId) {
        super.toBuffer(buffer, index, materialId);
        buffer.setType(index, $66964bfc3ddbcb4c$export$8daabe80e4a041.xYDisk);
        buffer.setSize0(index, (0, $31054a6c69637582$exports).fromValues(this._radius0, this._radius0, this._thickness));
        buffer.setSize1(index, (0, $31054a6c69637582$exports).fromValues(this._radius1, this._radius1, this._thickness));
        buffer.setTexCoord0(index, this._texCoord0);
        buffer.setTexCoord1(index, this._texCoord1);
    }
}
class $66964bfc3ddbcb4c$export$1d27985e95946d19 extends $66964bfc3ddbcb4c$export$3f7e8ab42d22375 {
    constructor(options){
        super(options);
        this._rotation0 = options.rotation0;
        this._rotation1 = options.rotation1;
        const rotatedBounds0 = new (0, $f858a5fa67a435f5$export$8ec70f2db73b49aa)();
        const rotatedBounds1 = new (0, $f858a5fa67a435f5$export$8ec70f2db73b49aa)();
        const min0 = rotatedBounds0.min;
        const max0 = rotatedBounds0.max;
        const min1 = rotatedBounds1.min;
        const max1 = rotatedBounds1.max;
        (0, $9614560ff899e49d$export$93b17801046b2267).rotateBounds(this._bounds.min, this._bounds.max, this._rotation0, min0, max0, this._offset0);
        (0, $9614560ff899e49d$export$93b17801046b2267).rotateBounds(this._bounds.min, this._bounds.max, this._rotation1, min1, max1, this._offset1);
        min0[0] = Math.min(min0[0], min1[0]);
        max0[0] = Math.max(max0[0], max1[0]);
        min0[1] = Math.min(min0[1], min1[1]);
        max0[1] = Math.max(max0[1], max1[1]);
        min0[2] = Math.min(min0[2], min1[2]);
        max0[2] = Math.max(max0[2], max1[2]);
        this._bounds = rotatedBounds0;
    }
    toBuffer(buffer, index, materialId) {
        super.toBuffer(buffer, index, materialId);
        buffer.setType(index, $66964bfc3ddbcb4c$export$8daabe80e4a041.rotatedXyDisk);
        buffer.setRotation0(index, this._rotation0);
        buffer.setRotation1(index, this._rotation1);
    }
}
class $66964bfc3ddbcb4c$export$d84131593262075b extends $66964bfc3ddbcb4c$export$cb7224ab7735b16e {
    constructor(options){
        super(options);
        this._size0 = options.size0;
        this._size1 = options.size1;
        this._angle = options.angle0;
        this._innerRadius = options.innerRadius0;
        this._rounding = options.rounding;
        const outerRadius = this._size0[0];
        const innerRadius = this._size0[1];
        const extrudedThicknesses = this._size0[2];
        const min = this._bounds.min;
        const max = this._bounds.max;
        max[1] = this._center0[1] + outerRadius;
        const sinAngle = Math.sin(this._angle);
        const cosAngle = Math.cos(this._angle);
        if (this._angle < (0, $d4d7bd6cc65a5081$export$a002182e51710d39).PI_OVER_TWO) {
            min[0] = this.center0[0] - sinAngle * outerRadius;
            max[0] = this.center0[0] + sinAngle * outerRadius;
            min[1] = this.center0[1] + cosAngle * innerRadius;
        } else {
            min[0] = this._center0[0] - outerRadius;
            max[0] = this._center0[0] + outerRadius;
            min[1] = this._center0[1] + cosAngle * outerRadius;
        }
        min[2] = this._center0[2] - extrudedThicknesses;
        max[2] = this._center0[2] + extrudedThicknesses;
        this.offset0[0] = (min[0] + max[0]) / 2 - this._center0[0];
        this.offset0[1] = (min[1] + max[1]) / 2 - this._center0[1];
        this.offset0[2] = (min[2] + max[2]) / 2 - this._center0[2];
        this.offset1[0] = (min[0] + max[0]) / 2 - this._center1[0];
        this.offset1[1] = (min[1] + max[1]) / 2 - this._center1[1];
        this.offset1[2] = (min[2] + max[2]) / 2 - this._center1[2];
    }
    toBuffer(buffer, index, materialId) {
        super.toBuffer(buffer, index, materialId);
        buffer.setType(index, $66964bfc3ddbcb4c$export$8daabe80e4a041.ringSdf);
        buffer.setSize0(index, this._size0);
        buffer.setSize1(index, this._size1);
        buffer.setParameter1(index, this._angle);
        buffer.setParameter2(index, this._innerRadius);
        buffer.setRounding(index, this._rounding);
    }
}
class $66964bfc3ddbcb4c$export$2d4dbfe5a7e22bdf extends $66964bfc3ddbcb4c$export$d84131593262075b {
    constructor(options){
        super(options);
        this._rotation0 = options.rotation0;
        this._rotation1 = options.rotation1;
        const rotatedBounds0 = new (0, $f858a5fa67a435f5$export$8ec70f2db73b49aa)();
        const rotatedBounds1 = new (0, $f858a5fa67a435f5$export$8ec70f2db73b49aa)();
        const min0 = rotatedBounds0.min;
        const max0 = rotatedBounds0.max;
        const min1 = rotatedBounds1.min;
        const max1 = rotatedBounds1.max;
        (0, $9614560ff899e49d$export$93b17801046b2267).rotateBounds(this._bounds.min, this._bounds.max, this._rotation0, min0, max0, this._offset0);
        (0, $9614560ff899e49d$export$93b17801046b2267).rotateBounds(this._bounds.min, this._bounds.max, this._rotation1, min1, max1, this._offset1);
        min0[0] = Math.min(min0[0], min1[0]);
        max0[0] = Math.max(max0[0], max1[0]);
        min0[1] = Math.min(min0[1], min1[1]);
        max0[1] = Math.max(max0[1], max1[1]);
        min0[2] = Math.min(min0[2], min1[2]);
        max0[2] = Math.max(max0[2], max1[2]);
        this._bounds = rotatedBounds0;
    }
    toBuffer(buffer, index, materialId) {
        super.toBuffer(buffer, index, materialId);
        buffer.setType(index, $66964bfc3ddbcb4c$export$8daabe80e4a041.rotatedRingSdf);
        buffer.setRotation0(index, this._rotation0);
        buffer.setRotation1(index, this._rotation1);
    }
}
class $66964bfc3ddbcb4c$export$28497cc10fec95c2 extends $66964bfc3ddbcb4c$export$cb7224ab7735b16e {
    constructor(options){
        super(options);
        this._size0 = options.size0;
        this._size1 = options.size1;
        const min = this._bounds.min;
        const max = this._bounds.max;
        min[0] = Math.min(this._center0[0] - this._size0[0], this._center1[0] - this._size1[0]);
        max[0] = Math.max(this._center0[0] + this._size0[0], this._center1[0] + this._size1[0]);
        min[1] = Math.min(this._center0[1] - this._size0[1], this._center1[1] - this._size1[1]);
        max[1] = Math.max(this._center0[1] + this._size0[1], this._center1[1] + this._size1[1]);
        min[2] = Math.min(this._center0[2] - this._size0[2], this._center1[2] - this._size1[2]);
        max[2] = Math.max(this._center0[2] + this._size0[2], this._center1[2] + this._size1[2]);
    }
    toBuffer(buffer, index, materialId) {
        super.toBuffer(buffer, index, materialId);
        buffer.setType(index, $66964bfc3ddbcb4c$export$8daabe80e4a041.box);
        buffer.setSize0(index, this._size0);
        buffer.setSize1(index, this._size1);
    }
}
class $66964bfc3ddbcb4c$export$dfaec831a2de7e90 extends $66964bfc3ddbcb4c$export$28497cc10fec95c2 {
    constructor(options){
        super(options);
        this._rounding = options.rounding;
    }
    toBuffer(buffer, index, materialId) {
        super.toBuffer(buffer, index, materialId);
        buffer.setType(index, $66964bfc3ddbcb4c$export$8daabe80e4a041.boxSdf);
        buffer.setRounding(index, this._rounding);
    }
}
class $66964bfc3ddbcb4c$export$e349e1996fd043a1 extends $66964bfc3ddbcb4c$export$dfaec831a2de7e90 {
    constructor(options){
        super(options);
        this._rotation0 = options.rotation0;
        this._rotation1 = options.rotation1;
        const rotatedBounds0 = new (0, $f858a5fa67a435f5$export$8ec70f2db73b49aa)();
        const rotatedBounds1 = new (0, $f858a5fa67a435f5$export$8ec70f2db73b49aa)();
        const min0 = rotatedBounds0.min;
        const max0 = rotatedBounds0.max;
        const min1 = rotatedBounds1.min;
        const max1 = rotatedBounds1.max;
        (0, $9614560ff899e49d$export$93b17801046b2267).rotateBounds(this._bounds.min, this._bounds.max, this._rotation0, min0, max0, this._offset0);
        (0, $9614560ff899e49d$export$93b17801046b2267).rotateBounds(this._bounds.min, this._bounds.max, this._rotation1, min1, max1, this._offset1);
        min0[0] = Math.min(min0[0], min1[0]);
        max0[0] = Math.max(max0[0], max1[0]);
        min0[1] = Math.min(min0[1], min1[1]);
        max0[1] = Math.max(max0[1], max1[1]);
        min0[2] = Math.min(min0[2], min1[2]);
        max0[2] = Math.max(max0[2], max1[2]);
        this._bounds = rotatedBounds0;
    }
    toBuffer(buffer, index, materialId) {
        super.toBuffer(buffer, index, materialId);
        buffer.setType(index, $66964bfc3ddbcb4c$export$8daabe80e4a041.rotatedBoxSdf);
        buffer.setRotation0(index, this._rotation0);
        buffer.setRotation1(index, this._rotation1);
    }
}
class $66964bfc3ddbcb4c$export$acdc70fb29a0312b extends $66964bfc3ddbcb4c$export$28497cc10fec95c2 {
    constructor(options){
        super(options);
        this._rotation0 = options.rotation0;
        this._rotation1 = options.rotation1;
        const rotatedBounds0 = new (0, $f858a5fa67a435f5$export$8ec70f2db73b49aa)();
        const rotatedBounds1 = new (0, $f858a5fa67a435f5$export$8ec70f2db73b49aa)();
        const min0 = rotatedBounds0.min;
        const max0 = rotatedBounds0.max;
        const min1 = rotatedBounds1.min;
        const max1 = rotatedBounds1.max;
        (0, $9614560ff899e49d$export$93b17801046b2267).rotateBounds(this._bounds.min, this._bounds.max, this._rotation0, min0, max0, this._offset0);
        (0, $9614560ff899e49d$export$93b17801046b2267).rotateBounds(this._bounds.min, this._bounds.max, this._rotation1, min1, max1, this._offset1);
        min0[0] = Math.min(min0[0], min1[0]);
        max0[0] = Math.max(max0[0], max1[0]);
        min0[1] = Math.min(min0[1], min1[1]);
        max0[1] = Math.max(max0[1], max1[1]);
        min0[2] = Math.min(min0[2], min1[2]);
        max0[2] = Math.max(max0[2], max1[2]);
        this._bounds = rotatedBounds0;
    }
    toBuffer(buffer, index, materialId) {
        super.toBuffer(buffer, index, materialId);
        buffer.setType(index, $66964bfc3ddbcb4c$export$8daabe80e4a041.rotatedBox);
        buffer.setRotation0(index, this._rotation0);
        buffer.setRotation1(index, this._rotation1);
    }
}
class $66964bfc3ddbcb4c$export$cd2cb390b9add281 extends $66964bfc3ddbcb4c$export$cb7224ab7735b16e {
    get radius() {
        return this._radius;
    }
    get height() {
        return this._height;
    }
    constructor(options){
        super(options);
        this._radius = options.radius;
        this._height = options.height;
        this._rotation0 = options.rotation0 || (0, $d4d7bd6cc65a5081$export$a002182e51710d39).QUAT_IDENTITY;
        this._rotation1 = options.rotation1 || (0, $d4d7bd6cc65a5081$export$a002182e51710d39).QUAT_IDENTITY;
        if (this._rotation0[3] * this._rotation1[3] == 1) {
            const min = this._bounds.min;
            const max = this._bounds.max;
            min[0] = Math.min(this._center0[0] - this._radius, this._center1[0] - this._radius);
            max[0] = Math.max(this._center0[0] + this._radius, this._center1[0] + this._radius);
            min[1] = Math.min(this._center0[1] - this._height, this._center1[1] - this._height);
            max[1] = Math.max(this._center0[1] + this._height, this._center1[1] + this._height);
            min[2] = Math.min(this._center0[2] - this._radius, this._center1[2] - this._radius);
            max[2] = Math.max(this._center0[2] + this._radius, this._center1[2] + this._radius);
        } else {
            const ca0 = (0, $31054a6c69637582$exports).create();
            const pa0 = (0, $31054a6c69637582$exports).create();
            const pb0 = (0, $31054a6c69637582$exports).create();
            (0, $31054a6c69637582$exports).transformQuat(ca0, (0, $d4d7bd6cc65a5081$export$a002182e51710d39).VECTOR3_UNITY, this._rotation0);
            (0, $31054a6c69637582$exports).scaleAndAdd(pa0, this._center0, ca0, -this._height);
            (0, $31054a6c69637582$exports).scaleAndAdd(pb0, this._center0, ca0, this._height);
            const ca1 = (0, $31054a6c69637582$exports).create();
            const pa1 = (0, $31054a6c69637582$exports).create();
            const pb1 = (0, $31054a6c69637582$exports).create();
            (0, $31054a6c69637582$exports).transformQuat(ca1, (0, $d4d7bd6cc65a5081$export$a002182e51710d39).VECTOR3_UNITY, this._rotation1);
            (0, $31054a6c69637582$exports).scaleAndAdd(pa1, this._center1, ca1, -this._height);
            (0, $31054a6c69637582$exports).scaleAndAdd(pb1, this._center1, ca1, this._height);
            this._bounds.fromCylinder(pa0, pb0, this._radius);
            const bounds = new (0, $f858a5fa67a435f5$export$8ec70f2db73b49aa)();
            bounds.fromCylinder(pa1, pb1, this._radius);
            const min0 = this._bounds.min;
            const max0 = this._bounds.max;
            const min1 = bounds.min;
            const max1 = bounds.max;
            min0[0] = Math.min(min0[0], min1[0]);
            max0[0] = Math.max(max0[0], max1[0]);
            min0[1] = Math.min(min0[1], min1[1]);
            max0[1] = Math.max(max0[1], max1[1]);
            min0[2] = Math.min(min0[2], min1[2]);
            max0[2] = Math.max(max0[2], max1[2]);
        }
    }
    toBuffer(buffer, index, materialId) {
        super.toBuffer(buffer, index, materialId);
        buffer.setType(index, $66964bfc3ddbcb4c$export$8daabe80e4a041.cylinder);
        buffer.setSize0(index, (0, $31054a6c69637582$exports).fromValues(this._radius, this._height, this._radius));
        buffer.setSize1(index, (0, $31054a6c69637582$exports).fromValues(this._radius, this._height, this._radius));
        buffer.setRotation0(index, this._rotation0);
        buffer.setRotation1(index, this._rotation1);
    }
}
class $66964bfc3ddbcb4c$export$563880b935f7aee2 extends $66964bfc3ddbcb4c$export$cd2cb390b9add281 {
    constructor(options){
        super(options);
        this._rounding = options.rounding;
    }
    toBuffer(buffer, index, materialId) {
        super.toBuffer(buffer, index, materialId);
        buffer.setType(index, $66964bfc3ddbcb4c$export$8daabe80e4a041.cylinderSdf);
        buffer.setRounding(index, this._rounding);
    }
}
class $66964bfc3ddbcb4c$export$2104cbf9d09a457a extends $66964bfc3ddbcb4c$export$cb7224ab7735b16e {
    get radius() {
        return this._radius;
    }
    get height() {
        return this._height;
    }
    constructor(options){
        super(options);
        this._radius = options.radius;
        this._height = options.height;
        const min = this._bounds.min;
        const max = this._bounds.max;
        min[0] = this._center0[0] - this._radius * (0, $d4d7bd6cc65a5081$export$a002182e51710d39).ROOT_THREE_OVER_TWO;
        max[0] = this._center0[0] + this._radius * (0, $d4d7bd6cc65a5081$export$a002182e51710d39).ROOT_THREE_OVER_TWO;
        min[1] = this._center0[1] - this._height;
        max[1] = this._center0[1] + this._height;
        min[2] = this._center0[2] - this._radius;
        max[2] = this._center0[2] + this._radius;
    }
    toBuffer(buffer, index, materialId) {
        super.toBuffer(buffer, index, materialId);
        buffer.setType(index, $66964bfc3ddbcb4c$export$8daabe80e4a041.hexPrism);
        buffer.setSize0(index, (0, $31054a6c69637582$exports).fromValues(this._radius * (0, $d4d7bd6cc65a5081$export$a002182e51710d39).ROOT_THREE_OVER_TWO, this._height, this._radius));
    }
}
class $66964bfc3ddbcb4c$export$df234dab64f8469a extends $66964bfc3ddbcb4c$export$2104cbf9d09a457a {
    constructor(options){
        super(options);
        this._rounding = options.rounding;
    }
    toBuffer(buffer, index, materialId) {
        super.toBuffer(buffer, index, materialId);
        buffer.setType(index, $66964bfc3ddbcb4c$export$8daabe80e4a041.hexPrismSdf);
        buffer.setRounding(index, this._rounding);
    }
}
class $66964bfc3ddbcb4c$export$3d594d9378ccaeb1 extends $66964bfc3ddbcb4c$export$cb7224ab7735b16e {
    get texCoord0() {
        return this._texCoord0;
    }
    get texCoord1() {
        return this._texCoord1;
    }
    constructor(options){
        super(options);
        this._thickness = 0.00001;
        this._size0 = options.size0;
        this._size1 = options.size1;
        this._texCoord0 = options.texCoord0;
        this._texCoord1 = options.texCoord1;
        this._setBounds();
    }
    toBuffer(buffer, index, materialId) {
        super.toBuffer(buffer, index, materialId);
        buffer.setTexCoord0(index, this._texCoord0);
        buffer.setTexCoord1(index, this._texCoord1);
    }
}
class $66964bfc3ddbcb4c$export$379f0673f20ddbc9 extends $66964bfc3ddbcb4c$export$3d594d9378ccaeb1 {
    _setBounds() {
        const min = this._bounds.min;
        const max = this._bounds.max;
        min[0] = Math.min(this._center0[0] - this._size0[0], this._center1[0] - this._size1[0]);
        max[0] = Math.max(this._center0[0] + this._size0[0], this._center1[0] + this._size1[0]);
        min[1] = Math.min(this._center0[1] - this._size0[1], this._center1[1] - this._size1[1]);
        max[1] = Math.max(this._center0[1] + this._size0[1], this._center1[1] + this._size1[1]);
        min[2] = Math.min(this._center0[2] - this._thickness, this._center1[2] - this._thickness);
        max[2] = Math.max(this._center0[2] + this._thickness, this._center1[2] + this._thickness);
    }
    toBuffer(buffer, index, materialId) {
        super.toBuffer(buffer, index, materialId);
        buffer.setType(index, $66964bfc3ddbcb4c$export$8daabe80e4a041.xyRect);
        buffer.setSize0(index, (0, $31054a6c69637582$exports).fromValues(this._size0[0], this._size0[1], this._thickness));
        buffer.setSize1(index, (0, $31054a6c69637582$exports).fromValues(this._size1[0], this._size1[1], this._thickness));
    }
}
class $66964bfc3ddbcb4c$export$57071e021ef37bbb extends $66964bfc3ddbcb4c$export$3d594d9378ccaeb1 {
    _setBounds() {
        const min = this._bounds.min;
        const max = this._bounds.max;
        min[0] = Math.min(this._center0[0] - this._size0[0], this._center1[0] - this._size1[0]);
        max[0] = Math.max(this._center0[0] + this._size0[0], this._center1[0] + this._size1[0]);
        min[1] = Math.min(this._center0[1] - this._thickness, this._center1[1] - this._thickness);
        max[1] = Math.max(this._center0[1] + this._thickness, this._center1[1] + this._thickness);
        min[2] = Math.min(this._center0[2] - this._size0[1], this._center1[2] - this._size1[1]);
        max[2] = Math.max(this._center0[2] + this._size0[1], this._center1[2] + this._size1[1]);
    }
    toBuffer(buffer, index, materialId) {
        super.toBuffer(buffer, index, materialId);
        buffer.setType(index, $66964bfc3ddbcb4c$export$8daabe80e4a041.xzRect);
        buffer.setSize0(index, (0, $31054a6c69637582$exports).fromValues(this._size0[0], this._thickness, this._size0[1]));
        buffer.setSize1(index, (0, $31054a6c69637582$exports).fromValues(this._size1[0], this._thickness, this._size1[1]));
    }
}
class $66964bfc3ddbcb4c$export$c9a72925228aaa16 extends $66964bfc3ddbcb4c$export$3d594d9378ccaeb1 {
    _setBounds() {
        const min = this._bounds.min;
        const max = this._bounds.max;
        min[0] = Math.min(this._center0[0] - this._thickness, this._center1[0] - this._thickness);
        max[0] = Math.max(this._center0[0] + this._thickness, this._center1[0] + this._thickness);
        min[1] = Math.min(this._center0[1] - this._size0[0], this._center1[1] - this._size1[0]);
        max[1] = Math.max(this._center0[1] + this._size0[0], this._center1[1] + this._size1[0]);
        min[2] = Math.min(this._center0[2] - this._size0[1], this._center1[2] - this._size1[1]);
        max[2] = Math.max(this._center0[2] + this._size0[1], this._center1[2] + this._size1[1]);
    }
    toBuffer(buffer, index, materialId) {
        super.toBuffer(buffer, index, materialId);
        buffer.setType(index, $66964bfc3ddbcb4c$export$8daabe80e4a041.yzRect);
        buffer.setSize0(index, (0, $31054a6c69637582$exports).fromValues(this._thickness, this._size0[0], this._size0[1]));
        buffer.setSize1(index, (0, $31054a6c69637582$exports).fromValues(this._thickness, this._size1[0], this._size1[1]));
    }
}
class $66964bfc3ddbcb4c$export$da0b2fe0ae5e85dd extends $66964bfc3ddbcb4c$export$379f0673f20ddbc9 {
    constructor(options){
        super(options);
        this._sdfBuffer = options.sdfBuffer;
    }
    toBuffer(buffer, index, materialId) {
        super.toBuffer(buffer, index, materialId);
        buffer.setSdfBuffer(index, this._sdfBuffer);
        buffer.setType(index, $66964bfc3ddbcb4c$export$8daabe80e4a041.fontXyRect);
    }
}
class $66964bfc3ddbcb4c$export$6d714417e0aa3f19 extends $66964bfc3ddbcb4c$export$379f0673f20ddbc9 {
    constructor(options){
        super(options);
        this._texId = options.texId;
        this._sdfBuffer = options.sdfBuffer;
        this._sdfBorder = options.sdfBorder;
    }
    toBuffer(buffer, index, materialId) {
        super.toBuffer(buffer, index, materialId);
        buffer.setTexId(index, this._texId);
        buffer.setSdfBuffer(index, this._sdfBuffer);
        buffer.setSdfBorder(index, this._sdfBorder);
        buffer.setType(index, $66964bfc3ddbcb4c$export$8daabe80e4a041.sdfXyRect);
    }
}
class $66964bfc3ddbcb4c$export$71089e9c0fdb5c5 extends $66964bfc3ddbcb4c$export$379f0673f20ddbc9 {
    constructor(options){
        super(options);
        this._rotation0 = options.rotation0;
        this._rotation1 = options.rotation1;
        const rotatedBounds0 = new (0, $f858a5fa67a435f5$export$8ec70f2db73b49aa)();
        const rotatedBounds1 = new (0, $f858a5fa67a435f5$export$8ec70f2db73b49aa)();
        const min0 = rotatedBounds0.min;
        const max0 = rotatedBounds0.max;
        const min1 = rotatedBounds1.min;
        const max1 = rotatedBounds1.max;
        (0, $9614560ff899e49d$export$93b17801046b2267).rotateBounds(this._bounds.min, this._bounds.max, this._rotation0, min0, max0, this._offset0);
        (0, $9614560ff899e49d$export$93b17801046b2267).rotateBounds(this._bounds.min, this._bounds.max, this._rotation1, min1, max1, this._offset1);
        min0[0] = Math.min(min0[0], min1[0]);
        max0[0] = Math.max(max0[0], max1[0]);
        min0[1] = Math.min(min0[1], min1[1]);
        max0[1] = Math.max(max0[1], max1[1]);
        min0[2] = Math.min(min0[2], min1[2]);
        max0[2] = Math.max(max0[2], max1[2]);
        this._bounds = rotatedBounds0;
    }
    toBuffer(buffer, index, materialId) {
        super.toBuffer(buffer, index, materialId);
        buffer.setType(index, $66964bfc3ddbcb4c$export$8daabe80e4a041.rotatedXyRect);
        buffer.setRotation0(index, this._rotation0);
        buffer.setRotation1(index, this._rotation1);
    }
}
class $66964bfc3ddbcb4c$export$402b844452575dc9 extends $66964bfc3ddbcb4c$export$71089e9c0fdb5c5 {
    constructor(options){
        super(options);
        this._sdfBuffer = options.sdfBuffer;
    }
    toBuffer(buffer, index, materialId) {
        super.toBuffer(buffer, index, materialId);
        buffer.setSdfBuffer(index, this._sdfBuffer);
        buffer.setType(index, $66964bfc3ddbcb4c$export$8daabe80e4a041.rotatedFontXyRect);
    }
}
class $66964bfc3ddbcb4c$export$c2e43d40ab2c967e extends $66964bfc3ddbcb4c$export$71089e9c0fdb5c5 {
    constructor(options){
        super(options);
        this._texId = options.texId;
        this._sdfBuffer = options.sdfBuffer;
        this._sdfBorder = options.sdfBorder;
    }
    toBuffer(buffer, index, materialId) {
        super.toBuffer(buffer, index, materialId);
        buffer.setTexId(index, this._texId);
        buffer.setSdfBuffer(index, this._sdfBuffer);
        buffer.setSdfBorder(index, this._sdfBorder);
        buffer.setType(index, $66964bfc3ddbcb4c$export$8daabe80e4a041.rotatedSdfXyRect);
    }
}
class $66964bfc3ddbcb4c$export$412c0ed39e393270 extends $66964bfc3ddbcb4c$export$cb7224ab7735b16e {
    get boundary() {
        return this._boundary;
    }
    constructor(options){
        super(options);
        this._boundary = options.boundary;
        this._bounds = this._boundary.bounds;
    }
    toBuffer(buffer, index, materialId) {
        this._boundary.toBuffer(buffer, index, materialId);
        buffer.setBoundaryType(index, buffer.getType(index));
        buffer.setType(index, $66964bfc3ddbcb4c$export$8daabe80e4a041.constantMedium);
    }
}



/*!
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 */ 
const $e1b604d7f27d3d8e$export$7173403786dbea8d = `
const PI = 3.1415926535897932385f;
const TWO_PI = 6.2831853071795864769f;
const ROOT_THREE_OVER_TWO = 0.86602540378443864676f;

struct ColorBuffer {
    values: array<f32>,
}

// (normal.x, normal.y, normal.z, depth)
struct NormalDepthBuffer {
    values: array<f32>,
}

// Min, max
// TODO: Convert to atomic add with uint
struct DepthMinMaxBuffer {
    values: array<atomic<u32>>,
}

struct Ray {
    origin: vec3<f32>,
    direction: vec3<f32>,
    time: f32,
}

struct HitRecord {
    normal: vec3<f32>,
    t: f32,
    frontFace: bool,
    materialId: u32,
    uv: vec2<f32>,
    id: u32,
    previousId: u32,
    position: vec3<f32>,
    previousPosition: vec3<f32>,
    isAbsorbing: bool,
    previousIsAbsorbing: bool,
    absorption: vec3<f32>,
    previousAbsorption: vec3<f32>,
    sdfBorder: bool,
}

struct Camera {
    origin: vec3<f32>,
    lowerLeftCorner: vec3<f32>,
    horizontal: vec3<f32>,
    vertical: vec3<f32>,
    lookAt: vec3<f32>,
    u: vec3<f32>,
    v: vec3<f32>,
    w: vec3<f32>,
    aspectRatio: f32,
    viewportWidth: f32,
    viewportHeight: f32,
    fov: f32,
    aperture: f32,
    time0: f32,
    time1: f32,
}

                                //         offest   align    size
struct Uniforms {               // ------------------------------
    position: vec3<f32>,        //              0      16      12
    width: f32,                 //             12       4       4
    right: vec3<f32>,           //             16      16      12
    height: f32,                //             28       4       4
    up: vec3<f32>,              //             32      16      12
    seed: f32,                  //             44       4       4
    forward: vec3<f32>,         //             48      16      12
    fov: f32,                   //             60       4       4
    lookAt: vec3<f32>,          //             64      16      12
    aperture: f32,              //             76       4       4
    backgroundColor: vec3<f32>, //             80      16      12
    time0: f32,                 //             92       4       4
    time1: f32,                 //             96       4       4
    tilesX : f32,               //            100       4       4
    tilesY : f32,               //            104       4       4
    tileOffsetX : f32,          //            108       4       4
    tileOffsetY : f32,          //            112       4       4
    raysPerFrame : f32,         //            116       4       4
                                // padding    120       4       8
                                // ------------------------------
                                //                     16     128
}

// id   type
// ----------------
// 0    none
// 1    solidColor
// 2    image
// 3    sdfText
// 4    checker
// 5    grid
                       //         offest   align    size   stride
struct Texture {       // ---------------------------------------
    color0: vec3<f32>, //              0      16      12
    typeId: f32,       //             12       4       4
    color1: vec3<f32>, //             16      12      12
                       // padding     28      12      12
    size0: vec4<f32>,  //             32      16      16
    size1: vec4<f32>,  //             48      16      16
    clip:  vec4<f32>,  //             64      16      16
    offset: vec2<f32>, //             80       8       8
}                      // ---------------------------------------
                       //                     16      88       96

// id   type
// ---------------
// 0    lambertian
// 1    metal
// 2    dielectric
// 3    diffuse light
// 4    glossy
// 5    isotropic
// 6    varnitsh
                          //         offest   align    size   stride
struct Material {         // ---------------------------------------
    typeId: f32,          //              0       4       4
    fuzz: f32,            //              4       4       4
    refractiveIndex: f32, //              8       4       4
    textureId: f32,       //             12       4       4
    color: vec3<f32>,     //             16      16      12
    glossiness: f32,      //             28       4       4
    idColor: vec4<f32>,   //             32      16      16
    density: f32,         //             48       4       4
                          // ---------------------------------------
}                         //                     16      52       64

// id   type
// ----------------
// 0    distant
// 1    sphere
// 2    rect
// 3    disk
// 4    cylinder
// 5    dome
                         //         offest   align    size   stride
struct Light {           // ---------------------------------------
    rotation: vec4<f32>, //              0      16      16
    center: vec3<f32>,   //             16      16      12
    typeId: f32,         //             28       4       4
    size: vec3<f32>,     //             32      16      12
                         // padding     44       4       4
    color: vec3<f32>,    //             48      16      12
}                        // ---------------------------------------
                         //                     16      60       64

// id   type
// ----------------
//  0   sphere
//  1   box
//  2   cylinder
//  3   hexPrism
//  4   rotatedBox
//  5   xyRect
//  6   xzRect
//  7   yzRect
//  8   rotatedXyRect
//  9   fontXyRect
// 10   rotatedFontXyRect
// 11   boxSdf
// 12   cylinderSdf
// 13   hexPrismSdf
// 14   constantMedium
// 15   sdfXyRect
// 16   rotatedSdfXyRect
// 17   rotatedBoxSdf
// 18   xyDisk
// 19   rotatedXyDisk
// 20   ringSdf
// 21   rotatedRingSdf
                          //         offest   align    size   stride
struct Hittable {         // ---------------------------------------
    center0: vec3<f32>,   //              0      16      12
    typeId: f32,          //             12       4       4
    size0: vec3<f32>,     //             16      16      12
    materialId: f32,      //             28       4       4
    rotation0: vec4<f32>, //             32      16      16
    rotation1: vec4<f32>, //             48      16      16
    texCoord0: vec2<f32>, //             64       8       8
    texCoord1: vec2<f32>, //             72       8       8
    center1: vec3<f32>,   //             80      16      12 
    rounding: f32,        //             92       4       4 
    size1: vec3<f32>,     //             96      16      12
    boundaryTypeId: f32,  //            108       4       4
    time0: f32,           //            112       4       4
    time1: f32,           //            116       4       4
    texId: f32,           //            120       4       4
    sdfBuffer: f32,       //            124       4       4
    sdfBorder: f32,       //            128       4       4
    parameter1: f32,      //            132       4       4
    parameter2: f32,      //            136       4       4
                          // padding    140       4       4
}                         // ---------------------------------------
                          //                     16     144      144

                            //         offest   align    size   stride
struct LinearBVHNode {      // ---------------------------------------
    center: vec3<f32>,      //              0      16      12
    primitivesOffset: f32,  //             12       4       4
    size: vec3<f32>,        //             16      16      12
    secondChildOffset: f32, //             28       4       4
    nPrimitives: f32,       //             32       4       4
    axis: f32,              //             36       4       4
}                           // ---------------------------------------
                            //                     16      40       48

struct HittableBuffer {
    hittables: array<Hittable>,
}

struct MaterialBuffer {
    materials: array<Material>,
}

struct TextureBuffer {
    textures: array<Texture>,
}

struct LightBuffer {
    lights: array<Light>,
}

struct LinearBVHNodeBuffer {
    nodes: array<LinearBVHNode>,
}

// Schlick's approximation for reflectance
fn reflectance(cos: f32, refractiveIndex: f32) -> f32 {
    var r = (1f - refractiveIndex) / (1f + refractiveIndex);
    r = r * r;
    return r + (1f - r) * pow(1f - cos, 5f);
}

fn refraction(uv: vec3<f32>, n: vec3<f32>, etaiOverEtat: f32) -> vec3<f32> {
    let cosTheta = min(dot(-uv, n), 1f);
    let rOutPerp =  etaiOverEtat * (uv + cosTheta * n);
    let rOutParallel = -sqrt(abs(1f - dot(rOutPerp, rOutPerp))) * n;
    return rOutPerp + rOutParallel;
}

fn getCamera(uniforms: Uniforms) -> Camera {
    var camera: Camera;
    camera.aperture = uniforms.aperture;
    camera.aspectRatio = uniforms.width / uniforms.height;
    camera.fov = uniforms.fov;
    camera.viewportHeight = 2f * tan(camera.fov / 2f);
    camera.viewportWidth = camera.aspectRatio * camera.viewportHeight;
    camera.origin = uniforms.position;
    camera.lookAt = uniforms.lookAt;
    camera.u = uniforms.right;
    camera.v = uniforms.up;
    camera.w = uniforms.forward;
    let focusDistance = dot(camera.w, camera.origin - camera.lookAt);
    camera.horizontal = camera.u * camera.viewportWidth * focusDistance;
    camera.vertical = camera.v * camera.viewportHeight * focusDistance;
    camera.lowerLeftCorner = camera.origin - camera.horizontal / 2f + camera.vertical / 2f - camera.w * focusDistance;
    camera.time0 = uniforms.time0;
    camera.time1 = uniforms.time1;
    return camera;
}

fn getCameraRay(camera: Camera, seed: ptr<function, u32>, texCoord: vec2<f32>) -> Ray {
    // Depth of field
    let rd = camera.aperture * randomInUnitDisk(seed);
    let offset = camera.u * rd.x + camera.v * rd.y;

    var ray: Ray;
    ray.origin = camera.origin + offset;
    ray.direction = normalize(camera.lowerLeftCorner + texCoord.x * camera.horizontal - texCoord.y * camera.vertical - camera.origin - offset);
    ray.time = camera.time0 + random(seed) * (camera.time1 - camera.time0);
    return ray;
}

fn degreesToRadians(degrees: f32) -> f32 {
    return degrees * PI / 180f;
}

// See https://www.reedbeta.com/blog/hash-functions-for-gpu-rendering/
fn random(seed: ptr<function, u32>) -> f32 {
    var random = ((*seed >> ((*seed >> 28u) + 4u)) ^ *seed) * 277803737u;
    random = (random >> 22u) ^ random;
    *seed = *seed * 747796405u + 2891336453u;
    return f32(random) / 4294967295f; // [0,1]
}

fn randomInUnitDisk(seed: ptr<function, u32>) -> vec2<f32> {
    var p: vec2<f32>;
    loop {
        p = 2f * vec2<f32>(random(seed), random(seed)) - vec2<f32>(1f, 1f);
        if (dot(p, p) <= 1f) { break; }
    }
    return p;
}

// fn randomInUnitDisk(seed: ptr<function, u32>) -> vec2<f32> {
//     let t = TWO_PI * random(seed);
//     let r = sqrt(random(seed));
//     return r * vec2<f32>(cos(t), sin(t));
// }

fn randomInUnitSphere(seed: ptr<function, u32>) -> vec3<f32> {
    var p: vec3<f32>;
    loop {
        p = 2f * vec3<f32>(random(seed), random(seed), random(seed)) - vec3<f32>(1f, 1f, 1f);
        if (dot(p, p) <= 1f) { break; }
    }
    return p;
}

fn randomUnitVector(seed: ptr<function, u32>) -> vec3<f32> {
    return normalize(randomInUnitSphere(seed));
}

// fn randomUnitVector(seed: ptr<function, u32>) -> vec3<f32> {
//     let theta = TWO_PI * random(seed); // [0,2Pi]
//     let phi = acos(2f * random(seed) - 1f); // [-1,1]
//     return vec3<f32>(sin(phi) * cos(theta), sin(phi) * sin(theta), cos(phi));
// }

fn rayAt(ray: Ray, t: f32) -> vec3<f32> {
    return ray.origin + ray.direction * t;
}

fn setFaceNormal(ray: Ray, outwardNormal: vec3<f32>, hitRecord: ptr<function, HitRecord>) {
    (*hitRecord).frontFace = dot(ray.direction, outwardNormal) < 0f;
    (*hitRecord).normal = select(-outwardNormal, outwardNormal, (*hitRecord).frontFace);
}

// fn hitWorld(ray: Ray, tMin: f32, tMax: f32, hitRecord: ptr<function, HitRecord>, seed: ptr<function, u32>) -> bool {
//     var hitAnything = false;
//     var closestSoFar = tMax;
//     let invDir = vec3<f32>(1f, 1f, 1f) / ray.direction;
//     var tempHitRecord: HitRecord;
//     for (var i: u32 = 0u; i < arrayLength(&hittableBuffer.hittables); i = i + 1u) {
//         if (hit(i, ray, invDir, tMin, closestSoFar, &tempHitRecord, seed)) {
//             hitAnything = true;
//             closestSoFar = tempHitRecord.t;
//             tempHitRecord.materialId = u32(hittableBuffer.hittables[i].materialId);
//             *hitRecord = tempHitRecord;
//         }
//     }
//     return hitAnything;
// }

fn hitBVH(ray: Ray, tMin: f32, tMax: f32, hitRecord: ptr<function, HitRecord>, seed: ptr<function, u32>) -> bool {
    var hitAnything = false;
    var closestSoFar = tMax;
    let invDir = vec3<f32>(1f, 1f, 1f) / ray.direction;
    var tempHitRecord: HitRecord;
    var toVisitOffset = 0u;
    var currentNodeIndex = 0u;
    var nodesToVisit: array<u32, 64>;
    loop {
        let node = &linearBVHNodeBuffer.nodes[currentNodeIndex];
        // Check ray against BVH node
        if (intersectBox((*node).center, (*node).size, ray, invDir, tMin, closestSoFar)) {
            let nPrimitives = u32((*node).nPrimitives);
            if (nPrimitives > 0u) {
                let primitiveOffset = u32((*node).primitivesOffset);
                for (var i: u32 = 0u; i < nPrimitives; i = i + 1u) {
                    let id = primitiveOffset + i;
                    if (hit(id, ray, invDir, tMin, closestSoFar, &tempHitRecord, seed)) {
                        hitAnything = true;
                        closestSoFar = tempHitRecord.t;
                        tempHitRecord.materialId = u32(hittableBuffer.hittables[id].materialId);
                        tempHitRecord.id = id;
                    }
                }
                if (toVisitOffset == 0u) { break; }
                toVisitOffset = toVisitOffset - 1u;
                currentNodeIndex = nodesToVisit[toVisitOffset];
            }
            else {
                // Put far BVH node on nodesToVisit stack, advance to near node
                if (ray.direction[u32((*node).axis)] < 0f) {
                   nodesToVisit[toVisitOffset] = currentNodeIndex + 1u;
                   currentNodeIndex = u32((*node).secondChildOffset);
                } else {
                   nodesToVisit[toVisitOffset] = u32((*node).secondChildOffset);
                   currentNodeIndex = currentNodeIndex + 1u;
                }
                toVisitOffset = toVisitOffset + 1u;
            }
        }
        else {
            if (toVisitOffset == 0u) { break; }
            toVisitOffset = toVisitOffset - 1u;
            currentNodeIndex = nodesToVisit[toVisitOffset];
        }
    }
    if (hitAnything) {
        tempHitRecord.previousId = (*hitRecord).id;
        tempHitRecord.previousPosition = (*hitRecord).position;
        tempHitRecord.previousIsAbsorbing = (*hitRecord).isAbsorbing;
        tempHitRecord.previousAbsorption = (*hitRecord).absorption;
        *hitRecord = tempHitRecord;
        return true;
    };
    return false;
}

fn hit(id: u32, ray: Ray, invDir: vec3<f32>, tMin: f32, tMax: f32, hitRecord: ptr<function, HitRecord>, seed: ptr<function, u32>) -> bool {
    switch u32(hittableBuffer.hittables[id].typeId) {
        default: {
            return false;
        }
        case 0u: {
            return hitSphere(id, ray, tMin, tMax, hitRecord);
        }
        case 1u: {
            return hitBox(id, ray, invDir, tMin, tMax, hitRecord);
        }
        case 2u: {
            return hitCylinder(id, ray, tMin, tMax, hitRecord);
        }
        case 3u: {
            return hitHexPrism(id, ray, tMin, tMax, hitRecord);
        }
        case 4u: {
            return hitRotatedBox(id, ray, tMin, tMax, hitRecord);
        }
        case 5u: {
            return hitXyRect(id, ray, tMin, tMax, hitRecord);
        }
        case 6u: {
            return hitXzRect(id, ray, tMin, tMax, hitRecord);
        }
        // case 7u: {
        //     return hitYzRect(hittable, ray, tMin, tMax, hitRecord);
        // }
        case 8u: {
            return hitRotatedXyRect(id, ray, tMin, tMax, hitRecord);
        }
        case 9u: {
            return hitFontXyRect(id, ray, tMin, tMax, hitRecord);
        }
        case 10u: {
            return hitRotatedFontXyRect(id, ray, tMin, tMax, hitRecord);
        }
        case 11u: {
            return hitBoxSdf(id, ray, tMin, tMax, hitRecord);
        }
        case 12u: {
            return hitCylinderSdf(id, ray, tMin, tMax, hitRecord);
        }
        case 13u: {
            return hitHexPrismSdf(id, ray, tMin, tMax, hitRecord);
        }
        case 14u: {
            return hitConstantMedium(id, ray, invDir, tMin, tMax, hitRecord, seed);
        }
        case 15u: {
            return hitSdfXyRect(id, ray, tMin, tMax, hitRecord, seed);
        }
        case 16u: {
            return hitRotatedSdfXyRect(id, ray, tMin, tMax, hitRecord, seed);
        }
        case 17u: {
            return hitRotatedBoxSdf(id, ray, tMin, tMax, hitRecord);
        }
        case 18u: {
            return hitXyDisk(id, ray, tMin, tMax, hitRecord);
        }
        case 19u: {
            return hitRotatedXyDisk(id, ray, tMin, tMax, hitRecord);
        }
        case 20u: {
            return hitRingSdf(id, ray, tMin, tMax, hitRecord);
        }
        case 21u: {
            return hitRotatedRingSdf(id, ray, tMin, tMax, hitRecord);
        }
    }
}

fn intersectBox(center: vec3<f32>, size: vec3<f32>, ray: Ray, invDir: vec3<f32>, tMin: f32, tMax: f32) -> bool {
    let oc = ray.origin - center;
    let n = invDir * oc;
    let k = abs(invDir) * size; // Box size is from center to edge
    let t0 = -n - k;
    let t1 = -n + k;
    let tNear = max(max(t0.x, t0.y), t0.z);
    let tFar = min(min(t1.x, t1.y), t1.z);
    if (tNear > tFar) { return false; }
    return tNear < tMax && tFar > 0f; // Must return true when inside box, even if closestSoFar is closer than far box intersection
}

fn hitConstantMedium(id: u32, ray: Ray, invDir: vec3<f32>, tMin: f32, tMax: f32, hitRecord: ptr<function, HitRecord>, seed: ptr<function, u32>) -> bool {
    let constantMedium = &hittableBuffer.hittables[id];
    let boundaryTypeId = u32((*constantMedium).boundaryTypeId);
    var tempHitRecord1: HitRecord;
    if (!hitConstantMediumBoundary(id, boundaryTypeId, ray, invDir, -100f, 100f, &tempHitRecord1)) { return false; }
    var tempHitRecord2: HitRecord;
    // When raymarching narrow grazing angles, adding SHADOW_OFFSET is < epsilon from surface, so hit function returns tN not tF, hence distanceInsideBoundary is incorrect
    // Add larger distance to t
    if (!hitConstantMediumBoundary(id, boundaryTypeId, ray, invDir, tempHitRecord1.t + 0.001f, 100f, &tempHitRecord2)) { return false; }
    if (tempHitRecord1.t < tMin) { tempHitRecord1.t = tMin; }
    if (tempHitRecord2.t > tMax) { tempHitRecord2.t = tMax; }
    if (tempHitRecord1.t >= tempHitRecord2.t) {
        return false;
    }
    tempHitRecord1.t = max(tempHitRecord1.t, 0f);
    let distanceInsideBoundary = tempHitRecord2.t - tempHitRecord1.t;
    let negativeInverseDensity = -1f / materialBuffer.materials[u32((*constantMedium).materialId)].density;
    let hitDistance = negativeInverseDensity * log(random(seed));
    if (hitDistance > distanceInsideBoundary) { return false; }
    let t = tempHitRecord1.t + hitDistance;
    (*hitRecord).t = t;
    (*hitRecord).position = rayAt(ray, t);
    return true;
}

fn hitConstantMediumBoundary(id: u32, boundaryTypeId: u32, ray: Ray, invDir: vec3<f32>, tMin: f32, tMax: f32, hitRecord: ptr<function, HitRecord>) -> bool {
    switch boundaryTypeId {
        default: {
            return false;
        }
        case 0u: {
            return hitSphere(id, ray, tMin, tMax, hitRecord);
        }
        case 1u: {
            return hitBox(id, ray, invDir, tMin, tMax, hitRecord);
        }
        case 2u: {
            return hitCylinder(id, ray, tMin, tMax, hitRecord);
        }
        case 3u: {
            return hitHexPrism(id, ray, tMin, tMax, hitRecord);
        }
        case 4u: {
            return hitRotatedBox(id, ray, tMin, tMax, hitRecord);
        }
        case 11u: {
            return hitBoxSdf(id, ray, tMin, tMax, hitRecord);
        }
        case 12u: {
            return hitCylinderSdf(id, ray, tMin, tMax, hitRecord);
        }
        case 13u: {
            return hitHexPrismSdf(id, ray, tMin, tMax, hitRecord);
        }
        case 17u: {
            return hitRotatedBoxSdf(id, ray, tMin, tMax, hitRecord);
        }
        case 20u: {
            return hitRingSdf(id, ray, tMin, tMax, hitRecord);
        }
        case 21u: {
            return hitRotatedRingSdf(id, ray, tMin, tMax, hitRecord);
        }
    }
}

fn hitSphere(id: u32, ray: Ray, tMin: f32, tMax: f32, hitRecord: ptr<function, HitRecord>) -> bool {
    let sphere = &hittableBuffer.hittables[id];
    let radius = (*sphere).size0.x;
    let time =  min(max((ray.time - (*sphere).time0) / ((*sphere).time1 - (*sphere).time0), 0f), 1f); // Normalize time to [0,1]
    let center = (*sphere).center0 + time * ((*sphere).center1 - (*sphere).center0);
    let oc = ray.origin - center;
    let b = dot(oc, ray.direction);
    let c = dot(oc, oc) - radius * radius;
    var h = b * b - c;
    if (h < 0f) { return false; }
    h = sqrt(h);

    // Find the nearest root in range
    var root = -b - h;
    if (root < tMin || root > tMax) {
        root = -b + h;
        if (root < tMin || root > tMax) { return false; }
    }
   
    // (*hitRecord).t = root;
    // (*hitRecord).position = rayAt(ray, root);
    // let outwardNormal = ((*hitRecord).position - center) / radius;
    // setFaceNormal(ray, outwardNormal, hitRecord);
   
    // Reduce precision error in t by ensuring hit position is on sphere surface
    let outwardNormal = normalize(ray.origin + ray.direction * root - center);  
    setFaceNormal(ray, outwardNormal, hitRecord);
    (*hitRecord).position = center + outwardNormal * radius; // Use outward normal with internal reflection
    (*hitRecord).t = root; // I should also re-calculate t, but this would involve another normalization. t is only used to check closest hit, so only important with overlapping geometry
   
    // UV
    let phi = atan2(outwardNormal.x, outwardNormal.z); // [-pi,pi]
    let theta = asin(outwardNormal.y); // [-pi/2, pi/2]
    (*hitRecord).uv = vec2<f32>(phi / TWO_PI + 0.5f, theta / PI + 0.5f); // [0,1]
    return true;
}

fn hitBox(id: u32, ray: Ray, invDir: vec3<f32>, tMin: f32, tMax: f32, hitRecord: ptr<function, HitRecord>) -> bool {
    let box = &hittableBuffer.hittables[id];
    let time =  min(max((ray.time - (*box).time0) / ((*box).time1 - (*box).time0), 0f), 1f); // Normalize time to [0,1]
    let center = (*box).center0 + time * ((*box).center1 - (*box).center0);
    let size = (*box).size0 + time * ((*box).size1 - (*box).size0);
    let oc = ray.origin - center;
    let n = invDir * oc;
    let k = abs(invDir) * size; // Box size is from center to edge
    let t1 = -n - k;
    let t2 = -n + k;
    let tNear = max(max(t1.x, t1.y), t1.z);
    let tFar = min(min(t2.x, t2.y), t2.z);
    // if (tFar <= tNear) { return false; }
    if (tNear > tFar || tFar < 0f) { return false; }
   
    // Find nearest root in range
    var outwardNormal: vec3<f32>;
    var root = tNear;
    if (root < tMin || root > tMax) {
        root = tFar;
        if (root < tMin || root > tMax) { return false; }
        outwardNormal = sign(ray.direction) * step(t2.xyz, t2.yzx) * step(t2.xyz, t2.zxy);
    }
    else {
        outwardNormal = -sign(ray.direction) * step(t1.yzx, t1.xyz) * step(t1.zxy, t1.xyz);
    }
   
    (*hitRecord).t = root;
    (*hitRecord).position = rayAt(ray, root);
    setFaceNormal(ray, outwardNormal, hitRecord);
    return true;
}

fn hitRotatedBox(id: u32, ray: Ray, tMin: f32, tMax: f32, hitRecord: ptr<function, HitRecord>) -> bool {
    let rotatedBox = &hittableBuffer.hittables[id];
    let time =  min(max((ray.time - (*rotatedBox).time0) / ((*rotatedBox).time1 - (*rotatedBox).time0), 0f), 1f); // Normalize time to [0,1]
    let center = (*rotatedBox).center0 + time * ((*rotatedBox).center1 - (*rotatedBox).center0);
    let rotation = slerpQuat((*rotatedBox).rotation0, (*rotatedBox).rotation1, time);
    let invRotation = conjugate(rotation);
    var rotatedRay: Ray;
    rotatedRay.origin = rotateQuat(ray.origin - center, invRotation) + center;
    rotatedRay.direction = rotateQuat(ray.direction, invRotation);
    rotatedRay.time = ray.time;
    let rotatedInvDir = vec3<f32>(1f, 1f, 1f) / rotatedRay.direction;
    let hit = hitBox(id, rotatedRay, rotatedInvDir, tMin, tMax, hitRecord);
    if (hit) {
        (*hitRecord).position = rotateQuat((*hitRecord).position - center, rotation) + center;
        (*hitRecord).normal = rotateQuat((*hitRecord).normal, rotation);
        return true;
    }
    return false;
}

fn hitXyDisk(id: u32, ray: Ray, tMin: f32, tMax: f32, hitRecord: ptr<function, HitRecord>) -> bool {
    let xyDisk = &hittableBuffer.hittables[id];
    let oc = ray.origin - (*xyDisk).center0;

    // Distance to plane, t
    let t = -oc.z / ray.direction.z;

    // If direction == 0, t = +/- infinity, which always returns false
    if (t < tMin || t > tMax) { return false; }

    // Intersection point in model space
    let p = oc + t * ray.direction;

    // Bounds
    let radius = (*xyDisk).size0.x;
    if (dot(p, p) > radius * radius) { return false; } // dot(p, p) is squared distance from disk center to intersection point
    
    // Texture coords
    var uv = vec2<f32>(0.5 * p.xy / radius + vec2<f32>(0.5f, 0.5f));
    let texCoord0 = (*xyDisk).texCoord0;
    let texCoord1 = (*xyDisk).texCoord1;
    uv = texCoord0 + uv * (texCoord1 - texCoord0);

    (*hitRecord).uv = uv;
    (*hitRecord).t = t;
    (*hitRecord).position = rayAt(ray, t);
    let outwardNormal = vec3<f32>(0f, 0f, 1f);
    setFaceNormal(ray, outwardNormal, hitRecord);
    return true;
}

fn hitRotatedXyDisk(id: u32, ray: Ray, tMin: f32, tMax: f32, hitRecord: ptr<function, HitRecord>) -> bool {
    let rotatedXyDisk = &hittableBuffer.hittables[id];
    // let center = (*rotatedXyDisk).center0;
    let time =  min(max((ray.time - (*rotatedXyDisk).time0) / ((*rotatedXyDisk).time1 - (*rotatedXyDisk).time0), 0f), 1f); // Normalize time to [0,1]
    let center = (*rotatedXyDisk).center0 + time * ((*rotatedXyDisk).center1 - (*rotatedXyDisk).center0);
    let rotation = slerpQuat((*rotatedXyDisk).rotation0, (*rotatedXyDisk).rotation1, time);
    let invRotation = conjugate(rotation);
    var rotatedRay: Ray;
    rotatedRay.origin = rotateQuat(ray.origin - center, invRotation) + center;
    rotatedRay.direction = rotateQuat(ray.direction, invRotation);
    rotatedRay.time = ray.time;
    let hit = hitXyDisk(id, rotatedRay, tMin, tMax, hitRecord);
    if (hit) {
        (*hitRecord).position = rotateQuat((*hitRecord).position - center, rotation) + center;
        (*hitRecord).normal = rotateQuat((*hitRecord).normal, rotation);
        return true;
    }
    return false;
}

fn hitXyRect(id: u32, ray: Ray, tMin: f32, tMax: f32, hitRecord: ptr<function, HitRecord>) -> bool {
    let xyRect = &hittableBuffer.hittables[id];
    let oc = ray.origin - (*xyRect).center0;

    // Distance to plane, t
    let t = -oc.z / ray.direction.z;

    // If direction == 0, t = +/- infinity, which always returns false
    if (t < tMin || t > tMax) { return false; }

    // Intersection point in model space
    let p = oc + t * ray.direction;

    // Bounds
    let size = (*xyRect).size0;
    if (abs(p.x) > size.x || abs(p.y) > size.y) { return false; }

    // Texture coords
    var uv = vec2<f32>(0.5 * p.xy / size.xy + vec2<f32>(0.5f, 0.5f));
    let texCoord0 = (*xyRect).texCoord0;
    let texCoord1 = (*xyRect).texCoord1;
    uv = texCoord0 + uv * (texCoord1 - texCoord0);

    (*hitRecord).uv = uv;
    (*hitRecord).t = t;
    (*hitRecord).position = rayAt(ray, t);
    let outwardNormal = vec3<f32>(0f, 0f, 1f);
    setFaceNormal(ray, outwardNormal, hitRecord);
    return true;
}

fn hitRotatedXyRect(id: u32, ray: Ray, tMin: f32, tMax: f32, hitRecord: ptr<function, HitRecord>) -> bool {
    let rotatedXyRect = &hittableBuffer.hittables[id];
    // let center = (*rotatedXyRect).center0;
    let time =  min(max((ray.time - (*rotatedXyRect).time0) / ((*rotatedXyRect).time1 - (*rotatedXyRect).time0), 0f), 1f); // Normalize time to [0,1]
    let center = (*rotatedXyRect).center0 + time * ((*rotatedXyRect).center1 - (*rotatedXyRect).center0);
    let rotation = slerpQuat((*rotatedXyRect).rotation0, (*rotatedXyRect).rotation1, time);
    let invRotation = conjugate(rotation);
    var rotatedRay: Ray;
    rotatedRay.origin = rotateQuat(ray.origin - center, invRotation) + center;
    rotatedRay.direction = rotateQuat(ray.direction, invRotation);
    rotatedRay.time = ray.time;
    let hit = hitXyRect(id, rotatedRay, tMin, tMax, hitRecord);
    if (hit) {
        (*hitRecord).position = rotateQuat((*hitRecord).position - center, rotation) + center;
        (*hitRecord).normal = rotateQuat((*hitRecord).normal, rotation);
        return true;
    }
    return false;
}

fn hitXzRect(id: u32, ray: Ray, tMin: f32, tMax: f32, hitRecord: ptr<function, HitRecord>) -> bool {
    let xzRect = &hittableBuffer.hittables[id];
    let oc = ray.origin - (*xzRect).center0;

    // Distance to plane, t
    let t = -oc.y / ray.direction.y;

    // If direction == 0, t = +/- infinity, which always returns false
    if (t < tMin || t > tMax) { return false; }

    // Intersection point in model space
    let p = oc + t * ray.direction;

    // Bounds
    let size = (*xzRect).size0;
    if (abs(p.x) > size.x || abs(p.z) > size.z) { return false; }

    // Texture coords
    var uv = vec2<f32>(0.5 * p.xz / size.xz + vec2<f32>(0.5f, 0.5f));
    let texCoord0 = (*xzRect).texCoord0;
    let texCoord1 = (*xzRect).texCoord1;
    uv = texCoord0 + uv * (texCoord1 - texCoord0);

    (*hitRecord).uv = uv;
    (*hitRecord).t = t;
    (*hitRecord).position = rayAt(ray, t);
    let outwardNormal = vec3<f32>(0f, 1f, 0f);
    setFaceNormal(ray, outwardNormal, hitRecord);
    return true;
}

// fn hitYzRect(yzRect: Hittable, ray: Ray, tMin: f32, tMax: f32, hitRecord: ptr<function, HitRecord>) -> bool {
//     let oc = ray.origin - yzRect.center0;

//     // Distance to plane, t
//     let t = -oc.x / ray.direction.x;

//     // If direction == 0, t = +/- infinity, which always returns false
//     if (t < tMin || t > tMax) { return false; }

//     // Intersection point in model space
//     let p = oc + t * ray.direction;

//     // Bounds
//     if (abs(p.y) > yzRect.size0.y || abs(p.z) > yzRect.size0.z) { return false; }

//     // Texture coords
//     var uv = vec2<f32>(0.5 * p.yz / yzRect.size0.yz + vec2<f32>(0.5f, 0.5f));
//     uv = yzRect.texCoord0 + uv * (yzRect.texCoord1 - yzRect.texCoord0);

//     (*hitRecord).uv = uv;
//     (*hitRecord).t = t;
//     (*hitRecord).position = rayAt(ray, t);
//     let outwardNormal = vec3<f32>(1f, 0f, 0f);
//     setFaceNormal(ray, outwardNormal, hitRecord);
//     return true;
// }

// TODO: Share hit function with XyRect
fn hitFontXyRect(id: u32, ray: Ray, tMin: f32, tMax: f32, hitRecord: ptr<function, HitRecord>) -> bool {
    let xyRect = &hittableBuffer.hittables[id];
    
    // let oc = ray.origin - (*xyRect).center0;
    let time =  min(max((ray.time - (*xyRect).time0) / ((*xyRect).time1 - (*xyRect).time0), 0f), 1f); // Normalize time to [0,1]
    let center = (*xyRect).center0 + time * ((*xyRect).center1 - (*xyRect).center0);
    let oc = ray.origin - center;

    // Distance to plane, t
    let t = -oc.z / ray.direction.z;

    // If direction == 0, t = +/- infinity, which always returns false
    if (t < tMin || t > tMax) { return false; }

    // Intersection point in model space
    let p = oc + t * ray.direction;

    // Bounds
    let size = (*xyRect).size0;
    if (abs(p.x) > size.x || abs(p.y) > size.y) { return false; }

    // Texture coords
    var uv = vec2<f32>(0.5 * p.xy / size.xy + vec2<f32>(0.5f, 0.5f));
    let texCoord0 = (*xyRect).texCoord0;
    let texCoord1 = (*xyRect).texCoord1;
    uv = texCoord0 + uv * (texCoord1 - texCoord0);

    // Sample sdf
    let buffer = xyRect.sdfBuffer / 0xff;
    let r = textureSampleLevel(fontTexture, linearSampler, uv, 0f).r;
    if (r < buffer) { return false; }

    (*hitRecord).uv = uv;
    (*hitRecord).t = t;
    (*hitRecord).position = rayAt(ray, t);
    let outwardNormal = vec3<f32>(0f, 0f, 1f);
    setFaceNormal(ray, outwardNormal, hitRecord);
    return true;
}

fn hitRotatedFontXyRect(id: u32, ray: Ray, tMin: f32, tMax: f32, hitRecord: ptr<function, HitRecord>) -> bool {
    let rotatedXyRect = &hittableBuffer.hittables[id];
    // let center = (*rotatedXyRect).center0;
    let time =  min(max((ray.time - (*rotatedXyRect).time0) / ((*rotatedXyRect).time1 - (*rotatedXyRect).time0), 0f), 1f); // Normalize time to [0,1]
    let center = (*rotatedXyRect).center0 + time * ((*rotatedXyRect).center1 - (*rotatedXyRect).center0);
    let rotation = slerpQuat((*rotatedXyRect).rotation0, (*rotatedXyRect).rotation1, time);
    let invRotation = conjugate(rotation);
    var rotatedRay: Ray;
    rotatedRay.origin = rotateQuat(ray.origin - center, invRotation) + center;
    rotatedRay.direction = rotateQuat(ray.direction, invRotation);
    rotatedRay.time = ray.time;
    let hit = hitFontXyRect(id, rotatedRay, tMin, tMax, hitRecord);
    if (hit) {
        (*hitRecord).position = rotateQuat((*hitRecord).position - center, rotation) + center;
        (*hitRecord).normal = rotateQuat((*hitRecord).normal, rotation);
        return true;
    }
    return false;
}

// TODO: Share hit function with FontXyRect, specifying texture
fn hitSdfXyRect(id: u32, ray: Ray, tMin: f32, tMax: f32, hitRecord: ptr<function, HitRecord>, seed: ptr<function, u32>) -> bool {
    let xyRect = &hittableBuffer.hittables[id];

    // let oc = ray.origin - (*xyRect).center0;
    let time =  min(max((ray.time - (*xyRect).time0) / ((*xyRect).time1 - (*xyRect).time0), 0f), 1f); // Normalize time to [0,1]
    let center = (*xyRect).center0 + time * ((*xyRect).center1 - (*xyRect).center0);
    let oc = ray.origin - center;

    // Distance to plane, t
    let t = -oc.z / ray.direction.z;

    // If direction == 0, t = +/- infinity, which always returns false
    if (t < tMin || t > tMax) { return false; }

    // Intersection point in model space
    let p = oc + t * ray.direction;

    // Bounds
    // let size = (*xyRect).size0;
    let size = (*xyRect).size0 + time * ((*xyRect).size1 - (*xyRect).size0);
    if (abs(p.x) > (*xyRect).size0.x || abs(p.y) > (*xyRect).size0.y) { return false; }

    // Zero-thickness transparency
    // TODO: Pre-multiplied alpha
    // if (random(seed) > 0.5f) { return false; }

    // Texture coords
    var uv = vec2<f32>(0.5 * p.xy / size.xy + vec2<f32>(0.5f, 0.5f));
    let texCoord0 = (*xyRect).texCoord0;
    let texCoord1 = (*xyRect).texCoord1;
    uv = texCoord0 + uv * (texCoord1 - texCoord0);

    // Sample sdf
    let buffer = xyRect.sdfBuffer / 0xff;
    // let r = textureSampleLevel(atlasTexture, linearSampler, uv, 0f).r;
    var r: f32;
    if ((*xyRect).texId == 0f) {
        r = textureSampleLevel(atlasTexture, linearSampler, uv, 0f).r;
    }
    else {
        r = textureSampleLevel(fontTexture, linearSampler, uv, 0f).r;
    }
    if (r < buffer) { return false; }

    // sdfBorder
    let border = xyRect.sdfBorder / 0xff;
    (*hitRecord).sdfBorder = r - buffer < border;
    
    (*hitRecord).uv = uv;
    (*hitRecord).t = t;
    (*hitRecord).position = rayAt(ray, t);
    let outwardNormal = vec3<f32>(0f, 0f, 1f);
    setFaceNormal(ray, outwardNormal, hitRecord);
    return true;
}

fn hitRotatedSdfXyRect(id: u32, ray: Ray, tMin: f32, tMax: f32, hitRecord: ptr<function, HitRecord>, seed: ptr<function, u32>) -> bool {
    let rotatedXyRect = &hittableBuffer.hittables[id];
    // let center = (*rotatedXyRect).center0;
    let time =  min(max((ray.time - (*rotatedXyRect).time0) / ((*rotatedXyRect).time1 - (*rotatedXyRect).time0), 0f), 1f); // Normalize time to [0,1]
    let center = (*rotatedXyRect).center0 + time * ((*rotatedXyRect).center1 - (*rotatedXyRect).center0);
    let rotation = slerpQuat((*rotatedXyRect).rotation0, (*rotatedXyRect).rotation1, time);
    let invRotation = conjugate(rotation);
    var rotatedRay: Ray;
    rotatedRay.origin = rotateQuat(ray.origin - center, invRotation) + center;
    rotatedRay.direction = rotateQuat(ray.direction, invRotation);
    rotatedRay.time = ray.time;
    let hit = hitSdfXyRect(id, rotatedRay, tMin, tMax, hitRecord, seed);
    if (hit) {
        (*hitRecord).position = rotateQuat((*hitRecord).position - center, rotation) + center;
        (*hitRecord).normal = rotateQuat((*hitRecord).normal, rotation);
        return true;
    }
    return false;
}

fn rotateQuat(v: vec3<f32>, q: vec4<f32>) -> vec3<f32> {
    return v + 2f * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

fn slerpQuat(q0: vec4<f32>, q1: vec4<f32>, t: f32) -> vec4<f32> {
    var cosom = dot(q0, q1);
    var q2 = q1;
	if (cosom < 0f) {
		cosom = -cosom;
		q2 = -q2;
	}
	var s0: f32;
    var s1: f32;
	if (1f - cosom > 0.000001f) {
		// SLERP
		let omega = acos(cosom);
		let sinom = sin(omega);
		s0 = sin((1f - t) * omega) / sinom;
		s1 = sin(t * omega) / sinom;
	}
	else {
		// Quaternions close enough for LERP
		s0 = 1f - t;
		s1 = t;
	}
	return s0 * q0 + s1 * q2;
}

fn conjugate(q: vec4<f32>) -> vec4<f32> {
    return vec4<f32>(-q.x, -q.y, -q.z, q.w);
}

fn hitCylinder(id: u32, ray: Ray, tMin: f32, tMax: f32, hitRecord: ptr<function, HitRecord>) -> bool {
    let cylinder = &hittableBuffer.hittables[id];
    let time =  min(max((ray.time - (*cylinder).time0) / ((*cylinder).time1 - (*cylinder).time0), 0f), 1f); // Normalize time to [0,1]
    let center = (*cylinder).center0 + time * ((*cylinder).center1 - (*cylinder).center0);
    let size = (*cylinder).size0 + time * ((*cylinder).size1 - (*cylinder).size0);
    let rotation = slerpQuat((*cylinder).rotation0, (*cylinder).rotation1, time);
    let ra = size.x; // Radius
    let ca = rotateQuat(vec3<f32>(0f, 1f, 0f), rotation);
    let oc = ray.origin - center;
    let card = dot(ca, ray.direction);
    let caoc = dot(ca, oc);
    let a = 1f - card * card;
    let b = dot(oc, ray.direction) - caoc * card;
    let c = dot(oc, oc) - caoc * caoc - ra * ra;
    var h = b * b - a * c;
    if (h < 0f) { return false; }
    h = sqrt(h);
    let br0 = (-b - h) / a;
    let br1 = (-b + h) / a;

    // Body
    let ch = size.y; // Half-height
    let y0 = caoc + br0 * card;
    let y1 = caoc + br1 * card;
    let bt0 = select(10000000f, br0, abs(y0) < ch);
    let bt1 = select(-10000000f, br1, abs(y1) < ch);

    // Caps
    let sy0 = sign(y0);
    let sy1 = sign(y1);
    let cr0 = (sy0 * ch - caoc) / card;
    let cr1 = (sy1 * ch - caoc) / card;
    let ct0 = select(10000000f, cr0, abs(b + a * cr0) < h);
    let ct1 = select(-10000000f, cr1, abs(b + a * cr1) < h);
   
    // Find the nearest root in range
    let tN = min(bt0, ct0);
    let tF = max(bt1, ct1);
    var root = tN;
    if (root < tMin || root > tMax) {
        root = tF;
        if (root < tMin || root > tMax) { return false; }
    }

    // Normal
    var outwardNormal: vec3<f32>;
    if (root == bt0 || root == bt1) {
        let y = select(y1, y0, root == bt0);
        // outwardNormal = (oc + root * ray.direction - ca * y) / ra;

        // Reduce precision error in t by ensuring hit position is on cylinder surface
        outwardNormal = normalize(oc + root * ray.direction - ca * y);
        setFaceNormal(ray, outwardNormal, hitRecord);
        (*hitRecord).position = center + ca * y + outwardNormal * ra; // Use outward normal with internal reflection
        (*hitRecord).t = root;
    }
    else {
        let sy = select(sy1, sy0, root == ct0);
        outwardNormal = ca * sy;
       
        // TODO: Reduce precision error
        setFaceNormal(ray, outwardNormal, hitRecord);
        (*hitRecord).position = rayAt(ray, root);
        (*hitRecord).t = root;
    }
   
    // setFaceNormal(ray, outwardNormal, hitRecord);
    // (*hitRecord).position = rayAt(ray, root);
    // (*hitRecord).t = root;
    return true;
}

fn hitHexPrism(id: u32, ray: Ray, tMin: f32, tMax: f32, hitRecord: ptr<function, HitRecord>) -> bool {
    let hexPrism = &hittableBuffer.hittables[id];
    let time =  min(max((ray.time - (*hexPrism).time0) / ((*hexPrism).time1 - (*hexPrism).time0), 0f), 1f); // Normalize time to [0,1]
    let center = (*hexPrism).center0 + time * ((*hexPrism).center1 - (*hexPrism).center0);
    let oc = ray.origin - center;
    let size = (*hexPrism).size0;
    let ra = size.x; // Distance from center to edge
    let he = size.y; // Half-height
    let rd = ray.direction;

    // Normals
    let n1 = vec3<f32>(1f, 0f, 0f);
    let n2 = vec3<f32>(0.5f, 0f, ROOT_THREE_OVER_TWO);
    let n3 = vec3<f32>(-0.5f, 0f, ROOT_THREE_OVER_TWO);
    let n4 = vec3<f32>(0f, 1f, 0f);

    // Slabs intersections
    var t1 = vec3<f32>((vec2<f32>(ra, -ra) - dot(oc, n1)) / dot(rd, n1), 1f);
    var t2 = vec3<f32>((vec2<f32>(ra, -ra) - dot(oc, n2)) / dot(rd, n2), 1f);
    var t3 = vec3<f32>((vec2<f32>(ra, -ra) - dot(oc, n3)) / dot(rd, n3), 1f);
    var t4 = vec3<f32>((vec2<f32>(he, -he) - dot(oc, n4)) / dot(rd, n4), 1f);

    // Inetsection selection
    if (t1.y < t1.x) { t1 = vec3<f32>(t1.yx, -1f); }
    if (t2.y < t2.x) { t2 = vec3<f32>(t2.yx, -1f); }
    if (t3.y < t3.x) { t3 = vec3<f32>(t3.yx, -1f); }
    if (t4.y < t4.x) { t4 = vec3<f32>(t4.yx, -1f); }

    var tN = vec4<f32>(t1.x, t1.z * n1);
    if (t2.x > tN.x) { tN = vec4<f32>(t2.x, t2.z * n2); }
    if (t3.x > tN.x) { tN = vec4<f32>(t3.x, t3.z * n3); }
    if (t4.x > tN.x) { tN = vec4<f32>(t4.x, t4.z * n4); }

    let tF = min(min(t1.y,t2.y),min(t3.y,t4.y));

    if (tN.x > tF || tF < 0f) { return false; }

    // Find the nearest root in range
    var outwardNormal: vec3<f32>;
    var root = tN.x;
    if (root < tMin || root > tMax) {
        root = tF;
        if (root < tMin || root > tMax) { return false; }

        // Normal
        if (root == t1.y) { outwardNormal = -t1.z * n1; }
        else if (root == t2.y) { outwardNormal = -t2.z * n2; }
        else if (root == t3.y) { outwardNormal = -t3.z * n3; }
        else if (root == t4.y) { outwardNormal = -t4.z * n4; }
    }
    else {
        outwardNormal = tN.yzw;
    }

    (*hitRecord).t = root;
    (*hitRecord).position = rayAt(ray, root);
    setFaceNormal(ray, outwardNormal, hitRecord);
    return true;
}

fn mapBoxSdf(p: vec3<f32>, b: vec3<f32>, r: f32) -> f32 {
    let q = abs(p) - b;
    return length(max(q, vec3<f32>(0f, 0f, 0f))) + min(max(q.x, max(q.y, q.z)), 0f) - r;
}

// Box frame
// fn mapBoxSdf(p: vec3<f32>, b: vec3<f32>, r: f32) -> f32 {
//     let s = abs(p) - b;
//     // let e = b.y / 3f;
//     let e = 0.0002f;
//     let q = abs(s + e) - e;
//     return min(min(
//       length(max(vec3<f32>(s.x, q.y, q.z), vec3<f32>(0f, 0f, 0f))) + min(max(s.x, max(q.y,q.z)), 0f),
//       length(max(vec3<f32>(q.x, s.y, q.z), vec3<f32>(0f, 0f, 0f))) + min(max(q.x, max(s.y,q.z)), 0f)),
//       length(max(vec3<f32>(q.x, q.y, s.z), vec3<f32>(0f, 0f, 0f))) + min(max(q.x, max(q.y,s.z)), 0f));
// }

fn hitBoxSdf(id: u32, ray: Ray, tMin: f32, tMax: f32, hitRecord: ptr<function, HitRecord>) -> bool {
    let boxSdf = &hittableBuffer.hittables[id];
    var t = tMin;
    let r = (*boxSdf).rounding;
    // let size = (*boxSdf).size0 - r;
    let time =  min(max((ray.time - (*boxSdf).time0) / ((*boxSdf).time1 - (*boxSdf).time0), 0f), 1f); // Normalize time to [0,1]
    let center = (*boxSdf).center0 + time * ((*boxSdf).center1 - (*boxSdf).center0);
    // TODO: r0, r1
    let size = (*boxSdf).size0 + time * ((*boxSdf).size1 - (*boxSdf).size0) - r;
    for (var i: u32 = 0u; i < 256u; i = i + 1u) {
        let position = rayAt(ray, t);
        let oc = position - center;
        let distance = abs(mapBoxSdf(oc, size, r));
        t = t + distance;
        if (t > tMax) { return false; }
        if (distance < 0.000001f) {
            (*hitRecord).t = t;
            (*hitRecord).position = rayAt(ray, t);

            // Normal
            let h = 0.000001f; // replace by an appropriate value
            let k = vec2<f32>(1f, -1f);
            let outwardNormal =  normalize(
                k.xyy * mapBoxSdf(oc + k.xyy * h, size, r) +
                k.yyx * mapBoxSdf(oc + k.yyx * h, size, r) +
                k.yxy * mapBoxSdf(oc + k.yxy * h, size, r) +
                k.xxx * mapBoxSdf(oc + k.xxx * h, size, r));
            setFaceNormal(ray, outwardNormal, hitRecord);
            return true;
        }
    }
    return false;
}

fn hitRotatedBoxSdf(id: u32, ray: Ray, tMin: f32, tMax: f32, hitRecord: ptr<function, HitRecord>) -> bool {
    let rotatedBoxSdf = &hittableBuffer.hittables[id];
    let time =  min(max((ray.time - (*rotatedBoxSdf).time0) / ((*rotatedBoxSdf).time1 - (*rotatedBoxSdf).time0), 0f), 1f); // Normalize time to [0,1]
    let center = (*rotatedBoxSdf).center0 + time * ((*rotatedBoxSdf).center1 - (*rotatedBoxSdf).center0);
    let rotation = slerpQuat((*rotatedBoxSdf).rotation0, (*rotatedBoxSdf).rotation1, time);
    let invRotation = conjugate(rotation);
    var rotatedRay: Ray;
    rotatedRay.origin = rotateQuat(ray.origin - center, invRotation) + center;
    rotatedRay.direction = rotateQuat(ray.direction, invRotation);
    rotatedRay.time = ray.time;
    let hit = hitBoxSdf(id, rotatedRay, tMin, tMax, hitRecord);
    if (hit) {
        (*hitRecord).position = rotateQuat((*hitRecord).position - center, rotation) + center;
        (*hitRecord).normal = rotateQuat((*hitRecord).normal, rotation);
        return true;
    }
    return false;
}

fn mapCylinderSdf(p: vec3<f32>, a: vec3<f32>, b: vec3<f32>, r0: f32, r1: f32) -> f32 {
    let ba: vec3<f32> = b - a;
    let pa: vec3<f32> = p - a;
    let baba: f32 = dot(ba, ba);
    let paba: f32 = dot(pa, ba);
    let x: f32 = length(pa * baba - ba * paba) - r0 * baba;
    let y: f32 = abs(paba - baba * 0.5f) - baba * 0.5f;
    let x2: f32 = x * x;
    let y2: f32 = y * y * baba;
    // let d: f32 = (max(x, y) < 0f) ? -min(x2, y2) : (((x > 0f) ? x2 : 0f) + ((y > 0f) ? y2 : 0f));
    let d: f32 = select(select(0f, x2, x > 0f) + select(0f, y2, y > 0f), -min(x2, y2), max(x, y) < 0f);
    return sign(d) * sqrt(abs(d)) / baba - r1;
}

fn hitCylinderSdf(id: u32, ray: Ray, tMin: f32, tMax: f32, hitRecord: ptr<function, HitRecord>) -> bool {
    let cylinderSdf = &hittableBuffer.hittables[id];
    let time =  min(max((ray.time - (*cylinderSdf).time0) / ((*cylinderSdf).time1 - (*cylinderSdf).time0), 0f), 1f); // Normalize time to [0,1]
    let center = (*cylinderSdf).center0 + time * ((*cylinderSdf).center1 - (*cylinderSdf).center0);
    let size = (*cylinderSdf).size0 + time * ((*cylinderSdf).size1 - (*cylinderSdf).size0);
    let rotation = slerpQuat((*cylinderSdf).rotation0, (*cylinderSdf).rotation1, time);
    var t = tMin;
    let r1 = (*cylinderSdf).rounding;
    let r0 = size.x - r1;
    let h0 = size.y - r1;
    let ca = rotateQuat(vec3<f32>(0f, 1f, 0f), rotation);
    let pa = ca * h0;
    let pb = -pa;
    for (var i: u32 = 0u; i < 256u; i = i + 1u) {
        let position = rayAt(ray, t);
        let oc = position - center;
        let distance = abs(mapCylinderSdf(oc, pa, pb, r0, r1));
        t = t + distance;
        if (t > tMax) { return false; }
        if (distance < 0.000001f) {
            (*hitRecord).t = t;
            (*hitRecord).position = rayAt(ray, t);

            // Normal
            let h = 0.000001f; // replace by an appropriate value
            let k = vec2<f32>(1f, -1f);
            let outwardNormal =  normalize(
                k.xyy * mapCylinderSdf(oc + k.xyy * h, pa, pb, r0, r1) +
                k.yyx * mapCylinderSdf(oc + k.yyx * h, pa, pb, r0, r1) +
                k.yxy * mapCylinderSdf(oc + k.yxy * h, pa, pb, r0, r1) +
                k.xxx * mapCylinderSdf(oc + k.xxx * h, pa, pb, r0, r1));
            setFaceNormal(ray, outwardNormal, hitRecord);
            return true;
        }
    }
    return false;
}

fn mapHexPrismSdf(p: vec3<f32>, hx: f32, hy: f32, r: f32) -> f32 {
    let k = vec3<f32>(-0.8660254, 0.5, 0.57735); // (-sqrt(3)/2 or sin(60), 0.5, sqrt(3)/3 or tan(30))
    var p0 = abs(p.zxy);
    let p1 = p0.xy - 2f * min(dot(k.xy, p0.xy), 0f) * k.xy;
    let d = vec2<f32>(length(p1.xy - vec2(clamp(p1.x, -k.z * hx, k.z * hx), hx)) * sign(p1.y - hx), p0.z - hy);
    return min(max(d.x, d.y), 0f) + length(max(d, vec2<f32>(0f, 0f))) - r;
}

fn hitHexPrismSdf(id: u32, ray: Ray, tMin: f32, tMax: f32, hitRecord: ptr<function, HitRecord>) -> bool {
    let hexPrismSdf = &hittableBuffer.hittables[id];
    var t = tMin;
    let r = (*hexPrismSdf).rounding;
    let size = (*hexPrismSdf).size0;
    let time =  min(max((ray.time - (*hexPrismSdf).time0) / ((*hexPrismSdf).time1 - (*hexPrismSdf).time0), 0f), 1f); // Normalize time to [0,1]
    let center = (*hexPrismSdf).center0 + time * ((*hexPrismSdf).center1 - (*hexPrismSdf).center0);
    let hx = size.x - r;
    let hy = size.y - r;
    for (var i: u32 = 0u; i < 256u; i = i + 1u) {
        let position = rayAt(ray, t);
        let oc = position - center;
        let distance = abs(mapHexPrismSdf(oc, hx, hy, r));
        t = t + distance;
        if (t > tMax) { return false; }
        if (distance < 0.000001f) {
            (*hitRecord).t = t;
            (*hitRecord).position = rayAt(ray, t);

            // Normal
            let h = 0.000001f; // Replace by an appropriate value
            let k = vec2<f32>(1f, -1f);
            let outwardNormal =  normalize(
                k.xyy * mapHexPrismSdf(oc + k.xyy * h, hx, hy, r) +
                k.yyx * mapHexPrismSdf(oc + k.yyx * h, hx, hy, r) +
                k.yxy * mapHexPrismSdf(oc + k.yxy * h, hx, hy, r) +
                k.xxx * mapHexPrismSdf(oc + k.xxx * h, hx, hy, r));
            setFaceNormal(ray, outwardNormal, hitRecord);
            return true;
        }
    }
    return false;
}

fn mapRingSdf(p: vec3<f32>, n: vec2<f32>, r: f32, th: f32, h: f32, rounding: f32) -> f32 {
    let px = abs(p.x);
    // expand result of mat2x2(n.x,n.y,-n.y,n.x)*p;
    // let p2 = vec2<f32>(n.x * px + n.y * p.y, -n.y * px + n.x * p.y);
    // Column-major instead of row-major
    let p2 = vec2<f32>(n.x * px - n.y * p.y, n.y * px + n.x * p.y);
    let d = max(abs(length(p2) - r) - th * 0.5f, length(vec2<f32>(p2.x, max(0f, abs(r - p2.y) - th * 0.5f))) * sign(p2.x));

    // Extrude
    let w = vec2<f32>(d, abs(p.z) - h);
  	return min(max(w.x, w.y), 0f) + length(max(w, vec2<f32>(0f, 0f))) - rounding;
}

fn hitRingSdf(id: u32, ray: Ray, tMin: f32, tMax: f32, hitRecord: ptr<function, HitRecord>) -> bool {
    let ringSdf = &hittableBuffer.hittables[id];
    var t = tMin;
    let size = (*ringSdf).size0;
    let center = (*ringSdf).center0;
    let rounding = (*ringSdf).rounding;
    let outerr = size.x;
    let innerr = size.y;
    // Reduce angle such that inner radius arc reduces by rounding
    var angle = (*ringSdf).parameter1;
    angle -= angle * rounding /  innerr * PI * 2;
    let cs = vec2<f32>(cos(angle), sin(angle));
    let r = (outerr + innerr) * 0.5f;
    let th = (outerr - innerr) - rounding;
    let e = size.z - rounding;
    for (var i: u32 = 0u; i < 256u; i = i + 1u) {
        let position = rayAt(ray, t);
        let oc = position - center;
        let distance = abs(mapRingSdf(oc, cs, r, th, e, rounding));
        t = t + distance;
        if (t > tMax) { return false; }
        if (distance < 0.000001f) {
            (*hitRecord).t = t;
            (*hitRecord).position = rayAt(ray, t);

            // Normal
            let h = 0.00001f; // replace by an appropriate value
            let k = vec2<f32>(1f, -1f);
            let outwardNormal =  normalize(
                k.xyy * mapRingSdf(oc + k.xyy * h, cs, r, th, e, rounding) +
                k.yyx * mapRingSdf(oc + k.yyx * h, cs, r, th, e, rounding) +
                k.yxy * mapRingSdf(oc + k.yxy * h, cs, r, th, e, rounding) +
                k.xxx * mapRingSdf(oc + k.xxx * h, cs, r, th, e, rounding));
            setFaceNormal(ray, outwardNormal, hitRecord);
            return true;
        }
    }
    return false;
}

fn hitRotatedRingSdf(id: u32, ray: Ray, tMin: f32, tMax: f32, hitRecord: ptr<function, HitRecord>) -> bool {
    let rotatedRingSdf = &hittableBuffer.hittables[id];
    let time =  min(max((ray.time - (*rotatedRingSdf).time0) / ((*rotatedRingSdf).time1 - (*rotatedRingSdf).time0), 0f), 1f); // Normalize time to [0,1]
    let center = (*rotatedRingSdf).center0 + time * ((*rotatedRingSdf).center1 - (*rotatedRingSdf).center0);
    let rotation = slerpQuat((*rotatedRingSdf).rotation0, (*rotatedRingSdf).rotation1, time);
    let invRotation = conjugate(rotation);
    var rotatedRay: Ray;
    rotatedRay.origin = rotateQuat(ray.origin - center, invRotation) + center;
    rotatedRay.direction = rotateQuat(ray.direction, invRotation);
    rotatedRay.time = ray.time;
    let hit = hitRingSdf(id, rotatedRay, tMin, tMax, hitRecord);
    if (hit) {
        (*hitRecord).position = rotateQuat((*hitRecord).position - center, rotation) + center;
        (*hitRecord).normal = rotateQuat((*hitRecord).normal, rotation);
        return true;
    }
    return false;
}

fn hitLights(ray: Ray) -> vec3<f32> {
    var hit: bool;
    for (var i: u32 = 0u; i < arrayLength(&lightBuffer.lights); i = i + 1u) {
        // let light = lightBuffer.lights[i];
        switch u32(lightBuffer.lights[i].typeId) {
            default: {
                hit = hitSphereLight(i, ray);
            }
            case 2u: {
                hit = hitRectLight(i, ray);
            }
        }
        if (hit) {
            return lightBuffer.lights[i].color;
        }
    }
   
    // Background color
    // return vec3<f32>(0f, 0f, 0f);
    // return vec3<f32>(1f, 1f, 1f);
    return uniforms.backgroundColor;

    // TODO: Dome light
    // let t = 0.5f * (ray.direction.y + 1f);
    // let background = (1f - t) * vec3<f32>(1f, 1f, 1f) + t * vec3<f32>(0.5f, 0.7f, 1.0f);
    // return background;
}

fn hitSphereLight(id: u32, ray: Ray) -> bool {
    let sphere = &lightBuffer.lights[id];
    let radius = (*sphere).size.x;
    let oc = ray.origin - (*sphere).center;
    let b = dot(oc, ray.direction);
    let c = dot(oc, oc) - radius * radius;
    var h = b * b - c;
    if (h < 0f) { return false; }
    return b < 0f; // Ensure ray towards light
}

fn hitRectLight(id: u32, ray: Ray) -> bool {
    let rotatedXyRect = &lightBuffer.lights[id];
    let center = (*rotatedXyRect).center;
    let rotation = (*rotatedXyRect).rotation;
    let invRotation = conjugate(rotation);
    var rotatedRay: Ray;
    rotatedRay.origin = rotateQuat(ray.origin - center, invRotation) + center;
    rotatedRay.direction = rotateQuat(ray.direction, invRotation);
    if (dot(rotatedRay.direction, vec3<f32>(0f, 0f, 1f)) < 0f) { return false; } // Directional light
    let oc = rotatedRay.origin - center;
    let t = -oc.z / rotatedRay.direction.z;
    if (t < 0f) { return false; }
    let p = oc + t * rotatedRay.direction;
    if (abs(p.x) > (*rotatedXyRect).size.x || abs(p.y) > (*rotatedXyRect).size.y) { return false; }
    return true;
}

fn nearZero(v: vec3<f32>) -> bool {
    return max(max(abs(v.x), abs(v.y)), abs(v.z)) < 0.00000001f; // 1e-8
}

fn scatterLambertian(ray: ptr<function, Ray>, hitRecord: HitRecord, attenuation: ptr<function, vec3<f32>>, seed: ptr<function, u32>) -> bool {
    let scatterDirection = hitRecord.normal + randomUnitVector(seed);
   
    // Catch degenerate scatter direction
    (*ray).direction = select(normalize(scatterDirection), hitRecord.normal, nearZero(scatterDirection));
   
    (*ray).origin = hitRecord.position;
    (*attenuation) = textureValue(hitRecord);
    return true;
}

fn scatterMetal(ray: ptr<function, Ray>, hitRecord: HitRecord, attenuation: ptr<function, vec3<f32>>, seed: ptr<function, u32>) -> bool {
    (*ray).direction = normalize(reflect((*ray).direction, hitRecord.normal) + materialBuffer.materials[hitRecord.materialId].fuzz * randomInUnitSphere(seed));
    (*ray).origin = hitRecord.position;
    (*attenuation) = textureValue(hitRecord);

    // Absorb any rays which fuzz scatters below the surface
    return dot((*ray).direction, hitRecord.normal) > 0f;
}

fn scatterGlossy(ray: ptr<function, Ray>, hitRecord: HitRecord, attenuation: ptr<function, vec3<f32>>, seed: ptr<function, u32>) -> bool {
    // Specular
    let material = &materialBuffer.materials[hitRecord.materialId];
    let refractiveIndex = (*material).refractiveIndex;
    let refractionRatio = select(refractiveIndex, 1f / refractiveIndex, hitRecord.frontFace);
    let cosTheta = min(dot(-(*ray).direction, hitRecord.normal), 1f);
    if (reflectance(cosTheta, refractionRatio) * (*material).glossiness > random(seed)) {
        (*ray).direction = normalize(reflect((*ray).direction, hitRecord.normal) + (*material).fuzz * randomInUnitSphere(seed));
        (*ray).origin = hitRecord.position;
        (*attenuation) = vec3<f32>(1f, 1f, 1f);

        // Absorb any rays which fuzz scatters below the surface
        return dot((*ray).direction, hitRecord.normal) > 0f;
    }
    else {
        // Lambertian
        return scatterLambertian(ray, hitRecord, attenuation, seed);
    }
}

fn scatterDielectric(ray: ptr<function, Ray>, hitRecord: ptr<function, HitRecord>, attenuation: ptr<function, vec3<f32>>, seed: ptr<function, u32>) -> bool {
    let material = &materialBuffer.materials[(*hitRecord).materialId];
    let refractiveIndex = (*material).refractiveIndex;
    // TODO: If still inside another material, use its refractive index
    let refractionRatio = select(refractiveIndex, 1f / refractiveIndex, (*hitRecord).frontFace);
    let cosTheta = min(dot(-(*ray).direction, (*hitRecord).normal), 1f);
    let sinTheta = sqrt(1f - cosTheta * cosTheta);
    let cannotRefract = refractionRatio * sinTheta > 1f;
    // if (cannotRefract || reflectance(cosTheta, refractionRatio) > random(seed)) {
    if (cannotRefract || reflectance(cosTheta, refractionRatio) * (*material).glossiness > random(seed)) {
        (*ray).direction = reflect((*ray).direction, (*hitRecord).normal);
    }
    else {
        (*ray).direction = refraction((*ray).direction, (*hitRecord).normal, refractionRatio);
    }
    (*ray).origin = (*hitRecord).position;
    (*ray).direction = normalize((*ray).direction + (*material).fuzz * randomInUnitSphere(seed));
    
    // Did the ray enter/stay inside?
    (*attenuation) = vec3<f32>(1f, 1f, 1f);
    // if (dot((*ray).direction, (*hitRecord).normal) < 0f) {
        if (dot((*ray).direction, select(-(*hitRecord).normal, (*hitRecord).normal, (*hitRecord).frontFace)) < 0f) {
        (*hitRecord).isAbsorbing = true;
        (*hitRecord).absorption = (*material).color;

        // If already inside another absorbing dielectric, add to absorption
        if ((*hitRecord).previousIsAbsorbing && (*hitRecord).id != (*hitRecord).previousId) {
            (*hitRecord).absorption = (*hitRecord).absorption + (*hitRecord).previousAbsorption;
        }
    }
    return true;
}

fn scatterIsotropic(ray: ptr<function, Ray>, hitRecord: HitRecord, attenuation: ptr<function, vec3<f32>>, seed: ptr<function, u32>) -> bool {
    (*ray).direction = randomUnitVector(seed);
    (*ray).origin = hitRecord.position;
    (*attenuation) = materialBuffer.materials[hitRecord.materialId].color;
    return true;
}

fn scatterVarnish(ray: ptr<function, Ray>, hitRecord: HitRecord, attenuation: ptr<function, vec3<f32>>, seed: ptr<function, u32>) -> bool {
    // Front-face only (no internal reflection or refraction)
    let material = &materialBuffer.materials[hitRecord.materialId];
    if (hitRecord.frontFace && (*material).glossiness > random(seed)) {
        let refractiveIndex = (*material).refractiveIndex;
        let refractionRatio = select(refractiveIndex, 1f / refractiveIndex, hitRecord.frontFace);
        let cosTheta = min(dot(-(*ray).direction, hitRecord.normal), 1f);
        let sinTheta = sqrt(1f - cosTheta * cosTheta);
        let cannotRefract = refractionRatio * sinTheta > 1f;
        if (cannotRefract || reflectance(cosTheta, refractionRatio) > random(seed)) {
            (*ray).direction = reflect((*ray).direction, hitRecord.normal);
        }
        else {
            // Refraction improves definition at edges and deepens color on faces
            (*ray).direction = refraction((*ray).direction, hitRecord.normal, refractionRatio);
        }
        (*ray).direction = normalize((*ray).direction + (*material).fuzz * randomInUnitSphere(seed));
    }
    // Pass-through
    (*ray).origin = hitRecord.position;
    (*attenuation) = vec3<f32>(1f, 1f, 1f);
    return true;
}

fn textureValue(hitRecord: HitRecord) -> vec3<f32> {
    let textureId = materialBuffer.materials[hitRecord.materialId].textureId;
    let texture = &textureBuffer.textures[u32(textureId)];
    switch u32((*texture).typeId) {
        // No texture
        default: {
            return vec3<f32>();
        }
        // Solid color
        case 1u: {
            if (hitRecord.sdfBorder) {
                return (*texture).color1;
            }
            else {
                return (*texture).color0;
            }

            // Debug uv
            // return vec3<f32>(hitRecord.uv, 0f);
        }
        // Image
        case 2u: {
            // Sample in linear space
            return textureSampleLevel(backgroundTexture, linearSampler, hitRecord.uv, 0f).rgb;
            // return vec3(hitRecord.uv.x, hitRecord.uv.y, 0f);
        }
        // Checker
        case 4u: {
            let q = trunc((hitRecord.uv + (*texture).offset) / (*texture).size0.xy);
            return select((*texture).color0, (*texture).color1, (q.x + q.y) % 2f > 0f);
        }
        // Grid
        case 5u: {
            let size0 = (*texture).size0;
            let size1 = (*texture).size1;
            let clip = (*texture).clip;
            if (hitRecord.uv.x < clip.x || hitRecord.uv.y < clip.y || hitRecord.uv.x > clip.z || hitRecord.uv.y > clip.w) {
                return (*texture).color1;
            }
            let uv = hitRecord.uv + (*texture).offset;
            var d = uv / size0.xy;
            d = abs(d - round(d)) * size0.xy;
            if (d.x < size1.x || d.y < size1.y) {
                return (*texture).color0;
            }
            else {
                d = uv / size0.zw;
                d = abs(d - round(d)) * size0.zw;
                if (d.x < size1.z || d.y < size1.w) {
                    return (*texture).color0;
                }
                return (*texture).color1;
            }
        }
    }
}

fn rayColor(ray: ptr<function, Ray>, seed: ptr<function, u32>) -> vec3<f32> {
    let maxDepth = 16u; // TODO: Pass as uniform
    var depth = 0u;
    // var result: Color;
    var color = vec3<f32>(1f, 1f, 1f);
    var attenuation = vec3<f32>(1f, 1f, 1f);
    var emitted = vec3<f32>(0f, 0f, 0f);
    var hitRecord: HitRecord;
    hitRecord.id = 4294967295; // -1 as u32
    var scatter: bool;
    loop {
        // if (hitWorld(*ray, 0.00001f, 100f, &hitRecord, seed)) {
        if (hitBVH(*ray, 0.00001f, 100f, &hitRecord, seed)) {
            // Debug normal, depth
            // First hit
            // if (depth == 0u) {
            //     result.normal = hitRecord.normal * 0.5f + vec3<f32>(0.5f, 0.5f, 0.5f);
            //     // result.normal = hitRecord.normal * 0.5f + vec3<f32>(0.5f, 0.5f, 0.5f) 
            //     // result.depth = 1f / hitRecord.t;
            //     result.depth = -1f / dot(hitRecord.position - (*ray).origin, uniforms.forward);
            // }
            // return result;

            // Depth
            depth = depth + 1u;
            if (depth == maxDepth) {
                // Exceeded bounce limit, no more light is gathered
                // result.color = vec3<f32>(0f, 0f, 0f);
                // return result;
                return vec3<f32>(0f, 0f, 0f);
            }
           
            // Bounce
            // If last hit was travelling INTO a dielectric, use last hit position to calculate distance
            // and apply Beer's law to attenuate the light. Modify the dielectric scattering function to
            // recrord travelling INTO a dielectric based on hitRecord normal and ray direction.
            // Reset this flag each time here.
            if (hitRecord.previousIsAbsorbing) {
                // Beer's law
                let d = distance(hitRecord.previousPosition, hitRecord.position);
                color = color * exp(-d * hitRecord.previousAbsorption);
            }
            // Reset absorption
            hitRecord.isAbsorbing = false;
            hitRecord.absorption = vec3<f32>(0f, 0f, 0f);
            switch u32(materialBuffer.materials[hitRecord.materialId].typeId) {
                default: {
                    scatter = false;
                }
                case 0u: {
                    scatter = scatterLambertian(ray, hitRecord, &attenuation, seed);
                }
                case 1u: {
                    scatter = scatterMetal(ray, hitRecord, &attenuation, seed);
                }
                case 2u: {
                    scatter = scatterDielectric(ray, &hitRecord, &attenuation, seed);
                }
                case 3u: {
                    scatter = scatterGlossy(ray, hitRecord, &attenuation, seed);
                }
                case 4u: {
                    // Diffuse light
                    scatter = false;
                    emitted = materialBuffer.materials[hitRecord.materialId].color;
                }
                case 5u: {
                    scatter = scatterIsotropic(ray, hitRecord, &attenuation, seed);
                }
                case 6u: {
                    scatter = scatterVarnish(ray, hitRecord, &attenuation, seed);
                }
            }

            if (scatter) {
                // Attenuate
                color = color * attenuation;
            }
            else {
                // Emit
                // result.color = color * emitted;
                // return result;
                return color * emitted;
            }
        }
        else {
            // return color;

            // No hits
            if (depth > 0u) { // Hide lights, background
                return hitLights(*ray) * color;
                // result.color = hitLights(*ray) * color;
                // return result;
            }
            else {
                // return vec3<f32>(0f, 0f, 0f);
                return uniforms.backgroundColor;
                // result.color = uniforms.backgroundColor;
                // return result;
            }

            // Background
            // let t = 0.5f * ((*ray).direction.y + 1f);
            // let background = (1f - t) * vec3<f32>(1f, 1f, 1f) + t * vec3<f32>(0.5f, 0.7f, 1.0f);
            // return color * background;
        }
    }
}

// TODO: Try writing color directly using var outputTexture : texture_storage_2d<rgb32f,read_write>;
// textureStore(outputTexture, uv, vec3<f32>(1f, 1f, 1f));
@group(0) @binding(0) var<storage, read_write> outputColorBuffer: ColorBuffer;
@group(0) @binding(1) var<uniform> uniforms: Uniforms;
@group(0) @binding(2) var<storage, read> hittableBuffer: HittableBuffer;
@group(0) @binding(3) var<storage, read> materialBuffer: MaterialBuffer;
@group(0) @binding(4) var<storage, read> textureBuffer: TextureBuffer;
@group(0) @binding(5) var<storage, read> lightBuffer: LightBuffer;
@group(0) @binding(6) var<storage, read> linearBVHNodeBuffer: LinearBVHNodeBuffer;
@group(0) @binding(7) var linearSampler: sampler;
@group(0) @binding(8) var fontTexture: texture_2d<f32>;
@group(0) @binding(9) var backgroundTexture: texture_2d<f32>;
@group(0) @binding(10) var atlasTexture: texture_2d<f32>;
@group(0) @binding(11) var<storage, read_write> outputNormalDepthBuffer: NormalDepthBuffer;
@group(0) @binding(12) var<storage, read_write> depthMinMaxBuffer: DepthMinMaxBuffer;

// TODO: Move lighting to seperate bind group so I can update it independently

@compute @workgroup_size(256, 1, 1)
fn clear(@builtin(global_invocation_id) globalId : vec3<u32>) {
    var index = globalId.x * 3u;
    outputColorBuffer.values[index] = 0f;
    outputColorBuffer.values[index + 1u] = 0f;
    outputColorBuffer.values[index + 2u] = 0f;
    index = globalId.x * 4u;
    outputNormalDepthBuffer.values[index] = 0f; // Normal x
    outputNormalDepthBuffer.values[index + 1u] = 0f; // Normal y
    outputNormalDepthBuffer.values[index + 2u] = 0f; // Normal z
    outputNormalDepthBuffer.values[index + 3u] = 0f; // Depth
    atomicStore(&depthMinMaxBuffer.values[0], 4294967295u);
    atomicStore(&depthMinMaxBuffer.values[1], 0u);
}

@compute @workgroup_size(256, 1, 1)
fn depthNormal(@builtin(global_invocation_id) globalId : vec3<u32>) {
    let imageSize = vec2<f32>(uniforms.width * uniforms.tilesX, uniforms.height * uniforms.tilesY);
    let tileSize = vec2<f32>(uniforms.width, uniforms.height);
   
    // Tex coords [0,1]
    // let id = f32(globalId.x);
    // let v = floor(id / imageSize.x);
    // let u = (id - v * imageSize.x);
    // let uv = vec2<f32>(u, v);
    // let texCoord = uv / imageSize;

    // Pixel coords ([0,width-1], [0,height-1])
    let id = f32(globalId.x);
    let tilePixelY = floor(id / tileSize.x);
    let tilePixelX = id - tilePixelY * tileSize.x;
    let imagePixelX = tilePixelX + uniforms.tileOffsetX * tileSize.x;
    let imagePixelY = tilePixelY + uniforms.tileOffsetY * tileSize.y;
    
    // Tex coords ([0,1], [0,1])
    let texCoord = vec2<f32>(imagePixelX / imageSize.x, imagePixelY / imageSize.y);
   
    // Camera
    var camera = getCamera(uniforms);
    
    // Sample position (sub-pixel sampling has same seed, but only sampled once per frame)
    let samplePos = vec2<f32>(texCoord);

    // Ray
    var seed = 0u; // No depth of field for depth, normal
    var ray = getCameraRay(camera, &seed, samplePos);

    // Result
    var normal = vec3<f32>(0f, 0f, 0f);
    var depth = 0f;
    var hitRecord: HitRecord;
    if (hitBVH(ray, 0.00001f, 100f, &hitRecord, &seed)) {
        normal = hitRecord.normal * 0.5f + vec3<f32>(0.5f, 0.5f, 0.5f);
        depth = -1f / dot(hitRecord.position - ray.origin, uniforms.forward);
    }

    let index = globalId.x * 4u;
    // let index = u32(pixelY * imageSize.x + pixelX) * 4u;
    outputNormalDepthBuffer.values[index] = normal.x;
    outputNormalDepthBuffer.values[index + 1u] = normal.y;
    outputNormalDepthBuffer.values[index + 2u] = normal.z;
    outputNormalDepthBuffer.values[index + 3u] = depth;

    // Min, max depth
    // When depth is 0, it means no hit, so ignore
    if (depth > 0f) {
        atomicMin(&depthMinMaxBuffer.values[0], u32(depth * 1000f));
    }
    atomicMax(&depthMinMaxBuffer.values[1], u32(depth * 1000f));
}

@compute @workgroup_size(256, 1, 1)
fn segment(@builtin(global_invocation_id) globalId : vec3<u32>) {
    let imageSize = vec2<f32>(uniforms.width * uniforms.tilesX, uniforms.height * uniforms.tilesY);
    let tileSize = vec2<f32>(uniforms.width, uniforms.height);
   
    // Tex coords [0,1]
    // let id = f32(globalId.x);
    // let v = floor(id / imageSize.x);
    // let u = (id - v * imageSize.x);
    // let uv = vec2<f32>(u, v);
    // let texCoord = uv / imageSize;

    // Pixel coords ([0,width-1], [0,height-1])
    let id = f32(globalId.x);
    let tilePixelY = floor(id / tileSize.x);
    let tilePixelX = id - tilePixelY * tileSize.x;
    let imagePixelX = tilePixelX + uniforms.tileOffsetX * tileSize.x;
    let imagePixelY = tilePixelY + uniforms.tileOffsetY * tileSize.y;
    
    // Tex coords ([0,1], [0,1])
    let texCoord = vec2<f32>(imagePixelX / imageSize.x, imagePixelY / imageSize.y);
   
    // Camera
    var camera = getCamera(uniforms);
    
    // Sample position (sub-pixel sampling has same seed, but only sampled once per frame)
    let samplePos = vec2<f32>(texCoord);

    // Ray
    var seed = 0u; // No depth of field for depth, normal
    var ray = getCameraRay(camera, &seed, samplePos);

    // Result
    var color = vec4<f32>(1f, 1f, 1f, 0f);
    var hitRecord: HitRecord;
    if (hitBVH(ray, 0.00001f, 100f, &hitRecord, &seed)) {
        // color = materialBuffer.materials[hitRecord.materialId].idColor;
        let id = f32(hitRecord.id & 255u) / 255f;
        color.x = id;
        color.y = id;
        color.z = id;
        // let color3 = textureValue(hitRecord);
        // color.x = color3.x;
        // color.y = color3.y;
        // color.z = color3.z;
    }
    
    let index = globalId.x * 4u;
    // let index = u32(pixelY * imageSize.x + pixelX) * 4u;
    outputNormalDepthBuffer.values[index] = color.x;
    outputNormalDepthBuffer.values[index + 1u] = color.y;
    outputNormalDepthBuffer.values[index + 2u] = color.z;
    outputNormalDepthBuffer.values[index + 3u] = 1f;
}

// @builtin(local_invocation_id) localId : vec3<u32>,
// @builtin(num_workgroups) numWorkgroups : vec3<u32>,
// @builtin(workgroup_id) workgroupId : vec3<u32>
// TODO: Use workgroup dimensions xy to get position directly froem globalId
//       Then store using textureStore
//       Check within bounds due to overdispatching

@compute @workgroup_size(256, 1, 1)
fn main(@builtin(global_invocation_id) globalId : vec3<u32>) {
    let imageSize = vec2<f32>(uniforms.width * uniforms.tilesX, uniforms.height * uniforms.tilesY);
    let tileSize = vec2<f32>(uniforms.width, uniforms.height);

    // TODO: Is additional noise when tiling due to sdf iterations (try non-sdf), texel offsets, (size - 1) issues, overdispatching?

    // Tex coords [0,1]
    // let id = f32(globalId.x);
    // TODO: Divide by (imageSize.x - 1)
    // let v = floor(id / imageSize.x);
    // let u = (id - v * imageSize.x);
    // let uv = vec2<f32>(u, v);
    // let texCoord = uv / imageSize;

    // Pixel coords ([0,width-1], [0,height-1])
    let id = f32(globalId.x);
    let tilePixelY = floor(id / tileSize.x);
    let tilePixelX = id - tilePixelY * tileSize.x;
    let imagePixelX = tilePixelX + uniforms.tileOffsetX * tileSize.x;
    let imagePixelY = tilePixelY + uniforms.tileOffsetY * tileSize.y;
    
    // Tex coords ([0,1], [0,1])
    let texCoord = vec2<f32>(imagePixelX / imageSize.x, imagePixelY / imageSize.y);
   
    // Camera
    var camera = getCamera(uniforms);
    
    // Frame seed
    var frameSeed = u32(uniforms.seed);
    let raysPerFrame = u32(uniforms.raysPerFrame);
    var color = vec3<f32>(0f, 0f, 0f);
    var depth = 0f;
    var normal = vec3<f32>(0f, 0f, 0f);
    var seed: u32;
    
    for (var i = 0u; i < raysPerFrame; i = i + 1u) {
        // Random number generator
        // See https://nelari.us/post/weekend_raytracing_with_wgpu_1/#implement-a-random-number-generator
        // fn initRng(pixel: vec2<u32>, resolution: vec2<u32>, frame: u32) -> u32 {
        //     // Adapted from https://github.com/boksajak/referencePT
        //     let seed = dot(pixel, vec2<u32>(1u, resolution.x)) ^ jenkinsHash(frame);
        //     return jenkinsHash(seed);
        // }
        // 
        // fn jenkinsHash(input: u32) -> u32 {
        //     var x = input;
        //     x += x << 10u;
        //     x ^= x >> 6u;
        //     x += x << 3u;
        //     x ^= x >> 11u;
        //     x += x << 15u;
        //     return x;
        // }
        // TODO: Consider switching to u32 for uniforms and use vec3<u32> arithmetic
        seed = u32(tilePixelY * tileSize.x + tilePixelX) + frameSeed * u32(tileSize.x * tileSize.y);

        // Sample position (sub-pixel sampling has same seed, but only sampled once per frame)
        let samplePos = vec2<f32>(texCoord) + vec2<f32>(random(&seed), random(&seed)) / imageSize;

        // Ray
        var ray = getCameraRay(camera, &seed, samplePos);

        // Color [0,1]
        // let color = result.color;
        // let color = clamp(result.color, vec3<f32>(0f, 0f, 0f), vec3<f32>(1f, 1f, 1f));
        // let color = clamp(result.color, vec3<f32>(0f, 0f, 0f), vec3<f32>(10f, 10f, 10f)); // Max light
        color += clamp(rayColor(&ray, &seed), vec3<f32>(0f, 0f, 0f), vec3<f32>(10f, 10f, 10f)); // Max light
        
        // Depth
        // let depth = 1f / rayColor(&ray, &seed).depth;
        // color = vec3<f32>(depth, depth, depth);
        // depth += result.depth;

        // Normal
        // normal += result.normal;
        
        // Next frame
        frameSeed = frameSeed + 1u;
    }
    let index = globalId.x * 3u;
    outputColorBuffer.values[index + 0u] = outputColorBuffer.values[index + 0u] + color.x;
    outputColorBuffer.values[index + 1u] = outputColorBuffer.values[index + 1u] + color.y;
    outputColorBuffer.values[index + 2u] = outputColorBuffer.values[index + 2u] + color.z;
    // outputDepthBuffer.values[globalId.x] = outputDepthBuffer.values[globalId.x] + depth;
    // outputNormalBuffer.values[index + 0u] = outputNormalBuffer.values[index + 0u] + normal.x;
    // outputNormalBuffer.values[index + 1u] = outputNormalBuffer.values[index + 1u] + normal.y;
    // outputNormalBuffer.values[index + 2u] = outputNormalBuffer.values[index + 2u] + normal.z;
}`;
class $e1b604d7f27d3d8e$export$893bf7cc4a794b30 extends Float32Array {
    constructor(){
        super($e1b604d7f27d3d8e$export$893bf7cc4a794b30.SIZE);
        this.POSITION_OFFSET = 0;
        this.WIDTH_OFFSET = 3;
        this.RIGHT_OFFSET = 4;
        this.HEIGHT_OFFSET = 7;
        this.UP_OFFSET = 8;
        this.SEED_OFFSET = 11;
        this.FORWARD_OFFSET = 12;
        this.FOV_OFFSET = 15;
        this.LOOKAT_OFFSET = 16;
        this.APERTURE_OFFSET = 19;
        this.BACKGROUND_COLOR_OFFSET = 20;
        this.TIME0_OFFSET = 23;
        this.TIME1_OFFSET = 24;
        this.TILES_X = 25;
        this.TILES_Y = 26;
        this.TILE_OFFSET_X = 27;
        this.TILE_OFFSET_Y = 28;
        this.RAYS_PER_FRAME_OFFSET = 29;
    }
    getWidth() {
        return this[this.WIDTH_OFFSET];
    }
    setWidth(value) {
        this[this.WIDTH_OFFSET] = value;
    }
    getHeight() {
        return this[this.HEIGHT_OFFSET];
    }
    setHeight(value) {
        this[this.HEIGHT_OFFSET] = value;
    }
    getSeed() {
        return this[this.SEED_OFFSET];
    }
    setSeed(value) {
        this[this.SEED_OFFSET] = value;
    }
    getRaysPerFrame() {
        return this[this.RAYS_PER_FRAME_OFFSET];
    }
    setRaysPerFrame(value) {
        this[this.RAYS_PER_FRAME_OFFSET] = value;
    }
    getFieldOfView() {
        return this[this.FOV_OFFSET];
    }
    setFieldOfView(value) {
        this[this.FOV_OFFSET] = value;
    }
    getAperture() {
        return this[this.APERTURE_OFFSET];
    }
    setAperture(value) {
        this[this.APERTURE_OFFSET] = value;
    }
    getPosition(value) {
        (0, $31054a6c69637582$exports).set(value, this[this.POSITION_OFFSET], this[this.POSITION_OFFSET + 1], this[this.POSITION_OFFSET + 2]);
    }
    setPosition(value) {
        this[this.POSITION_OFFSET] = value[0];
        this[this.POSITION_OFFSET + 1] = value[1];
        this[this.POSITION_OFFSET + 2] = value[2];
    }
    getRight(value) {
        (0, $31054a6c69637582$exports).set(value, this[this.RIGHT_OFFSET], this[this.RIGHT_OFFSET + 1], this[this.RIGHT_OFFSET + 2]);
    }
    setRight(value) {
        this[this.RIGHT_OFFSET] = value[0];
        this[this.RIGHT_OFFSET + 1] = value[1];
        this[this.RIGHT_OFFSET + 2] = value[2];
    }
    getUp(value) {
        (0, $31054a6c69637582$exports).set(value, this[this.UP_OFFSET], this[this.UP_OFFSET + 1], this[this.UP_OFFSET + 2]);
    }
    setUp(value) {
        this[this.UP_OFFSET] = value[0];
        this[this.UP_OFFSET + 1] = value[1];
        this[this.UP_OFFSET + 2] = value[2];
    }
    getForward(value) {
        (0, $31054a6c69637582$exports).set(value, this[this.FORWARD_OFFSET], this[this.FORWARD_OFFSET + 1], this[this.FORWARD_OFFSET + 2]);
    }
    setForward(value) {
        this[this.FORWARD_OFFSET] = value[0];
        this[this.FORWARD_OFFSET + 1] = value[1];
        this[this.FORWARD_OFFSET + 2] = value[2];
    }
    getLookAt(value) {
        (0, $31054a6c69637582$exports).set(value, this[this.LOOKAT_OFFSET], this[this.LOOKAT_OFFSET + 1], this[this.LOOKAT_OFFSET + 2]);
    }
    setLookAt(value) {
        this[this.LOOKAT_OFFSET] = value[0];
        this[this.LOOKAT_OFFSET + 1] = value[1];
        this[this.LOOKAT_OFFSET + 2] = value[2];
    }
    getBackgroundColor(value) {
        (0, $4c4ac78b213a9c07$exports).set(value, this[this.BACKGROUND_COLOR_OFFSET], this[this.BACKGROUND_COLOR_OFFSET + 1], this[this.BACKGROUND_COLOR_OFFSET + 2], 1);
    }
    setBackgroundColor(value) {
        this[this.BACKGROUND_COLOR_OFFSET] = value[0];
        this[this.BACKGROUND_COLOR_OFFSET + 1] = value[1];
        this[this.BACKGROUND_COLOR_OFFSET + 2] = value[2];
    }
    getTime0() {
        return this[this.TIME0_OFFSET];
    }
    setTime0(value) {
        this[this.TIME0_OFFSET] = value;
    }
    getTime1() {
        return this[this.TIME1_OFFSET];
    }
    setTime1(value) {
        this[this.TIME1_OFFSET] = value;
    }
    getTilesX() {
        return this[this.TILES_X];
    }
    setTilesX(value) {
        this[this.TILES_X] = value;
    }
    getTilesY() {
        return this[this.TILES_Y];
    }
    setTilesY(value) {
        this[this.TILES_Y] = value;
    }
    getTileOffsetX() {
        return this[this.TILE_OFFSET_X];
    }
    setTileOffsetX(value) {
        this[this.TILE_OFFSET_X] = value;
    }
    getTileOffsetY() {
        return this[this.TILE_OFFSET_Y];
    }
    setTileOffsetY(value) {
        this[this.TILE_OFFSET_Y] = value;
    }
}
$e1b604d7f27d3d8e$export$893bf7cc4a794b30.SIZE = 32;


/*!
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 */ const $e354276e6b56108d$export$739cc3561e95931b = `
const GAMMA = vec3<f32>(0.45454545f); // 1 / 2.2

struct ColorData {
    data : array<f32>,
}

struct NormalDepthData {
    data : array<f32>,
}

                            //         offest   align    size
struct Uniforms {           // ------------------------------
    width: f32,             //              0       4       4
    height: f32,            //              4       4       4
    samplesPerPixel: f32,   //              8       4       4
    exposure: f32,          //             12       4       4
    minDepth: f32,          //             16       4       4
    maxDepth: f32,          //             20       4       4
    normalEdge: f32,        //             24       4       4
    depthEdge: f32,         //             28       4       4
}                           // ------------------------------
                            //                      4      32

@group(0) @binding(0) var<uniform> uniforms : Uniforms;
@group(0) @binding(1) var<storage, read> colorBuffer : ColorData;
@group(0) @binding(2) var<storage, read> normalDepthBuffer : NormalDepthData;

struct VertexOutput {
    @builtin(position) Position : vec4<f32>,
};

@vertex
fn vert_main(@builtin(vertex_index) vertexIndex : u32) -> VertexOutput {
    var pos = array<vec2<f32>, 6>(
        vec2<f32>( 1f,  1f),
        vec2<f32>( 1f, -1f),
        vec2<f32>(-1f, -1f),
        vec2<f32>( 1f,  1f),
        vec2<f32>(-1f, -1f),
        vec2<f32>(-1f,  1f));
    var output : VertexOutput;
    output.Position = vec4<f32>(pos[vertexIndex], 0f, 1f);
    return output;
}

@fragment
fn frag_main(@builtin(position) coord: vec4<f32>) -> @location(0) vec4<f32> {
    let x = floor(coord.x);
    let y = floor(coord.y);
    let index = u32(x + y * uniforms.width) * 3u;
    // [0,1]
    var color = vec3<f32>(colorBuffer.data[index + 0u], colorBuffer.data[index + 1u], colorBuffer.data[index + 2u]) / uniforms.samplesPerPixel;
    // Gamma-correct
    return vec4<f32>(pow(color, GAMMA), 1f);
}

@fragment
fn frag_depth(@builtin(position) coord: vec4<f32>) -> @location(0) vec4<f32> {
    let x = floor(coord.x);
    let y = floor(coord.y);
    let index = u32(x + y * uniforms.width) * 4u;
    let depth = normalDepthBuffer.data[index + 3u];
    let minDepth = uniforms.minDepth;
    let maxDepth = uniforms.maxDepth;
    if (minDepth == maxDepth) {
        // Raw, unnormalized depth
        return vec4<f32>(vec3<f32>(depth, depth, depth), 1f);
    }
    else {
        // Normalize depth
        var normalizedDepth = (depth - minDepth) / (maxDepth - minDepth);
        return vec4<f32>(normalizedDepth, normalizedDepth, normalizedDepth, 1f);
    }
}

@fragment
fn frag_normal(@builtin(position) coord: vec4<f32>) -> @location(0) vec4<f32> {
    let x = floor(coord.x);
    let y = floor(coord.y);
    let index = u32(x + y * uniforms.width) * 4u;
    return vec4<f32>(normalDepthBuffer.data[index + 0u], normalDepthBuffer.data[index + 1u], normalDepthBuffer.data[index + 2u], 1f);
}

// @fragment
// fn frag_edge(@builtin(position) coord: vec4<f32>) -> @location(0) vec4<f32> {
//     let x = floor(coord.x);
//     let y = floor(coord.y);
//     let index = u32(x + y * uniforms.width) * 4u;

//     // Prevent edge detection at screen edges
//     if (x == 0 || x == uniforms.width - 1 || y == 0 || y == uniforms.height - 1) {
//         return vec4<f32>(0f, 0f, 0f, 1f);
//     }

//     // Normal derivatives
//     let p = vec3<f32>(normalDepthBuffer.data[index + 0u], normalDepthBuffer.data[index + 1u], normalDepthBuffer.data[index + 2u]);
//     let px = vec3<f32>(normalDepthBuffer.data[index + 4u], normalDepthBuffer.data[index + 5u], normalDepthBuffer.data[index + 6u]);
//     let py = vec3<f32>(normalDepthBuffer.data[index + u32(uniforms.width) * 4u + 0u], normalDepthBuffer.data[index + u32(uniforms.width) * 4u + 1u], normalDepthBuffer.data[index + u32(uniforms.width) * 4u + 2u]);
//     let dpdx = px - p;
//     let dpdy = py - p;
//     let fwidth = abs(dpdx) + abs(dpdy);

//     // Depth derivatives
//     let d = normalDepthBuffer.data[index + 3u];
//     let dx = normalDepthBuffer.data[index + 7u];
//     let dy = normalDepthBuffer.data[index + u32(uniforms.width) * 4u + 3u];
//     let ddpx = dx - d;
//     let ddpy = dy - d;
    
//     // Normalize depth
//     // let minDepth = uniforms.minDepth;
//     // let maxDepth = uniforms.maxDepth;
//     // let nd = (d - minDepth) / (maxDepth - minDepth);
//     // let ndx = (dx - minDepth) / (maxDepth - minDepth);
//     // let ndy = (dy - minDepth) / (maxDepth - minDepth);
//     // let ddpx = ndx - nd;
//     // let ddpy = ndy - nd;
    
//     let dfwidth = abs(ddpx) + abs(ddpy);

//     // Output white when magnitude of dpdx over a threshold
//     let depthEdge = uniforms.depthEdge;
//     let normalEdge = uniforms.normalEdge;
//     if (dot(fwidth, fwidth) > normalEdge || dfwidth > depthEdge) {
//         return vec4<f32>(1f, 1f, 1f, 1f);
//     } else {
//         return vec4<f32>(0f, 0f, 0f, 1f);
//     }
// }

@fragment
fn frag_edge(@builtin(position) coord: vec4<f32>) -> @location(0) vec4<f32> {
    let x = floor(coord.x);
    let y = floor(coord.y);
    let index = u32(x + y * uniforms.width) * 4u;

    // Prevent edge detection at screen edges
    if (x == 0 || x == uniforms.width - 1 || y == 0 || y == uniforms.height - 1) {
        return vec4<f32>(0f, 0f, 0f, 1f);
    }

    // Segment derivatives
    let p = vec4<f32>(normalDepthBuffer.data[index + 0u], normalDepthBuffer.data[index + 1u], normalDepthBuffer.data[index + 2u], normalDepthBuffer.data[index + 3u]);
    let px = vec4<f32>(normalDepthBuffer.data[index + 4u], normalDepthBuffer.data[index + 5u], normalDepthBuffer.data[index + 6u], normalDepthBuffer.data[index + 7u]);
    let py = vec4<f32>(normalDepthBuffer.data[index + u32(uniforms.width) * 4u + 0u], normalDepthBuffer.data[index + u32(uniforms.width) * 4u + 1u], normalDepthBuffer.data[index + u32(uniforms.width) * 4u + 2u], normalDepthBuffer.data[index + u32(uniforms.width) * 4u + 3u]);
    let dpdx = px - p;
    let dpdy = py - p;
    let fwidth = abs(dpdx) + abs(dpdy);

    // Output white when magnitude of dpdx over a threshold
    if (dot(fwidth, fwidth) > 0f) {
        return vec4<f32>(1f, 1f, 1f, 1f);
    } else {
        return vec4<f32>(0f, 0f, 0f, 1f);
        // return p;
    }
}

@fragment
fn frag_segment(@builtin(position) coord: vec4<f32>) -> @location(0) vec4<f32> {
    let x = floor(coord.x);
    let y = floor(coord.y);
    let index = u32(x + y * uniforms.width) * 4u;
    return vec4<f32>(normalDepthBuffer.data[index + 0u], normalDepthBuffer.data[index + 1u], normalDepthBuffer.data[index + 2u], 1f);
}

@fragment
fn frag_main_hdr(@builtin(position) coord: vec4<f32>) -> @location(0) vec4<f32> {
    let x = floor(coord.x);
    let y = floor(coord.y);
    let index = u32(x + y * uniforms.width) * 3u;
    var color = vec3<f32>(colorBuffer.data[index + 0u], colorBuffer.data[index + 1u], colorBuffer.data[index + 2u]) / uniforms.samplesPerPixel;

    // Simple tone-mapping from HDR to LDR
    // if (uniforms.exposure > 0f) {
    //     color = color * uniforms.exposure;
    //     color = color / (color + vec3<f32>(1f, 1f, 1f));
    // }
    
    color = color * uniforms.exposure;
    // ACES
    // https://knarkowicz.wordpress.com/2016/01/06/aces-filmic-tone-mapping-curve/
    let a = 2.51f;
    let b = 0.03f;
    let c = 2.43f;
    let d = 0.59f;
    let e = 0.14f;
    color = (color * (a * color + b)) / (color * (c * color + d) + e);

    // See https://bruop.github.io/tonemapping/
    // See https://www.shadertoy.com/view/WdjSW3

    // Gamma-correct
    return vec4<f32>(pow(color, GAMMA), 1f);
}`;
class $e354276e6b56108d$export$186ae5dce927ebd1 extends Float32Array {
    constructor(){
        super($e354276e6b56108d$export$186ae5dce927ebd1.SIZE);
        this.WIDTH_OFFSET = 0;
        this.HEIGHT_OFFSET = 1;
        this.SPP_OFFSET = 2;
        this.EXPOSURE_OFFSET = 3;
        this.MIN_DEPTH_OFFSET = 4;
        this.MAX_DEPTH_OFFSET = 5;
        this.EDGE_NORMAL_OFFSET = 6;
        this.EDGE_DEPTH_OFFSET = 7;
    }
    getWidth() {
        return this[this.WIDTH_OFFSET];
    }
    setWidth(value) {
        this[this.WIDTH_OFFSET] = value;
    }
    getHeight() {
        return this[this.HEIGHT_OFFSET];
    }
    setHeight(value) {
        this[this.HEIGHT_OFFSET] = value;
    }
    getSamplesPerPixel() {
        return this[this.SPP_OFFSET];
    }
    setSamplesPerPixel(value) {
        this[this.SPP_OFFSET] = value;
    }
    getExposure() {
        return this[this.EXPOSURE_OFFSET];
    }
    setExposure(value) {
        this[this.EXPOSURE_OFFSET] = value;
    }
    getMinDepth() {
        return this[this.MIN_DEPTH_OFFSET];
    }
    setMinDepth(value) {
        this[this.MIN_DEPTH_OFFSET] = value;
    }
    getMaxDepth() {
        return this[this.MAX_DEPTH_OFFSET];
    }
    setMaxDepth(value) {
        this[this.MAX_DEPTH_OFFSET] = value;
    }
    getEdgeDepth() {
        return this[this.EDGE_DEPTH_OFFSET];
    }
    setEdgeDepth(value) {
        this[this.EDGE_DEPTH_OFFSET] = value;
    }
    getEdgeNormal() {
        return this[this.EDGE_NORMAL_OFFSET];
    }
    setEdgeNormal(value) {
        this[this.EDGE_NORMAL_OFFSET] = value;
    }
}
$e354276e6b56108d$export$186ae5dce927ebd1.SIZE = 8;


/*!
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 */ 


const $ee56e2b41e5e87b5$export$17e31acd02f2a1e = {
    middle: "middle",
    equalCounts: "equalCounts",
    sah: "sah"
};
class $ee56e2b41e5e87b5$var$BVHPrimitiveInfo {
    get primitiveNumber() {
        return this._primitiveNumber;
    }
    get bounds() {
        return this._bounds;
    }
    get centroid() {
        return this._centroid;
    }
    constructor(primitiveNumber, bounds){
        this._primitiveNumber = primitiveNumber;
        this._bounds = bounds;
        this._centroid = (0, $31054a6c69637582$exports).create();
        bounds.centroid(this._centroid);
    }
}
class $ee56e2b41e5e87b5$var$BVHBuildNode {
    get bounds() {
        return this._bounds;
    }
    get left() {
        return this._left;
    }
    get right() {
        return this._right;
    }
    get splitAxis() {
        return this._splitAxis;
    }
    get firstPrimOffset() {
        return this._firstPrimOffset;
    }
    get nPrimitives() {
        return this._nPrimitives;
    }
    get start() {
        return this._start;
    }
    get end() {
        return this._end;
    }
    constructor(start, end){
        this._start = start;
        this._end = end;
    }
    initLeaf(first, n, bounds) {
        this._firstPrimOffset = first;
        this._nPrimitives = n;
        this._bounds = bounds;
        this._left = null;
        this._right = null;
    }
    initInterior(axis, left, right) {
        this._left = left;
        this._right = right;
        this._bounds = new (0, $f858a5fa67a435f5$export$8ec70f2db73b49aa)();
        this._bounds.unionBounds(this._left.bounds);
        this._bounds.unionBounds(this._right.bounds);
        this._splitAxis = axis;
        this._nPrimitives = 0;
    }
}
class $ee56e2b41e5e87b5$export$7213561f8313b4 {
    constructor(){
        this.bounds = new (0, $f858a5fa67a435f5$export$8ec70f2db73b49aa)();
        this.primitivesOffset = 0;
        this.secondChildOffset = 0;
        this.nPrimitives = 0;
        this.axis = 0;
        this._centroid = (0, $31054a6c69637582$exports).create();
        this._size = (0, $31054a6c69637582$exports).create();
    }
    toBuffer(buffer, index) {
        this.bounds.centroid(this._centroid);
        buffer.setCenter(index, this._centroid);
        this.bounds.size(this._size);
        (0, $31054a6c69637582$exports).scale(this._size, this._size, 0.5);
        buffer.setSize(index, this._size);
        buffer.setPrimitivesOffset(index, this.primitivesOffset);
        buffer.setSecondChildOffset(index, this.secondChildOffset);
        buffer.setNPrimitives(index, this.nPrimitives);
        buffer.setAxis(index, this.axis);
    }
}
class $ee56e2b41e5e87b5$export$c191703b2daa3f18 {
    get orderedPrimitives() {
        return this._orderedPrimitives;
    }
    get nodes() {
        return this._nodes;
    }
    constructor(core, primitives, maxPrimsInNode, splitMethod){
        this._core = core;
        if (!primitives || primitives.length == 0) return;
        let start = performance.now();
        this._maxPrimsInNode = maxPrimsInNode;
        this._splitMethod = splitMethod;
        this._primitives = primitives;
        this._normalized = (0, $31054a6c69637582$exports).create();
        this._primitiveInfo = [];
        for(let i = 0; i < primitives.length; i++)this._primitiveInfo.push(new $ee56e2b41e5e87b5$var$BVHPrimitiveInfo(i, primitives[i].bounds));
        this._totalNodes = 0;
        this._orderedPrimitives = [];
        const root = this._recursiveBuild(0, primitives.length);
        this._core.log.write((0, $4a6417d29706362f$export$243e62d78d3b544d).info, `bvh ${this._totalNodes} nodes split ${this._splitMethod} ${Math.round(window.performance.now() - start)}ms`);
        start = performance.now();
        this._nodes = [];
        for(let i = 0; i < this._totalNodes; i++)this._nodes.push(new $ee56e2b41e5e87b5$export$7213561f8313b4());
        this._offset = 0;
        this._flattenBVHTree(root);
        this._core.log.write((0, $4a6417d29706362f$export$243e62d78d3b544d).info, `bvh flattened ${Math.round(window.performance.now() - start)}ms`);
    }
    _recursiveBuild(start, end) {
        const node = new $ee56e2b41e5e87b5$var$BVHBuildNode(start, end - 1);
        this._totalNodes++;
        const bounds = new (0, $f858a5fa67a435f5$export$8ec70f2db73b49aa)();
        for(let i = start; i < end; i++)bounds.unionBounds(this._primitiveInfo[i].bounds);
        const nPrimitives = end - start;
        if (nPrimitives == 1) {
            const firstPrimOffset = this._orderedPrimitives.length;
            for(let i = start; i < end; i++){
                const primNum = this._primitiveInfo[i].primitiveNumber;
                this._orderedPrimitives.push(this._primitives[primNum]);
            }
            node.initLeaf(firstPrimOffset, nPrimitives, bounds);
            return node;
        } else {
            const centroidBounds = new (0, $f858a5fa67a435f5$export$8ec70f2db73b49aa)();
            for(let i = start; i < end; i++)centroidBounds.unionPoint(this._primitiveInfo[i].centroid);
            const dim = centroidBounds.maximumExtent();
            let mid = Math.floor((start + end) / 2);
            if (centroidBounds.max[dim] == centroidBounds.min[dim]) {
                const firstPrimOffset = this._orderedPrimitives.length;
                for(let i = start; i < end; i++){
                    const primNum = this._primitiveInfo[i].primitiveNumber;
                    this._orderedPrimitives.push(this._primitives[primNum]);
                }
                node.initLeaf(firstPrimOffset, nPrimitives, bounds);
                return node;
            } else {
                switch(this._splitMethod){
                    case $ee56e2b41e5e87b5$export$17e31acd02f2a1e.middle:
                        break;
                    case $ee56e2b41e5e87b5$export$17e31acd02f2a1e.equalCounts:
                        mid = Math.floor((start + end) / 2);
                        const primtiveInfo = this._primitiveInfo.slice(start, end);
                        primtiveInfo.sort(function(a, b) {
                            return a.centroid[dim] - b.centroid[dim];
                        });
                        for(let i = start; i < end; i++)this._primitiveInfo[i] = primtiveInfo[i - start];
                        break;
                    case $ee56e2b41e5e87b5$export$17e31acd02f2a1e.sah:
                    default:
                        if (nPrimitives <= 4) {
                            mid = Math.floor((start + end) / 2);
                            const primtiveInfo = this._primitiveInfo.slice(start, end);
                            primtiveInfo.sort(function(a, b) {
                                return a.centroid[dim] - b.centroid[dim];
                            });
                            for(let i = start; i < end; i++)this._primitiveInfo[i] = primtiveInfo[i - start];
                        } else {
                            const nBuckets = 12;
                            const buckets = [];
                            for(let i = 0; i < nBuckets; i++)buckets.push({
                                count: 0,
                                bounds: new (0, $f858a5fa67a435f5$export$8ec70f2db73b49aa)()
                            });
                            for(let i = start; i < end; i++){
                                centroidBounds.offset(this._primitiveInfo[i].centroid, this._normalized);
                                const b = Math.min(Math.round(nBuckets * this._normalized[dim]), nBuckets - 1);
                                buckets[b].count++;
                                buckets[b].bounds.unionBounds(this._primitiveInfo[i].bounds);
                            }
                            const cost = [];
                            for(let i = 0; i < nBuckets - 1; i++){
                                const b0 = new (0, $f858a5fa67a435f5$export$8ec70f2db73b49aa)();
                                const b1 = new (0, $f858a5fa67a435f5$export$8ec70f2db73b49aa)();
                                let count0 = 0;
                                let count1 = 0;
                                for(let j = 0; j <= i; j++){
                                    b0.unionBounds(buckets[j].bounds);
                                    count0 += buckets[j].count;
                                }
                                for(let j = i + 1; j < nBuckets; j++){
                                    b1.unionBounds(buckets[j].bounds);
                                    count1 += buckets[j].count;
                                }
                                cost.push(0.125 + (count0 * b0.surfaceArea() + count1 * b1.surfaceArea()) / bounds.surfaceArea());
                            }
                            let minCost = cost[0];
                            let minCostSplitBucket = 0;
                            for(let i = 1; i < nBuckets - 1; i++)if (cost[i] < minCost) {
                                minCost = cost[i];
                                minCostSplitBucket = i;
                            }
                            const leafCost = nPrimitives;
                            if (nPrimitives > this._maxPrimsInNode || minCost < leafCost) {
                                const primtiveInfo = this._primitiveInfo.slice(start, end);
                                primtiveInfo.sort(function(a, b) {
                                    return a.centroid[dim] - b.centroid[dim];
                                });
                                for(let i = start; i < end; i++)this._primitiveInfo[i] = primtiveInfo[i - start];
                                for(let i = start; i < end; i++){
                                    centroidBounds.offset(this._primitiveInfo[i].centroid, this._normalized);
                                    const b = Math.min(Math.round(nBuckets * this._normalized[dim]), nBuckets - 1);
                                    if (b > minCostSplitBucket) {
                                        mid = i;
                                        break;
                                    }
                                }
                            } else {
                                const firstPrimOffset = this._orderedPrimitives.length;
                                for(let i = start; i < end; i++){
                                    const primNum = this._primitiveInfo[i].primitiveNumber;
                                    this._orderedPrimitives.push(this._primitives[primNum]);
                                }
                                node.initLeaf(firstPrimOffset, nPrimitives, bounds);
                                return node;
                            }
                        }
                        break;
                }
                node.initInterior(dim, this._recursiveBuild(start, mid), this._recursiveBuild(mid, end));
            }
        }
        return node;
    }
    _flattenBVHTree(node) {
        const linearNode = this._nodes[this._offset];
        linearNode.bounds = node.bounds;
        const myOffset = this._offset++;
        if (node.nPrimitives > 0) {
            linearNode.primitivesOffset = node.firstPrimOffset;
            linearNode.nPrimitives = node.nPrimitives;
        } else {
            linearNode.axis = node.splitAxis;
            linearNode.nPrimitives = 0;
            this._flattenBVHTree(node.left);
            linearNode.secondChildOffset = this._flattenBVHTree(node.right);
        }
        return myOffset;
    }
}
class $ee56e2b41e5e87b5$export$9e920ed4165673f5 extends Float32Array {
    constructor(count){
        super(count * $ee56e2b41e5e87b5$export$9e920ed4165673f5.SIZE);
        this.CENTER_OFFSET = 0;
        this.SIZE_OFFSET = 4;
        this.PRIMITIVES_OFFSET_OFFSET = 3;
        this.SECOND_CHILD_OFFSET_OFFSET = 7;
        this.N_PRIMITIVES_OFFSET = 8;
        this.AXIS_OFFSET = 9;
    }
    getCenter(index, value) {
        const offset = $ee56e2b41e5e87b5$export$9e920ed4165673f5.SIZE * index + this.CENTER_OFFSET;
        (0, $31054a6c69637582$exports).set(value, this[offset], this[offset + 1], this[offset + 2]);
    }
    setCenter(index, value) {
        const offset = $ee56e2b41e5e87b5$export$9e920ed4165673f5.SIZE * index + this.CENTER_OFFSET;
        this[offset] = value[0];
        this[offset + 1] = value[1];
        this[offset + 2] = value[2];
    }
    getSize(index, value) {
        const offset = $ee56e2b41e5e87b5$export$9e920ed4165673f5.SIZE * index + this.SIZE_OFFSET;
        (0, $31054a6c69637582$exports).set(value, this[offset], this[offset + 1], this[offset + 2]);
    }
    setSize(index, value) {
        const offset = $ee56e2b41e5e87b5$export$9e920ed4165673f5.SIZE * index + this.SIZE_OFFSET;
        this[offset] = value[0];
        this[offset + 1] = value[1];
        this[offset + 2] = value[2];
    }
    getPrimitivesOffset(index) {
        return this[$ee56e2b41e5e87b5$export$9e920ed4165673f5.SIZE * index + this.PRIMITIVES_OFFSET_OFFSET];
    }
    setPrimitivesOffset(index, value) {
        this[$ee56e2b41e5e87b5$export$9e920ed4165673f5.SIZE * index + this.PRIMITIVES_OFFSET_OFFSET] = value;
    }
    getSecondChildOffset(index) {
        return this[$ee56e2b41e5e87b5$export$9e920ed4165673f5.SIZE * index + this.SECOND_CHILD_OFFSET_OFFSET];
    }
    setSecondChildOffset(index, value) {
        this[$ee56e2b41e5e87b5$export$9e920ed4165673f5.SIZE * index + this.SECOND_CHILD_OFFSET_OFFSET] = value;
    }
    getNPrimitives(index) {
        return this[$ee56e2b41e5e87b5$export$9e920ed4165673f5.SIZE * index + this.N_PRIMITIVES_OFFSET];
    }
    setNPrimitives(index, value) {
        this[$ee56e2b41e5e87b5$export$9e920ed4165673f5.SIZE * index + this.N_PRIMITIVES_OFFSET] = value;
    }
    getAxis(index) {
        return this[$ee56e2b41e5e87b5$export$9e920ed4165673f5.SIZE * index + this.AXIS_OFFSET];
    }
    setAxis(index, value) {
        this[$ee56e2b41e5e87b5$export$9e920ed4165673f5.SIZE * index + this.AXIS_OFFSET] = value;
    }
}
$ee56e2b41e5e87b5$export$9e920ed4165673f5.SIZE = 12;



/*!
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 */ 
const $1596feb7c9451159$export$72af01233b4eb08d = {
    distant: 0,
    sphere: 1,
    rect: 2,
    disc: 3,
    cylinder: 4,
    dome: 5
};
class $1596feb7c9451159$export$82650fd3490ceb3f extends Float32Array {
    constructor(count){
        super(count * $1596feb7c9451159$export$82650fd3490ceb3f.SIZE);
        this.ROTATION_OFFSET = 0;
        this.CENTER_OFFSET = 4;
        this.TYPE_OFFSET = 7;
        this.SIZE_OFFSET = 8;
        this.COLOR_OFFSET = 12;
    }
    getType(index) {
        return this[$1596feb7c9451159$export$82650fd3490ceb3f.SIZE * index + this.TYPE_OFFSET];
    }
    setType(index, value) {
        this[$1596feb7c9451159$export$82650fd3490ceb3f.SIZE * index + this.TYPE_OFFSET] = value;
    }
    getCenter(index, value) {
        const offset = $1596feb7c9451159$export$82650fd3490ceb3f.SIZE * index + this.CENTER_OFFSET;
        (0, $31054a6c69637582$exports).set(value, this[offset], this[offset + 1], this[offset + 2]);
    }
    setCenter(index, value) {
        const offset = $1596feb7c9451159$export$82650fd3490ceb3f.SIZE * index + this.CENTER_OFFSET;
        this[offset] = value[0];
        this[offset + 1] = value[1];
        this[offset + 2] = value[2];
    }
    getSize(index, value) {
        const offset = $1596feb7c9451159$export$82650fd3490ceb3f.SIZE * index + this.SIZE_OFFSET;
        (0, $31054a6c69637582$exports).set(value, this[offset], this[offset + 1], this[offset + 2]);
    }
    setSize(index, value) {
        const offset = $1596feb7c9451159$export$82650fd3490ceb3f.SIZE * index + this.SIZE_OFFSET;
        this[offset] = value[0];
        this[offset + 1] = value[1];
        this[offset + 2] = value[2];
    }
    getColor(index, value) {
        const offset = $1596feb7c9451159$export$82650fd3490ceb3f.SIZE * index + this.COLOR_OFFSET;
        (0, $31054a6c69637582$exports).set(value, this[offset], this[offset + 1], this[offset + 2]);
    }
    setColor(index, value) {
        const offset = $1596feb7c9451159$export$82650fd3490ceb3f.SIZE * index + this.COLOR_OFFSET;
        this[offset] = value[0];
        this[offset + 1] = value[1];
        this[offset + 2] = value[2];
    }
    getRotation(index, value) {
        const offset = $1596feb7c9451159$export$82650fd3490ceb3f.SIZE * index + this.ROTATION_OFFSET;
        (0, $39ece26d1239bb77$exports).set(value, this[offset], this[offset + 1], this[offset + 2], this[offset + 3]);
    }
    setRotation(index, value) {
        const offset = $1596feb7c9451159$export$82650fd3490ceb3f.SIZE * index + this.ROTATION_OFFSET;
        this[offset] = value[0];
        this[offset + 1] = value[1];
        this[offset + 2] = value[2];
        this[offset + 3] = value[3];
    }
}
$1596feb7c9451159$export$82650fd3490ceb3f.SIZE = 16;
class $1596feb7c9451159$export$6ecadb6ed240d696 {
    constructor(options){
        this.color = options.color;
        this.center = options.center;
    }
    toBuffer(buffer, index) {
        buffer.setCenter(index, this.center);
        buffer.setColor(index, this.color);
    }
}
class $1596feb7c9451159$export$f6705b6c922d7219 extends $1596feb7c9451159$export$6ecadb6ed240d696 {
    constructor(options){
        super(options);
        this.radius = options.radius / 2;
    }
    toBuffer(buffer, index) {
        super.toBuffer(buffer, index);
        buffer.setType(index, $1596feb7c9451159$export$72af01233b4eb08d.sphere);
        buffer.setSize(index, (0, $31054a6c69637582$exports).fromValues(this.radius, this.radius, this.radius));
    }
}
class $1596feb7c9451159$export$1f9284d52f5c21ca extends $1596feb7c9451159$export$6ecadb6ed240d696 {
    constructor(options){
        super(options);
        this._thickness = 0.00001;
        this.size = options.size;
        this.rotation = options.rotation;
    }
    toBuffer(buffer, index) {
        super.toBuffer(buffer, index);
        buffer.setType(index, $1596feb7c9451159$export$72af01233b4eb08d.rect);
        buffer.setSize(index, (0, $31054a6c69637582$exports).fromValues(this.size[0], this.size[1], this._thickness));
        buffer.setRotation(index, this.rotation);
    }
}




/*!
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 */ 
class $70798b808a7c0587$export$e784a6eab4d2d700 {
    get isInitialized() {
        return this._isInitialized;
    }
    get font() {
        return this._font;
    }
    constructor(core, font){
        this._core = core;
        this._font = font;
        font.hasChangedCallback = ()=>{
            this._hasChanged = true;
        };
    }
    initializeContext(device) {
        this._device = device;
        this._hasChanged = true;
        this._isInitialized = true;
    }
    update() {
        if (this._hasChanged && this._isInitialized) {
            this._hasChanged = false;
            const start = window.performance.now();
            const imageData = this._font.atlas.imageData;
            const textureSize = {
                width: imageData.width,
                height: imageData.height
            };
            createImageBitmap(imageData).then((imageBitmap)=>{
                const textureDescriptor = {
                    size: textureSize,
                    format: 'rgba8unorm',
                    usage: GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.COPY_DST | GPUTextureUsage.RENDER_ATTACHMENT
                };
                this.texture = this._device.createTexture(textureDescriptor);
                const imageCopyExternalImage = {
                    source: imageBitmap
                };
                const imageCopyTextureTagged = {
                    texture: this.texture
                };
                const copySize = {
                    width: imageData.width,
                    height: imageData.height
                };
                this._device.queue.copyExternalImageToTexture(imageCopyExternalImage, imageCopyTextureTagged, copySize);
                if (this.hasChangedCallback) this.hasChangedCallback();
                this._core.log.write((0, $4a6417d29706362f$export$243e62d78d3b544d).info, `${this._font.name} texture updated ${Math.round(window.performance.now() - start)}ms`);
            });
        }
    }
}


/*!
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 */ 


class $18e0078d8611e105$export$6f251cd327b2ff1 {
    get isInitialized() {
        return this._isInitialized;
    }
    get image() {
        return this._image;
    }
    render(elapsedTime) {}
    constructor(core, main, image){
        this._core = core;
        this._main = main;
        this._image = image;
        this.isVisible = true;
        image.hasChangedCallback = ()=>{
            this._hasChanged = true;
        };
    }
    initializeContext(device) {
        if (!this._image.isInitialized) this._image.initialize();
        this._hasChanged = true;
        this._isInitialized = true;
    }
    update() {
        if (this._hasChanged && this._isInitialized) {
            this._hasChanged = false;
            const material = this._image.material == -1 ? this._main.config.defaultMaterial : this._main.materials[this._image.material];
            const modelPosition = (0, $31054a6c69637582$exports).create();
            const modelScale = this._core.getModelScale();
            const modelRotation = (0, $39ece26d1239bb77$exports).create();
            this._core.getModelRotation(modelRotation);
            const modelSizeX = this._image.maxBoundsX - this._image.minBoundsX;
            const modelSizeY = this._image.maxBoundsY - this._image.minBoundsY;
            const modelSizeZ = this._image.maxBoundsZ - this._image.minBoundsZ;
            const maxBounds = Math.max(modelSizeX, Math.max(modelSizeY, modelSizeZ));
            const boundsScaling = maxBounds == 0 ? 1 : 1 / maxBounds;
            (0, $31054a6c69637582$exports).set(modelPosition, this._main.mMatrix[12], this._main.mMatrix[13], this._main.mMatrix[14]);
            if (this._image instanceof (0, $f7de7bdc7bccbb25$export$3f0bd71f9b37d8ee)) {
                const imageQuad = this._image;
                const position = (0, $31054a6c69637582$exports).fromValues((imageQuad.minBoundsX + imageQuad.maxBoundsX) / 2, (imageQuad.minBoundsY + imageQuad.maxBoundsY) / 2, (imageQuad.minBoundsZ + imageQuad.maxBoundsZ) / 2);
                (0, $31054a6c69637582$exports).subtract(position, imageQuad.position, position);
                (0, $31054a6c69637582$exports).scale(position, position, boundsScaling);
                (0, $31054a6c69637582$exports).scale(position, position, modelScale);
                (0, $31054a6c69637582$exports).transformQuat(position, position, modelRotation);
                (0, $31054a6c69637582$exports).add(position, position, modelPosition);
                const hittableRotatedXyRectOptions = {
                    center0: position,
                    center1: position,
                    time0: 1,
                    time1: 1,
                    size0: (0, $91b0cc4981465964$exports).fromValues(imageQuad.width * boundsScaling * modelScale / 2, imageQuad.height * boundsScaling * modelScale / 2),
                    size1: (0, $91b0cc4981465964$exports).fromValues(imageQuad.width * boundsScaling * modelScale / 2, imageQuad.height * boundsScaling * modelScale / 2),
                    material: material,
                    texCoord0: imageQuad.texCoord0,
                    texCoord1: imageQuad.texCoord1,
                    rotation0: imageQuad.rotation,
                    rotation1: imageQuad.rotation
                };
                this.hittable = new (0, $66964bfc3ddbcb4c$export$71089e9c0fdb5c5)(hittableRotatedXyRectOptions);
            } else if (this._image instanceof (0, $f7de7bdc7bccbb25$export$f4ca272a8ace4457)) {
                const imageSphere = this._image;
                const position = imageSphere.position;
                (0, $31054a6c69637582$exports).subtract(position, imageSphere.position, position);
                (0, $31054a6c69637582$exports).scale(position, position, boundsScaling);
                (0, $31054a6c69637582$exports).scale(position, position, modelScale);
                (0, $31054a6c69637582$exports).transformQuat(position, position, modelRotation);
                (0, $31054a6c69637582$exports).add(position, position, modelPosition);
                const hittableSphereOptions = {
                    center0: position,
                    center1: position,
                    time0: 1,
                    time1: 1,
                    radius: imageSphere.radius * boundsScaling,
                    material: material
                };
                this.hittable = new (0, $66964bfc3ddbcb4c$export$f44a85073ff35bb)(hittableSphereOptions);
            }
            if (this.hasChangedCallback) this.hasChangedCallback();
        }
    }
}


/*!
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 */ 


class $b084cfc4223cd4fe$export$97e93e7019ef67b9 {
    get isInitialized() {
        return this._isInitialized;
    }
    get label() {
        return this._labelSet;
    }
    render(elapsedTime) {}
    constructor(core, main, labelSet){
        this._core = core;
        this._main = main;
        this._labelSet = labelSet;
        this.isVisible = true;
        labelSet.hasChangedCallback = ()=>{
            this._hasChanged = true;
        };
        if (!this._labelSet.isInitialized) this._labelSet.initialize();
        if (this._labelSet.text && this._labelSet.text.length > 0) this._hasChanged = true;
        this._isInitialized = true;
    }
    update() {
        if (this._hasChanged && this._isInitialized) {
            this._hasChanged = false;
            this.hittables = [];
            const modelPosition = (0, $31054a6c69637582$exports).create();
            const modelScale = this._core.getModelScale();
            const modelRotation = (0, $39ece26d1239bb77$exports).create();
            this._core.getModelRotation(modelRotation);
            (0, $31054a6c69637582$exports).set(modelPosition, this._main.mMatrix[12], this._main.mMatrix[13], this._main.mMatrix[14]);
            const glpyhRotation = (0, $39ece26d1239bb77$exports).create();
            const glyphInvRotation = (0, $39ece26d1239bb77$exports).create();
            const position0 = (0, $31054a6c69637582$exports).create();
            const position1 = (0, $31054a6c69637582$exports).create();
            const dataView = this._labelSet.verticesView;
            const labelCount = this._labelSet.text.length;
            let glyphIndex = 0;
            for(let i = 0; i < labelCount; i++){
                const material = this._labelSet.material !== undefined ? this._main.materials[this._labelSet.material] : this._labelSet.materials ? this._main.materials[this._labelSet.materials[i]] : this._main.config.defaultTextMaterial;
                const glyphCount = this._labelSet.text[i].length;
                for(let j = 0; j < glyphCount; j++){
                    (0, $0a0587bd8b0d58e8$export$74c3c25430a16442).getPosition(dataView, glyphIndex * 4 + 2, position0);
                    (0, $0a0587bd8b0d58e8$export$74c3c25430a16442).getPosition(dataView, glyphIndex * 4 + 1, position1);
                    (0, $31054a6c69637582$exports).scale(position0, position0, modelScale);
                    (0, $31054a6c69637582$exports).scale(position1, position1, modelScale);
                    (0, $31054a6c69637582$exports).transformQuat(position0, position0, modelRotation);
                    (0, $31054a6c69637582$exports).transformQuat(position1, position1, modelRotation);
                    (0, $31054a6c69637582$exports).add(position0, position0, modelPosition);
                    (0, $31054a6c69637582$exports).add(position1, position1, modelPosition);
                    const centroid = (0, $31054a6c69637582$exports).create();
                    (0, $31054a6c69637582$exports).add(centroid, position0, position1);
                    (0, $31054a6c69637582$exports).scale(centroid, centroid, 0.5);
                    if (this._labelSet.rotation) (0, $39ece26d1239bb77$exports).set(glpyhRotation, this._labelSet.rotation[0], this._labelSet.rotation[1], this._labelSet.rotation[2], this._labelSet.rotation[3]);
                    else if (this._labelSet.rotations) (0, $39ece26d1239bb77$exports).set(glpyhRotation, this._labelSet.rotations[i * 4], this._labelSet.rotations[i * 4 + 1], this._labelSet.rotations[i * 4 + 2], this._labelSet.rotations[i * 4 + 3]);
                    else (0, $39ece26d1239bb77$exports).identity(glpyhRotation);
                    const rotation = (0, $39ece26d1239bb77$exports).clone(glpyhRotation);
                    (0, $39ece26d1239bb77$exports).multiply(rotation, modelRotation, rotation);
                    (0, $39ece26d1239bb77$exports).conjugate(glyphInvRotation, rotation);
                    (0, $31054a6c69637582$exports).subtract(position0, position0, centroid);
                    (0, $31054a6c69637582$exports).subtract(position1, position1, centroid);
                    (0, $31054a6c69637582$exports).transformQuat(position0, position0, glyphInvRotation);
                    (0, $31054a6c69637582$exports).transformQuat(position1, position1, glyphInvRotation);
                    (0, $31054a6c69637582$exports).add(position0, position0, centroid);
                    (0, $31054a6c69637582$exports).add(position1, position1, centroid);
                    const texCoord0 = (0, $91b0cc4981465964$exports).create();
                    const texCoord1 = (0, $91b0cc4981465964$exports).create();
                    (0, $0a0587bd8b0d58e8$export$74c3c25430a16442).getTexCoord(dataView, glyphIndex * 4 + 2, texCoord0);
                    (0, $0a0587bd8b0d58e8$export$74c3c25430a16442).getTexCoord(dataView, glyphIndex * 4 + 1, texCoord1);
                    const hittableFontOptions = {
                        center0: centroid,
                        center1: centroid,
                        time0: 1,
                        time1: 1,
                        size0: (0, $91b0cc4981465964$exports).fromValues((position1[0] - position0[0]) / 2, (position1[1] - position0[1]) / 2),
                        size1: (0, $91b0cc4981465964$exports).fromValues((position1[0] - position0[0]) / 2, (position1[1] - position0[1]) / 2),
                        material: material,
                        texCoord0: texCoord0,
                        texCoord1: texCoord1,
                        rotation0: rotation,
                        rotation1: rotation,
                        sdfBuffer: this._core.config.sdfBuffer
                    };
                    const hittable = new (0, $66964bfc3ddbcb4c$export$402b844452575dc9)(hittableFontOptions);
                    this.hittables.push(hittable);
                    glyphIndex++;
                }
            }
            if (this.hasChangedCallback) this.hasChangedCallback();
        }
    }
}


/*!
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 */ 









class $93345e9ee93b28fb$export$a143d493d941bafc extends (0, $96371271bb28b98d$export$c1cecec923d96e5c) {
    constructor(core, ids){
        super(core, ids);
        this._isInitialized = true;
    }
    update() {
        if (this._isInitialized) {
            if (this.hasChangedCallback) this.hasChangedCallback();
        }
    }
}
class $93345e9ee93b28fb$export$76de936b3c1c4170 extends (0, $96371271bb28b98d$export$e17d4fc1dafc1240) {
    get time0() {
        return this._time0;
    }
    set time0(value) {
        if (this._time0 != value) {
            this._time0 = value;
            this._hasChanged = true;
        }
    }
    get time1() {
        return this._time1;
    }
    set time1(value) {
        if (this._time1 != value) {
            this._time1 = value;
            this._hasChanged = true;
        }
    }
    get duration() {
        return this._duration;
    }
    set duration(value) {
        if (this._duration != value) {
            this._duration = value;
            this._hasChanged = true;
        }
    }
    get stagger() {
        return this.stagger;
    }
    set stagger(value) {
        if (this._stagger != value) {
            this._stagger = value;
            this._hasChanged = true;
        }
    }
    constructor(core, main, ids){
        super(core, ids, $93345e9ee93b28fb$export$a143d493d941bafc, (0, $548ced3eab978a8c$export$e2fbaa661ec19dbf), (0, $0a2e9437355c0494$export$e47fdbcb2ea069e5));
        this._main = main;
        this._time0 = 0;
        this._time1 = 1;
        this._buffer1.hasChangedCallback = ()=>{
            this._hasChanged = true;
        };
        this._buffer2.hasChangedCallback = ()=>{
            this._hasChanged = true;
        };
        this._isInitialized = true;
    }
    update() {
        if (this._hasChanged && this._isInitialized) {
            this._hasChanged = false;
            const start = window.performance.now();
            this.hittables = [];
            const modelPosition = (0, $31054a6c69637582$exports).create();
            const modelScale = this._core.getModelScale();
            const modelRotation = (0, $39ece26d1239bb77$exports).create();
            this._core.getModelRotation(modelRotation);
            this.minY = Number.MAX_VALUE;
            (0, $31054a6c69637582$exports).set(modelPosition, this._main.mMatrix[12], this._main.mMatrix[13], this._main.mMatrix[14]);
            const previousBuffer = this.previousBuffer;
            const currentBuffer = this.currentBuffer;
            const currentUnitTranslation = (0, $31054a6c69637582$exports).create();
            const previousUnitTranslation = (0, $31054a6c69637582$exports).create();
            const currentUnitScale = (0, $31054a6c69637582$exports).create();
            const previousUnitScale = (0, $31054a6c69637582$exports).create();
            const currentUnitRotation = (0, $39ece26d1239bb77$exports).create();
            const previousUnitRotation = (0, $39ece26d1239bb77$exports).create();
            const unitOrder = (0, $91b0cc4981465964$exports).create();
            const transitionDuration = this._duration / (this._duration + this._stagger);
            for(let j = 0; j < currentBuffer.ids.length; j++){
                (0, $0a0587bd8b0d58e8$export$849e31d725692576).getOrder(currentBuffer.dataView, j, unitOrder);
                const startTime = unitOrder[1] * (1 - transitionDuration);
                const animation0 = (0, $2d4d1eb6f32f02f2$export$80a8c44b8858d625).clamp((this._time0 - startTime) / transitionDuration, 0, 1);
                const animation1 = (0, $2d4d1eb6f32f02f2$export$80a8c44b8858d625).clamp((this._time1 - startTime) / transitionDuration, 0, 1);
                const unitScale0 = (0, $31054a6c69637582$exports).create();
                const unitScale1 = (0, $31054a6c69637582$exports).create();
                (0, $0a0587bd8b0d58e8$export$849e31d725692576).getScale(currentBuffer.dataView, j, currentUnitScale);
                (0, $0a0587bd8b0d58e8$export$849e31d725692576).getScale(previousBuffer.dataView, j, previousUnitScale);
                (0, $31054a6c69637582$exports).lerp(unitScale0, previousUnitScale, currentUnitScale, animation0);
                (0, $31054a6c69637582$exports).lerp(unitScale1, previousUnitScale, currentUnitScale, animation1);
                const unitTranslation0 = (0, $31054a6c69637582$exports).create();
                const unitTranslation1 = (0, $31054a6c69637582$exports).create();
                (0, $0a0587bd8b0d58e8$export$849e31d725692576).getTranslation(currentBuffer.dataView, j, currentUnitTranslation);
                (0, $0a0587bd8b0d58e8$export$849e31d725692576).getTranslation(previousBuffer.dataView, j, previousUnitTranslation);
                (0, $31054a6c69637582$exports).lerp(unitTranslation0, previousUnitTranslation, currentUnitTranslation, animation0);
                (0, $31054a6c69637582$exports).lerp(unitTranslation1, previousUnitTranslation, currentUnitTranslation, animation1);
                const unitRotation0 = (0, $39ece26d1239bb77$exports).create();
                const unitRotation1 = (0, $39ece26d1239bb77$exports).create();
                (0, $0a0587bd8b0d58e8$export$849e31d725692576).getRotation(currentBuffer.dataView, j, currentUnitRotation);
                (0, $0a0587bd8b0d58e8$export$849e31d725692576).getRotation(previousBuffer.dataView, j, previousUnitRotation);
                (0, $39ece26d1239bb77$exports).slerp(unitRotation0, previousUnitRotation, currentUnitRotation, animation0);
                (0, $39ece26d1239bb77$exports).slerp(unitRotation1, previousUnitRotation, currentUnitRotation, animation1);
                (0, $39ece26d1239bb77$exports).multiply(unitRotation0, modelRotation, unitRotation0);
                (0, $39ece26d1239bb77$exports).multiply(unitRotation1, modelRotation, unitRotation1);
                (0, $31054a6c69637582$exports).scale(unitTranslation0, unitTranslation0, modelScale);
                (0, $31054a6c69637582$exports).scale(unitTranslation1, unitTranslation1, modelScale);
                (0, $31054a6c69637582$exports).transformQuat(unitTranslation0, unitTranslation0, modelRotation);
                (0, $31054a6c69637582$exports).transformQuat(unitTranslation1, unitTranslation1, modelRotation);
                (0, $31054a6c69637582$exports).add(unitTranslation0, unitTranslation0, modelPosition);
                (0, $31054a6c69637582$exports).add(unitTranslation1, unitTranslation1, modelPosition);
                (0, $31054a6c69637582$exports).scale(unitScale0, unitScale0, modelScale / 2);
                (0, $31054a6c69637582$exports).scale(unitScale1, unitScale1, modelScale / 2);
                unitScale0[0] = Math.max(unitScale0[0], 0.00001);
                unitScale0[1] = Math.max(unitScale0[1], 0.00001);
                unitScale0[2] = Math.max(unitScale0[2], 0.00001);
                unitScale1[0] = Math.max(unitScale1[0], 0.00001);
                unitScale1[1] = Math.max(unitScale1[1], 0.00001);
                unitScale1[2] = Math.max(unitScale1[2], 0.00001);
                const endTime = startTime + transitionDuration;
                const time0 = Math.min(Math.max((startTime - this._time0) / (this._time1 - this.time0), 0), 1);
                const time1 = Math.min(Math.max((endTime - this._time0) / (this._time1 - this.time0), 0), 1);
                const materialId = (0, $0a0587bd8b0d58e8$export$849e31d725692576).getMaterial(currentBuffer.dataView, j);
                const material = this._main.materials && this._main.materials.length > materialId ? this._main.materials[materialId] : this._main.config.defaultMaterial;
                let hittable;
                let unitTexCoord;
                switch(currentBuffer.unitType){
                    case (0, $4a6417d29706362f$export$80d48287646c9e3b).sphere:
                    case (0, $4a6417d29706362f$export$80d48287646c9e3b).sphereSdf:
                        hittable = new (0, $66964bfc3ddbcb4c$export$f44a85073ff35bb)({
                            center0: unitTranslation0,
                            center1: unitTranslation1,
                            time0: time0,
                            time1: time1,
                            radius: unitScale0[0],
                            material: material
                        });
                        break;
                    case (0, $4a6417d29706362f$export$80d48287646c9e3b).disk:
                        unitTexCoord = (0, $4c4ac78b213a9c07$exports).create();
                        (0, $0a0587bd8b0d58e8$export$849e31d725692576).getTexCoord(currentBuffer.dataView, j, unitTexCoord);
                        if (unitRotation1[3] == 1) hittable = new (0, $66964bfc3ddbcb4c$export$3f7e8ab42d22375)({
                            center0: unitTranslation0,
                            center1: unitTranslation1,
                            time0: time0,
                            time1: time1,
                            radius0: unitScale0[0],
                            radius1: unitScale1[0],
                            material: material,
                            texCoord0: (0, $91b0cc4981465964$exports).fromValues(unitTexCoord[0], unitTexCoord[3]),
                            texCoord1: (0, $91b0cc4981465964$exports).fromValues(unitTexCoord[2], unitTexCoord[1])
                        });
                        else hittable = new (0, $66964bfc3ddbcb4c$export$1d27985e95946d19)({
                            center0: unitTranslation0,
                            center1: unitTranslation1,
                            time0: time0,
                            time1: time1,
                            radius0: unitScale0[0],
                            radius1: unitScale1[0],
                            rotation0: unitRotation0,
                            rotation1: unitRotation1,
                            material: material,
                            texCoord0: (0, $91b0cc4981465964$exports).fromValues(unitTexCoord[0], unitTexCoord[3]),
                            texCoord1: (0, $91b0cc4981465964$exports).fromValues(unitTexCoord[2], unitTexCoord[1])
                        });
                        break;
                    case (0, $4a6417d29706362f$export$80d48287646c9e3b).block:
                        if (unitRotation1[3] == 1) hittable = new (0, $66964bfc3ddbcb4c$export$28497cc10fec95c2)({
                            center0: unitTranslation0,
                            center1: unitTranslation1,
                            time0: time0,
                            time1: time1,
                            size0: unitScale0,
                            size1: unitScale1,
                            material: material
                        });
                        else hittable = new (0, $66964bfc3ddbcb4c$export$acdc70fb29a0312b)({
                            center0: unitTranslation0,
                            center1: unitTranslation1,
                            time0: time0,
                            time1: time1,
                            size0: unitScale0,
                            size1: unitScale1,
                            rotation0: unitRotation0,
                            rotation1: unitRotation1,
                            material: material
                        });
                        break;
                    case (0, $4a6417d29706362f$export$80d48287646c9e3b).sdf:
                        unitTexCoord = (0, $4c4ac78b213a9c07$exports).create();
                        (0, $0a0587bd8b0d58e8$export$849e31d725692576).getTexCoord(currentBuffer.dataView, j, unitTexCoord);
                        const texId = (0, $0a0587bd8b0d58e8$export$849e31d725692576).getTexture(currentBuffer.dataView, j);
                        const sdfBuffer = (0, $0a0587bd8b0d58e8$export$849e31d725692576).getSdfBuffer(currentBuffer.dataView, j);
                        const sdfBorder = (0, $0a0587bd8b0d58e8$export$849e31d725692576).getSdfBorder(currentBuffer.dataView, j);
                        const options = {
                            center0: unitTranslation0,
                            center1: unitTranslation1,
                            time0: time0,
                            time1: time1,
                            size0: (0, $91b0cc4981465964$exports).fromValues(unitScale0[0], unitScale0[1]),
                            size1: (0, $91b0cc4981465964$exports).fromValues(unitScale1[0], unitScale1[1]),
                            texCoord0: (0, $91b0cc4981465964$exports).fromValues(unitTexCoord[0], unitTexCoord[3]),
                            texCoord1: (0, $91b0cc4981465964$exports).fromValues(unitTexCoord[2], unitTexCoord[1]),
                            rotation0: unitRotation0,
                            rotation1: unitRotation1,
                            material: material,
                            texId: texId,
                            sdfBuffer: sdfBuffer,
                            sdfBorder: sdfBorder
                        };
                        hittable = unitRotation1[3] == 1 ? new (0, $66964bfc3ddbcb4c$export$6d714417e0aa3f19)(options) : new (0, $66964bfc3ddbcb4c$export$c2e43d40ab2c967e)(options);
                        break;
                    case (0, $4a6417d29706362f$export$80d48287646c9e3b).blockSdf:
                        if (unitRotation1[3] == 1) hittable = new (0, $66964bfc3ddbcb4c$export$dfaec831a2de7e90)({
                            center0: unitTranslation0,
                            center1: unitTranslation1,
                            time0: time0,
                            time1: time1,
                            size0: unitScale0,
                            size1: unitScale1,
                            rounding: Math.min(Math.min(Math.min((0, $0a0587bd8b0d58e8$export$849e31d725692576).getRounding(currentBuffer.dataView, j) * modelScale, unitScale0[0]), unitScale0[1]), unitScale0[2]),
                            material: material
                        });
                        else hittable = new (0, $66964bfc3ddbcb4c$export$e349e1996fd043a1)({
                            center0: unitTranslation0,
                            center1: unitTranslation1,
                            time0: time0,
                            time1: time1,
                            size0: unitScale0,
                            size1: unitScale1,
                            rounding: Math.min(Math.min(Math.min((0, $0a0587bd8b0d58e8$export$849e31d725692576).getRounding(currentBuffer.dataView, j) * modelScale, unitScale0[0]), unitScale0[1]), unitScale0[2]),
                            material: material,
                            rotation0: unitRotation0,
                            rotation1: unitRotation1
                        });
                        break;
                    case (0, $4a6417d29706362f$export$80d48287646c9e3b).ringSdf:
                        if (unitRotation1[3] == 1) hittable = new (0, $66964bfc3ddbcb4c$export$d84131593262075b)({
                            center0: unitTranslation0,
                            center1: unitTranslation1,
                            time0: time0,
                            time1: time1,
                            size0: unitScale0,
                            size1: unitScale1,
                            angle0: (0, $0a0587bd8b0d58e8$export$849e31d725692576).getParameter1(currentBuffer.dataView, j),
                            innerRadius0: (0, $0a0587bd8b0d58e8$export$849e31d725692576).getParameter2(currentBuffer.dataView, j),
                            rounding: Math.min(Math.min(Math.min((0, $0a0587bd8b0d58e8$export$849e31d725692576).getRounding(currentBuffer.dataView, j) * modelScale, unitScale0[0]), unitScale0[1]), unitScale0[2]),
                            material: material
                        });
                        else hittable = new (0, $66964bfc3ddbcb4c$export$2d4dbfe5a7e22bdf)({
                            center0: unitTranslation0,
                            center1: unitTranslation1,
                            time0: time0,
                            time1: time1,
                            size0: unitScale0,
                            size1: unitScale1,
                            angle0: (0, $0a0587bd8b0d58e8$export$849e31d725692576).getParameter1(currentBuffer.dataView, j),
                            innerRadius0: (0, $0a0587bd8b0d58e8$export$849e31d725692576).getParameter2(currentBuffer.dataView, j),
                            rounding: Math.min(Math.min(Math.min((0, $0a0587bd8b0d58e8$export$849e31d725692576).getRounding(currentBuffer.dataView, j) * modelScale, unitScale0[0]), unitScale0[1]), unitScale0[2]),
                            material: material,
                            rotation0: unitRotation0,
                            rotation1: unitRotation1
                        });
                        break;
                    case (0, $4a6417d29706362f$export$80d48287646c9e3b).cylinder:
                        hittable = new (0, $66964bfc3ddbcb4c$export$cd2cb390b9add281)({
                            center0: unitTranslation0,
                            center1: unitTranslation1,
                            time0: time0,
                            time1: time1,
                            radius: unitScale0[0],
                            height: unitScale0[1],
                            rotation0: unitRotation0,
                            rotation1: unitRotation1,
                            material: material
                        });
                        break;
                    case (0, $4a6417d29706362f$export$80d48287646c9e3b).cylinderSdf:
                        hittable = new (0, $66964bfc3ddbcb4c$export$563880b935f7aee2)({
                            center0: unitTranslation0,
                            center1: unitTranslation1,
                            time0: time0,
                            time1: time1,
                            radius: unitScale0[0],
                            height: unitScale0[1],
                            rounding: Math.min(Math.min((0, $0a0587bd8b0d58e8$export$849e31d725692576).getRounding(currentBuffer.dataView, j) * modelScale, unitScale0[0]), unitScale0[1]),
                            material: material,
                            rotation0: unitRotation0,
                            rotation1: unitRotation1
                        });
                        break;
                    case (0, $4a6417d29706362f$export$80d48287646c9e3b).hexPrism:
                        hittable = new (0, $66964bfc3ddbcb4c$export$2104cbf9d09a457a)({
                            center0: unitTranslation0,
                            center1: unitTranslation1,
                            time0: time0,
                            time1: time1,
                            radius: unitScale0[0],
                            height: unitScale0[1],
                            material: material
                        });
                        break;
                    case (0, $4a6417d29706362f$export$80d48287646c9e3b).hexPrismSdf:
                        hittable = new (0, $66964bfc3ddbcb4c$export$df234dab64f8469a)({
                            center0: unitTranslation0,
                            center1: unitTranslation1,
                            time0: time0,
                            time1: time1,
                            radius: unitScale0[0],
                            height: unitScale0[1],
                            rounding: Math.min(Math.min((0, $0a0587bd8b0d58e8$export$849e31d725692576).getRounding(currentBuffer.dataView, j) * modelScale, unitScale0[0]), unitScale0[1]),
                            material: material
                        });
                        break;
                }
                if (hittable.material instanceof (0, $62116d012d21b949$export$87cc275e72e16d48)) this.hittables.push(new (0, $66964bfc3ddbcb4c$export$412c0ed39e393270)({
                    boundary: hittable,
                    center0: unitTranslation0,
                    center1: unitTranslation1,
                    time0: time0,
                    time1: time1,
                    material: hittable.material
                }));
                else this.hittables.push(hittable);
                this.minY = Math.min(hittable.bounds.min[1], this.minY);
            }
            if (this.hasChangedCallback) this.hasChangedCallback();
            this._core.log.write((0, $4a6417d29706362f$export$243e62d78d3b544d).info, `buffer updated ${this._length} ${Math.round(window.performance.now() - start)}ms`);
        }
    }
}


/*!
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 */ class $ca7af8634961ee25$export$a002182e51710d39 {
}
$ca7af8634961ee25$export$a002182e51710d39.SHADOW_OFFSET = 0.001;


var $d5ed11dd11fe7749$var$__awaiter = undefined && undefined.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
            resolve(value);
        });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
            try {
                step(generator.next(value));
            } catch (e) {
                reject(e);
            }
        }
        function rejected(value) {
            try {
                step(generator["throw"](value));
            } catch (e) {
                reject(e);
            }
        }
        function step(result) {
            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
class $d5ed11dd11fe7749$export$861edd1ccea2f746 extends (0, $a123db7d2af0bebc$export$30686c90897c890d) {
    get frameCount() {
        return this._frameCount;
    }
    get duration() {
        return this._duration;
    }
    get config() {
        return this._config;
    }
    set lights(value) {
        if (value != this._lights) {
            this._lights = value;
            this._haveLightsChanged = true;
            this._frameCount = 0;
        }
    }
    get lights() {
        return this._lights;
    }
    restart() {
        this._frameCount = 0;
        this._core.start();
    }
    constructor(options){
        super(options);
        (0, $14f38b7dd89457d7$exports).setMatrixArrayType(Float32Array);
        this._config = new (0, $cdd30208cd147f64$export$29cd7b75162a9425)();
        this._frameCount = 0;
        this._duration = 0;
        this._position = (0, $31054a6c69637582$exports).create();
        this._right = (0, $31054a6c69637582$exports).create();
        this._up = (0, $31054a6c69637582$exports).create();
        this._forward = (0, $31054a6c69637582$exports).create();
        this._modelPosition = (0, $31054a6c69637582$exports).create();
        this._manipulationOrigin = (0, $31054a6c69637582$exports).create();
        this._backgroundColor = (0, $4c4ac78b213a9c07$exports).fromValues(0, 0, 0, 1);
    }
    initialize(core) {
        super.initialize(core);
        this._hittables = [];
        this._lightBuffer = null;
        this._worldCreated = false;
        this._initializeAPI().then(()=>{
            this._initializeResources();
        });
    }
    _initializeAPI() {
        return $d5ed11dd11fe7749$var$__awaiter(this, void 0, void 0, function*() {
            try {
                const start = window.performance.now();
                const gpu = navigator.gpu;
                this._presentationFormat = gpu.getPreferredCanvasFormat();
                this._adapter = yield gpu.requestAdapter();
                const gpuDeviceDescriptor = {
                    requiredLimits: {
                        maxStorageBufferBindingSize: 134217728,
                        maxComputeWorkgroupsPerDimension: 256
                    }
                };
                this._device = yield this._adapter.requestDevice(gpuDeviceDescriptor);
                this._queue = this._device.queue;
                this._context = this._canvas.getContext("webgpu");
                this._core.log.write((0, $4a6417d29706362f$export$243e62d78d3b544d).info, `WebGPU API initialized ${Math.round(window.performance.now() - start)}ms`);
            } catch (e) {
                this._core.log.write((0, $4a6417d29706362f$export$243e62d78d3b544d).error, e);
                return false;
            }
            return true;
        });
    }
    _initializeResources() {
        const start = window.performance.now();
        const canvasConfig = {
            device: this._device,
            format: this._presentationFormat,
            alphaMode: "premultiplied"
        };
        this._context.configure(canvasConfig);
        const computeUniformBufferDescriptor = {
            label: "Compute uniform buffer",
            size: (0, $e1b604d7f27d3d8e$export$893bf7cc4a794b30).SIZE * 4,
            usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST
        };
        this._computeUniformBuffer = this._device.createBuffer(computeUniformBufferDescriptor);
        this._computeUniformBufferData = new (0, $e1b604d7f27d3d8e$export$893bf7cc4a794b30)();
        const depthMinMaxBufferDescriptor = {
            label: "Depth min max buffer",
            size: 8,
            usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC
        };
        this._depthMinMaxBuffer = this._device.createBuffer(depthMinMaxBufferDescriptor);
        const depthMinMaxBufferResultDescriptor = {
            label: "Depth min max result buffer",
            size: 8,
            usage: GPUBufferUsage.COPY_DST | GPUBufferUsage.MAP_READ
        };
        this._depthMinMaxResultBuffer = this._device.createBuffer(depthMinMaxBufferResultDescriptor);
        const fullscreenQuadUniformBufferDescriptor = {
            label: "Full screen quad uniform buffer",
            size: (0, $e354276e6b56108d$export$186ae5dce927ebd1).SIZE * 4,
            usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST
        };
        this._fullscreenQuadUniformBuffer = this._device.createBuffer(fullscreenQuadUniformBufferDescriptor);
        this._fullscreenQuadUniformBufferData = new (0, $e354276e6b56108d$export$186ae5dce927ebd1)();
        this._sampler = this._device.createSampler({
            label: "Sampler",
            magFilter: "linear",
            minFilter: "linear"
        });
        for(const key in this.fonts){
            const fontVisual = this.fonts[key];
            fontVisual.initializeContext(this._device);
            fontVisual.update();
        }
        for(let i = 0; i < this.images.length; i++){
            const image = this.images[i];
            image.initializeContext(this._device);
            image.update();
        }
        const textureSize = {
            width: 1,
            height: 1
        };
        const textureDescriptor = {
            label: "Placeholder texture",
            size: textureSize,
            format: this._presentationFormat,
            usage: GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.COPY_DST | GPUTextureUsage.RENDER_ATTACHMENT
        };
        this._texture = this._device.createTexture(textureDescriptor);
        this._core.log.write((0, $4a6417d29706362f$export$243e62d78d3b544d).info, `WebGPU resources initialized ${Math.round(window.performance.now() - start)}ms`);
        this._isInitialized = true;
    }
    get isSupported() {
        return navigator.gpu !== undefined;
    }
    _createWorld() {
        return $d5ed11dd11fe7749$var$__awaiter(this, void 0, void 0, function*() {
            const start = performance.now();
            this._hittables = this._getHittables();
            if (this._hittables.length == 0) return;
            const bvhAccel = new (0, $ee56e2b41e5e87b5$export$c191703b2daa3f18)(this._core, this._hittables, this._config.maxPrimsInNode, (0, $ee56e2b41e5e87b5$export$17e31acd02f2a1e).sah);
            const hittables = bvhAccel.orderedPrimitives;
            for(let i = 0; i < this.transitionBuffers.length; i++){
                const transitionBuffer = this.transitionBuffers[i];
                if (transitionBuffer.isVisible) {
                    const atlas = transitionBuffer.currentAtlas;
                    if (atlas.imageData) {
                        const imageData = atlas.imageData;
                        const textureSize = {
                            width: imageData.width,
                            height: imageData.height
                        };
                        yield createImageBitmap(imageData).then((imageBitmap)=>{
                            const textureDescriptor = {
                                label: "Atlas texture",
                                size: textureSize,
                                format: this._presentationFormat,
                                usage: GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.COPY_DST | GPUTextureUsage.RENDER_ATTACHMENT
                            };
                            this._atlasTexture = this._device.createTexture(textureDescriptor);
                            const imageCopyExternalImage = {
                                source: imageBitmap
                            };
                            const imageCopyTextureTagged = {
                                texture: this._atlasTexture
                            };
                            const copySize = {
                                width: imageData.width,
                                height: imageData.height
                            };
                            this._device.queue.copyExternalImageToTexture(imageCopyExternalImage, imageCopyTextureTagged, copySize);
                            this._core.log.write((0, $4a6417d29706362f$export$243e62d78d3b544d).info, `atlas texture updated ${Math.round(window.performance.now() - start)}ms`);
                        });
                        break;
                    }
                }
            }
            const materials = [];
            const materialIds = [];
            for(let i = 0; i < hittables.length; i++){
                const hittable = hittables[i];
                const material = hittable.material;
                let materialId;
                let found;
                for(let j = 0; j < materials.length; j++)if (materials[j] === material) {
                    found = true;
                    materialId = j;
                    break;
                }
                if (!found) {
                    materialId = materials.length;
                    materials.push(material);
                }
                materialIds.push(materialId);
            }
            const textures = [];
            const textureIds = [];
            for(let i = 0; i < materials.length; i++){
                const material = materials[i];
                const texture = material.texture;
                if (texture) {
                    let textureId;
                    let found;
                    for(let j = 0; j < textures.length; j++)if (textures[j] === texture) {
                        found = true;
                        textureId = j;
                        break;
                    }
                    if (!found) {
                        textureId = textures.length;
                        textures.push(texture);
                        if (texture instanceof (0, $6060da1e598714a9$export$3ad126b3fdb68b5e)) {
                            const imageData = texture.image;
                            if (imageData) {
                                let start = performance.now();
                                const imageDataLinear = new ImageData(imageData.width, imageData.height);
                                for(let i = 0; i < imageData.data.length; i++)imageDataLinear.data[i] = Math.pow(imageData.data[i] / 0xff, 2.2) * 0xff;
                                this._core.log.write((0, $4a6417d29706362f$export$243e62d78d3b544d).info, `image inverse gamma ${Math.round(window.performance.now() - start)}ms`);
                                start = window.performance.now();
                                const textureSize = {
                                    width: imageData.width,
                                    height: imageData.height
                                };
                                createImageBitmap(imageDataLinear).then((imageBitmap)=>{
                                    const textureDescriptor = {
                                        size: textureSize,
                                        format: 'rgba8unorm',
                                        usage: GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.COPY_DST | GPUTextureUsage.RENDER_ATTACHMENT
                                    };
                                    this._backgroundTexture = this._device.createTexture(textureDescriptor);
                                    const imageCopyExternalImage = {
                                        source: imageBitmap,
                                        flipY: true
                                    };
                                    const imageCopyTextureTagged = {
                                        texture: this._backgroundTexture
                                    };
                                    const copySize = {
                                        width: imageData.width,
                                        height: imageData.height
                                    };
                                    this._device.queue.copyExternalImageToTexture(imageCopyExternalImage, imageCopyTextureTagged, copySize);
                                    this._core.log.write((0, $4a6417d29706362f$export$243e62d78d3b544d).info, `background image updated ${Math.round(window.performance.now() - start)}ms`);
                                });
                            }
                        }
                    }
                    textureIds.push(textureId);
                } else textureIds.push(0);
            }
            const textureBufferSizeBytes = textures.length * (0, $6060da1e598714a9$export$6aa93a36bc90f68e).SIZE * 4;
            const textureBufferDescriptor = {
                label: "Texture buffer",
                size: textureBufferSizeBytes,
                usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST
            };
            this._textureBuffer = this._device.createBuffer(textureBufferDescriptor);
            this._textureBufferData = new (0, $6060da1e598714a9$export$6aa93a36bc90f68e)(textures.length);
            for(let i = 0; i < textures.length; i++)textures[i].toBuffer(this._textureBufferData, i);
            const materialBufferSizeBytes = materials.length * (0, $62116d012d21b949$export$673ddcc6bf213111).SIZE * 4;
            const materialBufferDescriptor = {
                label: "Material buffer",
                size: materialBufferSizeBytes,
                usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST
            };
            this._materialBuffer = this._device.createBuffer(materialBufferDescriptor);
            this._materialBufferData = new (0, $62116d012d21b949$export$673ddcc6bf213111)(materials.length);
            for(let i = 0; i < materials.length; i++)materials[i].toBuffer(this._materialBufferData, i, textureIds[i]);
            const hittableBufferSizeBytes = hittables.length * (0, $66964bfc3ddbcb4c$export$1337e9dd34ffc243).SIZE * 4;
            const hittableBufferDescriptor = {
                label: "Hittable buffer",
                size: hittableBufferSizeBytes,
                usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST
            };
            this._hittableBuffer = this._device.createBuffer(hittableBufferDescriptor);
            this._hittableBufferData = new (0, $66964bfc3ddbcb4c$export$1337e9dd34ffc243)(hittables.length);
            for(let i = 0; i < hittables.length; i++){
                const hittable = hittables[i];
                hittable.toBuffer(this._hittableBufferData, i, materialIds[i]);
            }
            const linearBVHNodes = bvhAccel.nodes;
            const linearBVHNodeBufferSizeBytes = linearBVHNodes.length * (0, $ee56e2b41e5e87b5$export$9e920ed4165673f5).SIZE * 4;
            const linearBVHNodeBufferDescriptor = {
                label: "Linear BVH node buffer",
                size: linearBVHNodeBufferSizeBytes,
                usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST
            };
            this._linearBVHNodeBuffer = this._device.createBuffer(linearBVHNodeBufferDescriptor);
            this._linearBVHNodeBufferData = new (0, $ee56e2b41e5e87b5$export$9e920ed4165673f5)(linearBVHNodes.length);
            for(let i = 0; i < linearBVHNodes.length; i++)linearBVHNodes[i].toBuffer(this._linearBVHNodeBufferData, i);
            this._device.queue.writeBuffer(this._hittableBuffer, 0, this._hittableBufferData.buffer, this._hittableBufferData.byteOffset, this._hittableBufferData.byteLength);
            this._device.queue.writeBuffer(this._materialBuffer, 0, this._materialBufferData.buffer, this._materialBufferData.byteOffset, this._materialBufferData.byteLength);
            this._device.queue.writeBuffer(this._textureBuffer, 0, this._textureBufferData.buffer, this._textureBufferData.byteOffset, this._textureBufferData.byteLength);
            this._device.queue.writeBuffer(this._linearBVHNodeBuffer, 0, this._linearBVHNodeBufferData.buffer, this._linearBVHNodeBufferData.byteOffset, this._linearBVHNodeBufferData.byteLength);
            this._core.log.write((0, $4a6417d29706362f$export$243e62d78d3b544d).info, `create world ${Math.round(window.performance.now() - start)}ms`);
        });
    }
    _createLights() {
        if (!this._lights || this._lights.length == 0) return;
        const modelScale = this._core.getModelScale();
        (0, $31054a6c69637582$exports).set(this._modelPosition, this.mMatrix[12], this.mMatrix[13], this.mMatrix[14]);
        if (!this._lightBuffer) {
            const lightBufferSizeBytes = this._lights.length * (0, $1596feb7c9451159$export$82650fd3490ceb3f).SIZE * 4;
            const lightBufferDescriptor = {
                label: "Light buffer",
                size: lightBufferSizeBytes,
                usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST
            };
            this._lightBuffer = this._device.createBuffer(lightBufferDescriptor);
            this._lightBufferData = new (0, $1596feb7c9451159$export$82650fd3490ceb3f)(this._lights.length);
        }
        for(let i = 0; i < this._lights.length; i++){
            const light = this._lights[i];
            let lightCopy;
            if (light instanceof (0, $1596feb7c9451159$export$1f9284d52f5c21ca)) lightCopy = new (0, $1596feb7c9451159$export$1f9284d52f5c21ca)({
                center: (0, $31054a6c69637582$exports).clone(light.center),
                color: (0, $31054a6c69637582$exports).clone(light.color),
                rotation: (0, $39ece26d1239bb77$exports).clone(light.rotation),
                size: (0, $91b0cc4981465964$exports).fromValues(light.size[0] * modelScale, light.size[1] * modelScale)
            });
            else if (light instanceof (0, $1596feb7c9451159$export$f6705b6c922d7219)) lightCopy = new (0, $1596feb7c9451159$export$f6705b6c922d7219)({
                center: (0, $31054a6c69637582$exports).clone(light.center),
                color: (0, $31054a6c69637582$exports).clone(light.color),
                radius: light.radius * modelScale
            });
            (0, $31054a6c69637582$exports).scale(lightCopy.center, lightCopy.center, modelScale);
            (0, $31054a6c69637582$exports).add(lightCopy.center, lightCopy.center, this._modelPosition);
            lightCopy.toBuffer(this._lightBufferData, i);
        }
        this._device.queue.writeBuffer(this._lightBuffer, 0, this._lightBufferData.buffer, this._lightBufferData.byteOffset, this._lightBufferData.byteLength);
        this._areLightsInitialized = true;
    }
    standardLighting(lights) {
        lights || (lights = this._config.standardLightingOptions());
        const rectLights = [];
        for(let i = 0; i < lights.length; i++){
            const light = lights[i];
            const center = (0, $31054a6c69637582$exports).create();
            const rotation = (0, $39ece26d1239bb77$exports).create();
            const azimuth = (0, $a49c65c28e06311e$export$210d3b2db589eb5c).degreesToRadians(light.azimuth);
            const altitude = (0, $a49c65c28e06311e$export$210d3b2db589eb5c).degreesToRadians(-light.altitude);
            (0, $39ece26d1239bb77$exports).rotateY(rotation, (0, $d4d7bd6cc65a5081$export$a002182e51710d39).QUAT_IDENTITY, azimuth);
            (0, $39ece26d1239bb77$exports).rotateX(rotation, rotation, altitude);
            (0, $31054a6c69637582$exports).transformQuat(center, (0, $d4d7bd6cc65a5081$export$a002182e51710d39).VECTOR3_UNITZ, rotation);
            (0, $31054a6c69637582$exports).scale(center, center, light.distance);
            const yaw = (0, $a49c65c28e06311e$export$210d3b2db589eb5c).degreesToRadians(light.yaw);
            const pitch = (0, $a49c65c28e06311e$export$210d3b2db589eb5c).degreesToRadians(-light.altitude);
            (0, $39ece26d1239bb77$exports).rotateY(rotation, (0, $d4d7bd6cc65a5081$export$a002182e51710d39).QUAT_IDENTITY, yaw);
            (0, $39ece26d1239bb77$exports).rotateX(rotation, rotation, pitch);
            rectLights.push(new (0, $1596feb7c9451159$export$1f9284d52f5c21ca)({
                center: center,
                rotation: rotation,
                size: light.size,
                color: light.color
            }));
        }
        return rectLights;
    }
    _getHittables() {
        const hittables = [];
        let minY = Number.MAX_VALUE;
        for(let i = 0; i < this.transitionBuffers.length; i++){
            const transitionBuffer = this.transitionBuffers[i];
            if (transitionBuffer.isVisible && transitionBuffer.hittables && transitionBuffer.hittables.length > 0) {
                minY = Math.min(minY, transitionBuffer.minY);
                for(let j = 0; j < transitionBuffer.hittables.length; j++)hittables.push(transitionBuffer.hittables[j]);
            }
        }
        if (this.labelSets && this.labelSets.length > 0) for(let i = 0; i < this.labelSets.length; i++){
            const labelSet = this.labelSets[i];
            if (labelSet.hittables) for(let j = 0; j < labelSet.hittables.length; j++)hittables.push(labelSet.hittables[j]);
        }
        if (this.images && this.images.length > 0) {
            for(let i = 0; i < this.images.length; i++)if (this.images[i].hittable) {
                const hittable = this.images[i].hittable;
                hittables.push(hittable);
                minY = Math.min(hittable.bounds.min[1], minY);
            }
        }
        if (this.ground) {
            const modelPosition = (0, $31054a6c69637582$exports).create();
            const modelScale = this._core.getModelScale();
            const modelRotation = (0, $39ece26d1239bb77$exports).create();
            this._core.getModelRotation(modelRotation);
            (0, $31054a6c69637582$exports).set(modelPosition, this.mMatrix[12], this.mMatrix[13], this.mMatrix[14]);
            const groundSize = (0, $91b0cc4981465964$exports).create();
            const groundPosition = (0, $31054a6c69637582$exports).create();
            (0, $91b0cc4981465964$exports).scale(groundSize, this.ground.size || this._config.groundSize, modelScale);
            if (this.ground.position) (0, $31054a6c69637582$exports).scale(groundPosition, this.ground.position, modelScale);
            else (0, $31054a6c69637582$exports).set(groundPosition, 0, minY - (0, $ca7af8634961ee25$export$a002182e51710d39).SHADOW_OFFSET, 0);
            const options = {
                size0: groundSize,
                size1: groundSize,
                center0: groundPosition,
                center1: groundPosition,
                time0: 1,
                time1: 1,
                texCoord0: (0, $91b0cc4981465964$exports).fromValues(0, 0),
                texCoord1: (0, $91b0cc4981465964$exports).fromValues(1, 1),
                material: this.ground.material || this.config.defaultMaterial
            };
            (0, $31054a6c69637582$exports).add(options.center0, options.center0, modelPosition);
            hittables.push(new (0, $66964bfc3ddbcb4c$export$57071e021ef37bbb)(options));
        }
        return hittables;
    }
    createFontVisual(font) {
        const visual = new (0, $70798b808a7c0587$export$e784a6eab4d2d700)(this._core, font);
        if (this._isInitialized) visual.initializeContext(this._device);
        visual.hasChangedCallback = ()=>{
            this._hasWorldChanged = true;
        };
        return visual;
    }
    createImageVisual(image) {
        const visual = new (0, $18e0078d8611e105$export$6f251cd327b2ff1)(this._core, this, image);
        if (this._isInitialized) visual.initializeContext(this._device);
        visual.hasChangedCallback = ()=>{
            this._hasWorldChanged = true;
        };
        return visual;
    }
    createLabelSetVisual(labelSet) {
        const visual = new (0, $b084cfc4223cd4fe$export$97e93e7019ef67b9)(this._core, this, labelSet);
        visual.hasChangedCallback = ()=>{
            this._hasWorldChanged = true;
        };
        return visual;
    }
    createTransitionBuffer(ids) {
        const transitionBuffer = new (0, $93345e9ee93b28fb$export$76de936b3c1c4170)(this._core, this, ids);
        transitionBuffer.hasChangedCallback = ()=>{
            this._hasWorldChanged = true;
        };
        return transitionBuffer;
    }
    _resizeBackings() {
        const width = this.width;
        const height = this.height;
        const colorChannels = 3;
        const outputColorBufferSizeBytes = Uint32Array.BYTES_PER_ELEMENT * width * height * colorChannels;
        const outputColorBufferDescriptor = {
            label: "Output color buffer",
            size: outputColorBufferSizeBytes,
            usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC
        };
        const outputColorBuffer = this._device.createBuffer(outputColorBufferDescriptor);
        const outputNormalDepthBufferSizeBytes = Uint32Array.BYTES_PER_ELEMENT * width * height * 4;
        const outputDepthBufferDescriptor = {
            label: "Output normal depth buffer",
            size: outputNormalDepthBufferSizeBytes,
            usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC
        };
        const outputNormalDepthBuffer = this._device.createBuffer(outputDepthBufferDescriptor);
        const computeShaderModuleDescriptor = {
            code: (0, $e1b604d7f27d3d8e$export$7173403786dbea8d)
        };
        const computeModule = this._device.createShaderModule(computeShaderModuleDescriptor);
        const computeBindGroupLayoutDescriptor = {
            entries: [
                {
                    binding: 0,
                    visibility: GPUShaderStage.COMPUTE,
                    buffer: {
                        type: "storage"
                    }
                },
                {
                    binding: 1,
                    visibility: GPUShaderStage.COMPUTE,
                    buffer: {
                        type: "uniform"
                    }
                },
                {
                    binding: 2,
                    visibility: GPUShaderStage.COMPUTE,
                    buffer: {
                        type: "read-only-storage"
                    }
                },
                {
                    binding: 3,
                    visibility: GPUShaderStage.COMPUTE,
                    buffer: {
                        type: "read-only-storage"
                    }
                },
                {
                    binding: 4,
                    visibility: GPUShaderStage.COMPUTE,
                    buffer: {
                        type: "read-only-storage"
                    }
                },
                {
                    binding: 5,
                    visibility: GPUShaderStage.COMPUTE,
                    buffer: {
                        type: "read-only-storage"
                    }
                },
                {
                    binding: 6,
                    visibility: GPUShaderStage.COMPUTE,
                    buffer: {
                        type: "read-only-storage"
                    }
                },
                {
                    binding: 7,
                    visibility: GPUShaderStage.COMPUTE,
                    sampler: {
                        type: "filtering"
                    }
                },
                {
                    binding: 8,
                    visibility: GPUShaderStage.COMPUTE,
                    texture: {
                        multisampled: false,
                        sampleType: "float",
                        viewDimension: "2d"
                    }
                },
                {
                    binding: 9,
                    visibility: GPUShaderStage.COMPUTE,
                    texture: {
                        multisampled: false,
                        sampleType: "float",
                        viewDimension: "2d"
                    }
                },
                {
                    binding: 10,
                    visibility: GPUShaderStage.COMPUTE,
                    texture: {
                        multisampled: false,
                        sampleType: "float",
                        viewDimension: "2d"
                    }
                },
                {
                    binding: 11,
                    visibility: GPUShaderStage.COMPUTE,
                    buffer: {
                        type: "storage"
                    }
                },
                {
                    binding: 12,
                    visibility: GPUShaderStage.COMPUTE,
                    buffer: {
                        type: "storage"
                    }
                }
            ]
        };
        const computeBindGroupLayout = this._device.createBindGroupLayout(computeBindGroupLayoutDescriptor);
        const computeBindGroupDescriptor = {
            label: "Compute bind group descriptor",
            layout: computeBindGroupLayout,
            entries: [
                {
                    binding: 0,
                    resource: {
                        buffer: outputColorBuffer
                    }
                },
                {
                    binding: 1,
                    resource: {
                        buffer: this._computeUniformBuffer
                    }
                },
                {
                    binding: 2,
                    resource: {
                        buffer: this._hittableBuffer
                    }
                },
                {
                    binding: 3,
                    resource: {
                        buffer: this._materialBuffer
                    }
                },
                {
                    binding: 4,
                    resource: {
                        buffer: this._textureBuffer
                    }
                },
                {
                    binding: 5,
                    resource: {
                        buffer: this._lightBuffer
                    }
                },
                {
                    binding: 6,
                    resource: {
                        buffer: this._linearBVHNodeBuffer
                    }
                },
                {
                    binding: 7,
                    resource: this._sampler
                },
                {
                    binding: 8,
                    resource: (this.fonts[this._core.font.name].texture || this._texture).createView()
                },
                {
                    binding: 9,
                    resource: (this._backgroundTexture || this._texture).createView()
                },
                {
                    binding: 10,
                    resource: (this._atlasTexture || this._texture).createView()
                },
                {
                    binding: 11,
                    resource: {
                        buffer: outputNormalDepthBuffer
                    }
                },
                {
                    binding: 12,
                    resource: {
                        buffer: this._depthMinMaxBuffer
                    }
                }
            ]
        };
        this._computeBindGroup = this._device.createBindGroup(computeBindGroupDescriptor);
        const computePipelineLayoutDescriptor = {
            label: "Compute pipeline layout descriptor",
            bindGroupLayouts: [
                computeBindGroupLayout
            ]
        };
        const computePipelineLayout = this._device.createPipelineLayout(computePipelineLayoutDescriptor);
        const compute = {
            module: computeModule,
            entryPoint: "main"
        };
        const computePipelineDescriptor = {
            label: "Compute pipeline descriptor",
            layout: computePipelineLayout,
            compute: compute
        };
        this._computePipeline = this._device.createComputePipeline(computePipelineDescriptor);
        const computeDepthNormal = {
            module: computeModule,
            entryPoint: "depthNormal"
        };
        const computeDepthNormalPipelineDescriptor = {
            label: "Depth normal pipeline descriptor",
            layout: computePipelineLayout,
            compute: computeDepthNormal
        };
        this._computeDepthNormalPipeline = this._device.createComputePipeline(computeDepthNormalPipelineDescriptor);
        const computeSegment = {
            module: computeModule,
            entryPoint: "segment"
        };
        const computeSegmentPipelineDescriptor = {
            label: "Segment pipeline descriptor",
            layout: computePipelineLayout,
            compute: computeSegment
        };
        this._computeSegmentPipeline = this._device.createComputePipeline(computeSegmentPipelineDescriptor);
        const clearBindGroupLayoutDescriptor = {
            label: "Clear bind group layout descriptor",
            entries: [
                {
                    binding: 0,
                    visibility: GPUShaderStage.COMPUTE,
                    buffer: {
                        type: "storage"
                    }
                },
                {
                    binding: 11,
                    visibility: GPUShaderStage.COMPUTE,
                    buffer: {
                        type: "storage"
                    }
                },
                {
                    binding: 12,
                    visibility: GPUShaderStage.COMPUTE,
                    buffer: {
                        type: "storage"
                    }
                }
            ]
        };
        const clearBindGroupLayout = this._device.createBindGroupLayout(clearBindGroupLayoutDescriptor);
        const clearBindGroupDescriptor = {
            label: "Clear bind group descriptor",
            layout: clearBindGroupLayout,
            entries: [
                {
                    binding: 0,
                    resource: {
                        buffer: outputColorBuffer
                    }
                },
                {
                    binding: 11,
                    resource: {
                        buffer: outputNormalDepthBuffer
                    }
                },
                {
                    binding: 12,
                    resource: {
                        buffer: this._depthMinMaxBuffer
                    }
                }
            ]
        };
        this._clearBindGroup = this._device.createBindGroup(clearBindGroupDescriptor);
        const clearPipelineLayoutDescriptor = {
            label: "Clear pipeline layout descriptor",
            bindGroupLayouts: [
                clearBindGroupLayout
            ]
        };
        const clearPipelineLayout = this._device.createPipelineLayout(clearPipelineLayoutDescriptor);
        const clear = {
            module: computeModule,
            entryPoint: "clear"
        };
        const clearPipelineDescriptor = {
            label: "Clear pipeline descriptor",
            layout: clearPipelineLayout,
            compute: clear
        };
        this._clearPipeline = this._device.createComputePipeline(clearPipelineDescriptor);
        const fullscreenQuadShaderDescriptor = {
            label: "Fullscreen quad shader descriptor",
            code: (0, $e354276e6b56108d$export$739cc3561e95931b)
        };
        const fullscreenQuadModule = this._device.createShaderModule(fullscreenQuadShaderDescriptor);
        const fullscreenQuadBindGroupLayoutDescriptor = {
            label: "Fullscreen quad bind group layout descriptor",
            entries: [
                {
                    binding: 0,
                    visibility: GPUShaderStage.FRAGMENT,
                    buffer: {
                        type: "uniform"
                    }
                },
                {
                    binding: 1,
                    visibility: GPUShaderStage.FRAGMENT,
                    buffer: {
                        type: "read-only-storage"
                    }
                },
                {
                    binding: 2,
                    visibility: GPUShaderStage.FRAGMENT,
                    buffer: {
                        type: "read-only-storage"
                    }
                }
            ]
        };
        const fullscreenQuadBindGroupLayout = this._device.createBindGroupLayout(fullscreenQuadBindGroupLayoutDescriptor);
        const fullscreenQuadPipelineLayoutDescriptor = {
            label: "Fullscreen quad pipeline layout descriptor",
            bindGroupLayouts: [
                fullscreenQuadBindGroupLayout
            ]
        };
        const fullscreenQuadPipelineLayout = this._device.createPipelineLayout(fullscreenQuadPipelineLayoutDescriptor);
        const vertex = {
            module: fullscreenQuadModule,
            entryPoint: "vert_main"
        };
        const primitive = {
            topology: "triangle-list"
        };
        const colorState = {
            format: this._presentationFormat
        };
        const fragment = {
            module: fullscreenQuadModule,
            entryPoint: "frag_main",
            targets: [
                colorState
            ]
        };
        const fullscreenQuadPiplelineDescriptor = {
            label: "Fullscreen quad pipeline descriptor",
            layout: fullscreenQuadPipelineLayout,
            vertex: vertex,
            fragment: fragment,
            primitive: primitive
        };
        this._fullscreenQuadPipeline = this._device.createRenderPipeline(fullscreenQuadPiplelineDescriptor);
        const fullscreenQuadBindGroupDescriptor = {
            label: "Fullscreen quad bind group descriptor",
            layout: fullscreenQuadBindGroupLayout,
            entries: [
                {
                    binding: 0,
                    resource: {
                        buffer: this._fullscreenQuadUniformBuffer
                    }
                },
                {
                    binding: 1,
                    resource: {
                        buffer: outputColorBuffer
                    }
                },
                {
                    binding: 2,
                    resource: {
                        buffer: outputNormalDepthBuffer
                    }
                }
            ]
        };
        this._fullscreenQuadBindGroup = this._device.createBindGroup(fullscreenQuadBindGroupDescriptor);
        const fragmentHdr = {
            module: fullscreenQuadModule,
            entryPoint: "frag_main_hdr",
            targets: [
                colorState
            ]
        };
        const fullscreenQuadHdrPiplelineDescriptor = {
            label: "Fullscreen quad HDR pipeline descriptor",
            layout: fullscreenQuadPipelineLayout,
            vertex: vertex,
            fragment: fragmentHdr,
            primitive: primitive
        };
        this._fullscreenQuadHdrPipeline = this._device.createRenderPipeline(fullscreenQuadHdrPiplelineDescriptor);
        const fragmentDepth = {
            module: fullscreenQuadModule,
            entryPoint: "frag_depth",
            targets: [
                colorState
            ]
        };
        const fullscreenQuadDepthPiplelineDescriptor = {
            label: "Fullscreen quad depth pipeline descriptor",
            layout: fullscreenQuadPipelineLayout,
            vertex: vertex,
            fragment: fragmentDepth,
            primitive: primitive
        };
        this._fullscreenQuadDepthPipeline = this._device.createRenderPipeline(fullscreenQuadDepthPiplelineDescriptor);
        const fragmentNormal = {
            module: fullscreenQuadModule,
            entryPoint: "frag_normal",
            targets: [
                colorState
            ]
        };
        const fullscreenQuadNormalPiplelineDescriptor = {
            label: "Fullscreen quad normal pipeline descriptor",
            layout: fullscreenQuadPipelineLayout,
            vertex: vertex,
            fragment: fragmentNormal,
            primitive: primitive
        };
        this._fullscreenQuadNormalPipeline = this._device.createRenderPipeline(fullscreenQuadNormalPiplelineDescriptor);
        const fragmentEdge = {
            module: fullscreenQuadModule,
            entryPoint: "frag_edge",
            targets: [
                colorState
            ]
        };
        const fullscreenQuadEdgePiplelineDescriptor = {
            label: "Fullscreen quad edge pipeline descriptor",
            layout: fullscreenQuadPipelineLayout,
            vertex: vertex,
            fragment: fragmentEdge,
            primitive: primitive
        };
        this._fullscreenQuadEdgePipeline = this._device.createRenderPipeline(fullscreenQuadEdgePiplelineDescriptor);
        const fragmentSegment = {
            module: fullscreenQuadModule,
            entryPoint: "frag_segment",
            targets: [
                colorState
            ]
        };
        const fullscreenQuadSegmentPiplelineDescriptor = {
            label: "Fullscreen quad segment pipeline descriptor",
            layout: fullscreenQuadPipelineLayout,
            vertex: vertex,
            fragment: fragmentSegment,
            primitive: primitive
        };
        this._fullscreenQuadSegmentPipeline = this._device.createRenderPipeline(fullscreenQuadSegmentPiplelineDescriptor);
        this._computeUniformBufferData.setWidth(width);
        this._computeUniformBufferData.setHeight(height);
        this._fullscreenQuadUniformBufferData.setWidth(width);
        this._fullscreenQuadUniformBufferData.setHeight(height);
        this._computeUniformBufferData.setTime0(0);
        this._computeUniformBufferData.setTime1(1);
        this._computeDispatchCount = Math.min(Math.ceil(width * height / 256), this._device.limits.maxComputeWorkgroupsPerDimension);
        this._frameCount = 0;
        this._core.log.write((0, $4a6417d29706362f$export$243e62d78d3b544d).info, "backings resized");
    }
    update(elapsedTime) {
        super.update(elapsedTime);
        for(let i = 0; i < this.transitionBuffers.length; i++){
            const transitionBuffer = this.transitionBuffers[i];
            if (transitionBuffer.isVisible) {
                const time0 = this._core.renderer.transitionTime;
                const time1 = Math.min(time0 + this._config.shutterSpeed, 1);
                transitionBuffer.time0 = time0;
                transitionBuffer.time1 = time1;
                transitionBuffer.duration = this._core.config.transitionDuration;
                transitionBuffer.stagger = this._core.config.transitionStaggering;
                transitionBuffer.update();
            }
        }
        if (this._haveLightsChanged || !this._lightBuffer) {
            this._haveLightsChanged = false;
            this._createLights();
        }
        if (this._hasWorldChanged) {
            this._hasWorldChanged = false;
            this._createWorld().then(()=>{
                if (this._hittables.length > 0) {
                    this._resizeBackings();
                    this._worldCreated = true;
                }
            });
        }
        if (this._core.config.isDebugVisible) this._core.debugText.addLine(`frm tot  ${this._frameCount}`);
    }
    render(elapsedTime) {
        return $d5ed11dd11fe7749$var$__awaiter(this, void 0, void 0, function*() {
            if (!this._worldCreated || !this._areLightsInitialized || this._hittables.length == 0) return;
            const epsilon = 0.000001;
            if (Math.abs(this._computeUniformBufferData.getFieldOfView() - this._core.config.fov) > epsilon) {
                this._frameCount = 0;
                this._computeUniformBufferData.setFieldOfView(this._core.config.fov);
            }
            if (Math.abs(this._computeUniformBufferData.getAperture() - this._config.aperture) > epsilon) {
                this._frameCount = 0;
                this._computeUniformBufferData.setAperture(this._config.aperture);
            }
            const m = this.inverseVMatrices[0];
            this._computeUniformBufferData.getPosition(this._position);
            this._computeUniformBufferData.getRight(this._right);
            this._computeUniformBufferData.getUp(this._up);
            this._computeUniformBufferData.getForward(this._forward);
            if (Math.abs(this._position[0] - m[12]) > epsilon || Math.abs(this._position[1] - m[13]) > epsilon || Math.abs(this._position[2] - m[14]) > epsilon || Math.abs(this._right[0] - m[0]) > epsilon || Math.abs(this._right[1] - m[1]) > epsilon || Math.abs(this._right[2] - m[2]) > epsilon || Math.abs(this._up[0] - m[4]) > epsilon || Math.abs(this._up[1] - m[5]) > epsilon || Math.abs(this._up[2] - m[6]) > epsilon || Math.abs(this._forward[0] - m[8]) > epsilon || Math.abs(this._forward[1] - m[9]) > epsilon || Math.abs(this._forward[2] - m[10]) > epsilon) {
                this._frameCount = 0;
                (0, $31054a6c69637582$exports).set(this._position, m[12], m[13], m[14]);
                (0, $31054a6c69637582$exports).set(this._right, m[0], m[1], m[2]);
                (0, $31054a6c69637582$exports).set(this._up, m[4], m[5], m[6]);
                (0, $31054a6c69637582$exports).set(this._forward, m[8], m[9], m[10]);
                this._computeUniformBufferData.setPosition(this._position);
                this._computeUniformBufferData.setRight(this._right);
                this._computeUniformBufferData.setUp(this._up);
                this._computeUniformBufferData.setForward(this._forward);
                this._core.getModelPosition(this._modelPosition);
                this._core.getModelManipulationOrigin(this._manipulationOrigin);
                (0, $31054a6c69637582$exports).add(this._modelPosition, this._modelPosition, this._manipulationOrigin);
                this._computeUniformBufferData.setLookAt(this._modelPosition);
            }
            this._computeUniformBufferData.getBackgroundColor(this._backgroundColor);
            if (!(0, $4c4ac78b213a9c07$exports).equals(this._backgroundColor, this._config.backgroundColor)) {
                this._frameCount = 0;
                this._computeUniformBufferData.setBackgroundColor(this._config.backgroundColor);
            }
            this._tilesX = this._computeUniformBufferData.getTilesX();
            this._tilesY = this._computeUniformBufferData.getTilesY();
            this._tileOffsetX = this._computeUniformBufferData.getTileOffsetX();
            this._tileOffsetY = this._computeUniformBufferData.getTileOffsetY();
            if (this._tilesX != this._core.config.tilesX || this._tilesY != this._core.config.tilesY || this._tileOffsetX != this._core.config.tileOffsetX || this._tileOffsetY != this._core.config.tileOffsetY) {
                this._frameCount = 0;
                this._computeUniformBufferData.setTilesX(this._core.config.tilesX);
                this._computeUniformBufferData.setTilesY(this._core.config.tilesY);
                this._computeUniformBufferData.setTileOffsetX(this._core.config.tileOffsetX);
                this._computeUniformBufferData.setTileOffsetY(this._core.config.tileOffsetY);
            }
            const clear = this._frameCount == 0;
            if (clear) {
                this._duration = 0;
                this._startTime = performance.now();
            }
            if (this._frameCount >= this._config.maxSamplesPerPixel) {
                this._core.stop();
                return;
            }
            const raysPerFrame = this._config.raysPerFrame;
            this._computeUniformBufferData.setRaysPerFrame(raysPerFrame);
            this._computeUniformBufferData.setSeed(this._core.totalFrames * raysPerFrame);
            this._device.queue.writeBuffer(this._computeUniformBuffer, 0, this._computeUniformBufferData.buffer, this._computeUniformBufferData.byteOffset, this._computeUniformBufferData.byteLength);
            this._frameCount += raysPerFrame;
            this._fullscreenQuadUniformBufferData.setSamplesPerPixel(this._frameCount);
            this._fullscreenQuadUniformBufferData.setExposure(this._config.exposure);
            this._fullscreenQuadUniformBufferData.setMinDepth(this._config.minDepth);
            this._fullscreenQuadUniformBufferData.setMaxDepth(this._config.maxDepth);
            this._fullscreenQuadUniformBufferData.setEdgeDepth(this._config.edgeDepth);
            this._fullscreenQuadUniformBufferData.setEdgeNormal(this._config.edgeNormal);
            this._device.queue.writeBuffer(this._fullscreenQuadUniformBuffer, 0, this._fullscreenQuadUniformBufferData.buffer, this._fullscreenQuadUniformBufferData.byteOffset, this._fullscreenQuadUniformBufferData.byteLength);
            yield this._encodeCommands(clear);
            this._duration = performance.now() - this._startTime;
        });
    }
    clear() {
        this._frameCount = 0;
    }
    _encodeCommands(clear) {
        return $d5ed11dd11fe7749$var$__awaiter(this, void 0, void 0, function*() {
            const commandEncoder = this._device.createCommandEncoder();
            const computePassEncoder = commandEncoder.beginComputePass();
            if (clear) {
                computePassEncoder.setPipeline(this._clearPipeline);
                computePassEncoder.setBindGroup(0, this._clearBindGroup);
                computePassEncoder.dispatchWorkgroups(this._computeDispatchCount, 1, 1);
            }
            switch(this._core.config.renderMode){
                case (0, $4a6417d29706362f$export$2386c8c1d9db2d57).color:
                case (0, $4a6417d29706362f$export$2386c8c1d9db2d57).hdr:
                    computePassEncoder.setPipeline(this._computePipeline);
                    computePassEncoder.setBindGroup(0, this._computeBindGroup);
                    computePassEncoder.dispatchWorkgroups(this._computeDispatchCount, 1, 1);
                    computePassEncoder.end();
                    break;
                case (0, $4a6417d29706362f$export$2386c8c1d9db2d57).depth:
                case (0, $4a6417d29706362f$export$2386c8c1d9db2d57).normal:
                    computePassEncoder.setPipeline(this._computeDepthNormalPipeline);
                    computePassEncoder.setBindGroup(0, this._computeBindGroup);
                    computePassEncoder.dispatchWorkgroups(this._computeDispatchCount, 1, 1);
                    computePassEncoder.end();
                    commandEncoder.copyBufferToBuffer(this._depthMinMaxBuffer, 0, this._depthMinMaxResultBuffer, 0, this._depthMinMaxResultBuffer.size);
                    if (this._config.autoDepth) {
                        yield this._depthMinMaxResultBuffer.mapAsync(GPUMapMode.READ);
                        const depthMinMax = new Uint32Array(this._depthMinMaxResultBuffer.getMappedRange());
                        const depthMin = depthMinMax[0] / 1000;
                        const depthMax = depthMinMax[1] / 1000;
                        if (this._config.minDepth != depthMin || this._config.maxDepth != depthMax) console.log('depthMinMax', depthMin, depthMax);
                        this._config.minDepth = depthMin;
                        this._config.maxDepth = depthMax;
                        this._depthMinMaxResultBuffer.unmap();
                    }
                    break;
                case (0, $4a6417d29706362f$export$2386c8c1d9db2d57).edge:
                case (0, $4a6417d29706362f$export$2386c8c1d9db2d57).segment:
                    computePassEncoder.setPipeline(this._computeSegmentPipeline);
                    computePassEncoder.setBindGroup(0, this._computeBindGroup);
                    computePassEncoder.dispatchWorkgroups(this._computeDispatchCount, 1, 1);
                    computePassEncoder.end();
                    break;
            }
            const colorAttachment = {
                view: this._context.getCurrentTexture().createView(),
                clearValue: {
                    r: 0.0,
                    g: 0.0,
                    b: 0.0,
                    a: 0.0
                },
                loadOp: "clear",
                storeOp: "store"
            };
            const fullscreenQuadRenderPassDescriptor = {
                colorAttachments: [
                    colorAttachment
                ]
            };
            const renderPassEncoder = commandEncoder.beginRenderPass(fullscreenQuadRenderPassDescriptor);
            switch(this._core.config.renderMode){
                case (0, $4a6417d29706362f$export$2386c8c1d9db2d57).color:
                    renderPassEncoder.setPipeline(this._fullscreenQuadPipeline);
                    break;
                case (0, $4a6417d29706362f$export$2386c8c1d9db2d57).hdr:
                    renderPassEncoder.setPipeline(this._fullscreenQuadHdrPipeline);
                    break;
                case (0, $4a6417d29706362f$export$2386c8c1d9db2d57).depth:
                    renderPassEncoder.setPipeline(this._fullscreenQuadDepthPipeline);
                    break;
                case (0, $4a6417d29706362f$export$2386c8c1d9db2d57).normal:
                    renderPassEncoder.setPipeline(this._fullscreenQuadNormalPipeline);
                    break;
                case (0, $4a6417d29706362f$export$2386c8c1d9db2d57).edge:
                    renderPassEncoder.setPipeline(this._fullscreenQuadEdgePipeline);
                    break;
                case (0, $4a6417d29706362f$export$2386c8c1d9db2d57).segment:
                    renderPassEncoder.setPipeline(this._fullscreenQuadSegmentPipeline);
                    break;
            }
            renderPassEncoder.setBindGroup(0, this._fullscreenQuadBindGroup);
            renderPassEncoder.draw(6, 1, 0, 0);
            renderPassEncoder.end();
            this._queue.submit([
                commandEncoder.finish()
            ]);
        });
    }
    _resize(width, height) {
        super._resize(width, height);
        if (this._isInitialized && this._hittables.length > 0) {
            this._resizeBackings();
            this._core.log.write((0, $4a6417d29706362f$export$243e62d78d3b544d).info, `buffers resized ${width},${height}`);
        }
    }
}





class $6fc486c90d5a34f3$export$c6957adcf93c393f {
    constructor(options){
        if (options) {
            this.position = options.position;
            this.size = options.size;
            this.material = options.material;
        }
    }
}







/*!
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 */ 



/*!
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 */ 

/*!
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 */ 


class $1c0006f54d34984f$export$647e10fa8ac00c88 extends (0, $ec7cf7ba687c1511$export$c755714d282122f0) {
    getTwist(value) {
        (0, $39ece26d1239bb77$exports).copy(value, this._cameraRotation);
    }
    setTwist(value, isSmooth) {
        (0, $39ece26d1239bb77$exports).copy(this._cameraRotation, value);
        if (!isSmooth) (0, $39ece26d1239bb77$exports).copy(this._smoothedCameraRotation, value);
    }
    twist(angle, x, y) {
        this.unproject(this._vec3, x, y, 1);
        (0, $31054a6c69637582$exports).normalize(this._vec3, this._vec3);
        (0, $31054a6c69637582$exports).transformQuat(this._vec3, this._vec3, this._orbitRotation);
        this._twist(this._vec3, angle);
    }
    _twist(axis, angle) {
        (0, $39ece26d1239bb77$exports).setAxisAngle(this._quat, axis, angle);
        (0, $39ece26d1239bb77$exports).multiply(this._cameraRotation, this._quat, this._cameraRotation);
    }
    rotate(translationDelta) {
        (0, $31054a6c69637582$exports).set(this._vec3, translationDelta[1], translationDelta[0], 0);
        const length = (0, $31054a6c69637582$exports).length(this._vec3);
        const angle = length * (0, $d4d7bd6cc65a5081$export$a002182e51710d39).PI / Math.min(this.width, this.height);
        (0, $31054a6c69637582$exports).scale(this._vec3, this._vec3, 1 / length);
        (0, $39ece26d1239bb77$exports).setAxisAngle(this._quat, this._vec3, angle);
        (0, $39ece26d1239bb77$exports).multiply(this._orbitRotation, this._quat, this._orbitRotation);
    }
}










var $c5578f8838abba3d$exports = {};

$parcel$export($c5578f8838abba3d$exports, "addDiv", () => $99b4426d930847de$export$6758c6c7563dc60e);
$parcel$export($c5578f8838abba3d$exports, "addEl", () => $99b4426d930847de$export$3ca29736d56b698a);
$parcel$export($c5578f8838abba3d$exports, "allTruthy", () => $8abd7176cef66691$export$84af6d08e329f176);
$parcel$export($c5578f8838abba3d$exports, "clone", () => $97d77b6293df43c2$export$9cd59f9826255e47);
$parcel$export($c5578f8838abba3d$exports, "colorFromString", () => $ef0b145002741ccf$export$78ed65bc9abd64b1);
$parcel$export($c5578f8838abba3d$exports, "colorIsEqual", () => $ef0b145002741ccf$export$7da6ac10e55d4f2a);
$parcel$export($c5578f8838abba3d$exports, "colorToString", () => $ef0b145002741ccf$export$f86d83653e5a505e);
$parcel$export($c5578f8838abba3d$exports, "concat", () => $8abd7176cef66691$export$ee1b3e54f0441b22);
$parcel$export($c5578f8838abba3d$exports, "createElement", () => $fe86f88c0c9aea93$export$c8a8987d4410bf2d);
$parcel$export($c5578f8838abba3d$exports, "deepMerge", () => $97d77b6293df43c2$export$6969335ea1e4e77c);
$parcel$export($c5578f8838abba3d$exports, "desaturate", () => $ef0b145002741ccf$export$fb75607d98509d9);
$parcel$export($c5578f8838abba3d$exports, "getActiveElementInfo", () => $fe86f88c0c9aea93$export$5ec2c407fb44f02);
$parcel$export($c5578f8838abba3d$exports, "mount", () => $fe86f88c0c9aea93$export$186d02efde07ef98);
$parcel$export($c5578f8838abba3d$exports, "outerSize", () => $99b4426d930847de$export$7642631117982e98);
$parcel$export($c5578f8838abba3d$exports, "push", () => $8abd7176cef66691$export$4cbf152802aa238);
$parcel$export($c5578f8838abba3d$exports, "setActiveElement", () => $fe86f88c0c9aea93$export$7d007ff58288f238);
/*!
* Copyright (c) Microsoft Corporation.
* Licensed under the MIT License.
*/ /**
 * This file is for external facing export only, do not use this for internal references,
 * as it may cause circular dependencies in Rollup.
 */ /*!
* Copyright (c) Microsoft Corporation.
* Licensed under the MIT License.
*/ function $8abd7176cef66691$export$ee1b3e54f0441b22(...args) {
    return args.reduce((p, c)=>c ? p.concat(c) : p, []);
}
function $8abd7176cef66691$export$84af6d08e329f176(...args) {
    return args.reduce((p, c)=>c ? p.concat(c) : p, []).filter(Boolean);
}
function $8abd7176cef66691$export$4cbf152802aa238(arr, items) {
    arr.push.apply(arr, items);
}


/*!
* Copyright (c) Microsoft Corporation.
* Licensed under the MIT License.
*/ /**
 * Create a new element as a child of another element.
 * @param tagName Tag name of the new tag to create.
 * @param parentElement Reference of the element to append to.
 * @returns new HTMLElement.
 */ function $99b4426d930847de$export$3ca29736d56b698a(tagName, parentElement) {
    const el = document.createElement(tagName);
    parentElement.appendChild(el);
    return el;
}
function $99b4426d930847de$export$6758c6c7563dc60e(parentElement, className) {
    const div = $99b4426d930847de$export$3ca29736d56b698a('div', parentElement);
    if (className) div.className = className;
    return div;
}
function $99b4426d930847de$export$7642631117982e98(el) {
    const cs = getComputedStyle(el);
    const height = parseFloat(cs.marginTop) + parseFloat(cs.paddingTop) + parseFloat(cs.borderTopWidth) + el.offsetHeight + parseFloat(cs.borderBottomWidth) + parseFloat(cs.paddingBottom) + parseFloat(cs.marginBottom);
    const width = parseFloat(cs.marginLeft) + parseFloat(cs.paddingLeft) + parseFloat(cs.borderLeftWidth) + el.offsetWidth + parseFloat(cs.borderRightWidth) + parseFloat(cs.paddingRight) + parseFloat(cs.marginRight);
    return {
        height: height,
        width: width
    };
}


/*!
* Copyright (c) Microsoft Corporation.
* Licensed under the MIT License.
*/ var $6509a37883102e3a$exports = {};

$parcel$defineInteropFlag($6509a37883102e3a$exports);

$parcel$export($6509a37883102e3a$exports, "default", () => $6509a37883102e3a$export$2e2bcd8739ae039);
var $6509a37883102e3a$var$isMergeableObject = function isMergeableObject(value) {
    return $6509a37883102e3a$var$isNonNullObject(value) && !$6509a37883102e3a$var$isSpecial(value);
};
function $6509a37883102e3a$var$isNonNullObject(value) {
    return !!value && typeof value === 'object';
}
function $6509a37883102e3a$var$isSpecial(value) {
    var stringValue = Object.prototype.toString.call(value);
    return stringValue === '[object RegExp]' || stringValue === '[object Date]' || $6509a37883102e3a$var$isReactElement(value);
}
// see https://github.com/facebook/react/blob/b5ac963fb791d1298e7f396236383bc955f916c1/src/isomorphic/classic/element/ReactElement.js#L21-L25
var $6509a37883102e3a$var$canUseSymbol = typeof Symbol === 'function' && Symbol.for;
var $6509a37883102e3a$var$REACT_ELEMENT_TYPE = $6509a37883102e3a$var$canUseSymbol ? Symbol.for('react.element') : 0xeac7;
function $6509a37883102e3a$var$isReactElement(value) {
    return value.$$typeof === $6509a37883102e3a$var$REACT_ELEMENT_TYPE;
}
function $6509a37883102e3a$var$emptyTarget(val) {
    return Array.isArray(val) ? [] : {};
}
function $6509a37883102e3a$var$cloneUnlessOtherwiseSpecified(value, options) {
    return options.clone !== false && options.isMergeableObject(value) ? $6509a37883102e3a$var$deepmerge($6509a37883102e3a$var$emptyTarget(value), value, options) : value;
}
function $6509a37883102e3a$var$defaultArrayMerge(target, source, options) {
    return target.concat(source).map(function(element) {
        return $6509a37883102e3a$var$cloneUnlessOtherwiseSpecified(element, options);
    });
}
function $6509a37883102e3a$var$mergeObject(target, source, options) {
    var destination = {};
    if (options.isMergeableObject(target)) Object.keys(target).forEach(function(key) {
        destination[key] = $6509a37883102e3a$var$cloneUnlessOtherwiseSpecified(target[key], options);
    });
    Object.keys(source).forEach(function(key) {
        if (!options.isMergeableObject(source[key]) || !target[key]) destination[key] = $6509a37883102e3a$var$cloneUnlessOtherwiseSpecified(source[key], options);
        else destination[key] = $6509a37883102e3a$var$deepmerge(target[key], source[key], options);
    });
    return destination;
}
function $6509a37883102e3a$var$deepmerge(target, source, options) {
    options = options || {};
    options.arrayMerge = options.arrayMerge || $6509a37883102e3a$var$defaultArrayMerge;
    options.isMergeableObject = options.isMergeableObject || $6509a37883102e3a$var$isMergeableObject;
    var sourceIsArray = Array.isArray(source);
    var targetIsArray = Array.isArray(target);
    var sourceAndTargetTypesMatch = sourceIsArray === targetIsArray;
    if (!sourceAndTargetTypesMatch) return $6509a37883102e3a$var$cloneUnlessOtherwiseSpecified(source, options);
    else if (sourceIsArray) return options.arrayMerge(target, source, options);
    else return $6509a37883102e3a$var$mergeObject(target, source, options);
}
$6509a37883102e3a$var$deepmerge.all = function deepmergeAll(array, options) {
    if (!Array.isArray(array)) throw new Error('first argument should be an array');
    return array.reduce(function(prev, next) {
        return $6509a37883102e3a$var$deepmerge(prev, next, options);
    }, {});
};
var $6509a37883102e3a$var$deepmerge_1 = $6509a37883102e3a$var$deepmerge;
var $6509a37883102e3a$export$2e2bcd8739ae039 = $6509a37883102e3a$var$deepmerge_1;


/*!
 * is-plain-object <https://github.com/jonschlinkert/is-plain-object>
 *
 * Copyright (c) 2014-2017, Jon Schlinkert.
 * Released under the MIT License.
 */ function $d689e8e40778a90e$var$isObject(o) {
    return Object.prototype.toString.call(o) === '[object Object]';
}
function $d689e8e40778a90e$export$53b83ca8eaab0383(o) {
    var ctor, prot;
    if ($d689e8e40778a90e$var$isObject(o) === false) return false;
    // If has modified constructor
    ctor = o.constructor;
    if (ctor === undefined) return true;
    // If has modified prototype
    prot = ctor.prototype;
    if ($d689e8e40778a90e$var$isObject(prot) === false) return false;
    // If constructor does not have an Object-specific method
    if (prot.hasOwnProperty('isPrototypeOf') === false) return false;
    // Most likely a plain Object
    return true;
}


const $97d77b6293df43c2$var$deepmerge = $6509a37883102e3a$exports.default || $6509a37883102e3a$exports;
function $97d77b6293df43c2$export$9cd59f9826255e47(objectToClone) {
    if (!objectToClone) return objectToClone;
    return $97d77b6293df43c2$var$deepmerge.all([
        objectToClone
    ]);
}
const $97d77b6293df43c2$var$dontMerge = (destination, source)=>source;
function $97d77b6293df43c2$export$6969335ea1e4e77c(...objectsToMerge) {
    const objects = objectsToMerge.filter(Boolean);
    return $97d77b6293df43c2$var$deepmerge.all(objects, {
        arrayMerge: $97d77b6293df43c2$var$dontMerge,
        isMergeableObject: (0, $d689e8e40778a90e$export$53b83ca8eaab0383)
    });
}


/*!
* Copyright (c) Microsoft Corporation.
* Licensed under the MIT License.
*/ 
var $hNlxu = parcelRequire("hNlxu");
function $ef0b145002741ccf$var$rgbToDeckglColor(c) {
    return [
        c.r,
        c.g,
        c.b,
        c.opacity * 255
    ];
}
function $ef0b145002741ccf$export$7da6ac10e55d4f2a(a, b) {
    if (a.length !== b.length) return false;
    for(let i = 0; i < a.length; i++){
        if (a[i] !== b[i]) return false;
    }
    return true;
}
function $ef0b145002741ccf$export$78ed65bc9abd64b1(cssColorSpecifier) {
    if (cssColorSpecifier) {
        const dc = (0, $hNlxu.default)(cssColorSpecifier);
        if (dc) {
            const c = dc.rgb();
            return $ef0b145002741ccf$var$rgbToDeckglColor(c);
        }
    }
}
function $ef0b145002741ccf$export$f86d83653e5a505e(color) {
    const c = [
        ...color
    ];
    if (c.length > 3) c[3] /= 255;
    return `rgba(${c.join(',')})`;
}
function $ef0b145002741ccf$export$fb75607d98509d9(color, value) {
    const rgb = (0, $hNlxu.rgb)(color[0], color[1], color[2], color[3] / 255);
    const hslColor = (0, $hNlxu.hsl)(rgb);
    hslColor.s = value;
    const c = hslColor.rgb();
    return $ef0b145002741ccf$var$rgbToDeckglColor(c);
}





var $a2698ea08ecf5377$exports = {};

$parcel$export($a2698ea08ecf5377$exports, "minHeight", () => $a2698ea08ecf5377$export$a43cf604e12f3b17);
$parcel$export($a2698ea08ecf5377$exports, "minWidth", () => $a2698ea08ecf5377$export$ee148fbbe8357dd2);
$parcel$export($a2698ea08ecf5377$exports, "defaultPresenterStyle", () => $a2698ea08ecf5377$export$83ac8f5ae8122afc);
$parcel$export($a2698ea08ecf5377$exports, "defaultPresenterConfig", () => $a2698ea08ecf5377$export$200f593236aebbdc);
$parcel$export($a2698ea08ecf5377$exports, "createStage", () => $a2698ea08ecf5377$export$afa8810fbe5c2601);
$parcel$export($a2698ea08ecf5377$exports, "groupStrokeWidth", () => $a2698ea08ecf5377$export$62471df653c738cc);
$parcel$export($a2698ea08ecf5377$exports, "lineZ", () => $a2698ea08ecf5377$export$c25c42a6ee2ec894);
$parcel$export($a2698ea08ecf5377$exports, "defaultView", () => $a2698ea08ecf5377$export$93acc5219d6538bb);
$parcel$export($a2698ea08ecf5377$exports, "minZ", () => $a2698ea08ecf5377$export$ce94e349d95a214c);
$parcel$export($a2698ea08ecf5377$exports, "min3dDepth", () => $a2698ea08ecf5377$export$d90a7322036a432e);
$parcel$export($a2698ea08ecf5377$exports, "minPixelSize", () => $a2698ea08ecf5377$export$c9c7d435df6c4ed7);
$parcel$export($a2698ea08ecf5377$exports, "defaultOnAxisItem", () => $a2698ea08ecf5377$export$f66a5ef821fcc5df);
/*!
* Copyright (c) Microsoft Corporation.
* Licensed under the MIT License.
*/ 
const $a2698ea08ecf5377$export$a43cf604e12f3b17 = '100px';
const $a2698ea08ecf5377$export$ee148fbbe8357dd2 = '100px';
const $a2698ea08ecf5377$export$83ac8f5ae8122afc = {
    cssPrefix: 'vega-morphcharts-',
    defaultCubeColor: [
        128,
        128,
        128,
        255
    ],
    highlightColor: [
        0,
        0,
        0,
        255
    ]
};
const $a2698ea08ecf5377$export$200f593236aebbdc = {
    onCubeClick: (e, cube)=>{},
    onCubeHover: (e, cube)=>{},
    transitionDurations: {
        position: 600,
        stagger: 600,
        view: 600
    },
    renderer: {
        advanced: false,
        advancedOptions: {},
        basicOptions: {
            antialias: true
        }
    }
};
function $a2698ea08ecf5377$export$afa8810fbe5c2601(view) {
    const stage = {
        view: view,
        cubeData: [],
        pathData: [],
        axes: {
            x: [],
            y: [],
            z: []
        },
        gridLines: [],
        textData: [],
        legend: {
            rows: {}
        },
        facets: []
    };
    return stage;
}
const $a2698ea08ecf5377$export$62471df653c738cc = 1;
const $a2698ea08ecf5377$export$c25c42a6ee2ec894 = 0;
const $a2698ea08ecf5377$export$93acc5219d6538bb = '2d';
const $a2698ea08ecf5377$export$ce94e349d95a214c = 0.5;
const $a2698ea08ecf5377$export$d90a7322036a432e = 0.05;
const $a2698ea08ecf5377$export$c9c7d435df6c4ed7 = 0.5;
const $a2698ea08ecf5377$var$zAxisEncodeColor = [
    7,
    7,
    7,
    255
];
const $a2698ea08ecf5377$var$zAxisOutColor = [
    0,
    0,
    0,
    255
];
function $a2698ea08ecf5377$export$f66a5ef821fcc5df(vegaItem, stageItem, stage, currAxis) {
    if ((0, $ef0b145002741ccf$export$7da6ac10e55d4f2a)(stageItem.color, $a2698ea08ecf5377$var$zAxisEncodeColor)) {
        stageItem.color = $a2698ea08ecf5377$var$zAxisOutColor;
        if (currAxis.axisRole !== 'z') {
            const previousAxisRole = $a2698ea08ecf5377$var$removeCurrentAxes(stage, currAxis);
            if (previousAxisRole) {
                currAxis.axisRole = 'z';
                stage.axes.z.push(currAxis);
            }
        }
    }
}
function $a2698ea08ecf5377$var$removeCurrentAxes(stage, currAxis) {
    //find the current axis, remove it from parent
    for(const axisRole in stage.axes){
        const axes = stage.axes[axisRole];
        for(let i = 0; i < axes.length; i++)if (axes[i] === currAxis) {
            axes.splice(i, 1);
            return axisRole;
        }
    }
}


/*!
* Copyright (c) Microsoft Corporation.
* Licensed under the MIT License.
*/ const $94b078fc391e7135$var$vega = {
    CanvasHandler: null,
    inferType: null,
    inferTypes: null,
    loader: null,
    parse: null,
    read: null,
    renderModule: null,
    Renderer: null,
    sceneVisit: null,
    scheme: null,
    truncate: null,
    View: null
};
const $94b078fc391e7135$export$e2253033e6e1df16 = {
    vega: $94b078fc391e7135$var$vega
};
function $94b078fc391e7135$export$1f96ae73734a86cc(vega) {
    $94b078fc391e7135$export$e2253033e6e1df16.vega = vega;
}


/*!
* Copyright (c) Microsoft Corporation.
* Licensed under the MIT License.
*/ 

var $57337365aaceccbe$exports = {};

$parcel$export($57337365aaceccbe$exports, "PresenterElement", () => $57337365aaceccbe$export$79420be32f83a5b0);
/*!
* Copyright (c) Microsoft Corporation.
* Licensed under the MIT License.
*/ /**
 * HTML elements outputted by the presenter.
 */ var $57337365aaceccbe$export$79420be32f83a5b0;
(function(PresenterElement) {
    PresenterElement[PresenterElement["root"] = 0] = "root";
    PresenterElement[PresenterElement["gl"] = 1] = "gl";
    PresenterElement[PresenterElement["panel"] = 2] = "panel";
    PresenterElement[PresenterElement["legend"] = 3] = "legend";
    PresenterElement[PresenterElement["vegaControls"] = 4] = "vegaControls";
})($57337365aaceccbe$export$79420be32f83a5b0 || ($57337365aaceccbe$export$79420be32f83a5b0 = {}));


/*!
* Copyright (c) Microsoft Corporation.
* Licensed under the MIT License.
*/ 

const $93b302f28dcf836b$export$b0b33bcc0f604685 = (props)=>{
    const rows = [];
    const addRow = (row, i)=>{
        const fn = $93b302f28dcf836b$var$symbolMap[row.symbol.shape];
        let jsx;
        if (fn) jsx = fn(row.symbol);
        else jsx = (0, $fe86f88c0c9aea93$export$c8a8987d4410bf2d)("span", null, "x");
        rows.push({
            cells: [
                {
                    className: 'symbol',
                    content: jsx
                },
                {
                    className: 'label',
                    content: row.label,
                    title: row.label
                }
            ]
        });
    };
    const sorted = Object.keys(props.legend.rows).sort((a, b)=>+a - +b);
    sorted.forEach((i)=>addRow(props.legend.rows[i], +i));
    if (sorted.length) return (0, $fe86f88c0c9aea93$export$c8a8987d4410bf2d)((0, $837e7efbc300fecc$export$54ec01a60f47d33d), {
        rows: rows,
        rowClassName: "legend-row",
        onRowClick: (e, i)=>props.onClick(e, props.legend, i)
    }, props.legend.title !== void 0 && (0, $fe86f88c0c9aea93$export$c8a8987d4410bf2d)("tr", {
        onClick: (e)=>props.onClick(e, props.legend, null)
    }, (0, $fe86f88c0c9aea93$export$c8a8987d4410bf2d)("th", {
        colSpan: 2
    }, props.legend.title)));
};
const $93b302f28dcf836b$var$symbolMap = {
    square: function(symbol) {
        return (0, $fe86f88c0c9aea93$export$c8a8987d4410bf2d)("div", {
            style: {
                height: `${symbol.bounds.y2 - symbol.bounds.y1}px`,
                width: `${symbol.bounds.x2 - symbol.bounds.x1}px`,
                backgroundColor: symbol.fill,
                borderColor: symbol.fill
            }
        });
    }
};


/*!
* Copyright (c) Microsoft Corporation.
* Licensed under the MIT License.
*/ 


function $a1265428470a4521$export$ba5a93ad8642dce4(presenter) {
    const rootDiv = (0, $fe86f88c0c9aea93$export$c8a8987d4410bf2d)("div", {
        className: $a1265428470a4521$export$2913c0c0b5623090((0, $57337365aaceccbe$export$79420be32f83a5b0).root, presenter)
    }, (0, $fe86f88c0c9aea93$export$c8a8987d4410bf2d)("div", {
        className: $a1265428470a4521$export$2913c0c0b5623090((0, $57337365aaceccbe$export$79420be32f83a5b0).gl, presenter),
        style: {
            minHeight: $a2698ea08ecf5377$export$a43cf604e12f3b17,
            minWidth: $a2698ea08ecf5377$export$ee148fbbe8357dd2
        }
    }), (0, $fe86f88c0c9aea93$export$c8a8987d4410bf2d)("div", {
        className: $a1265428470a4521$export$2913c0c0b5623090((0, $57337365aaceccbe$export$79420be32f83a5b0).panel, presenter)
    }, (0, $fe86f88c0c9aea93$export$c8a8987d4410bf2d)("div", {
        className: $a1265428470a4521$export$2913c0c0b5623090((0, $57337365aaceccbe$export$79420be32f83a5b0).vegaControls, presenter)
    }), (0, $fe86f88c0c9aea93$export$c8a8987d4410bf2d)("div", {
        className: $a1265428470a4521$export$2913c0c0b5623090((0, $57337365aaceccbe$export$79420be32f83a5b0).legend, presenter)
    })));
    (0, $fe86f88c0c9aea93$export$186d02efde07ef98)(rootDiv, presenter.el);
}
function $a1265428470a4521$export$2913c0c0b5623090(type, presenter) {
    return `${presenter.style.cssPrefix}${(0, $57337365aaceccbe$export$79420be32f83a5b0)[type]}`;
}


/*!
* Copyright (c) Microsoft Corporation.
* Licensed under the MIT License.
*/ function $532135db04b63f4f$export$9a79ca9001afcc6d(allocatedSize, empty, cubes) {
    const patched = new Array(allocatedSize);
    patched.fill(empty);
    cubes.forEach((cube)=>patched[cube.ordinal] = cube);
    return patched;
}


/*!
* Copyright (c) Microsoft Corporation.
* Licensed under the MIT License.
*/ /*!
* Copyright (c) Microsoft Corporation.
* Licensed under the MIT License.
*/ 
const $ee42e7a385711003$var$legendMap = {
    'legend-title': function(legend, textItem) {
        legend.title = textItem.text;
    },
    'legend-symbol': function(legend, symbol) {
        const { bounds: bounds, fill: fill, shape: shape } = symbol;
        //this object is safe for serialization
        const legendRowSymbol = {
            bounds: bounds,
            fill: fill,
            shape: shape
        };
        const i = symbol.datum.index;
        legend.rows[i] = legend.rows[i] || {};
        legend.rows[i].symbol = legendRowSymbol;
    },
    'legend-label': function(legend, label) {
        const i = label.datum.index;
        legend.rows[i] = legend.rows[i] || {};
        const row = legend.rows[i];
        row.label = label.text;
        row.value = label.datum.value;
    }
};
const $ee42e7a385711003$var$markStager = (options, stage, scene, x, y, groupType)=>{
    (0, $94b078fc391e7135$export$e2253033e6e1df16).vega.sceneVisit(scene, function(item) {
        const fn = $ee42e7a385711003$var$legendMap[item.mark.role];
        if (fn) fn(stage.legend, item);
    });
};
var $ee42e7a385711003$export$2e2bcd8739ae039 = $ee42e7a385711003$var$markStager;


/*!
* Copyright (c) Microsoft Corporation.
* Licensed under the MIT License.
*/ 
const $1c2daaedca40f764$var$markStager = (options, stage, scene, x, y, groupType)=>{
    (0, $94b078fc391e7135$export$e2253033e6e1df16).vega.sceneVisit(scene, function(item) {
        const { bounds: bounds, height: height, url: url, width: width } = item;
        let { x1: x1, x2: x2, y1: y1, y2: y2 } = bounds;
        x1 += x;
        x2 += x;
        y1 += y;
        y2 += y;
        if (!stage.backgroundImages) stage.backgroundImages = [];
        stage.backgroundImages.push({
            bounds: {
                x1: x1,
                x2: x2,
                y1: y1,
                y2: y2
            },
            height: height,
            url: url,
            width: width
        });
    });
};
var $1c2daaedca40f764$export$2e2bcd8739ae039 = $1c2daaedca40f764$var$markStager;


/*!
* Copyright (c) Microsoft Corporation.
* Licensed under the MIT License.
*/ 


const $1c0091b6f51baefd$var$markStager = (options, stage, scene, x, y, groupType)=>{
    (0, $94b078fc391e7135$export$e2253033e6e1df16).vega.sceneVisit(scene, function(item) {
        const noZ = item.z === undefined;
        const z = noZ ? 0 : (item.z || 0) + (0, $a2698ea08ecf5377$export$ce94e349d95a214c);
        const depth = (noZ ? 0 : item.depth || 0) + (0, $a2698ea08ecf5377$export$d90a7322036a432e);
        //change direction of y from SVG to GL
        const ty = -1;
        const ordinal = options.assignCubeOrdinal(item.datum);
        if (ordinal > options.maxOrdinal) options.maxOrdinal = ordinal;
        if (ordinal === undefined) ;
        else {
            const cube = {
                ordinal: ordinal,
                size: [
                    item.width,
                    item.height,
                    depth
                ],
                position: [
                    x + (+item.x || 0),
                    ty * (y + (+item.y || 0)) - +item.height,
                    z
                ],
                color: (0, $ef0b145002741ccf$export$78ed65bc9abd64b1)(item.fill) || options.defaultCubeColor || [
                    128,
                    128,
                    128,
                    128
                ]
            };
            cube.color[3] = item.opacity === undefined ? 255 : 255 * item.opacity;
            stage.cubeData.push(cube);
        }
    });
};
var $1c0091b6f51baefd$export$2e2bcd8739ae039 = $1c0091b6f51baefd$var$markStager;


/*!
* Copyright (c) Microsoft Corporation.
* Licensed under the MIT License.
*/ 


const $3799405dfc10eafe$var$markStager = (options, stage, scene, x, y, groupType)=>{
    (0, $94b078fc391e7135$export$e2253033e6e1df16).vega.sceneVisit(scene, function(item) {
        const x1 = item.x || 0;
        const y1 = item.y || 0;
        const x2 = item.x2 != null ? item.x2 : x1;
        const y2 = item.y2 != null ? item.y2 : y1;
        const lineItem = $3799405dfc10eafe$var$styledLine(x1 + x, y1 + y, x2 + x, y2 + y, item.stroke, item.strokeWidth);
        const { currAxis: currAxis } = options;
        if (options.modifyAxis) options.modifyAxis(item, lineItem, stage, currAxis);
        if (item.mark.role === 'axis-tick') currAxis.ticks.push(lineItem);
        else if (item.mark.role === 'axis-domain') currAxis.domain = lineItem;
        else stage.gridLines.push(lineItem);
    });
};
function $3799405dfc10eafe$var$styledLine(x1, y1, x2, y2, stroke, strokeWidth) {
    const line = {
        sourcePosition: [
            x1,
            -y1,
            (0, $a2698ea08ecf5377$export$c25c42a6ee2ec894)
        ],
        targetPosition: [
            x2,
            -y2,
            (0, $a2698ea08ecf5377$export$c25c42a6ee2ec894)
        ],
        color: (0, $ef0b145002741ccf$export$78ed65bc9abd64b1)(stroke),
        strokeWidth: strokeWidth
    };
    return line;
}
function $3799405dfc10eafe$export$827f4ee28efc37(gx, gy, height, width, stroke, strokeWidth, diagonals = false) {
    const lines = [
        $3799405dfc10eafe$var$styledLine(gx, gy, gx + width, gy, stroke, strokeWidth),
        $3799405dfc10eafe$var$styledLine(gx + width, gy, gx + width, gy + height, stroke, strokeWidth),
        $3799405dfc10eafe$var$styledLine(gx + width, gy + height, gx, gy + height, stroke, strokeWidth),
        $3799405dfc10eafe$var$styledLine(gx, gy + height, gx, gy, stroke, strokeWidth)
    ];
    if (diagonals) {
        lines.push($3799405dfc10eafe$var$styledLine(gx, gy, gx + width, gy + height, stroke, strokeWidth));
        lines.push($3799405dfc10eafe$var$styledLine(gx, gy + height, gx + width, gy, stroke, strokeWidth));
    }
    return lines;
}
var $3799405dfc10eafe$export$2e2bcd8739ae039 = $3799405dfc10eafe$var$markStager;


/*!
* Copyright (c) Microsoft Corporation.
* Licensed under the MIT License.
*/ 
//change direction of y from SVG to GL
const $6a99e81bd9058351$var$ty = -1;
const $6a99e81bd9058351$var$markStager = (options, stage, scene, x, y, groupType)=>{
    const g = Object.assign({
        opacity: 1,
        strokeOpacity: 1,
        strokeWidth: 1
    }, scene.items[0]);
    const path = {
        strokeWidth: g.strokeWidth,
        strokeColor: (0, $ef0b145002741ccf$export$78ed65bc9abd64b1)(g.stroke),
        positions: scene.items.map((it)=>[
                it.x,
                $6a99e81bd9058351$var$ty * it.y,
                it.z || 0
            ])
    };
    path.strokeColor[3] *= g.strokeOpacity;
    path.strokeColor[3] *= g.opacity;
    stage.pathData.push(path);
};
var $6a99e81bd9058351$export$2e2bcd8739ae039 = $6a99e81bd9058351$var$markStager;


/*!
* Copyright (c) Microsoft Corporation.
* Licensed under the MIT License.
*/ // import { AlignmentBaseline, TextAnchor } from '@deck.gl/layers/text-layer/text-layer';


const $74ed9c7a2f9d83d8$var$markStager = (options, stage, scene, x, y, groupType)=>{
    //change direction of y from SVG to GL
    const ty = -1;
    (0, $94b078fc391e7135$export$e2253033e6e1df16).vega.sceneVisit(scene, function(item) {
        if (!item.text) return;
        const size = item.fontSize;
        //const alignmentBaseline = convertBaseline(item.baseline);
        //const yOffset = alignmentBaseline === 'top' ? item.fontSize / 2 : 0;    //fixup to get tick text correct
        const yOffset = 0;
        const textItem = {
            color: (0, $ef0b145002741ccf$export$78ed65bc9abd64b1)(item.fill),
            text: item.limit === undefined ? item.text : (0, $94b078fc391e7135$export$e2253033e6e1df16).vega.truncate(item.text, item.limit, 'right', item.ellipsis || '...'),
            position: [
                x + (item.x || 0),
                ty * (y + (item.y || 0) + yOffset),
                0
            ],
            size: size,
            angle: $74ed9c7a2f9d83d8$var$convertAngle(item.angle),
            //textAnchor: convertAlignment(item.align),
            //alignmentBaseline,
            metaData: item.metaData
        };
        const { currAxis: currAxis } = options;
        if (options.modifyAxis) options.modifyAxis(item, textItem, stage, currAxis);
        if (item.mark.role === 'axis-label') {
            const tickText = textItem;
            tickText.value = item.datum.value;
            currAxis.tickText.push(tickText);
        } else if (item.mark.role === 'axis-title') currAxis.title = textItem;
        else stage.textData.push(textItem);
    });
};
function $74ed9c7a2f9d83d8$var$convertAngle(vegaTextAngle) {
    if (vegaTextAngle && !isNaN(vegaTextAngle)) return 360 - vegaTextAngle;
    return 0;
}
var // function convertAlignment(textAlign: SceneTextAlign): TextAnchor {
//     switch (textAlign) {
//         case 'center': return 'middle';
//         case 'left': return 'start';
//         case 'right': return 'end';
//     }
//     return 'start';
// }
// function convertBaseline(baseline: SceneTextBaseline): AlignmentBaseline {
//     switch (baseline) {
//         case 'middle': return 'center';
//     }
//     return baseline || 'bottom';
// }
$74ed9c7a2f9d83d8$export$2e2bcd8739ae039 = $74ed9c7a2f9d83d8$var$markStager;





/*!
* Copyright (c) Microsoft Corporation.
* Licensed under the MIT License.
*/ var $f1bfde149acb9a2e$export$d460f747b73abb10;
(function(GroupType) {
    GroupType[GroupType["none"] = 0] = "none";
    GroupType[GroupType["legend"] = 1] = "legend";
    GroupType[GroupType["xAxis"] = 2] = "xAxis";
    GroupType[GroupType["yAxis"] = 3] = "yAxis";
    GroupType[GroupType["zAxis"] = 4] = "zAxis";
})($f1bfde149acb9a2e$export$d460f747b73abb10 || ($f1bfde149acb9a2e$export$d460f747b73abb10 = {}));


function $684c20b0d21986c1$var$getAxisGroupType(item, options) {
    const axisItem = item;
    const axisMark = axisItem === null || axisItem === void 0 ? void 0 : axisItem.mark;
    if ((axisMark === null || axisMark === void 0 ? void 0 : axisMark.zindex) === options.zAxisZindex && options.zAxisZindex !== undefined) return (0, $f1bfde149acb9a2e$export$d460f747b73abb10).zAxis;
    switch(axisItem.orient){
        case 'bottom':
        case 'top':
            return (0, $f1bfde149acb9a2e$export$d460f747b73abb10).xAxis;
        case 'left':
        case 'right':
            return (0, $f1bfde149acb9a2e$export$d460f747b73abb10).yAxis;
    }
}
function $684c20b0d21986c1$var$convertGroupRole(item, options) {
    if (item.mark.role === 'legend') return (0, $f1bfde149acb9a2e$export$d460f747b73abb10).legend;
    if (item.mark.role === 'axis') {
        const groupType = $684c20b0d21986c1$var$getAxisGroupType(item, options);
        if (groupType !== undefined) return groupType;
    }
}
const $684c20b0d21986c1$var$group = (options, stage, scene, x, y, groupType)=>{
    (0, $94b078fc391e7135$export$e2253033e6e1df16).vega.sceneVisit(scene, function(g) {
        const gx = g.x || 0, gy = g.y || 0;
        if (g.context && g.context.background && !stage.backgroundColor) stage.backgroundColor = (0, $ef0b145002741ccf$export$78ed65bc9abd64b1)(g.context.background);
        if (g.stroke) {
            const facetRect = {
                datum: g.datum,
                lines: (0, $3799405dfc10eafe$export$827f4ee28efc37)(gx + x, gy + y, g.height, g.width, g.stroke, (0, $a2698ea08ecf5377$export$62471df653c738cc))
            };
            stage.facets.push(facetRect);
        }
        groupType = $684c20b0d21986c1$var$convertGroupRole(g, options) || groupType;
        $684c20b0d21986c1$var$setCurrentAxis(options, stage, groupType);
        // draw group contents
        (0, $94b078fc391e7135$export$e2253033e6e1df16).vega.sceneVisit(g, function(item) {
            $684c20b0d21986c1$var$mainStager(options, stage, item, gx + x, gy + y, groupType);
        });
    });
};
function $684c20b0d21986c1$var$setCurrentAxis(options, stage, groupType) {
    let axisRole;
    switch(groupType){
        case (0, $f1bfde149acb9a2e$export$d460f747b73abb10).xAxis:
            axisRole = 'x';
            break;
        case (0, $f1bfde149acb9a2e$export$d460f747b73abb10).yAxis:
            axisRole = 'y';
            break;
        case (0, $f1bfde149acb9a2e$export$d460f747b73abb10).zAxis:
            axisRole = 'z';
            break;
        default:
            return;
    }
    options.currAxis = {
        axisRole: axisRole,
        domain: null,
        tickText: [],
        ticks: []
    };
    stage.axes[axisRole].push(options.currAxis);
}
const $684c20b0d21986c1$var$markStagers = {
    group: $684c20b0d21986c1$var$group,
    legend: $ee42e7a385711003$export$2e2bcd8739ae039,
    image: $1c2daaedca40f764$export$2e2bcd8739ae039,
    rect: $1c0091b6f51baefd$export$2e2bcd8739ae039,
    rule: $3799405dfc10eafe$export$2e2bcd8739ae039,
    line: $6a99e81bd9058351$export$2e2bcd8739ae039,
    text: $74ed9c7a2f9d83d8$export$2e2bcd8739ae039
};
const $684c20b0d21986c1$var$mainStager = (options, stage, scene, x, y, groupType)=>{
    if (scene.marktype !== 'group' && groupType === (0, $f1bfde149acb9a2e$export$d460f747b73abb10).legend) (0, $ee42e7a385711003$export$2e2bcd8739ae039)(options, stage, scene, x, y, groupType);
    else {
        const markStager = $684c20b0d21986c1$var$markStagers[scene.marktype];
        if (markStager) markStager(options, stage, scene, x, y, groupType);
    }
};
function $684c20b0d21986c1$export$d78988dba6734aaa(options, stage, scene) {
    $684c20b0d21986c1$var$mainStager(options, stage, scene, 0, 0, null);
    $684c20b0d21986c1$var$sortAxis(stage.axes.x, 0);
    $684c20b0d21986c1$var$sortAxis(stage.axes.y, 1);
    $684c20b0d21986c1$var$sortAxis(stage.axes.z, 1);
}
function $684c20b0d21986c1$var$sortAxis(axes, dim) {
    axes.forEach((axis)=>{
        if (axis.domain) $684c20b0d21986c1$var$orderDomain(axis.domain, dim);
        axis.ticks.sort((a, b)=>a.sourcePosition[dim] - b.sourcePosition[dim]);
        axis.tickText.sort((a, b)=>a.position[dim] - b.position[dim]);
    });
}
function $684c20b0d21986c1$var$orderDomain(domain, dim) {
    if (domain.sourcePosition[dim] > domain.targetPosition[dim]) {
        const temp = domain.targetPosition;
        domain.targetPosition = domain.sourcePosition;
        domain.sourcePosition = temp;
    }
}



/*!
* Copyright (c) Microsoft Corporation.
* Licensed under the MIT License.
*/ /*!
* Copyright (c) Microsoft Corporation.
* Licensed under the MIT License.
*/ /*!
* Copyright (c) Microsoft Corporation.
* Licensed under the MIT License.
*/ 
/*!
* Copyright (c) Microsoft Corporation.
* Licensed under the MIT License.
*/ function $36f1cad8963ffaec$export$b1d52f954c5faa57(b1, b2) {
    if (!b1 && !b2) return;
    if (!b1) return b2;
    if (!b2) return b1;
    const minProps = [
        'minBoundsX',
        'minBoundsY',
        'minBoundsZ'
    ];
    const maxProps = [
        'maxBoundsX',
        'maxBoundsY',
        'maxBoundsZ'
    ];
    const result = {};
    minProps.forEach((p)=>result[p] = $36f1cad8963ffaec$var$notNull(Math.min, b1[p], b2[p]));
    maxProps.forEach((p)=>result[p] = $36f1cad8963ffaec$var$notNull(Math.max, b1[p], b2[p]));
    return result;
}
function $36f1cad8963ffaec$var$notNull(fn, v1, v2) {
    if (v1 == null && v2 == null) return null;
    if (v1 == null) return v2;
    if (v2 == null) return v1;
    return fn(v1, v2);
}
function $36f1cad8963ffaec$export$a2647aa13413c947(b, minBoundsX, minBoundsY, minBoundsZ, maxBoundsX, maxBoundsY, maxBoundsZ) {
    return $36f1cad8963ffaec$export$b1d52f954c5faa57(b, {
        minBoundsX: minBoundsX,
        minBoundsY: minBoundsY,
        minBoundsZ: minBoundsZ,
        maxBoundsX: maxBoundsX,
        maxBoundsY: maxBoundsY,
        maxBoundsZ: maxBoundsZ
    });
}


const $81bc6306df670951$export$b820fac18d588132 = (props)=>{
    const { config: config, height: height, ref: ref, stage: stage } = props;
    const { core: core } = ref;
    const { renderer: renderer } = core;
    const { x: x, y: y, z: z } = stage.axes;
    const xyz = [
        ...x,
        ...y,
        ...z
    ];
    renderer.currentAxes = [];
    if (!xyz.length) {
        renderer.axesVisibility = (0, $4a6417d29706362f$export$7dbc7c2b82487e42).none;
        return;
    }
    renderer.axesVisibility = (0, $4a6417d29706362f$export$7dbc7c2b82487e42).current;
    const correlation = new $81bc6306df670951$var$AxesCorrelation(stage, 3);
    const { axesSets: axesSets, labels: labels } = correlation;
    const grid = correlation.getGrid();
    if (grid.byColumn[0]) {
        grid.byColumn[0].forEach((row)=>{
            row.axesSet.showFacetTitleY = true;
        });
        grid.byRow[0].forEach((col)=>{
            col.axesSet.showFacetTitleX = true;
        });
    }
    if (grid.rows > 1) {
        const { byRow: byRow } = grid;
        byRow[0].forEach(({ axesSet: axesSet }, col)=>{
            if (!axesSet.y) {
                if (byRow[1][col].axesSet) {
                    //move x up
                    byRow[1][col].axesSet.x.tickText = axesSet.x.tickText;
                    byRow[1][col].axesSet.showFacetTitleX = axesSet.showFacetTitleX;
                    delete axesSet.x;
                }
            }
        });
    }
    let bounds;
    const allAxesSetBounds = [];
    let anyZ = false;
    for(let i = 0; i < axesSets.length; i++)if (axesSets[i].z) {
        anyZ = true;
        break;
    }
    const is3d = stage.view === '3d' && anyZ;
    axesSets.forEach((axesSet)=>{
        if (!axesSet.x && !axesSet.y) return;
        const axesSetBounds = {
            axesSet: axesSet,
            maxBoundsX: null,
            maxBoundsY: null,
            maxBoundsZ: null,
            minBoundsX: null,
            minBoundsY: null,
            minBoundsZ: null
        };
        if (is3d) {
            const zBounds = $81bc6306df670951$var$getDomainBounds(1, axesSet.z);
            axesSetBounds.minBoundsZ = -zBounds.maxBounds;
            axesSetBounds.maxBoundsZ = -zBounds.minBounds;
        }
        const yBounds = $81bc6306df670951$var$getDomainBounds(1, axesSet.y);
        axesSetBounds.minBoundsY = yBounds.minBounds;
        axesSetBounds.maxBoundsY = yBounds.maxBounds;
        axesSetBounds.y = yBounds.minBounds;
        axesSetBounds.h = yBounds.maxBounds - yBounds.minBounds;
        const xBounds = $81bc6306df670951$var$getDomainBounds(0, axesSet.x);
        axesSetBounds.minBoundsX = xBounds.minBounds;
        axesSetBounds.maxBoundsX = xBounds.maxBounds;
        axesSetBounds.x = xBounds.minBounds;
        axesSetBounds.w = xBounds.maxBounds - xBounds.minBounds;
        allAxesSetBounds.push(axesSetBounds);
        bounds = (0, $36f1cad8963ffaec$export$b1d52f954c5faa57)(bounds, axesSetBounds);
    });
    const facetLabelX = labels.filter((label)=>label.axisRole === 'x')[0];
    const facetLabelY = labels.filter((label)=>label.axisRole === 'y')[0];
    core.inputManager.pickAxesTitleCallback = ({ axis: axis, axes: axes, manipulator: manipulator })=>{
        const axesSet = axesSets[axes];
        let a;
        let f;
        switch(axis){
            case 0:
                a = axesSet.x;
                f = facetLabelX;
                break;
            case 1:
                a = axesSet.y;
                f = facetLabelY;
                break;
            case 2:
                a = axesSet.z;
                break;
        }
        if (a) config.onTextClick(manipulator.event, a.title || f.title);
    };
    allAxesSetBounds.forEach((axesSetBounds)=>{
        const { axesSet: axesSet } = axesSetBounds;
        if (!axesSet.x && !axesSet.y) return;
        const cartesian = new (is3d ? (0, $4559f2a5f6bc9c8c$exports).Cartesian3dAxes : (0, $4559f2a5f6bc9c8c$exports).Cartesian2dAxes)(core);
        cartesian.isDivisionPickingEnabled = [
            false,
            false,
            false
        ];
        cartesian.arePickDivisionsVisible = [
            false,
            false,
            false
        ];
        cartesian.isLabelPickingEnabled = [
            false,
            false,
            false
        ];
        cartesian.isTitlePickingEnabled = [
            false,
            false,
            false
        ];
        cartesian.isGridPickingEnabled = false;
        cartesian.isHeadingPickingEnabled = [
            false,
            false,
            false
        ];
        $81bc6306df670951$var$createAxes(cartesian, 0, 0, axesSet.x, (0, $4a6417d29706362f$export$d2304d1f23cf3ace).perpendicular, height, props, axesSet.showFacetTitleX && facetLabelX);
        $81bc6306df670951$var$createAxes(cartesian, 1, 1, axesSet.y, (0, $4a6417d29706362f$export$d2304d1f23cf3ace).perpendicular, height, props, axesSet.showFacetTitleY && facetLabelY);
        if (is3d) $81bc6306df670951$var$createAxes(cartesian, 1, 2, axesSet.z, (0, $4a6417d29706362f$export$d2304d1f23cf3ace).perpendicular, height, props);
        $81bc6306df670951$var$configCartesianAxes(is3d, bounds, cartesian);
        const { maxBoundsX: maxBoundsX, maxBoundsY: maxBoundsY, minBoundsX: minBoundsX, minBoundsY: minBoundsY } = bounds;
        const w = maxBoundsX - minBoundsX;
        const h = maxBoundsY - minBoundsY;
        cartesian.scalingX = axesSetBounds.w / w;
        cartesian.scalingY = axesSetBounds.h / h;
        cartesian.offsetX = (axesSetBounds.x - minBoundsX + axesSetBounds.w / 2) / w - 0.5;
        cartesian.offsetY = (axesSetBounds.y - minBoundsY + axesSetBounds.h / 2) / h - 0.5;
        const aspect = h / w;
        if (aspect > 1) cartesian.offsetX /= aspect;
        else cartesian.offsetY *= aspect;
        const axes = is3d ? renderer.createCartesian3dAxesVisual(cartesian) : renderer.createCartesian2dAxesVisual(cartesian);
        renderer.currentAxes.push(axes);
        props.config.onAxesComplete && props.config.onAxesComplete(cartesian);
    });
    return {
        bounds: bounds
    };
};
const $81bc6306df670951$var$nullDomain = {
    sourcePosition: [
        0,
        0,
        0
    ],
    targetPosition: [
        0,
        0,
        0
    ]
};
class $81bc6306df670951$var$AxesCorrelation {
    constructor(stage, dimensions){
        this.dimensions = dimensions;
        const { x: x, y: y, z: z } = stage.axes;
        this.axesSets = [];
        this.labels = [];
        [
            x,
            y,
            z
        ].forEach((axes)=>{
            axes.forEach((axis)=>{
                if (this.axesSets.length === 0) this.initialize(axis);
                else this.correlate(axis);
            });
        });
    }
    getGrid() {
        const mapCols = {};
        const mapRows = {};
        this.axesSets.forEach((axesSet)=>{
            var _a;
            const domain = (_a = axesSet === null || axesSet === void 0 ? void 0 : axesSet.x) === null || _a === void 0 ? void 0 : _a.domain;
            if (!domain) return;
            const col = domain.sourcePosition[0].toString();
            const row = domain.sourcePosition[1].toString();
            if (!mapCols[col]) mapCols[col] = {};
            mapCols[col][row] = axesSet;
            mapRows[row] = null;
        });
        const colKeys = Object.keys(mapCols).sort((a, b)=>+a - +b);
        const rowKeys = Object.keys(mapRows).sort((a, b)=>+a - +b);
        return {
            cols: colKeys.length,
            rows: rowKeys.length,
            byColumn: colKeys.map((colKey)=>rowKeys.map((rowKey)=>{
                    return {
                        colKey: colKey,
                        rowKey: rowKey,
                        axesSet: mapCols[colKey][rowKey]
                    };
                })),
            byRow: rowKeys.map((rowKey)=>colKeys.map((colKey)=>{
                    return {
                        colKey: colKey,
                        rowKey: rowKey,
                        axesSet: mapCols[colKey][rowKey]
                    };
                }))
        };
    }
    initialize(axis) {
        if (!axis.domain) {
            this.labels.push(axis);
            return;
        }
        const axesSet = {};
        axesSet[axis.axisRole] = axis;
        this.axesSets.push(axesSet);
    }
    correlate(axis) {
        if (!axis.domain) {
            this.labels.push(axis);
            return;
        }
        for(let i = 0; i < this.axesSets.length; i++){
            const axesSet = this.axesSets[i];
            for(const axisRole in axesSet){
                const test = axesSet[axisRole];
                if (this.matchDomains(axis.domain, test.domain)) {
                    //prefer the axes with titles
                    if (!axesSet[axis.axisRole] || !axesSet[axis.axisRole].tickText.length && axis.tickText.length) axesSet[axis.axisRole] = axis;
                    return;
                }
            }
        }
        this.initialize(axis);
    }
    matchDomains(a, b) {
        if (this.matchPoint(a.sourcePosition, b.sourcePosition)) return true;
        if (this.matchPoint(a.sourcePosition, b.targetPosition)) return true;
        if (this.matchPoint(a.targetPosition, b.targetPosition)) return true;
        if (this.matchPoint(a.targetPosition, b.sourcePosition)) return true;
        return false;
    }
    matchPoint(a, b) {
        for(let i = 0; i < this.dimensions; i++){
            if (a[i] !== b[i]) return false;
        }
        return true;
    }
}
function $81bc6306df670951$var$createAxes(cartesian, dim2d, dim3d, axis, orientation, height, props, facetLabel) {
    const domain = (axis === null || axis === void 0 ? void 0 : axis.domain) || $81bc6306df670951$var$nullDomain;
    const { tickPositions: tickPositions, tickText: tickText, textPos: textPos, textSize: textSize } = $81bc6306df670951$var$convertAxis(axis, domain, dim2d, height);
    if (axis.axisRole === 'z') {
        tickPositions.forEach((t, i)=>tickPositions[i] = 1 - t);
        textPos.forEach((t, i)=>textPos[i] = 1 - t);
        tickText.reverse();
        tickPositions.reverse();
        textPos.reverse();
    }
    cartesian.setTickPositions(dim3d, tickPositions);
    cartesian.zero[dim3d] = 0; //TODO get any "zero" gridline position from vega
    cartesian.setLabelPositions(dim3d, textPos);
    cartesian.setLabels(dim3d, tickText);
    cartesian.setLabelSizes(dim3d, textSize);
    const title = (axis === null || axis === void 0 ? void 0 : axis.title) || (facetLabel === null || facetLabel === void 0 ? void 0 : facetLabel.title);
    if (title === null || title === void 0 ? void 0 : title.text) {
        cartesian.setTitle(dim3d, title.text);
        cartesian.setTitleSize(dim3d, title.size / height);
    }
    cartesian.setLabelOrientation(dim3d, orientation);
    props.config.onAxisConfig && props.config.onAxisConfig(cartesian, dim3d, axis);
    return {
        tickText: tickText
    };
}
function $81bc6306df670951$var$configCartesianAxes(is3d, bounds, cartesian) {
    if (is3d) cartesian.isEdgeVisible[(0, $4a6417d29706362f$export$99dacba06f5726bd).topBack] = false;
    cartesian.isEdgeVisible[(0, $4a6417d29706362f$export$99dacba06f5726bd).backRight] = false;
    cartesian.isEdgeVisible[(0, $4a6417d29706362f$export$99dacba06f5726bd).bottomRight] = false;
    cartesian.isEdgeVisible[(0, $4a6417d29706362f$export$99dacba06f5726bd).frontRight] = false;
    cartesian.isEdgeVisible[(0, $4a6417d29706362f$export$99dacba06f5726bd).topFront] = false;
    cartesian.isEdgeVisible[(0, $4a6417d29706362f$export$99dacba06f5726bd).topRight] = false;
    const { maxBoundsX: maxBoundsX, maxBoundsY: maxBoundsY, maxBoundsZ: maxBoundsZ, minBoundsX: minBoundsX, minBoundsY: minBoundsY, minBoundsZ: minBoundsZ } = bounds;
    cartesian.minBoundsX = minBoundsX;
    cartesian.maxBoundsX = maxBoundsX;
    cartesian.minBoundsY = minBoundsY;
    cartesian.maxBoundsY = maxBoundsY;
    if (is3d) {
        cartesian.minBoundsZ = minBoundsZ;
        cartesian.maxBoundsZ = maxBoundsZ;
    }
}
function $81bc6306df670951$var$getDomainBounds(dim2d, axis) {
    const domain = (axis === null || axis === void 0 ? void 0 : axis.domain) || $81bc6306df670951$var$nullDomain;
    const minBounds = domain.sourcePosition[dim2d];
    const maxBounds = domain.targetPosition[dim2d];
    return {
        maxBounds: maxBounds,
        minBounds: minBounds
    };
}
function $81bc6306df670951$var$convertAxis(axis, domain, dim, height) {
    const start = domain.sourcePosition[dim];
    const span = domain.targetPosition[dim] - start;
    const tickPositions = axis ? axis.ticks.map((t)=>(t.sourcePosition[dim] - start) / span) : [];
    const tickText = axis ? axis.tickText.map((t)=>t.text) : [];
    const textPos = axis ? axis.tickText.map((t)=>(t.position[dim] - start) / span) : [];
    const textSize = axis ? axis.tickText.map((t)=>t.size / height) : [];
    if (tickPositions.length) {
        if (tickPositions[0] !== 0) tickPositions[0] = 0;
        if (tickPositions[tickPositions.length - 1] !== 1) tickPositions[tickPositions.length - 1] = 1;
    }
    return {
        tickPositions: tickPositions,
        tickText: tickText,
        textPos: textPos,
        textSize: textSize
    };
}



/*!
* Copyright (c) Microsoft Corporation.
* Licensed under the MIT License.
*/ 

/*!
* Copyright (c) Microsoft Corporation.
* Licensed under the MIT License.
*/ 
class $b85abf0fe2345f80$export$7cefaad7e81641ff {
    constructor(quant = 5){
        this.quant = quant;
        this.colorMap = {};
        this.colorArray = [];
    }
    getColorKey(rgbaColor) {
        const color = rgbaColor.slice(0, 3).map((e)=>Math.floor(e / this.quant) * this.quant);
        color[3] = rgbaColor[3]; //retain alpha
        return JSON.stringify(color);
    }
    registerColor(rgbaColor) {
        const colorKey = this.getColorKey(rgbaColor);
        if (!this.colorMap[colorKey]) {
            this.colorMap[colorKey] = {
                index: this.colorArray.length,
                rgbaColor: rgbaColor
            };
            this.colorArray.push(rgbaColor);
        }
        return this.colorMap[colorKey].index;
    }
    getPalette() {
        return {
            palette: new Uint8Array(this.colorArray.flat()),
            maxColor: this.colorArray.length - 1
        };
    }
}
function $b85abf0fe2345f80$var$convert(newColor) {
    const c = (0, $ef0b145002741ccf$export$78ed65bc9abd64b1)(newColor).slice(0, 3);
    return c.map((v)=>v / 255);
}
function $b85abf0fe2345f80$export$419c579437571e95(ref, colors) {
    if (!colors) return;
    const { config: config } = ref.core;
    config.activeColor = $b85abf0fe2345f80$var$convert(colors.activeItemColor);
    config.backgroundColor = new Float32Array($b85abf0fe2345f80$var$convert(colors.backgroundColor));
    config.textColor = $b85abf0fe2345f80$var$convert(colors.textColor);
    config.textBorderColor = $b85abf0fe2345f80$var$convert(colors.textBorderColor);
    config.axesTextColor = $b85abf0fe2345f80$var$convert(colors.axesTextLabelColor);
    config.axesGridBackgroundColor = $b85abf0fe2345f80$var$convert(colors.axesGridBackgroundColor);
    config.axesGridHighlightColor = $b85abf0fe2345f80$var$convert(colors.axesGridHighlightColor);
    config.axesGridMinorColor = $b85abf0fe2345f80$var$convert(colors.axesGridMinorColor);
    config.axesGridMajorColor = $b85abf0fe2345f80$var$convert(colors.axesGridMajorColor);
    config.axesGridZeroColor = $b85abf0fe2345f80$var$convert(colors.axesGridZeroColor);
    //TODO fix this - hack to reset the background color
    ref.core.renderer['_theme'] = null;
}


const $9241682e5783df33$var$key = 'cube';
const $9241682e5783df33$export$1858923cd0c63ab5 = (props)=>{
    const { ref: ref, stage: stage } = props;
    const { core: core } = ref;
    const scatter = new (0, $f35934b4176df23d$exports).Scatter(core);
    const { ids: ids, colors: colors, positionsX: positionsX, positionsY: positionsY, positionsZ: positionsZ, sizesX: sizesX, sizesY: sizesY, sizesZ: sizesZ, bounds: bounds, maxColor: maxColor, palette: palette } = $9241682e5783df33$var$convert(stage);
    if (!ids.length) return;
    const { renderer: renderer } = core;
    let cubeTransitionBuffer = renderer.transitionBuffers.find((t)=>t.key === $9241682e5783df33$var$key);
    if (!cubeTransitionBuffer) {
        cubeTransitionBuffer = renderer.createTransitionBuffer(ids);
        cubeTransitionBuffer.key = $9241682e5783df33$var$key;
        renderer.transitionBuffers.push(cubeTransitionBuffer);
    } else cubeTransitionBuffer.swap();
    scatter.layout(cubeTransitionBuffer.currentBuffer, ids, {
        positionsX: positionsX,
        positionsY: positionsY,
        positionsZ: positionsZ
    });
    const layer = {
        positionsX: positionsX,
        positionsY: positionsY,
        positionsZ: positionsZ,
        update: (newBounds, selected, stagger)=>{
            const { colors: colors, maxColor: maxColor, minColor: minColor, palette: palette } = layer.unitColorMap;
            // reference off of core.renderer to get the actual buffer
            const currCubeTransitionBuffer = core.renderer.transitionBuffers.find((t)=>t.key === $9241682e5783df33$var$key);
            currCubeTransitionBuffer.currentBuffer.unitType = (0, $4a6417d29706362f$export$80d48287646c9e3b).block;
            currCubeTransitionBuffer.currentPalette.colors = palette;
            let options = Object.assign({
                selected: selected,
                colors: colors,
                minColor: minColor,
                maxColor: maxColor,
                sizesX: sizesX,
                sizesY: sizesY,
                sizesZ: sizesZ
            }, newBounds);
            if (stagger === null || stagger === void 0 ? void 0 : stagger.staggerOrders) {
                const { maxStaggerOrder: maxStaggerOrder, minStaggerOrder: minStaggerOrder, staggerOrders: staggerOrders } = stagger;
                options = Object.assign(Object.assign({}, options), {
                    maxStaggerOrder: maxStaggerOrder,
                    minStaggerOrder: minStaggerOrder,
                    staggerOrders: staggerOrders
                });
            }
            scatter.update(currCubeTransitionBuffer.currentBuffer, ids, options);
        },
        bounds: bounds,
        unitColorMap: {
            colors: colors,
            ids: ids,
            minColor: 0,
            maxColor: maxColor,
            palette: palette
        }
    };
    return layer;
};
function $9241682e5783df33$var$convert(stage) {
    const { cubeData: cubeData } = stage;
    const { length: length } = cubeData;
    const ids = [];
    const colors = new Float64Array(length);
    const positionsX = new Float64Array(length);
    const positionsY = new Float64Array(length);
    const positionsZ = new Float64Array(length);
    const sizesX = new Float64Array(length);
    const sizesY = new Float64Array(length);
    const sizesZ = new Float64Array(length);
    let bounds;
    const colorMap = new (0, $b85abf0fe2345f80$export$7cefaad7e81641ff)();
    cubeData.forEach((cube, i)=>{
        ids.push(i);
        if (cube.isEmpty) {
            positionsX[i] = 0;
            positionsY[i] = 0;
            positionsZ[i] = 0;
            sizesX[i] = 0;
            sizesY[i] = 0;
            sizesZ[i] = 0;
            colors[i] = 0;
        } else {
            //ids.push(cube.ordinal);
            positionsX[i] = cube.position[0] + cube.size[0] * 0.5;
            positionsY[i] = cube.position[1] + cube.size[1] * 0.5;
            positionsZ[i] = cube.position[2] + cube.size[2] * 0.5;
            sizesX[i] = cube.size[0];
            sizesY[i] = cube.size[1];
            sizesZ[i] = cube.size[2];
            bounds = (0, $36f1cad8963ffaec$export$a2647aa13413c947)(bounds, cube.position[0], cube.position[1], cube.position[2], cube.position[0] + cube.size[0], cube.position[1] + cube.size[1], cube.position[2] + cube.size[2]);
            colors[i] = colorMap.registerColor(cube.color);
        }
    });
    const { palette: palette, maxColor: maxColor } = colorMap.getPalette();
    return {
        ids: new Uint32Array(ids),
        colors: colors,
        positionsX: positionsX,
        positionsY: positionsY,
        positionsZ: positionsZ,
        sizesX: sizesX,
        sizesY: sizesY,
        sizesZ: sizesZ,
        bounds: bounds,
        maxColor: maxColor,
        palette: palette
    };
}


/*!
* Copyright (c) Microsoft Corporation.
* Licensed under the MIT License.
*/ 


const $7ec432d4679a9501$var$key = 'line';
const $7ec432d4679a9501$export$9c2bb35a54d315bd = (props)=>{
    const { height: height, ref: ref, stage: stage, width: width } = props;
    const { core: core } = ref;
    const lines = new (0, $f35934b4176df23d$exports).Line(core);
    const { ids: ids, fromIds: fromIds, toIds: toIds, lineColors: lineColors, lineSizes: lineSizes, bounds: bounds, positionsX: positionsX, positionsY: positionsY, positionsZ: positionsZ, lineMaxColor: lineMaxColor, palette: palette } = $7ec432d4679a9501$var$convert(stage, height, width);
    if (!ids.length) return;
    const { renderer: renderer } = core;
    let lineTransitionBuffer = renderer.transitionBuffers.find((t)=>t.key === $7ec432d4679a9501$var$key);
    if (!lineTransitionBuffer) {
        lineTransitionBuffer = renderer.createTransitionBuffer(ids);
        lineTransitionBuffer.key = $7ec432d4679a9501$var$key;
        renderer.transitionBuffers.push(lineTransitionBuffer);
    } else lineTransitionBuffer.swap();
    lines.layout(lineTransitionBuffer.currentBuffer, ids, fromIds, toIds, {
        positionsX: positionsX,
        positionsY: positionsY,
        positionsZ: positionsZ,
        lineSizes: lineSizes,
        sizeScaling: 1
    });
    let options = {
        lineColors: lineColors,
        lineMinColor: 0,
        lineMaxColor: lineMaxColor
    };
    // Unit type
    lineTransitionBuffer.currentBuffer.unitType = (0, $4a6417d29706362f$export$80d48287646c9e3b).cylinder;
    lineTransitionBuffer.currentPalette.colors = palette;
    return {
        update: (newBounds)=>{
            options = Object.assign(Object.assign({}, options), newBounds);
            // reference off of core.renderer to get the actual buffer
            const currLineTransitionBuffer = core.renderer.transitionBuffers.find((t)=>t.key === $7ec432d4679a9501$var$key);
            lines.update(currLineTransitionBuffer.currentBuffer, ids, fromIds, toIds, options);
        },
        bounds: bounds,
        unitColorMap: {
            ids: ids,
            colors: lineColors,
            minColor: 0,
            maxColor: lineMaxColor,
            palette: palette
        }
    };
};
function $7ec432d4679a9501$var$convert(stage, height, width) {
    const { pathData: pathData } = stage;
    const positions = [];
    const lines = [];
    const colorMap = new (0, $b85abf0fe2345f80$export$7cefaad7e81641ff)();
    pathData.forEach((path)=>{
        const color = colorMap.registerColor(path.strokeColor);
        let from = positions.length;
        positions.push(path.positions[0]);
        for(let i = 1; i < path.positions.length; i++){
            const to = positions.length;
            positions.push(path.positions[i]);
            lines.push({
                id: lines.length,
                from: from,
                to: to,
                color: color,
                size: path.strokeWidth
            });
            from = to;
        }
    });
    const ids = new Uint32Array(lines.length);
    const fromIds = new Uint32Array(lines.length);
    const toIds = new Uint32Array(lines.length);
    const lineColors = new Float64Array(lines.length);
    const lineSizes = new Float64Array(lines.length);
    lines.forEach((line, i)=>{
        ids[i] = i;
        fromIds[i] = line.from;
        toIds[i] = line.to;
        lineColors[i] = line.color;
        lineSizes[i] = line.size;
    });
    const positionsX = new Float64Array(positions.length);
    const positionsY = new Float64Array(positions.length);
    const positionsZ = new Float64Array(positions.length);
    let bounds;
    positions.forEach((p, i)=>{
        positionsX[i] = p[0];
        positionsY[i] = p[1] + height;
        positionsZ[i] = p[2];
        bounds = (0, $36f1cad8963ffaec$export$a2647aa13413c947)(bounds, positionsX[i], positionsY[i], positionsZ[i], positionsX[i], positionsY[i], positionsZ[i]);
    });
    const { palette: palette, maxColor: lineMaxColor } = colorMap.getPalette();
    return {
        ids: ids,
        fromIds: fromIds,
        toIds: toIds,
        lineColors: lineColors,
        lineSizes: lineSizes,
        bounds: bounds,
        positionsX: positionsX,
        positionsY: positionsY,
        positionsZ: positionsZ,
        lineMaxColor: lineMaxColor,
        palette: palette
    };
}


/*!
* Copyright (c) Microsoft Corporation.
* Licensed under the MIT License.
*/ 


const $ee7c2c84baff3529$export$bbc48f7bb3ba03ac = (props)=>{
    const { ref: ref, stage: stage } = props;
    const { core: core } = ref;
    const { positionsX: positionsX, positionsY: positionsY, positionsZ: positionsZ, sizes: sizes, bounds: bounds, maxGlyphs: maxGlyphs, text: text } = $ee7c2c84baff3529$var$convert(stage);
    if (text.length === 0) {
        core.renderer.labelSets = [];
        return;
    }
    const options = {
        text: text,
        maxGlyphs: maxGlyphs,
        scales: sizes
    };
    const labelSet = new (0, $8fe9a403f3311664$exports).LabelSet(core, options);
    labelSet.positionsX = positionsX;
    labelSet.positionsY = positionsY;
    labelSet.positionsZ = positionsZ;
    labelSet.horizontalAlignment = (0, $4a6417d29706362f$export$d94dcb5bec64086e).center;
    labelSet.verticalAlignment = (0, $4a6417d29706362f$export$c12e835f91722ef8).center;
    const layer = {
        update: (bounds)=>{
            const { maxBoundsX: maxBoundsX, maxBoundsY: maxBoundsY, maxBoundsZ: maxBoundsZ, minBoundsX: minBoundsX, minBoundsY: minBoundsY, minBoundsZ: minBoundsZ } = bounds;
            labelSet.minBoundsX = minBoundsX;
            labelSet.minBoundsY = minBoundsY;
            labelSet.minBoundsZ = minBoundsZ;
            labelSet.maxBoundsX = maxBoundsX;
            labelSet.maxBoundsY = maxBoundsY;
            labelSet.maxBoundsZ = maxBoundsZ;
        },
        bounds: bounds
    };
    const labelSetVisual = core.renderer.createLabelSetVisual(labelSet);
    core.renderer.labelSets = [
        labelSetVisual
    ];
    return layer;
};
function $ee7c2c84baff3529$var$convert(stage) {
    const { textData: textData } = stage;
    const { length: length } = textData;
    const ids = [];
    const text = [];
    const colors = new Float64Array(length);
    const positionsX = new Float64Array(length);
    const positionsY = new Float64Array(length);
    const positionsZ = new Float64Array(length);
    const sizes = new Float64Array(length);
    let bounds;
    let maxGlyphs = 0;
    const colorMap = new (0, $b85abf0fe2345f80$export$7cefaad7e81641ff)();
    textData.forEach((t, i)=>{
        ids.push(i);
        text.push(t.text);
        maxGlyphs += t.text.length;
        positionsX[i] = t.position[0];
        positionsY[i] = t.position[1];
        positionsZ[i] = t.position[2];
        sizes[i] = 1.5 * t.size; //scale similar to axes
        bounds = (0, $36f1cad8963ffaec$export$a2647aa13413c947)(bounds, t.position[0], t.position[1], t.position[2], t.position[0], t.position[1], t.position[2]);
        colors[i] = colorMap.registerColor(t.color);
    });
    const { palette: palette, maxColor: maxColor } = colorMap.getPalette();
    return {
        ids: new Uint32Array(ids),
        colors: colors,
        positionsX: positionsX,
        positionsY: positionsY,
        positionsZ: positionsZ,
        sizes: sizes,
        bounds: bounds,
        maxColor: maxColor,
        maxGlyphs: maxGlyphs,
        palette: palette,
        text: text
    };
}


/*!
* Copyright (c) Microsoft Corporation.
* Licensed under the MIT License.
*/ 
function $e8568da1cd4c527e$export$d93c68e129326488(url) {
    return new Promise((resolve, reject)=>{
        const imageElement = document.createElement('img');
        imageElement.onload = ()=>{
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            const { height: height, width: width } = imageElement;
            canvas.width = width;
            canvas.height = height;
            ctx.drawImage(imageElement, 0, 0);
            resolve(ctx.getImageData(0, 0, width, height));
        };
        imageElement.src = url;
    });
}
function $e8568da1cd4c527e$export$9d5d32bc62ddf581(core, imageData, bounds, position, width, height) {
    const { maxBoundsX: maxBoundsX, maxBoundsY: maxBoundsY, maxBoundsZ: maxBoundsZ, minBoundsX: minBoundsX, minBoundsY: minBoundsY, minBoundsZ: minBoundsZ } = bounds;
    const imageOptions = {
        imageData: imageData,
        position: position,
        height: height,
        width: width,
        minBoundsX: minBoundsX,
        maxBoundsX: maxBoundsX,
        minBoundsZ: minBoundsZ,
        maxBoundsZ: maxBoundsZ,
        minBoundsY: minBoundsY,
        maxBoundsY: maxBoundsY
    };
    return new (0, $8fe9a403f3311664$exports).ImageQuad(core, imageOptions);
}




/*!
* Copyright (c) Microsoft Corporation.
* Licensed under the MIT License.
*/ 

function $2d7c211c29fc4124$var$createCameraDefaults() {
    const qModelRotation2d = (0, $39ece26d1239bb77$exports).create();
    const qModelRotation3d = (0, $d4d7bd6cc65a5081$export$a002182e51710d39).QUAT_ROTATEX_MINUS_90;
    const qCameraRotation2d = (0, $39ece26d1239bb77$exports).create();
    const qCameraRotation3d = (0, $39ece26d1239bb77$exports).create();
    const qAngle = (0, $39ece26d1239bb77$exports).create();
    const vCameraPosition = (0, $31054a6c69637582$exports).create();
    // Altitude (pitch around local right axis)
    (0, $39ece26d1239bb77$exports).setAxisAngle(qCameraRotation3d, (0, $d4d7bd6cc65a5081$export$a002182e51710d39).VECTOR3_UNITX, (0, $92f02b8a0655b486$exports).AngleHelper.degreesToRadians(30));
    // Azimuth (yaw around global up axis)
    (0, $39ece26d1239bb77$exports).setAxisAngle(qAngle, (0, $d4d7bd6cc65a5081$export$a002182e51710d39).VECTOR3_UNITY, (0, $92f02b8a0655b486$exports).AngleHelper.degreesToRadians(-25));
    (0, $39ece26d1239bb77$exports).multiply(qCameraRotation3d, qCameraRotation3d, qAngle);
    return {
        qModelRotation2d: qModelRotation2d,
        qModelRotation3d: qModelRotation3d,
        qCameraRotation2d: qCameraRotation2d,
        qCameraRotation3d: qCameraRotation3d,
        vCameraPosition: vCameraPosition
    };
}
const $2d7c211c29fc4124$export$504e5adc1166f08a = $2d7c211c29fc4124$var$createCameraDefaults();


/*!
* Copyright (c) Microsoft Corporation.
* Licensed under the MIT License.
*/ 


const { qCameraRotation2d: $10880856df36f20b$var$qCameraRotation2d, qCameraRotation3d: $10880856df36f20b$var$qCameraRotation3d, qModelRotation2d: $10880856df36f20b$var$qModelRotation2d, qModelRotation3d: $10880856df36f20b$var$qModelRotation3d, vCameraPosition: $10880856df36f20b$var$vCameraPosition } = (0, $2d7c211c29fc4124$export$504e5adc1166f08a);
function $10880856df36f20b$export$21ad5731ba175a64(ref, lastPresenterConfig, lastView, transistion2dOnly) {
    const { cameraTransitioner: cameraTransitioner, core: core, modelTransitioner: modelTransitioner, positionTransitioner: positionTransitioner } = ref;
    ref.reset = ()=>{
        core.reset(true);
        if (lastView === '3d') {
            modelTransitioner.qRotation.to = $10880856df36f20b$var$qModelRotation3d;
            cameraTransitioner.qRotation.to = $10880856df36f20b$var$qCameraRotation3d;
            cameraTransitioner.vPosition.to = $10880856df36f20b$var$vCameraPosition;
        } else {
            modelTransitioner.qRotation.to = $10880856df36f20b$var$qModelRotation2d;
            cameraTransitioner.qRotation.to = $10880856df36f20b$var$qCameraRotation2d;
            cameraTransitioner.vPosition.to = $10880856df36f20b$var$vCameraPosition;
        }
        (0, $39ece26d1239bb77$exports).slerp(modelTransitioner.qRotation.current, modelTransitioner.qRotation.to, modelTransitioner.qRotation.to, 0);
        core.setModelRotation(modelTransitioner.qRotation.current, true);
        core.camera.setOrbit(cameraTransitioner.qRotation.to, true);
        core.camera.setPosition(cameraTransitioner.vPosition.to, true);
    };
    const cam = (t)=>{
        (0, $39ece26d1239bb77$exports).slerp(cameraTransitioner.qRotation.current, cameraTransitioner.qRotation.from, cameraTransitioner.qRotation.to, t);
        (0, $31054a6c69637582$exports).lerp(cameraTransitioner.vPosition.current, cameraTransitioner.vPosition.from, cameraTransitioner.vPosition.to, t);
        core.camera.setOrbit(cameraTransitioner.qRotation.current, false);
        core.camera.setPosition(cameraTransitioner.vPosition.current, false);
        // disable picking during transitions, as the performance degradation could reduce the framerate
        core.inputManager.isPickingEnabled = false;
    };
    core.updateCallback = (elapsedTime)=>{
        const { transitionDurations: transitionDurations } = lastPresenterConfig;
        if (positionTransitioner.isTransitioning) {
            const t = positionTransitioner.elapse(elapsedTime, transitionDurations.position + transitionDurations.stagger);
            core.renderer.transitionTime = t;
            $10880856df36f20b$export$7e9aa6bed81b6dc3(transistion2dOnly, core);
        } else core.inputManager.isPickingEnabled = true;
        if (modelTransitioner.isTransitioning) {
            const tm = modelTransitioner.elapse(elapsedTime, transitionDurations.view, true);
            if (modelTransitioner.shouldTransition) {
                (0, $39ece26d1239bb77$exports).slerp(modelTransitioner.qRotation.current, modelTransitioner.qRotation.from, modelTransitioner.qRotation.to, tm);
                core.setModelRotation(modelTransitioner.qRotation.current, false);
            }
            cam(tm);
        }
        if (cameraTransitioner.isTransitioning) {
            const t = cameraTransitioner.elapse(elapsedTime, transitionDurations.view, true);
            cam(t);
        }
    };
}
function $10880856df36f20b$export$7e9aa6bed81b6dc3(transistion2dOnly, core) {
    const t = core.renderer.transitionTime;
    if (transistion2dOnly) {
        if (t < 0.5) core.renderer.axesVisibility = (0, $4a6417d29706362f$export$7dbc7c2b82487e42).previous;
        else core.renderer.axesVisibility = (0, $4a6417d29706362f$export$7dbc7c2b82487e42).current;
    } else {
        if (t <= 0.01) core.renderer.axesVisibility = (0, $4a6417d29706362f$export$7dbc7c2b82487e42).previous;
        else if (t >= 0.99) core.renderer.axesVisibility = (0, $4a6417d29706362f$export$7dbc7c2b82487e42).current;
        else core.renderer.axesVisibility = (0, $4a6417d29706362f$export$7dbc7c2b82487e42).none;
    }
}


function $1b83ab2bb6ce8534$export$bd1c7209c525d9d0(ref, prevStage, stage, height, width, preStage, colors, config) {
    const { qCameraRotation2d: qCameraRotation2d, qCameraRotation3d: qCameraRotation3d, qModelRotation2d: qModelRotation2d, qModelRotation3d: qModelRotation3d, vCameraPosition: vCameraPosition } = (0, $2d7c211c29fc4124$export$504e5adc1166f08a);
    const { core: core, cameraTransitioner: cameraTransitioner, modelTransitioner: modelTransitioner, positionTransitioner: positionTransitioner } = ref;
    let transistion2dOnly = false;
    let cameraTo;
    let holdCamera;
    if (config.camera === 'hold') holdCamera = true;
    else cameraTo = config.camera;
    if (prevStage && prevStage.view !== stage.view) {
        modelTransitioner.shouldTransition = !holdCamera;
        if (stage.view === '2d') {
            modelTransitioner.qRotation.from = qModelRotation3d;
            modelTransitioner.qRotation.to = qModelRotation2d;
            cameraTransitioner.qRotation.to = (cameraTo === null || cameraTo === void 0 ? void 0 : cameraTo.rotation) || qCameraRotation2d;
            cameraTransitioner.vPosition.to = (cameraTo === null || cameraTo === void 0 ? void 0 : cameraTo.position) || vCameraPosition;
        } else {
            modelTransitioner.qRotation.from = qModelRotation2d;
            modelTransitioner.qRotation.to = qModelRotation3d;
            cameraTransitioner.qRotation.to = (cameraTo === null || cameraTo === void 0 ? void 0 : cameraTo.rotation) || qCameraRotation3d;
            cameraTransitioner.vPosition.to = (cameraTo === null || cameraTo === void 0 ? void 0 : cameraTo.position) || vCameraPosition;
        }
    } else {
        modelTransitioner.shouldTransition = false;
        if (stage.view === '2d') {
            transistion2dOnly = true;
            modelTransitioner.qRotation.to = qModelRotation2d;
            cameraTransitioner.qRotation.to = (cameraTo === null || cameraTo === void 0 ? void 0 : cameraTo.rotation) || qCameraRotation2d;
            cameraTransitioner.vPosition.to = (cameraTo === null || cameraTo === void 0 ? void 0 : cameraTo.position) || vCameraPosition;
        } else {
            modelTransitioner.qRotation.to = qModelRotation3d;
            cameraTransitioner.qRotation.to = (cameraTo === null || cameraTo === void 0 ? void 0 : cameraTo.rotation) || qCameraRotation3d;
            cameraTransitioner.vPosition.to = (cameraTo === null || cameraTo === void 0 ? void 0 : cameraTo.position) || vCameraPosition;
        }
    }
    core.camera.getOrbit(cameraTransitioner.qRotation.from);
    core.camera.getPosition(cameraTransitioner.vPosition.from);
    if (!prevStage) {
        core.setModelRotation(modelTransitioner.qRotation.to, false);
        core.camera.setOrbit(cameraTransitioner.qRotation.to, false);
        core.camera.setPosition(cameraTransitioner.vPosition.to, false);
    } else if (!holdCamera) cameraTransitioner.begin();
    positionTransitioner.begin();
    if (modelTransitioner.shouldTransition) modelTransitioner.begin();
    const props = {
        ref: ref,
        stage: stage,
        height: height,
        width: width,
        config: config
    };
    const cubeLayer = (0, $9241682e5783df33$export$1858923cd0c63ab5)(props);
    const lineLayer = (0, $7ec432d4679a9501$export$9c2bb35a54d315bd)(props);
    const textLayer = (0, $ee7c2c84baff3529$export$bbc48f7bb3ba03ac)(props);
    const { backgroundImages: backgroundImages } = stage;
    let contentBounds = (0, $36f1cad8963ffaec$export$b1d52f954c5faa57)((0, $36f1cad8963ffaec$export$b1d52f954c5faa57)(cubeLayer === null || cubeLayer === void 0 ? void 0 : cubeLayer.bounds, lineLayer === null || lineLayer === void 0 ? void 0 : lineLayer.bounds), (0, $36f1cad8963ffaec$export$b1d52f954c5faa57)(textLayer === null || textLayer === void 0 ? void 0 : textLayer.bounds, null));
    backgroundImages === null || backgroundImages === void 0 || backgroundImages.forEach((backgroundImage)=>{
        contentBounds = (0, $36f1cad8963ffaec$export$b1d52f954c5faa57)(contentBounds, $1b83ab2bb6ce8534$var$convertBounds(backgroundImage.bounds));
    });
    props.bounds = contentBounds;
    core.renderer.previousAxes = core.renderer.currentAxes;
    const axesLayer = (0, $81bc6306df670951$export$b820fac18d588132)(props);
    core.config.transitionStaggering = config.transitionDurations.stagger;
    core.config.transitionDuration = config.transitionDurations.position;
    let bounds;
    if (axesLayer && axesLayer.bounds) bounds = axesLayer.bounds;
    else bounds = contentBounds;
    ref.setMorphChartsRendererOptions(config.renderer);
    if (preStage) preStage(stage, cubeLayer);
    //add images
    core.renderer.images = [];
    if (backgroundImages) {
        const addImage = (imageBounds, imageData)=>{
            const imageWidth = imageBounds.maxBoundsX - imageBounds.minBoundsX;
            const imageHeight = imageBounds.maxBoundsY - imageBounds.minBoundsY;
            const position = [
                imageBounds.minBoundsX + imageWidth / 2,
                imageBounds.minBoundsY + imageHeight / 2,
                0
            ];
            const imageQuad = (0, $e8568da1cd4c527e$export$9d5d32bc62ddf581)(core, imageData, contentBounds, position, imageWidth, imageHeight);
            const imageVisual = core.renderer.createImageVisual(imageQuad);
            core.renderer.images.push(imageVisual);
        };
        const imageDataCache = {};
        backgroundImages.forEach((backgroundImage)=>{
            const imageBounds = $1b83ab2bb6ce8534$var$convertBounds(backgroundImage.bounds);
            const imageData = imageDataCache[backgroundImage.url];
            if (imageData) addImage(imageBounds, imageData);
            else (0, $e8568da1cd4c527e$export$d93c68e129326488)(backgroundImage.url).then((imageData)=>{
                imageDataCache[backgroundImage.url] = imageData;
                addImage(imageBounds, imageData);
            });
        });
    }
    //Now call update on each layout
    $1b83ab2bb6ce8534$var$layersWithSelection(cubeLayer, lineLayer, textLayer, config.layerSelection, bounds, ref.layerStagger);
    (0, $10880856df36f20b$export$21ad5731ba175a64)(ref, config, stage.view, transistion2dOnly);
    core.renderer.transitionTime = 0; // Set renderer transition time for this render pass to prevent rendering target buffer for single frame
    (0, $b85abf0fe2345f80$export$419c579437571e95)(ref, colors);
    return {
        bounds: bounds,
        getCubeLayer: ()=>cubeLayer,
        update: (layerSelection)=>$1b83ab2bb6ce8534$var$layersWithSelection(cubeLayer, lineLayer, textLayer, layerSelection, bounds, ref.layerStagger),
        activate: (id)=>core.renderer.transitionBuffers[0].activeId = id,
        moveCamera: (camera)=>{
            if (!(positionTransitioner.isTransitioning || modelTransitioner.isTransitioning)) {
                core.camera.getOrbit(cameraTransitioner.qRotation.from);
                core.camera.getPosition(cameraTransitioner.vPosition.from);
                cameraTransitioner.move(camera.position, camera.rotation);
            }
        },
        setTransitionTimeAxesVisibility: ()=>{
            (0, $10880856df36f20b$export$7e9aa6bed81b6dc3)(transistion2dOnly, core);
        }
    };
}
function $1b83ab2bb6ce8534$var$layersWithSelection(cubeLayer, lineLayer, textLayer, layerSelection, bounds, layerStagger) {
    const layerItems = [
        {
            layer: cubeLayer,
            selection: layerSelection === null || layerSelection === void 0 ? void 0 : layerSelection.cubes,
            stagger: layerStagger === null || layerStagger === void 0 ? void 0 : layerStagger.cubes
        },
        {
            layer: lineLayer,
            selection: layerSelection === null || layerSelection === void 0 ? void 0 : layerSelection.lines,
            stagger: layerStagger === null || layerStagger === void 0 ? void 0 : layerStagger.lines
        },
        {
            layer: textLayer,
            selection: layerSelection === null || layerSelection === void 0 ? void 0 : layerSelection.texts,
            stagger: layerStagger === null || layerStagger === void 0 ? void 0 : layerStagger.texts
        }
    ];
    layerItems.forEach((layerItem)=>{
        var _a;
        return (_a = layerItem.layer) === null || _a === void 0 ? void 0 : _a.update(bounds, layerItem.selection, layerItem.stagger);
    });
}
function $1b83ab2bb6ce8534$var$convertBounds(bounds) {
    if (!bounds) return;
    return {
        minBoundsX: bounds.x1,
        maxBoundsX: bounds.x2,
        minBoundsY: -bounds.y2,
        maxBoundsY: -bounds.y1,
        minBoundsZ: (0, $a2698ea08ecf5377$export$ce94e349d95a214c),
        maxBoundsZ: (0, $a2698ea08ecf5377$export$ce94e349d95a214c)
    };
}



/*!
* Copyright (c) Microsoft Corporation.
* Licensed under the MIT License.
*/ 
/*!
* Copyright (c) Microsoft Corporation.
* Licensed under the MIT License.
*/ 
function $d8003eaa8f8e4cc9$export$9d095798a92180d1(prev, next) {
    var _a, _b;
    if (!prev || !next) return true;
    if (prev.advanced !== next.advanced) return true;
    if (!prev.advanced) return ((_a = prev.basicOptions) === null || _a === void 0 ? void 0 : _a.antialias) != ((_b = next.basicOptions) === null || _b === void 0 ? void 0 : _b.antialias);
}
function $d8003eaa8f8e4cc9$export$4aa259f2a0167a49(mcRendererOptions, core) {
    const advanced = mcRendererOptions === null || mcRendererOptions === void 0 ? void 0 : mcRendererOptions.advanced;
    const r = advanced ? new (0, $2d9c5cad0d6d7650$exports).Advanced.Main() : new (0, $2d9c5cad0d6d7650$exports).Basic.Main(mcRendererOptions === null || mcRendererOptions === void 0 ? void 0 : mcRendererOptions.basicOptions);
    core.renderer = r;
    $d8003eaa8f8e4cc9$export$cfea0671ae41cdf(r, mcRendererOptions);
    return r;
}
function $d8003eaa8f8e4cc9$export$cfea0671ae41cdf(renderer, mcRendererOptions) {
    const o = mcRendererOptions === null || mcRendererOptions === void 0 ? void 0 : mcRendererOptions.advancedOptions;
    if ((mcRendererOptions === null || mcRendererOptions === void 0 ? void 0 : mcRendererOptions.advanced) && o) for(const key in o)renderer.config[key] = o[key];
}
function $d8003eaa8f8e4cc9$export$12cca049a4826e61(advanced) {
    const r = advanced ? new (0, $2d9c5cad0d6d7650$exports).Advanced.Main() : new (0, $2d9c5cad0d6d7650$exports).Basic.Main();
    return r.isSupported;
}


/*!
* Copyright (c) Microsoft Corporation.
* Licensed under the MIT License.
*/ 
const $683c1da9288101c3$var$rightButton = 2;
function $683c1da9288101c3$export$63db8d52413993da(core, options) {
    const { container: container, pickGridCallback: pickGridCallback } = options;
    const { inputManager: inputManager } = core;
    if (options.onLasso) inputManager.pickLassoCallback = (result)=>{
        options.onLasso(result.ids[0], result.manipulator.event);
    };
    inputManager.singleTouchAction = (manipulator)=>{
        if (manipulator.button == $683c1da9288101c3$var$rightButton || manipulator.shiftKey || manipulator.ctrlKey) return (0, $4a6417d29706362f$export$226dc1249c607930).rotate;
        else if (manipulator.altKey) return (0, $4a6417d29706362f$export$226dc1249c607930).lasso;
        else return (0, $4a6417d29706362f$export$226dc1249c607930).translate;
    };
    inputManager.pickAxesGridCallback = ({ divisionX: divisionX, divisionY: divisionY, divisionZ: divisionZ, manipulator: manipulator })=>{
        clearClickTimeout();
        const { altKey: altKey, button: button, shiftKey: shiftKey } = manipulator;
        const me = {
            altKey: altKey,
            shiftKey: shiftKey,
            button: button
        };
        const e = me;
        pickGridCallback([
            divisionX,
            divisionY,
            divisionZ
        ], e);
    };
    const canvas = container.getElementsByTagName('canvas')[0];
    let pickedId;
    const hover = (e)=>{
        if (core.renderer.pickedId !== pickedId) {
            pickedId = core.renderer.pickedId;
            const ordinal = core.renderer.transitionBuffers[0].pickIdLookup[pickedId];
            options.onCubeHover(e, ordinal);
        }
    };
    canvas.addEventListener('mousemove', (e)=>{
        clearClickTimeout();
        if (mousedown) options.onCubeHover(e, null);
        hover(e);
    });
    canvas.addEventListener('mouseout', hover);
    canvas.addEventListener('mouseover', hover);
    let mousedown;
    canvas.addEventListener('mousedown', ()=>{
        mousedown = true;
    });
    canvas.addEventListener('mouseup', (e)=>{
        mousedown = false;
    });
    let canvasClickTimeout;
    const clearClickTimeout = ()=>{
        clearTimeout(canvasClickTimeout);
        canvasClickTimeout = null;
    };
    canvas.addEventListener('click', (e)=>{
        canvasClickTimeout = setTimeout(()=>{
            options.onCanvasClick(e);
        }, 50);
    });
    inputManager.pickItemCallback = ({ manipulator: manipulator })=>{
        clearClickTimeout();
        const ordinal = core.renderer.transitionBuffers[0].pickIdLookup[pickedId];
        options.onCubeClick(manipulator.event, ordinal);
    };
}


/*!
* Copyright (c) Microsoft Corporation.
* Licensed under the MIT License.
*/ 
/*!
* Copyright (c) Microsoft Corporation.
* Licensed under the MIT License.
*/ function $330562a1521921df$export$b1a09cb1b71f86aa(t) {
    return t * t * t;
}
function $330562a1521921df$export$68d528839c701b6(t) {
    return --t * t * t + 1;
}
function $330562a1521921df$export$89238d3bc79d3ada(t) {
    return ((t *= 2) <= 1 ? t * t * t : (t -= 2) * t * t + 2) / 2;
}


function $b5dc14ede53105b0$export$24c5ac7c37452e7d(t) {
    if (t === 0 || t === 1) return t;
    return (0, $330562a1521921df$export$89238d3bc79d3ada)(t);
}


class $94a3b4c744fcf3db$export$935eb9f0b5d28fbb {
    constructor(){
        this.isTransitioning = false;
    }
    begin() {
        this.isTransitioning = true;
        this.time = 0;
    }
    elapse(elapsedTime, totalTime, ease = false) {
        this.time += elapsedTime;
        if (this.time >= totalTime) {
            this.isTransitioning = false;
            this.time = totalTime;
            this.ended && this.ended();
        }
        const t = this.time / totalTime;
        return ease ? (0, $b5dc14ede53105b0$export$24c5ac7c37452e7d)(t) : t;
    }
}
class $94a3b4c744fcf3db$export$8498d8ad19b48a8b extends $94a3b4c744fcf3db$export$935eb9f0b5d28fbb {
    constructor(){
        super();
        this.qRotation = {
            from: (0, $39ece26d1239bb77$exports).create(),
            to: null,
            current: (0, $39ece26d1239bb77$exports).create()
        };
        this.vPosition = {
            from: (0, $31054a6c69637582$exports).create(),
            to: null,
            current: (0, $31054a6c69637582$exports).create()
        };
    }
    move(position, rotation) {
        this.begin();
        this.qRotation.to = rotation;
        this.vPosition.to = position;
    }
}
class $94a3b4c744fcf3db$export$e4008bc37533ca62 extends $94a3b4c744fcf3db$export$935eb9f0b5d28fbb {
    constructor(){
        super();
        this.shouldTransition = false;
        this.qRotation = {
            from: null,
            to: null,
            current: (0, $39ece26d1239bb77$exports).create()
        };
    }
}


function $77dc6121b64606a8$export$2cd8252107eb640b(options, mcRendererOptions) {
    const { container: container } = options;
    const core = new (0, $4a6417d29706362f$export$4143ab5b91744744)({
        container: container
    });
    (0, $d8003eaa8f8e4cc9$export$4aa259f2a0167a49)(mcRendererOptions, core);
    (0, $683c1da9288101c3$export$63db8d52413993da)(core, options);
    core.config.pickSelectDelay = 50;
    const cameraTransitioner = new (0, $94a3b4c744fcf3db$export$8498d8ad19b48a8b)();
    const modelTransitioner = new (0, $94a3b4c744fcf3db$export$e4008bc37533ca62)();
    const positionTransitioner = new (0, $94a3b4c744fcf3db$export$935eb9f0b5d28fbb)();
    positionTransitioner.ended = ()=>{
        core.renderer.axesVisibility = (0, $4a6417d29706362f$export$7dbc7c2b82487e42).current;
    };
    const ref = {
        supportedRenders: {
            advanced: (0, $d8003eaa8f8e4cc9$export$12cca049a4826e61)(true),
            basic: (0, $d8003eaa8f8e4cc9$export$12cca049a4826e61)(false)
        },
        reset: null,
        cameraTransitioner: cameraTransitioner,
        modelTransitioner: modelTransitioner,
        positionTransitioner: positionTransitioner,
        core: core,
        setMorphChartsRendererOptions (mcRendererOptions) {
            if ((0, $d8003eaa8f8e4cc9$export$9d095798a92180d1)(ref.lastMorphChartsRendererOptions, mcRendererOptions)) {
                (0, $d8003eaa8f8e4cc9$export$4aa259f2a0167a49)(mcRendererOptions, core);
                (0, $683c1da9288101c3$export$63db8d52413993da)(core, options);
            } else if (mcRendererOptions.advanced) //same renderer, poke the config
            (0, $d8003eaa8f8e4cc9$export$cfea0671ae41cdf)(core.renderer, mcRendererOptions);
            ref.lastMorphChartsRendererOptions = mcRendererOptions;
        },
        lastMorphChartsRendererOptions: mcRendererOptions,
        layerStagger: {}
    };
    return ref;
}




class $6dfc103fcb41a0e6$export$893c88c42e3630f9 {
    /**
     * Get the previously rendered Stage object.
     */ get stage() {
        return this._last.stage;
    }
    /**
     * Get the current View camera type.
     */ get view() {
        return this._last.view;
    }
    /**
     * Instantiate a new Presenter.
     * @param el Parent HTMLElement to present within.
     * @param style Optional PresenterStyle styling options.
     */ constructor(el, style){
        this.el = el;
        this.style = (0, $97d77b6293df43c2$export$6969335ea1e4e77c)((0, $a2698ea08ecf5377$export$83ac8f5ae8122afc), style);
        (0, $a1265428470a4521$export$ba5a93ad8642dce4)(this);
        this._last = {
            view: null,
            height: null,
            width: null,
            cubeCount: null,
            stage: null
        };
    }
    /**
     * Cancels any pending animation, calling animationCanceled() on original queue.
     */ animationCancel() {
        if (this.animationTimer) {
            clearTimeout(this.animationTimer);
            this.animationTimer = null;
            if (this.logger) this.logger(`canceling animation ${this.queuedAnimationOptions && this.queuedAnimationOptions.handlerLabel || 'handler'}`);
            if (this.queuedAnimationOptions && this.queuedAnimationOptions.animationCanceled) this.queuedAnimationOptions.animationCanceled.call(null);
        }
    }
    /**
     * Stops the current animation and queues a new animation.
     * @param handler Function to invoke when timeout is complete.
     * @param timeout Length of time to wait before invoking the handler.
     * @param options Optional QueuedAnimationOptions object.
     */ animationQueue(handler, timeout, options) {
        if (this.logger) this.logger(`queueing animation ${options && options.waitingLabel || 'waiting'}...(${timeout})`);
        this.animationCancel();
        this.animationTimer = setTimeout(()=>{
            if (this.logger) this.logger(`queueing animation ${options && options.handlerLabel || 'handler'}...`);
            handler();
        }, timeout);
    }
    /**
     * Retrieve a sub-element of the rendered output.
     * @param type PresenterElement type of the HTMLElement to retrieve.
     */ getElement(type) {
        const elements = this.el.getElementsByClassName((0, $a1265428470a4521$export$2913c0c0b5623090)(type, this));
        if (elements && elements.length) return elements[0];
    }
    /**
     * Present the Vega Scene, or Stage object using Morphcharts.
     * @param sceneOrStage Vega Scene object, or Stage object containing chart layout info.
     * @param height Height of the rendering area.
     * @param width Width of the rendering area.
     * @param config Optional presentation configuration object.
     */ present(sceneOrStage, height, width, config) {
        this.animationCancel();
        const scene = sceneOrStage;
        let stage;
        const options = {
            maxOrdinal: 0,
            currAxis: null,
            defaultCubeColor: this.style.defaultCubeColor,
            assignCubeOrdinal: config && config.onSceneRectAssignCubeOrdinal || (()=>options.maxOrdinal++),
            modifyAxis: (config === null || config === void 0 ? void 0 : config.onAxisItem) ? config.onAxisItem : (0, $a2698ea08ecf5377$export$f66a5ef821fcc5df),
            zAxisZindex: config === null || config === void 0 ? void 0 : config.zAxisZindex
        };
        //determine if this is a vega scene
        if (scene.marktype) {
            stage = (0, $a2698ea08ecf5377$export$afa8810fbe5c2601)(scene.view);
            (0, $684c20b0d21986c1$export$d78988dba6734aaa)(options, stage, scene);
        } else stage = sceneOrStage;
        const c = (0, $97d77b6293df43c2$export$6969335ea1e4e77c)((0, $a2698ea08ecf5377$export$200f593236aebbdc), config);
        if (!this.morphchartsref) {
            this._morphChartsOptions = {
                container: this.getElement((0, $57337365aaceccbe$export$79420be32f83a5b0).gl),
                pickGridCallback: c.axisPickGridCallback,
                onCubeHover: (e, ordinal)=>{
                    c.onCubeHover(e, {
                        ordinal: ordinal,
                        color: null,
                        position: null,
                        size: null
                    });
                },
                onCubeClick: (e, ordinal)=>{
                    c.onCubeClick(e, {
                        ordinal: ordinal,
                        color: null,
                        position: null,
                        size: null
                    });
                },
                onCanvasClick: config === null || config === void 0 ? void 0 : config.onLayerClick,
                onLasso: config === null || config === void 0 ? void 0 : config.onLasso
            };
            this.morphchartsref = (0, $77dc6121b64606a8$export$2cd8252107eb640b)(this._morphChartsOptions, c.renderer || (0, $a2698ea08ecf5377$export$200f593236aebbdc).renderer);
        }
        let cubeCount = Math.max(this._last.cubeCount, stage.cubeData.length);
        if (options.maxOrdinal) {
            cubeCount = Math.max(cubeCount, options.maxOrdinal);
            const empty = {
                isEmpty: true
            };
            stage.cubeData = (0, $532135db04b63f4f$export$9a79ca9001afcc6d)(cubeCount, empty, stage.cubeData);
        }
        config.preLayer && config.preLayer(stage);
        this.morphChartsRenderResult = (0, $1b83ab2bb6ce8534$export$bd1c7209c525d9d0)(this.morphchartsref, this._last.stage, stage, height, width, config && config.preStage, config && config.morphChartsColors, c);
        delete stage.cubeData;
        delete stage.redraw;
        this._last = {
            cubeCount: cubeCount,
            height: height,
            width: width,
            stage: stage,
            view: stage.view
        };
        const a = (0, $fe86f88c0c9aea93$export$5ec2c407fb44f02)();
        (0, $fe86f88c0c9aea93$export$186d02efde07ef98)((0, $93b302f28dcf836b$export$b0b33bcc0f604685)({
            legend: stage.legend,
            onClick: config && config.onLegendClick
        }), this.getElement((0, $57337365aaceccbe$export$79420be32f83a5b0).legend));
        (0, $fe86f88c0c9aea93$export$7d007ff58288f238)(a);
        if (config && config.onPresent) config.onPresent();
    }
    canvasToDataURL() {
        return new Promise((resolve, reject)=>{
            this.morphchartsref.core.afterRenderCallback = ()=>{
                this.morphchartsref.core.afterRenderCallback = null;
                const canvas = this.getElement((0, $57337365aaceccbe$export$79420be32f83a5b0).gl).getElementsByTagName('canvas')[0];
                const png = canvas.toDataURL('image/png');
                resolve(png);
            };
        });
    }
    configColors(mcColors) {
        (0, $b85abf0fe2345f80$export$419c579437571e95)(this.morphchartsref, mcColors);
    }
    /**
     * Home the camera to the last initial position.
     */ homeCamera() {
        var _a;
        (_a = this.morphchartsref) === null || _a === void 0 || _a.reset();
    }
    /**
     * Show guidelines of rendering height/width and center of OrbitView.
     */ showGuides() {
        this.getElement((0, $57337365aaceccbe$export$79420be32f83a5b0).gl).classList.add('show-center');
    //TODO Morphcharts gridlines
    }
    finalize() {
        this.animationCancel();
        if (this.morphchartsref) this.morphchartsref.core.stop();
        if (this.el) this.el.innerHTML = '';
        this._last = null;
        this.morphchartsref = null;
        this.el = null;
        this.logger = null;
        this.queuedAnimationOptions = null;
    }
}


/*!
* Copyright (c) Microsoft Corporation.
* Licensed under the MIT License.
*/ 



/*!
* Copyright (c) Microsoft Corporation.
* Licensed under the MIT License.
*/ 
//pass in the SuperClass, which should be a vega.View
function $c4d8d05347e8dad9$var$_RendererGl(loader) {
    //dynamic superclass, since we don't know have vega.View in the declaration phase
    class RendererGlInternal extends (0, $94b078fc391e7135$export$e2253033e6e1df16).vega.Renderer {
        initialize(el, width, height, origin) {
            this.height = height;
            this.width = width;
            // this method will invoke resize to size the canvas appropriately
            return super.initialize(el, width, height, origin);
        }
        resize(width, height, origin) {
            super.resize(width, height, origin);
            this.origin = origin;
            this.height = height;
            this.width = width;
            //rteturn this for vega
            return this;
        }
        _render(scene, items) {
            const scene3d = scene;
            scene3d.view = this.getView();
            this.presenter.present(scene3d, this.height, this.width, this.presenterConfig);
            //return this for vega
            return this;
        }
    }
    const instance = new RendererGlInternal(loader);
    return instance;
}
const $c4d8d05347e8dad9$export$ca9a02b0553384e7 = $c4d8d05347e8dad9$var$_RendererGl;


let $51fbad27d38c01a6$var$registered = false;
//dynamic superclass lets us create a subclass at execution phase instead of declaration phase.
//This allows us to retrieve vega.View from either UMD or ES6 consumers of this class.
//pass in the SuperClass, which should be a vega.View
function $51fbad27d38c01a6$var$_ViewGl(runtime, config) {
    //dynamic superclass, since we don't know have vega.View in the declaration phase
    class ViewGlInternal extends (0, $94b078fc391e7135$export$e2253033e6e1df16).vega.View {
        constructor(runtime, config = {}){
            super(runtime, config);
            this.config = config;
            this.presenter = config.presenter;
            config.presenterConfig = config.presenterConfig || {};
            config.presenterConfig.redraw = ()=>{
                this._redraw = true; //use Vega View private member _redraw
                this.run();
            };
        }
        renderer(...args) {
            if (args && args.length) {
                const renderer = args[0];
                if (renderer === 'morphcharts' && !$51fbad27d38c01a6$var$registered) {
                    (0, $94b078fc391e7135$export$e2253033e6e1df16).vega.renderModule('morphcharts', {
                        handler: (0, $94b078fc391e7135$export$e2253033e6e1df16).vega.CanvasHandler,
                        renderer: (0, $c4d8d05347e8dad9$export$ca9a02b0553384e7)
                    });
                    $51fbad27d38c01a6$var$registered = true;
                }
                return super.renderer(renderer);
            } else return super.renderer();
        }
        initialize(el) {
            if (!this.presenter) this.presenter = new (0, $6dfc103fcb41a0e6$export$893c88c42e3630f9)(el);
            super.initialize(this.presenter.getElement((0, $57337365aaceccbe$export$79420be32f83a5b0).vegaControls));
            const renderer = this._renderer;
            renderer.presenterConfig = this.config.presenterConfig;
            renderer.presenter = this.presenter;
            renderer.getView = this.config && this.config.getView || (()=>this.presenter.view || (0, $a2698ea08ecf5377$export$93acc5219d6538bb));
            return this;
        }
        error(e) {
            if (this.presenter.logger) this.presenter.logger(e);
        }
    }
    const instance = new ViewGlInternal(runtime, config);
    return instance;
}
const $51fbad27d38c01a6$export$6d8f9057dcd7f9e6 = $51fbad27d38c01a6$var$_ViewGl;



/*!
* Copyright (c) Microsoft Corporation.
* Licensed under the MIT License.
*/ const $f6508cfd53d266a5$export$83d89fbfd8236492 = '1.0.6';


$parcel$exportWildcard($e296aaf527fc4d25$exports, $57337365aaceccbe$exports);


const { defaultPresenterStyle: $16f9e3e56a5dcd59$var$defaultPresenterStyle } = $a2698ea08ecf5377$exports;
const $16f9e3e56a5dcd59$export$fb736e4909afb3d7 = {
    colors: {
        activeCube: 'purple',
        defaultCube: $c5578f8838abba3d$exports.colorToString($16f9e3e56a5dcd59$var$defaultPresenterStyle.defaultCubeColor),
        hoveredCube: $c5578f8838abba3d$exports.colorToString($16f9e3e56a5dcd59$var$defaultPresenterStyle.highlightColor),
        selectedCube: 'yellow',
        axisSelectHighlight: $c5578f8838abba3d$exports.colorToString([
            128,
            128,
            128,
            128
        ]),
        axisLine: '#000',
        axisText: '#000',
        gridLine: '#CCC',
        backgroundColor: '#FFF'
    },
    language: {
        headers: {
            chart: 'Chart',
            details: 'Details',
            legend: 'Legend',
            selection: 'Select & Filter'
        },
        bing: 'bing',
        newColorMap: 'remap color to filtered items',
        oldColorMap: 'keep same colors',
        deselect: 'deselect',
        exclude: 'exclude',
        isolate: 'isolate',
        legendOther: 'other',
        nextDetail: '>',
        previousDetail: '<',
        reset: 'reset',
        colorBinCount: 'Color bin count',
        colorReverse: 'Color reverse',
        count: 'Count',
        percent: 'Percent',
        sum: 'Sum',
        scatterPointScale: 'Point scale',
        FacetMaxBins: 'Facet max bins',
        FacetVMaxBins: 'Cross facet max bins',
        XMaxBins: 'X axis max bins',
        YMaxBins: 'Y axis max bins',
        XGridSize: 'X grid size',
        YGridSize: 'Y grid size',
        InnerPaddingSize: 'Inner padding size',
        OuterPaddingSize: 'Outer padding size',
        treeMapMethod: 'Treemap layout',
        facetColumns: 'Facet columns',
        facetRows: 'Facet rows',
        markOpacitySignal: 'Mark opacity',
        textScaleSignal: 'Text scale',
        xAxisTextAngleSignal: 'X axis text angle',
        yAxisTextAngleSignal: 'Y axis text angle',
        zGrounded: 'Z grounded',
        zScaleProportion: 'Z scale proportion to Y',
        selectionCount: (count)=>`${count} items selected`
    },
    maxLegends: 19,
    onError: (errors)=>{
    //console.log(`UnitVisViewer errors: ${errors.join('\n')}`);
    },
    filterRenderingTimerPadding: 200,
    selectionPolygonZ: -1,
    tickSize: 10
};
function $16f9e3e56a5dcd59$export$c4db461e5e345a8(options) {
    const style = {
        cssPrefix: $16f9e3e56a5dcd59$export$f0d47e1c119d5bf2,
        fontFamily: options.fontFamily,
        defaultCubeColor: $c5578f8838abba3d$exports.colorFromString(options.colors.defaultCube)
    };
    if (options.colors.hoveredCube) style.highlightColor = $c5578f8838abba3d$exports.colorFromString(options.colors.hoveredCube);
    //if (options.lightSettings) {
    // style.lightSettings = options.lightSettings;
    //}
    return style;
}
const $16f9e3e56a5dcd59$export$f0d47e1c119d5bf2 = 'sanddance-';
const $16f9e3e56a5dcd59$export$1641cdccd8d44edd = {
    black: '#212121',
    gray: '#D2D2D2',
    blue: '#0060F0',
    green: '#00C000',
    orange: '#FF9900',
    red: '#E00000'
};


function $048ba25c9a3f4065$export$81adea670bebefbe(columnName, includeVegaMorphChartsFields = false) {
    if (includeVegaMorphChartsFields) {
        if (columnName === (0, $44b8bb162b63b5b5$export$5672246984822a29)) return true;
    }
    for(const f in 0, $8d0624e259fe9d79$export$10df5429b7082be2){
        if (columnName === (0, $8d0624e259fe9d79$export$10df5429b7082be2)[f]) return true;
    }
    return false;
}



/*!
* Copyright (c) Microsoft Corporation.
* Licensed under the MIT License.
*/ 

const $1f9940ddae6f4302$var$dualPairs = [
    [
        (0, $16f9e3e56a5dcd59$export$1641cdccd8d44edd).black,
        (0, $16f9e3e56a5dcd59$export$1641cdccd8d44edd).gray
    ],
    [
        (0, $16f9e3e56a5dcd59$export$1641cdccd8d44edd).red,
        (0, $16f9e3e56a5dcd59$export$1641cdccd8d44edd).green
    ],
    [
        (0, $16f9e3e56a5dcd59$export$1641cdccd8d44edd).red,
        (0, $16f9e3e56a5dcd59$export$1641cdccd8d44edd).blue
    ],
    [
        (0, $16f9e3e56a5dcd59$export$1641cdccd8d44edd).black,
        (0, $16f9e3e56a5dcd59$export$1641cdccd8d44edd).red
    ],
    [
        (0, $16f9e3e56a5dcd59$export$1641cdccd8d44edd).black,
        (0, $16f9e3e56a5dcd59$export$1641cdccd8d44edd).orange
    ],
    [
        (0, $16f9e3e56a5dcd59$export$1641cdccd8d44edd).black,
        (0, $16f9e3e56a5dcd59$export$1641cdccd8d44edd).green
    ]
];
const $1f9940ddae6f4302$export$2ad73d393c16f81c = [
    {
        scheme: (0, $8d0624e259fe9d79$export$c991c3dd58d9959c),
        colors: [
            (0, $16f9e3e56a5dcd59$export$fb736e4909afb3d7).colors.defaultCube
        ]
    }
];
$1f9940ddae6f4302$var$createDualColorSchemes();
function $1f9940ddae6f4302$export$3030070885af9365(vega) {
    $1f9940ddae6f4302$export$2ad73d393c16f81c.forEach((cs)=>{
        if (cs.colors.length === 1) vega.scheme(cs.scheme, (x)=>cs.colors[0]);
        else vega.scheme(cs.scheme, cs.colors);
    });
}
function $1f9940ddae6f4302$var$createPair(names, colors) {
    const scheme = `dual_${names[0]}${names[1]}`;
    $1f9940ddae6f4302$export$2ad73d393c16f81c.push({
        scheme: scheme,
        colors: colors
    });
}
function $1f9940ddae6f4302$var$createDualColorSchemes() {
    $1f9940ddae6f4302$var$dualPairs.forEach((colors)=>{
        const names = colors.map((color)=>{
            for(const key in 0, $16f9e3e56a5dcd59$export$1641cdccd8d44edd)if (color === (0, $16f9e3e56a5dcd59$export$1641cdccd8d44edd)[key]) return key;
        });
        $1f9940ddae6f4302$var$createPair(names, colors);
        $1f9940ddae6f4302$var$createPair([
            ...names
        ].reverse(), [
            ...colors
        ].reverse());
    });
}


/*!
* Copyright (c) Microsoft Corporation.
* Licensed under the MIT License.
*/ /*!
* Copyright (c) Microsoft Corporation.
* Licensed under the MIT License.
*/ var $6b115708bb157a7f$export$d9e571576e98a7ab;
(function(DataLayoutChange) {
    DataLayoutChange[DataLayoutChange["same"] = 0] = "same";
    DataLayoutChange[DataLayoutChange["reset"] = 1] = "reset";
    DataLayoutChange[DataLayoutChange["refine"] = 2] = "refine";
})($6b115708bb157a7f$export$d9e571576e98a7ab || ($6b115708bb157a7f$export$d9e571576e98a7ab = {}));
class $6b115708bb157a7f$export$c774d8c9d4e9e234 {
    constructor(dataScope, props){
        this.dataScope = dataScope;
        this.props = props;
    }
    select(search) {
        return new Promise((resolve, reject)=>{
            this.dataScope.select(search);
            this.props.onDataChanged($6b115708bb157a7f$export$d9e571576e98a7ab.same);
            resolve();
        });
    }
    deselect() {
        return new Promise((resolve, reject)=>{
            this.dataScope.deselect();
            this.props.onDataChanged($6b115708bb157a7f$export$d9e571576e98a7ab.same);
            resolve();
        });
    }
    filter(search, keepData, collapseData, rebase) {
        if (rebase) this.dataScope.collapse(false, keepData);
        this.dataScope.collapse(true, collapseData);
        return new Promise((resolve, reject)=>{
            this.props.onAnimateDataChange($6b115708bb157a7f$export$d9e571576e98a7ab.refine, 'before refine', 'refine').then(()=>{
                this.dataScope.deselect();
                this.dataScope.setFilteredData(keepData);
                this.props.onDataChanged($6b115708bb157a7f$export$d9e571576e98a7ab.refine, search);
                resolve();
            }).catch(reject);
        });
    }
    reset() {
        return new Promise((resolve, reject)=>{
            this.dataScope.deselect();
            let time;
            if (!this.dataScope.hasFilteredData()) time = 0;
            else this.dataScope.setFilteredData(null);
            this.props.onAnimateDataChange($6b115708bb157a7f$export$d9e571576e98a7ab.reset, 'before reset', 'reset', time).then(()=>{
                this.dataScope.collapse(false);
                this.props.onDataChanged($6b115708bb157a7f$export$d9e571576e98a7ab.reset);
                resolve();
            }).catch(reject);
        });
    }
    activate(datum) {
        return new Promise((resolve, reject)=>{
            this.dataScope.activate(datum);
            this.props.onDataChanged($6b115708bb157a7f$export$d9e571576e98a7ab.same);
            resolve();
        });
    }
    deactivate() {
        return new Promise((resolve, reject)=>{
            this.dataScope.deactivate();
            this.props.onDataChanged($6b115708bb157a7f$export$d9e571576e98a7ab.same);
            resolve();
        });
    }
}


/*!
* Copyright (c) Microsoft Corporation.
* Licensed under the MIT License.
*/ /*!
* Copyright (c) Microsoft Corporation.
* Licensed under the MIT License.
*/ function $e4e496e11632ad2b$export$cb7265fd11709ea(niceValue) {
    //convert "nice" numbers to numeric value
    return (niceValue + '').replace(/[\s,]/g, '');
}
function $e4e496e11632ad2b$var$tickValue(axis, i) {
    const tick = axis.tickText[i];
    let value;
    if (tick) value = axis.tickText[i].value;
    return {
        tick: tick,
        value: value
    };
}
function $e4e496e11632ad2b$export$1be0843eea5393e4(column) {
    const searchExpression = {
        name: column.name,
        operator: 'isnullorEmpty'
    };
    return searchExpression;
}
function $e4e496e11632ad2b$export$8543b98d22318eca(column, value) {
    if (value == null) return $e4e496e11632ad2b$export$1be0843eea5393e4(column);
    const searchExpression = {
        name: column.name,
        operator: '==',
        value: value
    };
    return searchExpression;
}
function $e4e496e11632ad2b$export$e531b549585c011c(column, values) {
    const expressions = values.map((value, i)=>{
        const searchExpression = {
            name: column.name,
            operator: '!=',
            value: value
        };
        if (i) searchExpression.clause = '&&';
        return searchExpression;
    });
    const searchExpressionGroup = {
        expressions: expressions
    };
    return searchExpressionGroup;
}
function $e4e496e11632ad2b$export$64b81e116b959f8a(axis, column, i) {
    const result = $e4e496e11632ad2b$var$tickValue(axis, i);
    if (result.tick) return $e4e496e11632ad2b$export$8543b98d22318eca(column, result.value);
}
function $e4e496e11632ad2b$export$8bb38a473c12645e(column, lowValue, highValue, lowOperator = '>=', highOperator = '<') {
    const expressions = [];
    if (lowValue !== undefined) expressions.push({
        name: column.name,
        operator: lowOperator,
        value: lowValue
    });
    if (highValue !== undefined) expressions.push({
        name: column.name,
        operator: highOperator,
        value: highValue
    });
    if (expressions.length > 1) expressions[1].clause = '&&';
    const searchExpressionGroup = {
        expressions: expressions
    };
    return searchExpressionGroup;
}
function $e4e496e11632ad2b$export$80908cccce4a97cb(axis, column, i) {
    const low = $e4e496e11632ad2b$var$tickValue(axis, i);
    const high = $e4e496e11632ad2b$var$tickValue(axis, i + 1);
    return $e4e496e11632ad2b$export$8bb38a473c12645e(column, low.value, high.value);
}


const $a696a51a900f8bbc$var$dimToRole = {
    0: 'x',
    1: 'y',
    2: 'z'
};
const $a696a51a900f8bbc$var$roleToDim = {
    x: 0,
    y: 1,
    z: 1
};
class $a696a51a900f8bbc$export$b4d41fd4fcc19c {
    constructor(specCapabilities, columns, stage){
        this.specCapabilities = specCapabilities;
        this.columns = columns;
        this.stage = stage;
    }
    convert(divisions) {
        const searchRoles = [];
        divisions.forEach((division, i)=>{
            const role = $a696a51a900f8bbc$var$dimToRole[i];
            const axes = this.stage.axes[role];
            //all axes in a faceted chart should be the same
            const axis = axes.filter((axis)=>axis.tickText.length)[0];
            if (axis) {
                const capabilities = this.specCapabilities.roles.filter((r)=>r.role === role)[0];
                const column = this.columns[role];
                if (division >= 0 && (capabilities === null || capabilities === void 0 ? void 0 : capabilities.axisSelection)) searchRoles.push({
                    axis: axis,
                    role: role,
                    capabilities: capabilities,
                    column: column,
                    division: division
                });
            }
        });
        switch(searchRoles.length){
            case 0:
                return null;
            case 1:
                return this.getSearchFromSearchRole(searchRoles[0]);
            default:
                {
                    const roles = searchRoles.map((searchRole)=>this.getSearchFromSearchRole(searchRole));
                    roles.forEach((role, i)=>{
                        if (i === 0) return;
                        role.clause = '&&';
                    });
                    return roles;
                }
        }
    }
    getSearchFromSearchRole(searchRole) {
        const getSearch = searchRole.capabilities.axisSelection === 'exact' ? (a, c, i)=>({
                expressions: [
                    (0, $e4e496e11632ad2b$export$64b81e116b959f8a)(a, c, i)
                ]
            }) : (0, $e4e496e11632ad2b$export$80908cccce4a97cb);
        const { axis: axis, column: column, division: division } = searchRole;
        return getSearch(axis, column, division);
    }
}
function $a696a51a900f8bbc$export$abaa25886c91cb0e(axes) {
    axes.forEach((axis)=>{
        if (axis.ticks.length === 0) return;
        const dim = $a696a51a900f8bbc$var$roleToDim[axis.axisRole];
        const { color: color } = axis.ticks[0];
        const newLine = (value)=>{
            const line = {
                sourcePosition: [
                    0,
                    0,
                    0
                ],
                targetPosition: [
                    0,
                    0,
                    0
                ],
                color: color
            };
            line.sourcePosition[dim] = value;
            return line;
        };
        const newTicks = [];
        newTicks.push(newLine(axis.domain.sourcePosition[dim]));
        for(let i = 1; i < axis.ticks.length; i++)newTicks.push(newLine((axis.ticks[i].sourcePosition[dim] + axis.ticks[i - 1].sourcePosition[dim]) / 2));
        newTicks.push(newLine(axis.domain.targetPosition[dim]));
        axis.ticks = newTicks;
    });
}


/*!
* Copyright (c) Microsoft Corporation.
* Licensed under the MIT License.
*/ 
function $d862cbedfe5e328a$export$44addeff9a96c1e7(colorContext, presenter) {
    if (!colorContext.colorMap) colorContext.colorMap = presenter.morphChartsRenderResult.getCubeLayer().unitColorMap;
    colorContext.legend = $c5578f8838abba3d$exports.clone(presenter.stage.legend);
    colorContext.legendElement = presenter.getElement($57337365aaceccbe$export$79420be32f83a5b0.legend).children[0];
}




/*!
* Copyright (c) Microsoft Corporation.
* Licensed under the MIT License.
*/ 



class $298086c83cbc7842$export$3fb74a6ae4f1171d {
    constructor(){
        this.filteredColumnsStats = {};
    }
    setData(data, columns) {
        const differentData = this.data !== data;
        if (differentData) {
            if (this.data) //clean up things we added to old data
            this.deselect();
            this.data = data;
            this.columns = columns;
            this.filteredData = null;
            this.filteredColumnsStats = {};
        }
        return differentData;
    }
    setFilteredData(filteredData) {
        this.filteredData = filteredData;
        this.filteredColumnsStats = {};
    }
    getColumns(columnTypes) {
        if (!this.columns) this.columns = (0, $15b363a2e3ff0bb7$export$3f19ad07848df794)($94b078fc391e7135$export$e2253033e6e1df16.vega.inferTypes, this.data, columnTypes);
        return this.columns;
    }
    getFilteredColumnStats(columnName) {
        if (!this.filteredColumnsStats[columnName]) this.filteredColumnsStats[columnName] = (0, $8e54999951217c95$export$432f698644f45d1)(this.filteredData, this.columns.filter((c)=>c.name === columnName)[0]);
        return this.filteredColumnsStats[columnName];
    }
    currentData() {
        return this.filteredData || this.data;
    }
    select(search) {
        this.deselect();
        if (search) {
            this.selection = this.createUserSelection(search, true, false);
            if (this.selection.included.length) this.activate(this.selection.included[0]);
        }
    }
    createUserSelection(search, assign, rebase) {
        const exec = new (0, $60ec9c9c9a132a89$export$bbfd672d43392844)(search, this.getColumns());
        const s = {
            search: search,
            included: [],
            excluded: []
        };
        const data = rebase ? this.data : this.currentData();
        data.forEach((datum)=>{
            if (exec.run(datum)) {
                if (assign) datum[(0, $8d0624e259fe9d79$export$10df5429b7082be2).Selected] = true;
                s.included.push(datum);
            } else s.excluded.push(datum);
        });
        return s;
    }
    deselect() {
        this.deactivate();
        this.data.forEach((datum)=>{
            delete datum[(0, $8d0624e259fe9d79$export$10df5429b7082be2).Selected];
        });
        this.selection = null;
    }
    hasFilteredData() {
        return !!this.filteredData;
    }
    hasSelectedData() {
        return !!this.selection;
    }
    collapse(collapsed, data = this.data) {
        data.forEach((datum)=>{
            datum[(0, $8d0624e259fe9d79$export$10df5429b7082be2).Collapsed] = collapsed;
        });
        this.isCollapsed = collapsed;
    }
    activate(datum) {
        this.deactivate();
        datum[(0, $8d0624e259fe9d79$export$10df5429b7082be2).Active] = true;
        this.active = datum;
    }
    deactivate() {
        if (this.active) delete this.active[(0, $8d0624e259fe9d79$export$10df5429b7082be2).Active];
        this.active = null;
    }
    ordinalIndexWithinSelection(ordinal) {
        if (this.selection) for(let i = 0; i < this.selection.included.length; i++){
            const datum = this.selection.included[i];
            if (datum[0, $44b8bb162b63b5b5$export$5672246984822a29] === ordinal) return {
                datum: datum,
                index: i
            };
        }
        return {
            datum: null,
            index: -1
        };
    }
    finalize() {
        this.data = null;
        this.filteredData = null;
        this.filteredColumnsStats = null;
        if (this.selection) {
            this.selection.excluded = null;
            this.selection.included = null;
            this.selection = null;
        }
    }
}



/*!
* Copyright (c) Microsoft Corporation.
* Licensed under the MIT License.
*/ 




var $f701b9e6e9858c3b$var$Action;
(function(Action) {
    Action[Action["deselect"] = 0] = "deselect";
    Action[Action["isolate"] = 1] = "isolate";
    Action[Action["exclude"] = 2] = "exclude";
    Action[Action["reset"] = 3] = "reset";
    Action[Action["next"] = 4] = "next";
    Action[Action["previous"] = 5] = "previous";
})($f701b9e6e9858c3b$var$Action || ($f701b9e6e9858c3b$var$Action = {}));
class $f701b9e6e9858c3b$export$3e8048d3cf2ba3fd {
    constructor(parentElement, language, animator, dataScope, colorMapHandler, hasColorMaps){
        this.language = language;
        this.animator = animator;
        this.dataScope = dataScope;
        this.colorMapHandler = colorMapHandler;
        this.hasColorMaps = hasColorMaps;
        this.element = (0, $c5578f8838abba3d$exports).addDiv(parentElement, `${(0, $16f9e3e56a5dcd59$export$f0d47e1c119d5bf2)}unitControls`);
        this.clear();
    }
    finalize() {
        if (this.element) this.element.innerHTML = '';
        this.dataScope = null;
        this.element = null;
    }
    clear() {
        this.state = {
            userSelection: null,
            index: -1,
            remapColor: false
        };
        this.render();
    }
    clearSelection() {
        this.state.userSelection = null;
        this.state.index = -1;
        this.render();
    }
    populate(userSelection, index = 0) {
        this.state.userSelection = userSelection;
        this.state.index = index;
        this.render();
    }
    selectByNameValue(columnName, value) {
        const search = {
            name: columnName,
            operator: '==',
            value: value
        };
        this.clearSelection();
        this.animator.select(search);
        this.populate(this.dataScope.selection);
    }
    remapChanged(remap) {
        this.state.remapColor = remap;
        this.colorMapHandler(remap);
        this.render();
    }
    handleAction(action) {
        let p;
        const u = this.state.userSelection;
        switch(action){
            case $f701b9e6e9858c3b$var$Action.deselect:
                this.clearSelection();
                p = this.animator.deselect();
                break;
            case $f701b9e6e9858c3b$var$Action.exclude:
                this.clearSelection();
                p = this.animator.filter((0, $b144ef381004fc94$export$6897c284b6f9f4dc)(u.search), u.excluded, u.included, false);
                this.state.remapColor = false;
                break;
            case $f701b9e6e9858c3b$var$Action.isolate:
                this.clearSelection();
                p = this.animator.filter(u.search, u.included, u.excluded, false);
                this.state.remapColor = false;
                break;
            case $f701b9e6e9858c3b$var$Action.reset:
                this.clear();
                p = this.animator.reset();
                break;
            default:
                switch(action){
                    case $f701b9e6e9858c3b$var$Action.previous:
                        this.state.index--;
                        if (this.state.index < 0) this.state.index = this.state.userSelection.included.length - 1;
                        break;
                    case $f701b9e6e9858c3b$var$Action.next:
                        this.state.index++;
                        if (this.state.index >= this.state.userSelection.included.length) this.state.index = 0;
                        break;
                }
                this.render();
                p = this.animator.activate(this.state.userSelection.included[this.state.index]);
        }
        p.then(()=>this.render());
    }
    render() {
        const hasRefinedData = this.dataScope.hasFilteredData();
        const renderProps = {
            language: this.language,
            actionHandler: (action)=>this.handleAction(action),
            selectionHandler: (columnName, value)=>this.selectByNameValue(columnName, value),
            count: this.state.userSelection && this.state.userSelection.included.length,
            hasRefinedData: hasRefinedData,
            item: this.state.userSelection && this.state.userSelection.included[this.state.index],
            remapColorHandler: (remap)=>this.remapChanged(remap),
            hasColorMaps: this.hasColorMaps() && hasRefinedData,
            remapColor: this.state.remapColor
        };
        const a = $c5578f8838abba3d$exports.getActiveElementInfo();
        $c5578f8838abba3d$exports.mount($f701b9e6e9858c3b$var$renderDetails(renderProps), this.element);
        $c5578f8838abba3d$exports.setActiveElement(a);
    }
}
const $f701b9e6e9858c3b$var$renderDetails = (props)=>{
    const controlButtons = [
        $c5578f8838abba3d$exports.createElement("button", {
            disabled: !props.item,
            onClick: (e)=>props.actionHandler($f701b9e6e9858c3b$var$Action.deselect)
        }, props.language.deselect),
        $c5578f8838abba3d$exports.createElement("button", {
            disabled: !props.item,
            onClick: (e)=>props.actionHandler($f701b9e6e9858c3b$var$Action.isolate)
        }, props.language.isolate),
        $c5578f8838abba3d$exports.createElement("button", {
            disabled: !props.item,
            onClick: (e)=>props.actionHandler($f701b9e6e9858c3b$var$Action.exclude)
        }, props.language.exclude)
    ];
    const colorMapping = $c5578f8838abba3d$exports.createElement("div", null, $c5578f8838abba3d$exports.createElement("button", {
        disabled: props.remapColor,
        onClick: (e)=>props.remapColorHandler(true)
    }, props.language.newColorMap), $c5578f8838abba3d$exports.createElement("button", {
        disabled: !props.remapColor,
        onClick: (e)=>props.remapColorHandler(false)
    }, props.language.oldColorMap));
    const singleItem = props.count === 1;
    const scrollButtons = [
        $c5578f8838abba3d$exports.createElement("button", {
            disabled: singleItem,
            onClick: (e)=>props.actionHandler($f701b9e6e9858c3b$var$Action.previous)
        }, props.language.previousDetail),
        $c5578f8838abba3d$exports.createElement("button", {
            disabled: singleItem,
            onClick: (e)=>props.actionHandler($f701b9e6e9858c3b$var$Action.next)
        }, props.language.nextDetail),
        $c5578f8838abba3d$exports.createElement("span", null, " ", props.language.selectionCount(props.count))
    ];
    const rows = [];
    for(const prop in props.item){
        if (prop === (0, $44b8bb162b63b5b5$export$5672246984822a29)) continue;
        if ((0, $048ba25c9a3f4065$export$81adea670bebefbe)(prop)) continue;
        rows.push({
            cells: [
                {
                    content: prop
                },
                {
                    content: $f701b9e6e9858c3b$var$linkSelect(props.language, prop, props.item[prop], props.selectionHandler)
                }
            ]
        });
    }
    return $c5578f8838abba3d$exports.createElement("div", null, props.hasColorMaps && colorMapping, $c5578f8838abba3d$exports.createElement("h4", null, props.language.headers.selection), $c5578f8838abba3d$exports.createElement("div", {
        className: `${(0, $16f9e3e56a5dcd59$export$f0d47e1c119d5bf2)}selection`
    }, controlButtons, $c5578f8838abba3d$exports.createElement("button", {
        disabled: !props.hasRefinedData,
        onClick: (e)=>props.actionHandler($f701b9e6e9858c3b$var$Action.reset)
    }, "reset")), props.item && $c5578f8838abba3d$exports.createElement("h4", null, props.language.headers.details), $c5578f8838abba3d$exports.createElement("div", null, $c5578f8838abba3d$exports.createElement("div", {
        className: `${(0, $16f9e3e56a5dcd59$export$f0d47e1c119d5bf2)}details-scroll`
    }, props.item && scrollButtons), $c5578f8838abba3d$exports.createElement("div", {
        className: `${(0, $16f9e3e56a5dcd59$export$f0d47e1c119d5bf2)}details`
    }, props.item && $c5578f8838abba3d$exports.createElement((0, $230d9e8a9013f7fd$exports).Table, {
        rows: rows
    }))));
};
function $f701b9e6e9858c3b$var$linkSelect(language, columnName, value, selectionHandler) {
    return $c5578f8838abba3d$exports.createElement("span", null, $c5578f8838abba3d$exports.createElement("a", {
        href: "#",
        onClick: (e)=>selectionHandler(columnName, value)
    }, value), isNaN(value) ? [
        ' ',
        $c5578f8838abba3d$exports.createElement("a", {
            className: "bing-search",
            href: `https://www.bing.com/search?q=${encodeURIComponent(value)}`,
            target: "_blank"
        }, language.bing)
    ] : '');
}


/*!
* Copyright (c) Microsoft Corporation.
* Licensed under the MIT License.
*/ 
function $5daa0c31e678116a$export$1d674716cc6da32f(presenter, headers) {
    const vegaControls = presenter.getElement((0, $57337365aaceccbe$export$79420be32f83a5b0).vegaControls);
    $5daa0c31e678116a$var$conditionalHeader(!!vegaControls.querySelectorAll('.vega-bindings > *').length, vegaControls, headers.chart);
    const legend = presenter.getElement((0, $57337365aaceccbe$export$79420be32f83a5b0).legend);
    $5daa0c31e678116a$var$conditionalHeader(!!legend.children.length, legend, headers.legend);
}
function $5daa0c31e678116a$var$conditionalHeader(condition, element, header) {
    const existing = $5daa0c31e678116a$var$existingHeader(element, header);
    if (condition && !existing) $5daa0c31e678116a$var$addHeader(element, header);
    if (!condition && existing) existing.remove();
}
function $5daa0c31e678116a$var$addHeader(element, header) {
    const h = document.createElement('h4');
    h.innerHTML = header;
    element.insertAdjacentElement('beforebegin', h);
}
function $5daa0c31e678116a$var$existingHeader(element, header) {
    const { previousElementSibling: previousElementSibling } = element;
    if (previousElementSibling && previousElementSibling.innerHTML === header) return previousElementSibling;
}


/*!
* Copyright (c) Microsoft Corporation.
* Licensed under the MIT License.
*/ 

function $5c5541ba560b58df$var$legendRange(colorBinType, column, legend, clickedIndex) {
    if (column.quantitative) return $5c5541ba560b58df$var$selectQuantitative(colorBinType, column, legend, clickedIndex);
    else return $5c5541ba560b58df$var$selectCategorical(column, legend, clickedIndex);
}
function $5c5541ba560b58df$var$selectCategorical(column, legend, clickedIndex) {
    const value = legend.rows[clickedIndex].value;
    if (value === (0, $8d0624e259fe9d79$export$8653a30c44b6e879)) {
        const values = [];
        for(const i in legend.rows)if (+i !== clickedIndex) values.push(legend.rows[i].value);
        return (0, $e4e496e11632ad2b$export$e531b549585c011c)(column, values);
    } else //select equal
    return {
        expressions: [
            (0, $e4e496e11632ad2b$export$8543b98d22318eca)(column, legend.rows[clickedIndex].value)
        ]
    };
}
function $5c5541ba560b58df$var$selectQuantitative(colorBinType, column, legend, clickedIndex) {
    const keys = Object.keys(legend.rows).map((key)=>+key).sort((a, b)=>+a - +b);
    let lowValue;
    let lowOperator;
    let highValue;
    let highOperator;
    const rowText = legend.rows[clickedIndex].label;
    switch(colorBinType){
        case 'continuous':
            lowValue = rowText;
            if (clickedIndex < keys.length - 1) highValue = legend.rows[clickedIndex + 1].value;
            break;
        default:
            {
                if (rowText.indexOf('null') > 0) {
                    const ex = {
                        expressions: [
                            (0, $e4e496e11632ad2b$export$1be0843eea5393e4)(column)
                        ]
                    };
                    return ex;
                }
                const dash = rowText.indexOf("\u2013"); //this is not the common dash character!
                if (dash > 0) {
                    //bug in Vega for quantize?
                    //lowOperator = '>';
                    //highOperator = '<=';
                    lowValue = rowText.substr(0, dash);
                    highValue = rowText.substr(dash + 1);
                } else {
                    if (rowText.indexOf('<') >= 0) highValue = rowText.substring(2);
                    else if (rowText.indexOf("\u2265") >= 0) lowValue = rowText.substring(2);
                }
            }
    }
    if (lowValue) lowValue = (0, $e4e496e11632ad2b$export$cb7265fd11709ea)(lowValue);
    if (highValue) highValue = (0, $e4e496e11632ad2b$export$cb7265fd11709ea)(highValue);
    if (lowValue === highValue) return {
        expressions: [
            (0, $e4e496e11632ad2b$export$8543b98d22318eca)(column, lowValue)
        ]
    };
    else return (0, $e4e496e11632ad2b$export$8bb38a473c12645e)(column, lowValue, highValue, lowOperator, highOperator);
}
function $5c5541ba560b58df$export$71ab65a966760ac3(colorBinType, colorColumn, legend, language) {
    const rowTexts = [];
    for(const i in legend.rows){
        const row = legend.rows[i];
        row.search = $5c5541ba560b58df$var$legendRange(colorBinType, colorColumn, legend, +i);
        if (row.value === (0, $8d0624e259fe9d79$export$8653a30c44b6e879)) row.label = language.legendOther;
        else rowTexts.push(row.value);
    }
}


/*!
* Copyright (c) Microsoft Corporation.
* Licensed under the MIT License.
*/ 
function $70eaad7e9e4ac896$export$f03cc77b21b3a2b2(columns, data, ordinalMap) {
    const uCol = columns.uid && columns.uid.name;
    if (ordinalMap) data.forEach((d, i)=>{
        const key = uCol ? d[uCol] : i;
        d[0, $44b8bb162b63b5b5$export$5672246984822a29] = ordinalMap[key];
    });
    else {
        ordinalMap = {};
        data.forEach((d, i)=>{
            d[0, $44b8bb162b63b5b5$export$5672246984822a29] = i;
            const uColValue = uCol ? d[uCol] : i;
            ordinalMap[uColValue] = i;
        });
    }
    return ordinalMap;
}
function $70eaad7e9e4ac896$export$5844459bbee68321(cube, data) {
    const len = data.length;
    for(let i = 0; i < len; i++){
        if (data[i][0, $44b8bb162b63b5b5$export$5672246984822a29] === cube.ordinal) return i;
    }
}


/*!
* Copyright (c) Microsoft Corporation.
* Licensed under the MIT License.
*/ 
/*!
* Copyright (c) Microsoft Corporation.
* Licensed under the MIT License.
*/ 
const { allTruthy: $a4463fda52a937f9$export$84af6d08e329f176, concat: $a4463fda52a937f9$export$ee1b3e54f0441b22, push: $a4463fda52a937f9$export$4cbf152802aa238 } = (0, $c5578f8838abba3d$exports);


function $a52b757f33a54d2e$export$cb06c97de370398d(search) {
    let group;
    const vegaSearch = search;
    if (Array.isArray(vegaSearch)) {
        //flatten into one group
        group = {
            expressions: []
        };
        vegaSearch.forEach((g)=>{
            const clonedExpressions = $c5578f8838abba3d$exports.clone(g.expressions).filter(Boolean);
            clonedExpressions[0].clause = '&&';
            (0, $a4463fda52a937f9$export$4cbf152802aa238)(group.expressions, clonedExpressions);
        });
    } else group = vegaSearch ? {
        expressions: vegaSearch.expressions.filter(Boolean)
    } : null;
    return group;
}


/*!
* Copyright (c) Microsoft Corporation.
* Licensed under the MIT License.
*/ 
function $6728ad2e40252478$export$385a06e733eab4de(sv, b) {
    if (!sv || !b || !b.signals || !b.signals.length) return;
    for(const key in sv){
        const value = sv[key];
        const signalB = b.signals.filter((signal)=>signal.name === key)[0];
        if (signalB && signalB.bind) signalB.value = value;
    }
}
function $6728ad2e40252478$export$764590c093441ac7(view, spec) {
    if (!view || !spec || !spec.signals || !spec.signals.length) return;
    const result = {};
    spec.signals.forEach((signalA)=>{
        //bound to a UI control
        if (signalA.bind) try {
            result[signalA.name] = view.signal(signalA.name);
        } catch (e) {
        // continue regardless of error
        }
    });
    return result;
}
//signals not capable of handling with MorphCharts
const $6728ad2e40252478$var$hideSignalUI = [
    (0, $8d0624e259fe9d79$export$809e371dee643808).MarkOpacity,
    (0, $8d0624e259fe9d79$export$809e371dee643808).TextAngleX,
    (0, $8d0624e259fe9d79$export$809e371dee643808).TextAngleY
];
function $6728ad2e40252478$export$dc91f38fb87dcbc8(spec) {
    spec.signals.forEach((signal)=>{
        if ($6728ad2e40252478$var$hideSignalUI.indexOf(signal.name) >= 0) delete signal.bind;
    });
}


/*!
* Copyright (c) Microsoft Corporation.
* Licensed under the MIT License.
*/ 


const { outerSize: $40d5ab22242de7d1$var$outerSize } = $c5578f8838abba3d$exports;
const { Table: $40d5ab22242de7d1$var$Table } = $230d9e8a9013f7fd$exports;
class $40d5ab22242de7d1$export$28c660c63b792dea {
    constructor(props){
        this.props = props;
        const renderProps = {
            cssPrefix: props.cssPrefix,
            rows: $40d5ab22242de7d1$var$getRows(props.dataItem)
        };
        this.finalizeHandler = ()=>this.destroy();
        this.element = $40d5ab22242de7d1$var$renderTooltip(renderProps);
        if (this.element) {
            this.element.style.position = 'absolute';
            this.child = this.element.firstChild;
            document.body.appendChild(this.element);
            //measure and move as necessary
            let m = $40d5ab22242de7d1$var$outerSize(this.child);
            while(m.height > document.documentElement.clientHeight){
                const tr = this.child.querySelector('tr:last-child');
                if (tr) tr.parentElement.removeChild(tr);
                else break;
                m = $40d5ab22242de7d1$var$outerSize(this.child);
            }
            let position;
            const te = props.event;
            if (te.touches) position = te[0];
            else {
                const pme = props.event;
                position = pme;
            }
            if (position.clientX + m.width >= document.documentElement.clientWidth) this.child.style.right = '0';
            let moveTop = true;
            if (position.clientY + m.height >= document.documentElement.clientHeight) {
                if (position.clientY - m.height > 0) this.child.style.bottom = '0';
                else moveTop = false;
            }
            if (moveTop) this.element.style.top = `${position.clientY}px`;
            this.element.style.left = `${position.clientX}px`;
            this.child.addEventListener('mouseenter', this.finalizeHandler);
            this.child.addEventListener('mousemove', this.finalizeHandler);
            this.child.addEventListener('mouseover', this.finalizeHandler);
        }
    }
    destroy() {
        this.child.removeEventListener('mouseenter', this.finalizeHandler);
        this.child.removeEventListener('mousemove', this.finalizeHandler);
        this.child.removeEventListener('mouseover', this.finalizeHandler);
        if (this.element) document.body.removeChild(this.element);
        this.element = null;
    }
}
function $40d5ab22242de7d1$export$ce0d7ac3b25f14e3(item) {
    const ret = {};
    for(const columnName in item){
        if (columnName === (0, $44b8bb162b63b5b5$export$5672246984822a29)) continue;
        if ((0, $048ba25c9a3f4065$export$81adea670bebefbe)(columnName)) continue;
        ret[columnName] = item[columnName];
    }
    return ret;
}
function $40d5ab22242de7d1$var$getRows(item) {
    const rows = [];
    for(const columnName in item){
        const value = item[columnName];
        let content;
        switch(value){
            case null:
                content = $c5578f8838abba3d$exports.createElement("i", null, "null");
                break;
            case undefined:
                content = $c5578f8838abba3d$exports.createElement("i", null, "undefined");
                break;
            default:
                content = value.toString();
        }
        //}
        rows.push({
            cells: [
                {
                    content: columnName + ':'
                },
                {
                    content: content
                }
            ]
        });
    }
    return rows;
}
const $40d5ab22242de7d1$var$renderTooltip = (props)=>{
    return props.rows.length === 0 ? null : $c5578f8838abba3d$exports.createElement("div", {
        className: `${props.cssPrefix}tooltip`
    }, $40d5ab22242de7d1$var$Table({
        rows: props.rows
    }));
};





/*!
* Copyright (c) Microsoft Corporation.
* Licensed under the MIT License.
*/ class $10ee4fd0042461c6$export$fba22c9d3f66adb {
    resetCharacterSet(forceNewCharacterSet, oldInsight, newInsight) {
        if (forceNewCharacterSet || $10ee4fd0042461c6$var$needsNewCharacterSet(oldInsight, newInsight)) this.chars = undefined;
    }
    getCharacterSet(stage) {
        if (!this.chars) {
            const map = {};
            const addText = (text)=>{
                Array.from(text).forEach((char)=>{
                    map[char] = true;
                });
            };
            stage.textData.forEach((t)=>addText(t.text));
            const { x: x, y: y } = stage.axes;
            [
                x,
                y
            ].forEach((axes)=>{
                axes.forEach((axis)=>{
                    if (axis.tickText) axis.tickText.forEach((t)=>addText(t.text));
                    if (axis.title) addText(axis.title.text);
                });
            });
            this.chars = Object.keys(map);
        }
        return this.chars;
    }
}
function $10ee4fd0042461c6$var$needsNewCharacterSet(oldInsight, newInsight) {
    if (!oldInsight) return true;
    if (!newInsight) return true;
    if (oldInsight.chart !== newInsight.chart) return true;
    if (oldInsight.facetStyle !== newInsight.facetStyle) return true;
    if (oldInsight.totalStyle !== newInsight.totalStyle) return true;
    if (oldInsight.hideAxes !== newInsight.hideAxes) return true;
    if ($10ee4fd0042461c6$var$differentObjectValues(oldInsight.signalValues, newInsight.signalValues)) return true;
    if ($10ee4fd0042461c6$var$differentObjectValues(oldInsight.size, newInsight.size)) return true;
    const oldColumns = oldInsight.columns;
    const newColumns = newInsight.columns;
    if (oldColumns.facet !== newColumns.facet) return true;
    if (oldColumns.facetV !== newColumns.facetV) return true;
    if (oldColumns.x !== newColumns.x) return true;
    if (oldColumns.y !== newColumns.y) return true;
    if (oldColumns.z !== newColumns.z) return true;
    return false;
}
function $10ee4fd0042461c6$var$differentObjectValues(a, b) {
    if (!a && !b) return false;
    if (!a || !b) return true;
    const keys = Object.keys(b);
    for(let i = 0; i < keys.length; i++){
        const key = keys[i];
        const ta = typeof a;
        const tb = typeof b;
        if (ta !== tb) return true;
        if (ta === 'object') return $10ee4fd0042461c6$var$differentObjectValues(a[key], b[key]);
        else {
            if (a[key] !== b[key]) return true;
        }
    }
    return false;
}


/*!
* Copyright (c) Microsoft Corporation.
* Licensed under the MIT License.
*/ 
const $b37ec5f783bfc709$var$e10 = Math.sqrt(50), $b37ec5f783bfc709$var$e5 = Math.sqrt(10), $b37ec5f783bfc709$var$e2 = Math.sqrt(2);
function $b37ec5f783bfc709$var$tickSpec(start, stop, count) {
    const step = (stop - start) / Math.max(0, count), power = Math.floor(Math.log10(step)), error = step / Math.pow(10, power), factor = error >= $b37ec5f783bfc709$var$e10 ? 10 : error >= $b37ec5f783bfc709$var$e5 ? 5 : error >= $b37ec5f783bfc709$var$e2 ? 2 : 1;
    let i1, i2, inc;
    if (power < 0) {
        inc = Math.pow(10, -power) / factor;
        i1 = Math.round(start * inc);
        i2 = Math.round(stop * inc);
        if (i1 / inc < start) ++i1;
        if (i2 / inc > stop) --i2;
        inc = -inc;
    } else {
        inc = Math.pow(10, power) * factor;
        i1 = Math.round(start / inc);
        i2 = Math.round(stop / inc);
        if (i1 * inc < start) ++i1;
        if (i2 * inc > stop) --i2;
    }
    if (i2 < i1 && 0.5 <= count && count < 2) return $b37ec5f783bfc709$var$tickSpec(start, stop, count * 2);
    return [
        i1,
        i2,
        inc
    ];
}
function $b37ec5f783bfc709$export$2e2bcd8739ae039(start, stop, count) {
    stop = +stop, start = +start, count = +count;
    if (!(count > 0)) return [];
    if (start === stop) return [
        start
    ];
    const reverse = stop < start, [i1, i2, inc] = reverse ? $b37ec5f783bfc709$var$tickSpec(stop, start, count) : $b37ec5f783bfc709$var$tickSpec(start, stop, count);
    if (!(i2 >= i1)) return [];
    const n = i2 - i1 + 1, ticks = new Array(n);
    if (reverse) {
        if (inc < 0) for(let i = 0; i < n; ++i)ticks[i] = (i2 - i) / -inc;
        else for(let i = 0; i < n; ++i)ticks[i] = (i2 - i) * inc;
    } else {
        if (inc < 0) for(let i = 0; i < n; ++i)ticks[i] = (i1 + i) / -inc;
        else for(let i = 0; i < n; ++i)ticks[i] = (i1 + i) * inc;
    }
    return ticks;
}
function $b37ec5f783bfc709$export$bc64d00cc98e7e95(start, stop, count) {
    stop = +stop, start = +start, count = +count;
    return $b37ec5f783bfc709$var$tickSpec(start, stop, count)[2];
}
function $b37ec5f783bfc709$export$81087d9b915d4ede(start, stop, count) {
    stop = +stop, start = +start, count = +count;
    const reverse = stop < start, inc = reverse ? $b37ec5f783bfc709$export$bc64d00cc98e7e95(stop, start, count) : $b37ec5f783bfc709$export$bc64d00cc98e7e95(start, stop, count);
    return (reverse ? -1 : 1) * (inc < 0 ? 1 / -inc : inc);
}


function $3de15593722c01cd$export$2e2bcd8739ae039(a, b) {
    return a == null || b == null ? NaN : a < b ? -1 : a > b ? 1 : a >= b ? 0 : NaN;
}



function $3b670352137ef9af$export$2e2bcd8739ae039(a, b) {
    return a == null || b == null ? NaN : b < a ? -1 : b > a ? 1 : b >= a ? 0 : NaN;
}


function $df292301a551a084$export$2e2bcd8739ae039(f) {
    let compare1, compare2, delta;
    // If an accessor is specified, promote it to a comparator. In this case we
    // can test whether the search value is (self-) comparable. We cant do this
    // for a comparator (except for specific, known comparators) because we cant
    // tell if the comparator is symmetric, and an asymmetric comparator cant be
    // used to test whether a single value is comparable.
    if (f.length !== 2) {
        compare1 = (0, $3de15593722c01cd$export$2e2bcd8739ae039);
        compare2 = (d, x)=>(0, $3de15593722c01cd$export$2e2bcd8739ae039)(f(d), x);
        delta = (d, x)=>f(d) - x;
    } else {
        compare1 = f === (0, $3de15593722c01cd$export$2e2bcd8739ae039) || f === (0, $3b670352137ef9af$export$2e2bcd8739ae039) ? f : $df292301a551a084$var$zero;
        compare2 = f;
        delta = f;
    }
    function left(a, x, lo = 0, hi = a.length) {
        if (lo < hi) {
            if (compare1(x, x) !== 0) return hi;
            do {
                const mid = lo + hi >>> 1;
                if (compare2(a[mid], x) < 0) lo = mid + 1;
                else hi = mid;
            }while (lo < hi);
        }
        return lo;
    }
    function right(a, x, lo = 0, hi = a.length) {
        if (lo < hi) {
            if (compare1(x, x) !== 0) return hi;
            do {
                const mid = lo + hi >>> 1;
                if (compare2(a[mid], x) <= 0) lo = mid + 1;
                else hi = mid;
            }while (lo < hi);
        }
        return lo;
    }
    function center(a, x, lo = 0, hi = a.length) {
        const i = left(a, x, lo, hi - 1);
        return i > lo && delta(a[i - 1], x) > -delta(a[i], x) ? i - 1 : i;
    }
    return {
        left: left,
        center: center,
        right: right
    };
}
function $df292301a551a084$var$zero() {
    return 0;
}


function $37fd68d7f32545a9$export$2e2bcd8739ae039(x) {
    return x === null ? NaN : +x;
}
function* $37fd68d7f32545a9$export$1f6c9cc012ebacae(values, valueof) {
    if (valueof === undefined) {
        for (let value of values)if (value != null && (value = +value) >= value) yield value;
    } else {
        let index = -1;
        for (let value of values)if ((value = valueof(value, ++index, values)) != null && (value = +value) >= value) yield value;
    }
}


const $b9a62473dad8dfb1$var$ascendingBisect = (0, $df292301a551a084$export$2e2bcd8739ae039)((0, $3de15593722c01cd$export$2e2bcd8739ae039));
const $b9a62473dad8dfb1$export$4d945ad3ad5751b0 = $b9a62473dad8dfb1$var$ascendingBisect.right;
const $b9a62473dad8dfb1$export$df7d25c84ebd12a5 = $b9a62473dad8dfb1$var$ascendingBisect.left;
const $b9a62473dad8dfb1$export$c1cb828b1117c77b = (0, $df292301a551a084$export$2e2bcd8739ae039)((0, $37fd68d7f32545a9$export$2e2bcd8739ae039)).center;
var $b9a62473dad8dfb1$export$2e2bcd8739ae039 = $b9a62473dad8dfb1$export$4d945ad3ad5751b0;



var $hNlxu = parcelRequire("hNlxu");

var $hNlxu = parcelRequire("hNlxu");
function $518fc8babc76e0b6$export$4e41033bfeec1a4c(t1, v0, v1, v2, v3) {
    var t2 = t1 * t1, t3 = t2 * t1;
    return ((1 - 3 * t1 + 3 * t2 - t3) * v0 + (4 - 6 * t2 + 3 * t3) * v1 + (1 + 3 * t1 + 3 * t2 - 3 * t3) * v2 + t3 * v3) / 6;
}
function $518fc8babc76e0b6$export$2e2bcd8739ae039(values) {
    var n = values.length - 1;
    return function(t) {
        var i = t <= 0 ? t = 0 : t >= 1 ? (t = 1, n - 1) : Math.floor(t * n), v1 = values[i], v2 = values[i + 1], v0 = i > 0 ? values[i - 1] : 2 * v1 - v2, v3 = i < n - 1 ? values[i + 2] : 2 * v2 - v1;
        return $518fc8babc76e0b6$export$4e41033bfeec1a4c((t - i / n) * n, v0, v1, v2, v3);
    };
}



function $e9dd78f8e9102c31$export$2e2bcd8739ae039(values) {
    var n = values.length;
    return function(t) {
        var i = Math.floor(((t %= 1) < 0 ? ++t : t) * n), v0 = values[(i + n - 1) % n], v1 = values[i % n], v2 = values[(i + 1) % n], v3 = values[(i + 2) % n];
        return (0, $518fc8babc76e0b6$export$4e41033bfeec1a4c)((t - i / n) * n, v0, v1, v2, v3);
    };
}


var $4e3362e63ead71f2$export$2e2bcd8739ae039 = (x)=>()=>x;


function $27ad955e998bf52e$var$linear(a, d) {
    return function(t) {
        return a + t * d;
    };
}
function $27ad955e998bf52e$var$exponential(a, b, y) {
    return a = Math.pow(a, y), b = Math.pow(b, y) - a, y = 1 / y, function(t) {
        return Math.pow(a + t * b, y);
    };
}
function $27ad955e998bf52e$export$97d7b0c7ddb78dcf(a, b) {
    var d = b - a;
    return d ? $27ad955e998bf52e$var$linear(a, d > 180 || d < -180 ? d - 360 * Math.round(d / 360) : d) : (0, $4e3362e63ead71f2$export$2e2bcd8739ae039)(isNaN(a) ? b : a);
}
function $27ad955e998bf52e$export$a7ebe8cc6aaf8d37(y) {
    return (y = +y) === 1 ? $27ad955e998bf52e$export$2e2bcd8739ae039 : function(a, b) {
        return b - a ? $27ad955e998bf52e$var$exponential(a, b, y) : (0, $4e3362e63ead71f2$export$2e2bcd8739ae039)(isNaN(a) ? b : a);
    };
}
function $27ad955e998bf52e$export$2e2bcd8739ae039(a, b) {
    var d = b - a;
    return d ? $27ad955e998bf52e$var$linear(a, d) : (0, $4e3362e63ead71f2$export$2e2bcd8739ae039)(isNaN(a) ? b : a);
}


var $d2b5792f11522b9c$export$2e2bcd8739ae039 = function rgbGamma(y) {
    var color = (0, $27ad955e998bf52e$export$a7ebe8cc6aaf8d37)(y);
    function rgb(start, end) {
        var r = color((start = (0, $hNlxu.rgb)(start)).r, (end = (0, $hNlxu.rgb)(end)).r), g = color(start.g, end.g), b = color(start.b, end.b), opacity = (0, $27ad955e998bf52e$export$2e2bcd8739ae039)(start.opacity, end.opacity);
        return function(t) {
            start.r = r(t);
            start.g = g(t);
            start.b = b(t);
            start.opacity = opacity(t);
            return start + "";
        };
    }
    rgb.gamma = rgbGamma;
    return rgb;
}(1);
function $d2b5792f11522b9c$var$rgbSpline(spline) {
    return function(colors) {
        var n = colors.length, r = new Array(n), g = new Array(n), b = new Array(n), i, color;
        for(i = 0; i < n; ++i){
            color = (0, $hNlxu.rgb)(colors[i]);
            r[i] = color.r || 0;
            g[i] = color.g || 0;
            b[i] = color.b || 0;
        }
        r = spline(r);
        g = spline(g);
        b = spline(b);
        color.opacity = 1;
        return function(t) {
            color.r = r(t);
            color.g = g(t);
            color.b = b(t);
            return color + "";
        };
    };
}
var $d2b5792f11522b9c$export$2c0e28f2e2852d3f = $d2b5792f11522b9c$var$rgbSpline((0, $518fc8babc76e0b6$export$2e2bcd8739ae039));
var $d2b5792f11522b9c$export$53d5214f625ccd4c = $d2b5792f11522b9c$var$rgbSpline((0, $e9dd78f8e9102c31$export$2e2bcd8739ae039));



function $46768ce7d23501ac$export$2e2bcd8739ae039(a, b) {
    if (!b) b = [];
    var n = a ? Math.min(b.length, a.length) : 0, c = b.slice(), i;
    return function(t) {
        for(i = 0; i < n; ++i)c[i] = a[i] * (1 - t) + b[i] * t;
        return c;
    };
}
function $46768ce7d23501ac$export$5cd576d1827d40c8(x) {
    return ArrayBuffer.isView(x) && !(x instanceof DataView);
}


function $95a25b90f136cdc4$export$2e2bcd8739ae039(a, b) {
    return ((0, $46768ce7d23501ac$export$5cd576d1827d40c8)(b) ? (0, $46768ce7d23501ac$export$2e2bcd8739ae039) : $95a25b90f136cdc4$export$15d09067c6a5ee49)(a, b);
}
function $95a25b90f136cdc4$export$15d09067c6a5ee49(a, b) {
    var nb = b ? b.length : 0, na = a ? Math.min(nb, a.length) : 0, x = new Array(na), c = new Array(nb), i;
    for(i = 0; i < na; ++i)x[i] = (0, $2225a6ce38a3bc4c$export$2e2bcd8739ae039)(a[i], b[i]);
    for(; i < nb; ++i)c[i] = b[i];
    return function(t) {
        for(i = 0; i < na; ++i)c[i] = x[i](t);
        return c;
    };
}


function $da6ea7fcca21587a$export$2e2bcd8739ae039(a, b) {
    var d = new Date;
    return a = +a, b = +b, function(t) {
        return d.setTime(a * (1 - t) + b * t), d;
    };
}


function $861516f390bef007$export$2e2bcd8739ae039(a, b) {
    return a = +a, b = +b, function(t) {
        return a * (1 - t) + b * t;
    };
}



function $53cc6176cc97d313$export$2e2bcd8739ae039(a, b) {
    var i = {}, c = {}, k;
    if (a === null || typeof a !== "object") a = {};
    if (b === null || typeof b !== "object") b = {};
    for(k in b)if (k in a) i[k] = (0, $2225a6ce38a3bc4c$export$2e2bcd8739ae039)(a[k], b[k]);
    else c[k] = b[k];
    return function(t) {
        for(k in i)c[k] = i[k](t);
        return c;
    };
}



var $ffc4486c2fe4e856$var$reA = /[-+]?(?:\d+\.?\d*|\.?\d+)(?:[eE][-+]?\d+)?/g, $ffc4486c2fe4e856$var$reB = new RegExp($ffc4486c2fe4e856$var$reA.source, "g");
function $ffc4486c2fe4e856$var$zero(b) {
    return function() {
        return b;
    };
}
function $ffc4486c2fe4e856$var$one(b) {
    return function(t) {
        return b(t) + "";
    };
}
function $ffc4486c2fe4e856$export$2e2bcd8739ae039(a, b) {
    var bi = $ffc4486c2fe4e856$var$reA.lastIndex = $ffc4486c2fe4e856$var$reB.lastIndex = 0, am, bm, bs, i = -1, s = [], q = []; // number interpolators
    // Coerce inputs to strings.
    a = a + "", b = b + "";
    // Interpolate pairs of numbers in a & b.
    while((am = $ffc4486c2fe4e856$var$reA.exec(a)) && (bm = $ffc4486c2fe4e856$var$reB.exec(b))){
        if ((bs = bm.index) > bi) {
            bs = b.slice(bi, bs);
            if (s[i]) s[i] += bs; // coalesce with previous string
            else s[++i] = bs;
        }
        if ((am = am[0]) === (bm = bm[0])) {
            if (s[i]) s[i] += bm; // coalesce with previous string
            else s[++i] = bm;
        } else {
            s[++i] = null;
            q.push({
                i: i,
                x: (0, $861516f390bef007$export$2e2bcd8739ae039)(am, bm)
            });
        }
        bi = $ffc4486c2fe4e856$var$reB.lastIndex;
    }
    // Add remains of b.
    if (bi < b.length) {
        bs = b.slice(bi);
        if (s[i]) s[i] += bs; // coalesce with previous string
        else s[++i] = bs;
    }
    // Special optimization for only a single match.
    // Otherwise, interpolate each of the numbers and rejoin the string.
    return s.length < 2 ? q[0] ? $ffc4486c2fe4e856$var$one(q[0].x) : $ffc4486c2fe4e856$var$zero(b) : (b = q.length, function(t) {
        for(var i = 0, o; i < b; ++i)s[(o = q[i]).i] = o.x(t);
        return s.join("");
    });
}




function $2225a6ce38a3bc4c$export$2e2bcd8739ae039(a, b) {
    var t = typeof b, c;
    return b == null || t === "boolean" ? (0, $4e3362e63ead71f2$export$2e2bcd8739ae039)(b) : (t === "number" ? (0, $861516f390bef007$export$2e2bcd8739ae039) : t === "string" ? (c = (0, $hNlxu.default)(b)) ? (b = c, $d2b5792f11522b9c$export$2e2bcd8739ae039) : (0, $ffc4486c2fe4e856$export$2e2bcd8739ae039) : b instanceof (0, $hNlxu.default) ? (0, $d2b5792f11522b9c$export$2e2bcd8739ae039) : b instanceof Date ? (0, $da6ea7fcca21587a$export$2e2bcd8739ae039) : (0, $46768ce7d23501ac$export$5cd576d1827d40c8)(b) ? (0, $46768ce7d23501ac$export$2e2bcd8739ae039) : Array.isArray(b) ? (0, $95a25b90f136cdc4$export$15d09067c6a5ee49) : typeof b.valueOf !== "function" && typeof b.toString !== "function" || isNaN(b) ? (0, $53cc6176cc97d313$export$2e2bcd8739ae039) : (0, $861516f390bef007$export$2e2bcd8739ae039))(a, b);
}

function $066659eef754a0fa$export$2e2bcd8739ae039(a, b) {
    return a = +a, b = +b, function(t) {
        return Math.round(a * (1 - t) + b * t);
    };
}


function $c3498260456ca185$export$2e2bcd8739ae039(x) {
    return function() {
        return x;
    };
}


function $40c2318887ac8736$export$2e2bcd8739ae039(x) {
    return +x;
}


var $c16acaa6fa39a403$var$unit = [
    0,
    1
];
function $c16acaa6fa39a403$export$f0954fd7d5368655(x) {
    return x;
}
function $c16acaa6fa39a403$var$normalize(a, b) {
    return (b -= a = +a) ? function(x) {
        return (x - a) / b;
    } : (0, $c3498260456ca185$export$2e2bcd8739ae039)(isNaN(b) ? NaN : 0.5);
}
function $c16acaa6fa39a403$var$clamper(a, b) {
    var t;
    if (a > b) t = a, a = b, b = t;
    return function(x) {
        return Math.max(a, Math.min(b, x));
    };
}
// normalize(a, b)(x) takes a domain value x in [a,b] and returns the corresponding parameter t in [0,1].
// interpolate(a, b)(t) takes a parameter t in [0,1] and returns the corresponding range value x in [a,b].
function $c16acaa6fa39a403$var$bimap(domain, range, interpolate) {
    var d0 = domain[0], d1 = domain[1], r0 = range[0], r1 = range[1];
    if (d1 < d0) d0 = $c16acaa6fa39a403$var$normalize(d1, d0), r0 = interpolate(r1, r0);
    else d0 = $c16acaa6fa39a403$var$normalize(d0, d1), r0 = interpolate(r0, r1);
    return function(x) {
        return r0(d0(x));
    };
}
function $c16acaa6fa39a403$var$polymap(domain, range, interpolate) {
    var j = Math.min(domain.length, range.length) - 1, d = new Array(j), r = new Array(j), i = -1;
    // Reverse descending domains.
    if (domain[j] < domain[0]) {
        domain = domain.slice().reverse();
        range = range.slice().reverse();
    }
    while(++i < j){
        d[i] = $c16acaa6fa39a403$var$normalize(domain[i], domain[i + 1]);
        r[i] = interpolate(range[i], range[i + 1]);
    }
    return function(x) {
        var i = (0, $b9a62473dad8dfb1$export$2e2bcd8739ae039)(domain, x, 1, j) - 1;
        return r[i](d[i](x));
    };
}
function $c16acaa6fa39a403$export$784d13d8ee351f07(source, target) {
    return target.domain(source.domain()).range(source.range()).interpolate(source.interpolate()).clamp(source.clamp()).unknown(source.unknown());
}
function $c16acaa6fa39a403$export$6b468dcfb64c653c() {
    var domain = $c16acaa6fa39a403$var$unit, range = $c16acaa6fa39a403$var$unit, interpolate = (0, $2225a6ce38a3bc4c$export$2e2bcd8739ae039), transform, untransform, unknown, clamp = $c16acaa6fa39a403$export$f0954fd7d5368655, piecewise, output, input;
    function rescale() {
        var n = Math.min(domain.length, range.length);
        if (clamp !== $c16acaa6fa39a403$export$f0954fd7d5368655) clamp = $c16acaa6fa39a403$var$clamper(domain[0], domain[n - 1]);
        piecewise = n > 2 ? $c16acaa6fa39a403$var$polymap : $c16acaa6fa39a403$var$bimap;
        output = input = null;
        return scale;
    }
    function scale(x) {
        return x == null || isNaN(x = +x) ? unknown : (output || (output = piecewise(domain.map(transform), range, interpolate)))(transform(clamp(x)));
    }
    scale.invert = function(y) {
        return clamp(untransform((input || (input = piecewise(range, domain.map(transform), (0, $861516f390bef007$export$2e2bcd8739ae039))))(y)));
    };
    scale.domain = function(_) {
        return arguments.length ? (domain = Array.from(_, (0, $40c2318887ac8736$export$2e2bcd8739ae039)), rescale()) : domain.slice();
    };
    scale.range = function(_) {
        return arguments.length ? (range = Array.from(_), rescale()) : range.slice();
    };
    scale.rangeRound = function(_) {
        return range = Array.from(_), interpolate = (0, $066659eef754a0fa$export$2e2bcd8739ae039), rescale();
    };
    scale.clamp = function(_) {
        return arguments.length ? (clamp = _ ? true : $c16acaa6fa39a403$export$f0954fd7d5368655, rescale()) : clamp !== $c16acaa6fa39a403$export$f0954fd7d5368655;
    };
    scale.interpolate = function(_) {
        return arguments.length ? (interpolate = _, rescale()) : interpolate;
    };
    scale.unknown = function(_) {
        return arguments.length ? (unknown = _, scale) : unknown;
    };
    return function(t, u) {
        transform = t, untransform = u;
        return rescale();
    };
}
function $c16acaa6fa39a403$export$2e2bcd8739ae039() {
    return $c16acaa6fa39a403$export$6b468dcfb64c653c()($c16acaa6fa39a403$export$f0954fd7d5368655, $c16acaa6fa39a403$export$f0954fd7d5368655);
}


function $73c7a1f077a54c73$export$23c7bb9e6558da2a(domain, range) {
    switch(arguments.length){
        case 0:
            break;
        case 1:
            this.range(domain);
            break;
        default:
            this.range(range).domain(domain);
            break;
    }
    return this;
}
function $73c7a1f077a54c73$export$7d6b419e59e83f3d(domain, interpolator) {
    switch(arguments.length){
        case 0:
            break;
        case 1:
            if (typeof domain === "function") this.interpolator(domain);
            else this.range(domain);
            break;
        default:
            this.domain(domain);
            if (typeof interpolator === "function") this.interpolator(interpolator);
            else this.range(interpolator);
            break;
    }
    return this;
}



function $336606e4467c7c06$export$2e2bcd8739ae039(x) {
    return Math.abs(x = Math.round(x)) >= 1e21 ? x.toLocaleString("en").replace(/,/g, "") : x.toString(10);
}
function $336606e4467c7c06$export$8f8e23dd27dc19f5(x, p) {
    if ((i = (x = p ? x.toExponential(p - 1) : x.toExponential()).indexOf("e")) < 0) return null; // NaN, Infinity
    var i, coefficient = x.slice(0, i);
    // The string returned by toExponential either has the form \d\.\d+e[-+]\d+
    // (e.g., 1.2e+3) or the form \de[-+]\d+ (e.g., 1e+3).
    return [
        coefficient.length > 1 ? coefficient[0] + coefficient.slice(2) : coefficient,
        +x.slice(i + 1)
    ];
}


function $66ddd43ef132fe4c$export$2e2bcd8739ae039(x) {
    return x = (0, $336606e4467c7c06$export$8f8e23dd27dc19f5)(Math.abs(x)), x ? x[1] : NaN;
}


function $4886ae7df3b00c8d$export$2e2bcd8739ae039(grouping, thousands) {
    return function(value, width) {
        var i = value.length, t = [], j = 0, g = grouping[0], length = 0;
        while(i > 0 && g > 0){
            if (length + g + 1 > width) g = Math.max(1, width - length);
            t.push(value.substring(i -= g, i + g));
            if ((length += g + 1) > width) break;
            g = grouping[j = (j + 1) % grouping.length];
        }
        return t.reverse().join(thousands);
    };
}


function $08e49d150cf0e40b$export$2e2bcd8739ae039(numerals) {
    return function(value) {
        return value.replace(/[0-9]/g, function(i) {
            return numerals[+i];
        });
    };
}


// [[fill]align][sign][symbol][0][width][,][.precision][~][type]
var $4e7c2ad27f8b8986$var$re = /^(?:(.)?([<>=^]))?([+\-( ])?([$#])?(0)?(\d+)?(,)?(\.\d+)?(~)?([a-z%])?$/i;
function $4e7c2ad27f8b8986$export$2e2bcd8739ae039(specifier) {
    if (!(match = $4e7c2ad27f8b8986$var$re.exec(specifier))) throw new Error("invalid format: " + specifier);
    var match;
    return new $4e7c2ad27f8b8986$export$963aac351db36ed4({
        fill: match[1],
        align: match[2],
        sign: match[3],
        symbol: match[4],
        zero: match[5],
        width: match[6],
        comma: match[7],
        precision: match[8] && match[8].slice(1),
        trim: match[9],
        type: match[10]
    });
}
$4e7c2ad27f8b8986$export$2e2bcd8739ae039.prototype = $4e7c2ad27f8b8986$export$963aac351db36ed4.prototype; // instanceof
function $4e7c2ad27f8b8986$export$963aac351db36ed4(specifier) {
    this.fill = specifier.fill === undefined ? " " : specifier.fill + "";
    this.align = specifier.align === undefined ? ">" : specifier.align + "";
    this.sign = specifier.sign === undefined ? "-" : specifier.sign + "";
    this.symbol = specifier.symbol === undefined ? "" : specifier.symbol + "";
    this.zero = !!specifier.zero;
    this.width = specifier.width === undefined ? undefined : +specifier.width;
    this.comma = !!specifier.comma;
    this.precision = specifier.precision === undefined ? undefined : +specifier.precision;
    this.trim = !!specifier.trim;
    this.type = specifier.type === undefined ? "" : specifier.type + "";
}
$4e7c2ad27f8b8986$export$963aac351db36ed4.prototype.toString = function() {
    return this.fill + this.align + this.sign + this.symbol + (this.zero ? "0" : "") + (this.width === undefined ? "" : Math.max(1, this.width | 0)) + (this.comma ? "," : "") + (this.precision === undefined ? "" : "." + Math.max(0, this.precision | 0)) + (this.trim ? "~" : "") + this.type;
};


// Trims insignificant zeros, e.g., replaces 1.2000k with 1.2k.
function $df30648ee9197e79$export$2e2bcd8739ae039(s) {
    out: for(var n = s.length, i = 1, i0 = -1, i1; i < n; ++i)switch(s[i]){
        case ".":
            i0 = i1 = i;
            break;
        case "0":
            if (i0 === 0) i0 = i;
            i1 = i;
            break;
        default:
            if (!+s[i]) break out;
            if (i0 > 0) i0 = 0;
            break;
    }
    return i0 > 0 ? s.slice(0, i0) + s.slice(i1 + 1) : s;
}




var $54258f7cd36fe54f$export$6863724d9a42263;
function $54258f7cd36fe54f$export$2e2bcd8739ae039(x, p) {
    var d = (0, $336606e4467c7c06$export$8f8e23dd27dc19f5)(x, p);
    if (!d) return x + "";
    var coefficient = d[0], exponent = d[1], i = exponent - ($54258f7cd36fe54f$export$6863724d9a42263 = Math.max(-8, Math.min(8, Math.floor(exponent / 3))) * 3) + 1, n = coefficient.length;
    return i === n ? coefficient : i > n ? coefficient + new Array(i - n + 1).join("0") : i > 0 ? coefficient.slice(0, i) + "." + coefficient.slice(i) : "0." + new Array(1 - i).join("0") + (0, $336606e4467c7c06$export$8f8e23dd27dc19f5)(x, Math.max(0, p + i - 1))[0]; // less than 1y!
}



function $679e3c4c7287d755$export$2e2bcd8739ae039(x, p) {
    var d = (0, $336606e4467c7c06$export$8f8e23dd27dc19f5)(x, p);
    if (!d) return x + "";
    var coefficient = d[0], exponent = d[1];
    return exponent < 0 ? "0." + new Array(-exponent).join("0") + coefficient : coefficient.length > exponent + 1 ? coefficient.slice(0, exponent + 1) + "." + coefficient.slice(exponent + 1) : coefficient + new Array(exponent - coefficient.length + 2).join("0");
}


var $80f7b023ca9d43c7$export$2e2bcd8739ae039 = {
    "%": (x, p)=>(x * 100).toFixed(p),
    "b": (x)=>Math.round(x).toString(2),
    "c": (x)=>x + "",
    "d": (0, $336606e4467c7c06$export$2e2bcd8739ae039),
    "e": (x, p)=>x.toExponential(p),
    "f": (x, p)=>x.toFixed(p),
    "g": (x, p)=>x.toPrecision(p),
    "o": (x)=>Math.round(x).toString(8),
    "p": (x, p)=>(0, $679e3c4c7287d755$export$2e2bcd8739ae039)(x * 100, p),
    "r": (0, $679e3c4c7287d755$export$2e2bcd8739ae039),
    "s": (0, $54258f7cd36fe54f$export$2e2bcd8739ae039),
    "X": (x)=>Math.round(x).toString(16).toUpperCase(),
    "x": (x)=>Math.round(x).toString(16)
};



function $40245bd1e15a08bc$export$2e2bcd8739ae039(x) {
    return x;
}


var $c953dd2438486cb9$var$map = Array.prototype.map, $c953dd2438486cb9$var$prefixes = [
    "y",
    "z",
    "a",
    "f",
    "p",
    "n",
    "\xb5",
    "m",
    "",
    "k",
    "M",
    "G",
    "T",
    "P",
    "E",
    "Z",
    "Y"
];
function $c953dd2438486cb9$export$2e2bcd8739ae039(locale) {
    var group = locale.grouping === undefined || locale.thousands === undefined ? (0, $40245bd1e15a08bc$export$2e2bcd8739ae039) : (0, $4886ae7df3b00c8d$export$2e2bcd8739ae039)($c953dd2438486cb9$var$map.call(locale.grouping, Number), locale.thousands + ""), currencyPrefix = locale.currency === undefined ? "" : locale.currency[0] + "", currencySuffix = locale.currency === undefined ? "" : locale.currency[1] + "", decimal = locale.decimal === undefined ? "." : locale.decimal + "", numerals = locale.numerals === undefined ? (0, $40245bd1e15a08bc$export$2e2bcd8739ae039) : (0, $08e49d150cf0e40b$export$2e2bcd8739ae039)($c953dd2438486cb9$var$map.call(locale.numerals, String)), percent = locale.percent === undefined ? "%" : locale.percent + "", minus = locale.minus === undefined ? "\u2212" : locale.minus + "", nan = locale.nan === undefined ? "NaN" : locale.nan + "";
    function newFormat(specifier) {
        specifier = (0, $4e7c2ad27f8b8986$export$2e2bcd8739ae039)(specifier);
        var fill = specifier.fill, align = specifier.align, sign = specifier.sign, symbol = specifier.symbol, zero = specifier.zero, width = specifier.width, comma = specifier.comma, precision = specifier.precision, trim = specifier.trim, type = specifier.type;
        // The "n" type is an alias for ",g".
        if (type === "n") comma = true, type = "g";
        else if (!(0, $80f7b023ca9d43c7$export$2e2bcd8739ae039)[type]) precision === undefined && (precision = 12), trim = true, type = "g";
        // If zero fill is specified, padding goes after sign and before digits.
        if (zero || fill === "0" && align === "=") zero = true, fill = "0", align = "=";
        // Compute the prefix and suffix.
        // For SI-prefix, the suffix is lazily computed.
        var prefix = symbol === "$" ? currencyPrefix : symbol === "#" && /[boxX]/.test(type) ? "0" + type.toLowerCase() : "", suffix = symbol === "$" ? currencySuffix : /[%p]/.test(type) ? percent : "";
        // What format function should we use?
        // Is this an integer type?
        // Can this type generate exponential notation?
        var formatType = (0, $80f7b023ca9d43c7$export$2e2bcd8739ae039)[type], maybeSuffix = /[defgprs%]/.test(type);
        // Set the default precision if not specified,
        // or clamp the specified precision to the supported range.
        // For significant precision, it must be in [1, 21].
        // For fixed precision, it must be in [0, 20].
        precision = precision === undefined ? 6 : /[gprs]/.test(type) ? Math.max(1, Math.min(21, precision)) : Math.max(0, Math.min(20, precision));
        function format(value) {
            var valuePrefix = prefix, valueSuffix = suffix, i, n, c;
            if (type === "c") {
                valueSuffix = formatType(value) + valueSuffix;
                value = "";
            } else {
                value = +value;
                // Determine the sign. -0 is not less than 0, but 1 / -0 is!
                var valueNegative = value < 0 || 1 / value < 0;
                // Perform the initial formatting.
                value = isNaN(value) ? nan : formatType(Math.abs(value), precision);
                // Trim insignificant zeros.
                if (trim) value = (0, $df30648ee9197e79$export$2e2bcd8739ae039)(value);
                // If a negative value rounds to zero after formatting, and no explicit positive sign is requested, hide the sign.
                if (valueNegative && +value === 0 && sign !== "+") valueNegative = false;
                // Compute the prefix and suffix.
                valuePrefix = (valueNegative ? sign === "(" ? sign : minus : sign === "-" || sign === "(" ? "" : sign) + valuePrefix;
                valueSuffix = (type === "s" ? $c953dd2438486cb9$var$prefixes[8 + (0, $54258f7cd36fe54f$export$6863724d9a42263) / 3] : "") + valueSuffix + (valueNegative && sign === "(" ? ")" : "");
                // Break the formatted value into the integer value part that can be
                // grouped, and fractional or exponential suffix part that is not.
                if (maybeSuffix) {
                    i = -1, n = value.length;
                    while(++i < n)if (c = value.charCodeAt(i), 48 > c || c > 57) {
                        valueSuffix = (c === 46 ? decimal + value.slice(i + 1) : value.slice(i)) + valueSuffix;
                        value = value.slice(0, i);
                        break;
                    }
                }
            }
            // If the fill character is not "0", grouping is applied before padding.
            if (comma && !zero) value = group(value, Infinity);
            // Compute the padding.
            var length = valuePrefix.length + value.length + valueSuffix.length, padding = length < width ? new Array(width - length + 1).join(fill) : "";
            // If the fill character is "0", grouping is applied after padding.
            if (comma && zero) value = group(padding + value, padding.length ? width - valueSuffix.length : Infinity), padding = "";
            // Reconstruct the final output based on the desired alignment.
            switch(align){
                case "<":
                    value = valuePrefix + value + valueSuffix + padding;
                    break;
                case "=":
                    value = valuePrefix + padding + value + valueSuffix;
                    break;
                case "^":
                    value = padding.slice(0, length = padding.length >> 1) + valuePrefix + value + valueSuffix + padding.slice(length);
                    break;
                default:
                    value = padding + valuePrefix + value + valueSuffix;
                    break;
            }
            return numerals(value);
        }
        format.toString = function() {
            return specifier + "";
        };
        return format;
    }
    function formatPrefix(specifier, value) {
        var f = newFormat((specifier = (0, $4e7c2ad27f8b8986$export$2e2bcd8739ae039)(specifier), specifier.type = "f", specifier)), e = Math.max(-8, Math.min(8, Math.floor((0, $66ddd43ef132fe4c$export$2e2bcd8739ae039)(value) / 3))) * 3, k = Math.pow(10, -e), prefix = $c953dd2438486cb9$var$prefixes[8 + e / 3];
        return function(value) {
            return f(k * value) + prefix;
        };
    }
    return {
        format: newFormat,
        formatPrefix: formatPrefix
    };
}


var $2ab610105ad986f3$var$locale;
var $2ab610105ad986f3$export$d9468344d3651243;
var $2ab610105ad986f3$export$8d85692a469dde6f;
$2ab610105ad986f3$export$2e2bcd8739ae039({
    thousands: ",",
    grouping: [
        3
    ],
    currency: [
        "$",
        ""
    ]
});
function $2ab610105ad986f3$export$2e2bcd8739ae039(definition) {
    $2ab610105ad986f3$var$locale = (0, $c953dd2438486cb9$export$2e2bcd8739ae039)(definition);
    $2ab610105ad986f3$export$d9468344d3651243 = $2ab610105ad986f3$var$locale.format;
    $2ab610105ad986f3$export$8d85692a469dde6f = $2ab610105ad986f3$var$locale.formatPrefix;
    return $2ab610105ad986f3$var$locale;
}


function $d781694d8ec32acd$export$2e2bcd8739ae039(step) {
    return Math.max(0, -(0, $66ddd43ef132fe4c$export$2e2bcd8739ae039)(Math.abs(step)));
}


function $c52109cbb6bdab7a$export$2e2bcd8739ae039(step, value) {
    return Math.max(0, Math.max(-8, Math.min(8, Math.floor((0, $66ddd43ef132fe4c$export$2e2bcd8739ae039)(value) / 3))) * 3 - (0, $66ddd43ef132fe4c$export$2e2bcd8739ae039)(Math.abs(step)));
}


function $d7d2d4681a1afd8c$export$2e2bcd8739ae039(step, max) {
    step = Math.abs(step), max = Math.abs(max) - step;
    return Math.max(0, (0, $66ddd43ef132fe4c$export$2e2bcd8739ae039)(max) - (0, $66ddd43ef132fe4c$export$2e2bcd8739ae039)(step)) + 1;
}


function $2f05cfe5fa1e6600$export$2e2bcd8739ae039(start, stop, count, specifier) {
    var step = (0, $b37ec5f783bfc709$export$81087d9b915d4ede)(start, stop, count), precision;
    specifier = (0, $4e7c2ad27f8b8986$export$2e2bcd8739ae039)(specifier == null ? ",f" : specifier);
    switch(specifier.type){
        case "s":
            var value = Math.max(Math.abs(start), Math.abs(stop));
            if (specifier.precision == null && !isNaN(precision = (0, $c52109cbb6bdab7a$export$2e2bcd8739ae039)(step, value))) specifier.precision = precision;
            return (0, $2ab610105ad986f3$export$8d85692a469dde6f)(specifier, value);
        case "":
        case "e":
        case "g":
        case "p":
        case "r":
            if (specifier.precision == null && !isNaN(precision = (0, $d7d2d4681a1afd8c$export$2e2bcd8739ae039)(step, Math.max(Math.abs(start), Math.abs(stop))))) specifier.precision = precision - (specifier.type === "e");
            break;
        case "f":
        case "%":
            if (specifier.precision == null && !isNaN(precision = (0, $d781694d8ec32acd$export$2e2bcd8739ae039)(step))) specifier.precision = precision - (specifier.type === "%") * 2;
            break;
    }
    return (0, $2ab610105ad986f3$export$d9468344d3651243)(specifier);
}


function $f7220656076fa594$export$16a5d4b4a61a274d(scale) {
    var domain = scale.domain;
    scale.ticks = function(count) {
        var d = domain();
        return (0, $b37ec5f783bfc709$export$2e2bcd8739ae039)(d[0], d[d.length - 1], count == null ? 10 : count);
    };
    scale.tickFormat = function(count, specifier) {
        var d = domain();
        return (0, $2f05cfe5fa1e6600$export$2e2bcd8739ae039)(d[0], d[d.length - 1], count == null ? 10 : count, specifier);
    };
    scale.nice = function(count) {
        if (count == null) count = 10;
        var d = domain();
        var i0 = 0;
        var i1 = d.length - 1;
        var start = d[i0];
        var stop = d[i1];
        var prestep;
        var step;
        var maxIter = 10;
        if (stop < start) {
            step = start, start = stop, stop = step;
            step = i0, i0 = i1, i1 = step;
        }
        while(maxIter-- > 0){
            step = (0, $b37ec5f783bfc709$export$bc64d00cc98e7e95)(start, stop, count);
            if (step === prestep) {
                d[i0] = start;
                d[i1] = stop;
                return domain(d);
            } else if (step > 0) {
                start = Math.floor(start / step) * step;
                stop = Math.ceil(stop / step) * step;
            } else if (step < 0) {
                start = Math.ceil(start * step) / step;
                stop = Math.floor(stop * step) / step;
            } else break;
            prestep = step;
        }
        return scale;
    };
    return scale;
}
function $f7220656076fa594$export$2e2bcd8739ae039() {
    var scale = (0, $c16acaa6fa39a403$export$2e2bcd8739ae039)();
    scale.copy = function() {
        return (0, $c16acaa6fa39a403$export$784d13d8ee351f07)(scale, $f7220656076fa594$export$2e2bcd8739ae039());
    };
    (0, $73c7a1f077a54c73$export$23c7bb9e6558da2a).apply(scale, arguments);
    return $f7220656076fa594$export$16a5d4b4a61a274d(scale);
}



function $099aaea57d9dcbf4$export$2be97f482a239d30(transition, currentData, selection, presenter) {
    const { layerStagger: layerStagger } = presenter.morphchartsref;
    const { morphChartsRenderResult: morphChartsRenderResult } = presenter;
    const cubelayer = morphChartsRenderResult.getCubeLayer();
    const range = transition.reverse ? [
        1,
        0
    ] : [
        0,
        1
    ];
    if (!transition || transition.type === 'ordinal' && !transition.reverse) delete layerStagger.cubes;
    else {
        const staggerOrders = new Float64Array(cubelayer.positionsX.length);
        switch(transition.type){
            case 'ordinal':
                {
                    //reverse ordinal
                    const scale = (0, $f7220656076fa594$export$2e2bcd8739ae039)(range).domain([
                        0,
                        currentData.length
                    ]);
                    currentData.forEach((datum, i)=>{
                        const glOrdinal = datum[0, $44b8bb162b63b5b5$export$5672246984822a29];
                        staggerOrders[glOrdinal] = scale(i);
                    });
                    break;
                }
            case 'column':
                if (transition.column.quantitative) {
                    const values = new Float64Array(currentData.length);
                    currentData.forEach((datum, i)=>{
                        values[i] = datum[transition.column.name];
                    });
                    const stats = (0, $8e54999951217c95$export$432f698644f45d1)(currentData, transition.column);
                    const scale = (0, $f7220656076fa594$export$2e2bcd8739ae039)(range).domain([
                        stats.min,
                        stats.max
                    ]);
                    currentData.forEach((datum, i)=>{
                        const glOrdinal = datum[0, $44b8bb162b63b5b5$export$5672246984822a29];
                        staggerOrders[glOrdinal] = scale(values[i]);
                    });
                } else {
                    const strings = new Array(currentData.length);
                    currentData.forEach((datum, i)=>{
                        strings[i] = datum[transition.column.name];
                    });
                    (0, $8e54999951217c95$export$432f698644f45d1)(currentData, transition.column, (distictValues)=>{
                        currentData.forEach((datum, i)=>{
                            const glOrdinal = datum[0, $44b8bb162b63b5b5$export$5672246984822a29];
                            const index = distictValues.indexOf(strings[i]);
                            const staggerOrder = index / distictValues.length;
                            staggerOrders[glOrdinal] = transition.reverse ? 1 - staggerOrder : staggerOrder;
                        });
                    });
                }
                break;
            case 'position':
                {
                    const dimensions = {
                        x: cubelayer.positionsX,
                        y: cubelayer.positionsY,
                        z: cubelayer.positionsZ
                    };
                    const positions = dimensions[transition.dimension];
                    const values = new Float64Array(currentData.length);
                    currentData.forEach((datum, i)=>{
                        const glOrdinal = datum[0, $44b8bb162b63b5b5$export$5672246984822a29];
                        values[i] = positions[glOrdinal];
                    });
                    const stats = (0, $8e54999951217c95$export$432f698644f45d1)(values, null, 'number', true);
                    const scale = (0, $f7220656076fa594$export$2e2bcd8739ae039)(range).domain([
                        stats.min,
                        stats.max
                    ]);
                    currentData.forEach((datum, i)=>{
                        const glOrdinal = datum[0, $44b8bb162b63b5b5$export$5672246984822a29];
                        staggerOrders[glOrdinal] = scale(values[i]);
                    });
                    break;
                }
        }
        layerStagger.cubes = {
            staggerOrders: staggerOrders,
            maxStaggerOrder: 1,
            minStaggerOrder: 0
        };
    }
    cubelayer.update(morphChartsRenderResult.bounds, selection, layerStagger.cubes);
}


var $6662f126c1d9f58b$var$__awaiter = undefined && undefined.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
            resolve(value);
        });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
            try {
                step(generator.next(value));
            } catch (e) {
                reject(e);
            }
        }
        function rejected(value) {
            try {
                step(generator["throw"](value));
            } catch (e) {
                reject(e);
            }
        }
        function step(result) {
            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
const { defaultView: $6662f126c1d9f58b$var$defaultView } = $a2698ea08ecf5377$exports;
const $6662f126c1d9f58b$var$zAxisZindex = 1010;
let $6662f126c1d9f58b$var$didRegisterColorSchemes = false;
class $6662f126c1d9f58b$export$2ec4afd9b3c16a85 {
    /**
     * Instantiate a new Viewer.
     * @param element Parent HTMLElement to present within.
     * @param options Optional viewer options object.
     */ constructor(element, options){
        this.element = element;
        this.options = $c5578f8838abba3d$exports.deepMerge((0, $16f9e3e56a5dcd59$export$fb736e4909afb3d7), options);
        this.presenter = new $6dfc103fcb41a0e6$export$893c88c42e3630f9(element, (0, $16f9e3e56a5dcd59$export$c4db461e5e345a8)(this.options));
        //this.presenter.logger = console.log;
        this._characterSet = new (0, $10ee4fd0042461c6$export$fba22c9d3f66adb)();
        this._dataScope = new (0, $298086c83cbc7842$export$3fb74a6ae4f1171d)();
        this._animator = new (0, $6b115708bb157a7f$export$c774d8c9d4e9e234)(this._dataScope, {
            onDataChanged: this.onDataChanged.bind(this),
            onAnimateDataChange: this.onAnimateDataChange.bind(this)
        });
        this._details = new (0, $f701b9e6e9858c3b$export$3e8048d3cf2ba3fd)(this.presenter.getElement($57337365aaceccbe$export$79420be32f83a5b0.panel), this.options.language, this._animator, this._dataScope, (remap)=>{
            this.currentColorContext = ~~remap;
            this.renderSameLayout();
        }, ()=>this.insight && this.insight.columns && !!this.insight.columns.color && this.colorContexts && this.colorContexts.length > 1);
        this.insight = {};
    }
    changeColorContexts(colorContexts) {
        this.colorContexts = colorContexts;
        this.currentColorContext = 0;
        this.options.onColorContextChange && this.options.onColorContextChange();
    }
    applyLegendColorContext(colorContext) {
        const a = $c5578f8838abba3d$exports.getActiveElementInfo();
        $c5578f8838abba3d$exports.mount(colorContext.legendElement, this.presenter.getElement($57337365aaceccbe$export$79420be32f83a5b0.legend));
        $c5578f8838abba3d$exports.setActiveElement(a);
        this.presenter.stage.legend = colorContext.legend;
    }
    onAnimateDataChange(dataChange, waitingLabel, handlerLabel, time) {
        var _a;
        if (time === undefined) {
            const transitionDurations = ((_a = this.setup) === null || _a === void 0 ? void 0 : _a.transitionDurations) || $a2698ea08ecf5377$exports.defaultPresenterConfig.transitionDurations;
            time = transitionDurations.position + transitionDurations.stagger;
        }
        return new Promise((resolve, reject)=>{
            let innerPromise;
            if (dataChange === (0, $6b115708bb157a7f$export$d9e571576e98a7ab).refine) {
                const oldColorContext = this.colorContexts[this.currentColorContext];
                innerPromise = new Promise((innerResolve)=>{
                    this.renderNewLayout({}, Object.assign(Object.assign({}, this.setup || {}), {
                        preStage: (stage, cubeLayer)=>{
                            (0, $5c5541ba560b58df$export$71ab65a966760ac3)(this.insight.colorBin, this._specColumns.color, stage.legend, this.options.language);
                            this.overrideAxisLabels(stage);
                            cubeLayer.unitColorMap = oldColorContext.colorMap;
                            if (this.options.onStage) this.options.onStage(stage);
                        }
                    })).then(()=>{
                        //apply old legend
                        this.applyLegendColorContext(oldColorContext);
                        innerResolve();
                    });
                });
            } else innerPromise = this.renderNewLayout({}, Object.assign(Object.assign({}, this.setup || {}), {
                preStage: (stage, colorMapper)=>{
                    (0, $5c5541ba560b58df$export$71ab65a966760ac3)(this.insight.colorBin, this._specColumns.color, stage.legend, this.options.language);
                    this.overrideAxisLabels(stage);
                    if (this.options.onStage) this.options.onStage(stage);
                }
            }));
            innerPromise.then(()=>{
                this.presenter.animationQueue(resolve, time, {
                    waitingLabel: waitingLabel,
                    handlerLabel: handlerLabel,
                    animationCanceled: reject
                });
            });
        });
    }
    onDataChanged(dataLayout, filter) {
        return $6662f126c1d9f58b$var$__awaiter(this, void 0, void 0, function*() {
            switch(dataLayout){
                case (0, $6b115708bb157a7f$export$d9e571576e98a7ab).same:
                    {
                        const hasSelectedData = this._dataScope.hasSelectedData();
                        const hasActive = !!this._dataScope.active;
                        if (hasSelectedData || hasActive) this.presenter.morphChartsRenderResult.update({
                            cubes: this.convertSearchToSet()
                        });
                        else this.presenter.morphChartsRenderResult.update({
                            cubes: null
                        });
                        break;
                    }
                case (0, $6b115708bb157a7f$export$d9e571576e98a7ab).refine:
                    {
                        //save cube colors
                        const oldColorContext = this.colorContexts[this.currentColorContext];
                        let colorMap;
                        this.presenter.morphChartsRenderResult.update({
                            cubes: null
                        });
                        yield this.renderNewLayout({}, Object.assign(Object.assign({}, this.setup || {}), {
                            preStage: (stage, cubeLayer)=>{
                                //save off the spec colors
                                colorMap = cubeLayer.unitColorMap;
                                cubeLayer.unitColorMap = oldColorContext.colorMap;
                                this.preStage(stage, cubeLayer);
                            },
                            onPresent: ()=>{
                                //save new legend
                                const newColorContext = {
                                    colorMap: colorMap,
                                    legend: $c5578f8838abba3d$exports.clone(this.presenter.stage.legend),
                                    legendElement: this.presenter.getElement($57337365aaceccbe$export$79420be32f83a5b0.legend).children[0]
                                };
                                //apply old legend
                                this.applyLegendColorContext(oldColorContext);
                                this.changeColorContexts([
                                    oldColorContext,
                                    newColorContext
                                ]);
                                this.onPresent();
                            }
                        }));
                        //narrow the filter only if it is different
                        if (!$4c4e2fc4d7da02f0$export$398604a469f7de9a(this.insight.filter, filter)) this.insight.filter = $ed08d33b174a5471$export$ec67f55c222e1546(this.insight.filter, filter);
                        if (this.options.onDataFilter) this.options.onDataFilter(this.insight.filter, this._dataScope.currentData());
                        break;
                    }
                case (0, $6b115708bb157a7f$export$d9e571576e98a7ab).reset:
                    {
                        const colorContext = {
                            colorMap: null,
                            legend: null,
                            legendElement: null
                        };
                        this.changeColorContexts([
                            colorContext
                        ]);
                        this.presenter.morphChartsRenderResult.update({
                            cubes: null
                        });
                        yield this.renderNewLayout({}, Object.assign(Object.assign({}, this.setup || {}), {
                            onPresent: ()=>{
                                //color needs to change instantly
                                (0, $d862cbedfe5e328a$export$44addeff9a96c1e7)(colorContext, this.presenter);
                                this.onPresent();
                            }
                        }));
                        delete this.insight.filter;
                        if (this.options.onDataFilter) this.options.onDataFilter(null, null);
                        break;
                    }
            }
            if (this.options.onSelectionChanged) {
                const sel = this.getSelection();
                this.options.onSelectionChanged(sel && sel.search || null, 0, sel && sel.selectedData || null);
            }
        });
    }
    convertSearchToSet() {
        if (this._dataScope.selection) {
            const s = new Set();
            let found = false;
            this._dataScope.selection.included.forEach((o, i)=>{
                s.add(o[0, $44b8bb162b63b5b5$export$5672246984822a29]);
                found = true;
            });
            if (!found) s.add(-1);
            return s;
        }
    }
    convertSetToSearch(s) {
        const search = {
            expressions: []
        };
        s.forEach((value)=>{
            search.expressions.push({
                name: (0, $44b8bb162b63b5b5$export$5672246984822a29),
                operator: '==',
                value: value,
                clause: '||'
            });
        });
        return search;
    }
    getSpecColumnsWithFilteredStats() {
        if (!this._dataScope.hasFilteredData()) return this._specColumns;
        const roles = [
            'color',
            'facet',
            'group',
            'size',
            'sort',
            'sum',
            'x',
            'y',
            'z'
        ];
        const specColumns = Object.assign({}, this._specColumns);
        roles.forEach((r)=>{
            if (specColumns[r]) {
                const column = Object.assign({}, specColumns[r]);
                column.stats = this.getColumnStats(column);
                specColumns[r] = column;
            }
        });
        return specColumns;
    }
    renderNewLayout(signalValues, presenterConfig, view) {
        return $6662f126c1d9f58b$var$__awaiter(this, void 0, void 0, function*() {
            const currData = this._dataScope.currentData();
            const context = {
                specColumns: this.getSpecColumnsWithFilteredStats(),
                insight: this.insight,
                specViewOptions: Object.assign(Object.assign({}, this.options), {
                    zAxisOptions: {
                        showZAxis: true,
                        zIndex: $6662f126c1d9f58b$var$zAxisZindex
                    },
                    collapseFacetAxes: true
                })
            };
            const specResult = (0, $1c081eb26c39473d$export$3f8fe6489e95757d)(context, currData);
            if (!specResult.errors) {
                const uiValues = (0, $6728ad2e40252478$export$764590c093441ac7)(this.vegaViewGl, this.vegaSpec);
                (0, $6728ad2e40252478$export$385a06e733eab4de)(Object.assign(Object.assign({}, uiValues), signalValues), specResult.vegaSpec);
                (0, $6728ad2e40252478$export$dc91f38fb87dcbc8)(specResult.vegaSpec);
                this.vegaSpec = specResult.vegaSpec;
                this.options.onVegaSpec && this.options.onVegaSpec(this.vegaSpec);
                this.specCapabilities = specResult.specCapabilities;
                const config = this.createConfig(presenterConfig);
                this._lastPresenterConfig = config.presenterConfig;
                if (view) config.getView = ()=>view;
                if (!$6662f126c1d9f58b$var$didRegisterColorSchemes) {
                    (0, $1f9940ddae6f4302$export$3030070885af9365)($94b078fc391e7135$export$e2253033e6e1df16.vega);
                    $6662f126c1d9f58b$var$didRegisterColorSchemes = true;
                }
                try {
                    if (this.vegaViewGl) this.vegaViewGl.finalize();
                    const runtime = $94b078fc391e7135$export$e2253033e6e1df16.vega.parse(this.vegaSpec);
                    this.vegaViewGl = new $51fbad27d38c01a6$export$6d8f9057dcd7f9e6(runtime, config).renderer('morphcharts').initialize(this.element);
                    yield this.vegaViewGl.runAsync();
                    const handler = (n, v)=>{
                        this._characterSet.resetCharacterSet(true);
                    };
                    this.vegaSpec.signals.forEach((s)=>{
                        this.vegaViewGl.addSignalListener(s.name, handler);
                    });
                    //capture new color color contexts via signals
                    this.configForSignalCapture(config.presenterConfig);
                } catch (e) {
                    specResult.errors = [
                        e.message
                    ];
                }
                if (!specResult.errors) (0, $5daa0c31e678116a$export$1d674716cc6da32f)(this.presenter, this.options.language.headers);
            }
            if (specResult.errors) {
                if (this.options.onError) this.options.onError(specResult.errors);
                else if (this.presenter.logger) this.presenter.logger(`errors rendering Vega spec:${specResult.errors.join('\n')}`);
            }
            return specResult;
        });
    }
    /**
     * Render the same layout with new options.
     * @param newViewerOptions New options object.
     */ renderSameLayout(newViewerOptions) {
        const colorContext = this.colorContexts[this.currentColorContext];
        this.applyLegendColorContext(colorContext);
        if (newViewerOptions) {
            if (newViewerOptions.colors) {
                //set theme colors PresenterConfig
                const mcColors = this.getMorphChartsColors();
                this.presenter.configColors(mcColors);
                this._lastPresenterConfig.morphChartsColors = mcColors;
            }
            this.options = $c5578f8838abba3d$exports.deepMerge(this.options, newViewerOptions);
        }
        this.presenter.morphChartsRenderResult.getCubeLayer().unitColorMap = colorContext.colorMap;
        this.presenter.morphChartsRenderResult.update({
            cubes: this.convertSearchToSet()
        });
    }
    getView(view) {
        if (view === undefined) {
            if (this.presenter.view === null) return $6662f126c1d9f58b$var$defaultView;
            else return this.presenter.view;
        } else return view;
    }
    transformData(values, transform) {
        try {
            const runtime = $94b078fc391e7135$export$e2253033e6e1df16.vega.parse({
                $schema: 'https://vega.github.io/schema/vega/v4.json',
                data: [
                    {
                        name: 'source',
                        values: values,
                        transform: transform
                    }
                ]
            });
            new $51fbad27d38c01a6$export$6d8f9057dcd7f9e6(runtime).run();
        } catch (e) {
        // continue regardless of error
        }
        return values;
    }
    /**
     * Render data into a visualization.
     * @param insightSetup InsightSetup object to create a visualization rendering.
     * @param data Array of data objects.
     * @param renderOptions Optional RenderOptions object.
     */ render(insightSetup_1, data_1) {
        return $6662f126c1d9f58b$var$__awaiter(this, arguments, void 0, function*(insightSetup, data, renderOptions = {}) {
            const { insight: insight, setup: setup } = insightSetup;
            let result;
            //see if refine expression has changed
            if (!$4c4e2fc4d7da02f0$export$398604a469f7de9a(insight.filter, this.insight.filter)) {
                const transitionDurations = (setup === null || setup === void 0 ? void 0 : setup.transitionDurations) || $a2698ea08ecf5377$exports.defaultPresenterConfig.transitionDurations;
                const renderTime = transitionDurations.position + transitionDurations.stagger;
                const allowAsyncRenderTime = renderTime + this.options.filterRenderingTimerPadding;
                if (insight.filter) {
                    //refining
                    result = yield this._render(insightSetup, data, renderOptions, true);
                    this.presenter.animationQueue(()=>{
                        this.filter(insight.filter, renderOptions.rebaseFilter && renderOptions.rebaseFilter());
                    }, allowAsyncRenderTime, {
                        waitingLabel: 'layout before refine',
                        handlerLabel: 'refine after layout'
                    });
                } else {
                    //not refining
                    this._dataScope.setFilteredData(null);
                    result = yield this._render(insightSetup, data, renderOptions, true);
                    this.presenter.animationQueue(()=>{
                        this.reset();
                    }, allowAsyncRenderTime, {
                        waitingLabel: 'layout before reset',
                        handlerLabel: 'reset after layout'
                    });
                }
            } else result = yield this._render(insightSetup, data, renderOptions, false);
            return result;
        });
    }
    shouldViewstateTransition(newInsight, oldInsight) {
        if (!oldInsight.columns) return false;
        if (oldInsight.chart !== newInsight.chart) return true;
        if (oldInsight.size.height !== newInsight.size.height) return true;
        if (oldInsight.size.width !== newInsight.size.width) return true;
        if (oldInsight.columns.facet !== newInsight.columns.facet) return true;
        return false;
    }
    configForSignalCapture(presenterConfig) {
        const colorContext = {
            colorMap: null,
            legend: null,
            legendElement: null
        };
        //now be ready to capture color changing signals 
        presenterConfig.preStage = (stage, cubeLayer)=>{
            if (this._shouldSaveColorContext()) //save off the colors from Vega layout
            colorContext.colorMap = cubeLayer.unitColorMap;
            this.preStage(stage, cubeLayer);
        };
        presenterConfig.onPresent = ()=>{
            if (this._shouldSaveColorContext()) {
                (0, $d862cbedfe5e328a$export$44addeff9a96c1e7)(colorContext, this.presenter);
                this.changeColorContexts([
                    colorContext
                ]);
                this._dataScope.deselect();
            }
            this.onPresent();
        };
    }
    onPresent() {
        var _a;
        if ((_a = this.setup) === null || _a === void 0 ? void 0 : _a.transition) (0, $099aaea57d9dcbf4$export$2be97f482a239d30)(this.setup.transition, this._dataScope.currentData(), this.convertSearchToSet(), this.presenter);
        this.options.onPresent && this.options.onPresent();
    }
    _render(insightSetup, data, renderOptions, forceNewCharacterSet) {
        return $6662f126c1d9f58b$var$__awaiter(this, void 0, void 0, function*() {
            const { insight: insight, setup: setup } = insightSetup;
            if (this._tooltip) {
                this._tooltip.destroy();
                this._tooltip = null;
            }
            if (this._dataScope.setData(data, renderOptions.columns)) //apply transform to the data
            this.transformData(data, insight.transform);
            this._specColumns = (0, $2b29a67d615af3f6$export$9e6128b2231f5173)(insight, this._dataScope.getColumns(renderOptions.columnTypes));
            const ordinalMap = (0, $70eaad7e9e4ac896$export$f03cc77b21b3a2b2)(this._specColumns, data, renderOptions.ordinalMap);
            this._characterSet.resetCharacterSet(forceNewCharacterSet, this.insight, insight);
            this.insight = $c5578f8838abba3d$exports.clone(insight);
            this.setup = setup;
            this._shouldSaveColorContext = ()=>!renderOptions.initialColorContext;
            const colorContext = renderOptions.initialColorContext || {
                colorMap: null,
                legend: null,
                legendElement: null
            };
            const specResult = yield this.renderNewLayout(insight.signalValues, Object.assign(Object.assign({}, setup || {}), {
                preStage: (stage, cubeLayer)=>{
                    if (this._shouldSaveColorContext()) //save off the colors from Vega layout
                    colorContext.colorMap = cubeLayer.unitColorMap;
                    else //apply passed colorContext
                    cubeLayer.unitColorMap = colorContext.colorMap;
                    //if items are selected, repaint
                    const hasSelectedData = !!this._dataScope.hasSelectedData();
                    //const hasActive = !!this._dataScope.active;
                    hasSelectedData || this._dataScope.active;
                    this.preStage(stage, cubeLayer);
                },
                onPresent: ()=>{
                    if (this._shouldSaveColorContext()) {
                        (0, $d862cbedfe5e328a$export$44addeff9a96c1e7)(colorContext, this.presenter);
                        this.changeColorContexts([
                            colorContext
                        ]);
                    } else //apply passed colorContext
                    this.applyLegendColorContext(colorContext);
                    this.onPresent();
                },
                shouldViewstateTransition: ()=>this.shouldViewstateTransition(insight, this.insight)
            }), this.getView(insight.view));
            //future signal changes should save the color context
            this._shouldSaveColorContext = ()=>!renderOptions.discardColorContextUpdates || !renderOptions.discardColorContextUpdates();
            this._details.render();
            const result = {
                ordinalMap: ordinalMap,
                specResult: specResult
            };
            return result;
        });
    }
    overrideAxisLabels(stage) {
    // if (this._specColumns.x && this._specColumns.x.type === 'date') {
    //     stage.axes.x.forEach(axis => makeDateRange(
    //         axis.tickText,
    //         this.getColumnStats(this._specColumns.x)
    //     ));
    // }
    // if (this._specColumns.y && this._specColumns.y.type === 'date') {
    //     stage.axes.y.forEach(axis => makeDateRange(
    //         axis.tickText,
    //         this.getColumnStats(this._specColumns.y)
    //     ));
    // }
    }
    preLayer(stage) {
        //convert ticks
        let axisRole;
        for(axisRole in stage.axes){
            const capability = this.specCapabilities.roles.filter((r)=>r.role === axisRole)[0];
            if (capability && (capability.axisSelectionBetweenTicks || capability.axisSelection === 'exact')) (0, $a696a51a900f8bbc$export$abaa25886c91cb0e)(stage.axes[axisRole]);
        }
    }
    preStage(stage, cubeLayer) {
        this.overrideAxisLabels(stage);
        this._axisSelection = new (0, $a696a51a900f8bbc$export$b4d41fd4fcc19c)(this.specCapabilities, this._specColumns, stage);
        (0, $5c5541ba560b58df$export$71ab65a966760ac3)(this.insight.colorBin, this._specColumns.color, stage.legend, this.options.language);
        if (this.options.onStage) this.options.onStage(stage);
    }
    onCubeClick(e, cube) {
        this.options.onCubeClick && this.options.onCubeClick(e, cube);
        const hasSelectedData = this._dataScope.hasSelectedData();
        if (hasSelectedData && this._dataScope.selection.included.length > 1) {
            //if active is within selection, keep the selection and activate the one.
            const indexWithinSelection = this._dataScope.ordinalIndexWithinSelection(cube.ordinal);
            if (indexWithinSelection.index >= 0) {
                this.activate(indexWithinSelection.datum);
                this._details.populate(this._dataScope.selection, indexWithinSelection.index);
                if (this.options.onSelectionChanged) {
                    const sel = this.getSelection();
                    this.options.onSelectionChanged(sel.search, indexWithinSelection.index, sel.selectedData);
                }
                return;
            }
        }
        if (hasSelectedData && this._dataScope.selection.included.length === 1 && this._dataScope.selection.included[0][0, $44b8bb162b63b5b5$export$5672246984822a29] === cube.ordinal) {
            this.deselect();
            return;
        }
        const search = {
            name: (0, $44b8bb162b63b5b5$export$5672246984822a29),
            operator: '==',
            value: cube.ordinal
        };
        this.select(search);
    }
    onCubeHover(event, cube) {
        var _a, _b;
        if (this._tooltip) {
            this._tooltip.destroy();
            this._tooltip = null;
        }
        if (!cube) return;
        const currentData = this._dataScope.currentData();
        const index = (0, $70eaad7e9e4ac896$export$5844459bbee68321)(cube, currentData);
        if (index >= 0) {
            const dataItem = (0, $40d5ab22242de7d1$export$ce0d7ac3b25f14e3)(((_a = this.options.tooltipOptions) === null || _a === void 0 ? void 0 : _a.prepareDataItem(currentData[index])) || currentData[index]);
            const tooltipCreateOptions = {
                dataItem: dataItem,
                event: event
            };
            if ((_b = this.options.tooltipOptions) === null || _b === void 0 ? void 0 : _b.create) this._tooltip = this.options.tooltipOptions.create(tooltipCreateOptions);
            else this._tooltip = new (0, $40d5ab22242de7d1$export$28c660c63b792dea)(Object.assign(Object.assign({}, tooltipCreateOptions), {
                cssPrefix: this.presenter.style.cssPrefix
            }));
        }
    }
    onTextHover(e, t) {
        //return true if highlight color is different
        if (!t || !this.options.getTextColor || !this.options.getTextHighlightColor) return false;
        return !$c5578f8838abba3d$exports.colorIsEqual(this.options.getTextColor(t), this.options.getTextHighlightColor(t));
    }
    getMorphChartsColors() {
        const { colors: colors } = this.options;
        return {
            activeItemColor: colors.activeCube,
            axesGridBackgroundColor: colors.backgroundColor,
            axesGridHighlightColor: colors.axisSelectHighlight,
            axesGridMajorColor: colors.gridLine,
            axesGridMinorColor: colors.gridLine,
            axesGridZeroColor: colors.gridLine,
            axesTextHeadingColor: colors.axisText,
            axesTextLabelColor: colors.axisText,
            axesTextTitleColor: colors.axisText,
            backgroundColor: colors.backgroundColor,
            textBorderColor: colors.backgroundColor,
            textColor: colors.axisText
        };
    }
    createConfig(c) {
        var _a;
        const { getTextColor: getTextColor, getTextHighlightColor: getTextHighlightColor, onTextClick: onTextClick } = this.options;
        const defaultPresenterConfig = {
            morphChartsColors: this.getMorphChartsColors(),
            zAxisZindex: $6662f126c1d9f58b$var$zAxisZindex,
            getCharacterSet: (stage)=>this._characterSet.getCharacterSet(stage),
            getTextColor: getTextColor,
            getTextHighlightColor: getTextHighlightColor,
            onTextClick: (e, t)=>{
                if (t.metaData && t.metaData.search) {
                    //used by facets to select the facet
                    const search = (0, $a52b757f33a54d2e$export$cb06c97de370398d)(t.metaData.search);
                    if (this.options.onAxisClick) this.options.onAxisClick(e, search);
                    else this.select(search);
                }
                if (onTextClick) onTextClick(e, t);
            },
            onCubeClick: this.onCubeClick.bind(this),
            onCubeHover: this.onCubeHover.bind(this),
            onTextHover: this.onTextHover.bind(this),
            preLayer: this.preLayer.bind(this),
            preStage: this.preStage.bind(this),
            onPresent: this.onPresent.bind(this),
            onAxisConfig: (cartesian, dim3d, axis)=>{
                if (!axis) return;
                const role = this.specCapabilities.roles.filter((r)=>r.role === axis.axisRole)[0];
                if (role === null || role === void 0 ? void 0 : role.axisSelection) {
                    cartesian.isDivisionPickingEnabled[dim3d] = true;
                    cartesian.arePickDivisionsVisible[dim3d] = axis.tickText.length > 0;
                    cartesian.isLabelPickingEnabled[dim3d] = true;
                    cartesian.isTitlePickingEnabled[dim3d] = true;
                    cartesian.isHeadingPickingEnabled[dim3d] = true;
                    cartesian.isGridPickingEnabled = false;
                }
            },
            onAxesComplete: (cartesian)=>{},
            axisPickGridCallback: (divisions, e)=>{
                const search = this._axisSelection.convert(divisions);
                if (this.options.onAxisClick) this.options.onAxisClick(e, search); //TODO change onAxisClick to accept Search
                else this.select(search);
            },
            onLayerClick: (e)=>{
                this.options.onCanvasClick && this.options.onCanvasClick(e);
                this.deselect();
            },
            onLegendClick: (e, legend, clickedIndex)=>{
                const legendRow = clickedIndex !== null && legend.rows[clickedIndex];
                if (legendRow) {
                    if (this.options.onLegendRowClick) this.options.onLegendRowClick(e, legendRow);
                    else this.select(legendRow.search);
                } else if (this.options.onLegendHeaderClick) //header clicked
                this.options.onLegendHeaderClick(e);
            },
            onSceneRectAssignCubeOrdinal: (datum)=>{
                //TODO see if datum is a facet selection rect
                return datum[0, $44b8bb162b63b5b5$export$5672246984822a29];
            },
            onTargetViewState: (h, w)=>{
                const { height: height, width: width } = this.insight.size;
                let newViewStateTarget;
                if (this.options.onNewViewStateTarget) newViewStateTarget = this.options.onNewViewStateTarget();
                return {
                    height: height,
                    width: width,
                    newViewStateTarget: newViewStateTarget
                };
            },
            layerSelection: {
                cubes: this.convertSearchToSet()
            },
            preserveDrawingBuffer: this.options.preserveDrawingBuffer
        };
        if (!this.options.disableLasso) defaultPresenterConfig.onLasso = (ids, e)=>{
            this.deselect();
            const search = this.convertSetToSearch(ids);
            this.select(search);
        };
        if (this.options.onBeforeCreateLayers) defaultPresenterConfig.preLayer = (stage)=>{
            this.preLayer(stage);
            this.options.onBeforeCreateLayers(stage, this.specCapabilities);
        };
        const config = {
            presenter: this.presenter,
            presenterConfig: Object.assign(defaultPresenterConfig, c)
        };
        if ((_a = this.setup) === null || _a === void 0 ? void 0 : _a.transitionDurations) config.presenterConfig.transitionDurations = this.setup.transitionDurations;
        return config;
    }
    /**
     * Filter the data and animate.
     * @param search Filter expression, see https://vega.github.io/vega/docs/expressions/
     * @param rebase Optional flag to apply to entire dataset. A false value will apply the filter upon any existing filter.
     */ filter(search, rebase = false) {
        const u = this._dataScope.createUserSelection(search, false, rebase);
        return new Promise((resolve, reject)=>{
            this._animator.filter(search, u.included, u.excluded, rebase).then(()=>{
                this._details.clear();
                this._details.clearSelection();
                this._details.populate(this._dataScope.selection);
                resolve();
            });
        });
    }
    /**
     * Remove any filtration and animate.
     */ reset() {
        return new Promise((resolve, reject)=>{
            this._animator.reset().then(()=>{
                this._details.clear();
                this._details.clearSelection();
                resolve();
            });
        });
    }
    /**
     * Select cubes by a filter expression.
     * @param search Filter expression, see https://vega.github.io/vega/docs/expressions/
     */ select(search) {
        return new Promise((resolve, reject)=>{
            this._animator.select(search).then(()=>{
                this._details.populate(this._dataScope.selection);
                resolve();
            });
        });
    }
    /**
     * Removes any selection.
     */ deselect() {
        return new Promise((resolve, reject)=>{
            this._animator.deselect().then(()=>{
                this._details.clearSelection();
                resolve();
            });
        });
    }
    /**
     * Gets the current selection.
     */ getSelection() {
        if (!this._dataScope) return null;
        const selectionState = {
            search: this._dataScope.selection && this._dataScope.selection.search || null,
            selectedData: this._dataScope.selection && this._dataScope.selection.included || null,
            active: this._dataScope.active
        };
        return selectionState;
    }
    /**
     * Set one data row to the active state.
     */ activate(datum) {
        return new Promise((resolve, reject)=>{
            this._animator.activate(datum).then(()=>{
                this.presenter.morphChartsRenderResult.activate(datum[0, $44b8bb162b63b5b5$export$5672246984822a29]);
                this._details.render();
                resolve();
            });
        });
    }
    /**
     * Deactivate item.
     */ deActivate() {
        return new Promise((resolve, reject)=>{
            if (this._dataScope && this._dataScope.active) this._animator.deactivate().then(()=>{
                this.presenter.morphChartsRenderResult.activate(-1);
                this._details.render();
                resolve();
            });
            else resolve();
        });
    }
    /**
     * Gets the current camera.
     * @param transitionFinal Optional flag to get camera destination when transition completes.
     */ getCamera(transitionFinal = false) {
        var _a, _b, _c, _d, _e, _f, _g;
        let position = [
            0,
            0,
            0
        ];
        let rotation = [
            0,
            0,
            0,
            0
        ];
        if (transitionFinal) {
            position = Array.from((_b = (_a = this.presenter) === null || _a === void 0 ? void 0 : _a.morphchartsref) === null || _b === void 0 ? void 0 : _b.cameraTransitioner.vPosition.to);
            rotation = Array.from((_d = (_c = this.presenter) === null || _c === void 0 ? void 0 : _c.morphchartsref) === null || _d === void 0 ? void 0 : _d.cameraTransitioner.qRotation.to);
        } else {
            const camera = (_g = (_f = (_e = this.presenter) === null || _e === void 0 ? void 0 : _e.morphchartsref) === null || _f === void 0 ? void 0 : _f.core) === null || _g === void 0 ? void 0 : _g.camera;
            if (camera) {
                camera.getPosition(position);
                camera.getOrbit(rotation);
            }
        }
        return {
            position: position,
            rotation: rotation,
            captureSize: this.insight.size
        };
    }
    /**
     * Sets the current camera.
     * @param camera Camera to set.
     */ setCamera(camera) {
        var _a, _b;
        if (camera) (_b = (_a = this.presenter) === null || _a === void 0 ? void 0 : _a.morphChartsRenderResult) === null || _b === void 0 || _b.moveCamera(camera);
    }
    /**
     * Gets the current insight with signal values.
     */ getInsight() {
        const insight = Object.assign({}, this.insight);
        insight.signalValues = this.getSignalValues();
        return insight;
    }
    /**
     * Gets column stats from current data (filtered or all).
     * @param column Column to get stats for.
     */ getColumnStats(column) {
        return this._dataScope.hasFilteredData() ? this._dataScope.getFilteredColumnStats(column.name) : column.stats;
    }
    /**
     * Gets current signal values.
     */ getSignalValues() {
        return (0, $6728ad2e40252478$export$764590c093441ac7)(this.vegaViewGl, this.vegaSpec);
    }
    assignTransitionStagger(transition) {
        (0, $099aaea57d9dcbf4$export$2be97f482a239d30)(transition, this._dataScope.currentData(), this.convertSearchToSet(), this.presenter);
    }
    finalize() {
        if (this._dataScope) this._dataScope.finalize();
        if (this._details) this._details.finalize();
        if (this._tooltip) this._tooltip.destroy();
        if (this.vegaViewGl) this.vegaViewGl.finalize();
        if (this.presenter) this.presenter.finalize();
        if (this.element) this.element.innerHTML = '';
        this.colorContexts = null;
        this.element = null;
        this.options = null;
        this.presenter = null;
        this.vegaSpec = null;
        this.vegaViewGl = null;
        this._animator = null;
        this._dataScope = null;
        this._details = null;
        this._tooltip = null;
    }
}
/**
 * Default Viewer options.
 */ $6662f126c1d9f58b$export$2ec4afd9b3c16a85.defaultViewerOptions = (0, $16f9e3e56a5dcd59$export$fb736e4909afb3d7);


/*!
* Copyright (c) Microsoft Corporation.
* Licensed under the MIT License.
*/ const $59c3ac7cbbe40380$export$83d89fbfd8236492 = '4.0.6';


const $1342cf7df79546f0$export$1f96ae73734a86cc = (0, $94b078fc391e7135$export$1f96ae73734a86cc);


var $e295d8097c1ad61a$exports = {};

$parcel$export($e295d8097c1ad61a$exports, "classList", () => $e295d8097c1ad61a$export$11c615ce16f87241);
$parcel$export($e295d8097c1ad61a$exports, "deepCompare", () => $e295d8097c1ad61a$export$e12301e595e16ad8);
$parcel$export($e295d8097c1ad61a$exports, "compareInsight", () => $e295d8097c1ad61a$export$62baf1cd3780635c);
/*!
* Copyright (c) Microsoft Corporation.
* Licensed under the MIT License.
*/ var $0e23dbf070c5d238$exports = {};

$parcel$defineInteropFlag($0e23dbf070c5d238$exports);

$parcel$export($0e23dbf070c5d238$exports, "default", () => $0e23dbf070c5d238$export$2e2bcd8739ae039);
var $0e23dbf070c5d238$export$2e2bcd8739ae039 = $0e23dbf070c5d238$var$compare;
/*
  primitives: value1 === value2
  functions: value1.toString == value2.toString
  arrays: if length, sequence and values of properties are identical
  objects: if length, names and values of properties are identical
  compare([[1, [2, 3]], [[1, [2, 3]]); // true
  compare([[1, [2, 3], 4], [[1, [2, 3]]); // false
  compare({a: 2, b: 3}, {a: 2, b: 3}); // true
  compare({a: 2, b: 3}, {b: 3, a: 2}); // true
  compare({a: 2, b: 3, c: 4}, {a: 2, b: 3}); // false
  compare({a: 2, b: 3}, {a: 2, b: 3, c: 4}); // false
  compare([[1, [2, {a: 4}], 4], [[1, [2, {a: 4}]]); // true
*/ function $0e23dbf070c5d238$var$compare(value1, value2) {
    if (value1 === value2) return true;
    /* eslint-disable no-self-compare */ // if both values are NaNs return true
    if (value1 !== value1 && value2 !== value2) return true;
    if (({}).toString.call(value1) != ({}).toString.call(value2)) return false;
    if (value1 !== Object(value1)) // non equal primitives
    return false;
    if (!value1) return false;
    if (Array.isArray(value1)) return $0e23dbf070c5d238$var$compareArrays(value1, value2);
    if (({}).toString.call(value1) == '[object Set]') return $0e23dbf070c5d238$var$compareArrays(Array.from(value1), Array.from(value2));
    if (({}).toString.call(value1) == '[object Object]') return $0e23dbf070c5d238$var$compareObjects(value1, value2);
    else return $0e23dbf070c5d238$var$compareNativeSubtypes(value1, value2);
}
function $0e23dbf070c5d238$var$compareNativeSubtypes(value1, value2) {
    // e.g. Function, RegExp, Date
    return value1.toString() === value2.toString();
}
function $0e23dbf070c5d238$var$compareArrays(value1, value2) {
    var len = value1.length;
    if (len != value2.length) return false;
    var alike = true;
    for(var i = 0; i < len; i++)if (!$0e23dbf070c5d238$var$compare(value1[i], value2[i])) {
        alike = false;
        break;
    }
    return alike;
}
function $0e23dbf070c5d238$var$compareObjects(value1, value2) {
    var keys1 = Object.keys(value1).sort();
    var keys2 = Object.keys(value2).sort();
    var len = keys1.length;
    if (len != keys2.length) return false;
    for(var i = 0; i < len; i++){
        var key1 = keys1[i];
        var key2 = keys2[i];
        if (!(key1 == key2 && $0e23dbf070c5d238$var$compare(value1[key1], value2[key2]))) return false;
    }
    return true;
}


const $e295d8097c1ad61a$export$11c615ce16f87241 = (...args)=>{
    return args.filter(Boolean).join(' ');
};
const $e295d8097c1ad61a$export$e12301e595e16ad8 = $0e23dbf070c5d238$exports.default || $0e23dbf070c5d238$exports;
function $e295d8097c1ad61a$var$addNullable(insight, signalValues) {
    const withNulls = Object.assign(Object.assign({
        view: null,
        filter: null
    }, insight), {
        signalValues: signalValues
    });
    return withNulls;
}
function $e295d8097c1ad61a$export$62baf1cd3780635c(viewer, insight) {
    const currentInsight = viewer.getInsight();
    const a = $e295d8097c1ad61a$var$addNullable(currentInsight, Object.assign(Object.assign({}, viewer.insight.signalValues), currentInsight.signalValues));
    const b = $e295d8097c1ad61a$var$addNullable(insight, Object.assign(Object.assign({}, a.signalValues), insight.signalValues));
    const compare = $e295d8097c1ad61a$export$e12301e595e16ad8(a, b);
    return {
        a: a,
        b: b,
        compare: compare
    };
}


/*!
* Copyright (c) Microsoft Corporation.
* Licensed under the MIT License.
*/ /*!
* Copyright (c) Microsoft Corporation.
* Licensed under the MIT License.
*/ 

const $a94804e25c3acfaf$export$e2253033e6e1df16 = {
    react: null,
    reactDOM: null
};
function $a94804e25c3acfaf$export$1f96ae73734a86cc(react, reactDOM, vega) {
    $e296aaf527fc4d25$exports.use(vega);
    $a94804e25c3acfaf$export$e2253033e6e1df16.react = react;
    $a94804e25c3acfaf$export$e2253033e6e1df16.reactDOM = reactDOM;
    //inform React that we are using a dynamic base class
    (0, $7a3dcfea67f8da12$export$2ec4afd9b3c16a85).prototype = react.Component.prototype;
}




function $7a3dcfea67f8da12$var$_Viewer(_props) {
    class __Viewer extends (0, $a94804e25c3acfaf$export$e2253033e6e1df16).react.Component {
        layout() {
            const { props: props } = this;
            this.lastData = props.data;
            this.viewer.render({
                insight: props.insight,
                setup: props.setup
            }, props.data, props.renderOptions).then((renderResult)=>{
                //TODO: show errors if any
                //console.log('viewer render');
                props.onView && props.onView(renderResult);
            }).catch((e)=>{
                //console.log('viewer error');
                props.onError && props.onError(e);
            });
        }
        view() {
            var _a, _b, _c, _d, _e;
            const { props: props } = this;
            let didLayout = false;
            if (props.insight && props.data) {
                const c = (0, $e295d8097c1ad61a$export$62baf1cd3780635c)(this.viewer, props.insight);
                const sameDataRef = props.data === this.lastData;
                if (!c.compare || !sameDataRef) {
                    this.layout();
                    didLayout = true;
                }
            }
            if (!didLayout && props.setup) {
                const { camera: camera } = props.setup;
                //compare setup, move camera
                if (camera !== 'hold') {
                    if (!(0, $e295d8097c1ad61a$export$e12301e595e16ad8)(this.viewer.setup.camera, camera)) {
                        //camera is different
                        if (!camera) (_b = (_a = this.viewer) === null || _a === void 0 ? void 0 : _a.presenter) === null || _b === void 0 || _b.homeCamera();
                        else this.viewer.setCamera(camera);
                        //save this for next comparison
                        const setup = (0, $e296aaf527fc4d25$exports).util.clone(this.viewer.setup);
                        setup.camera = camera;
                        this.viewer.setup = setup;
                    }
                }
                if (props.setup.renderer) (_e = (_d = (_c = this.viewer) === null || _c === void 0 ? void 0 : _c.presenter) === null || _d === void 0 ? void 0 : _d.morphchartsref) === null || _e === void 0 || _e.setMorphChartsRendererOptions(props.setup.renderer);
            }
        }
        componentDidMount() {
            const { props: props } = this;
            const element = (0, $a94804e25c3acfaf$export$e2253033e6e1df16).reactDOM.findDOMNode(this.viewerDiv);
            this.viewer = new (0, $6662f126c1d9f58b$export$2ec4afd9b3c16a85)(element, props.viewerOptions);
            if (props.onMount) {
                if (props.onMount(this.viewer.presenter.getElement((0, $e296aaf527fc4d25$exports).PresenterElement.gl))) this.view();
            } else this.view();
        }
        componentDidUpdate() {
            const { props: props } = this;
            this.viewer.options = (0, $e296aaf527fc4d25$exports).util.deepMerge(this.viewer.options, props.viewerOptions);
            this.view();
        }
        componentWillUnmount() {
            this.viewer.finalize();
        }
        render() {
            return (0, $a94804e25c3acfaf$export$e2253033e6e1df16).react.createElement("div", {
                className: "sanddance-ReactViewer",
                ref: (div)=>this.viewerDiv = div
            });
        }
    }
    return new __Viewer(_props);
}
const $7a3dcfea67f8da12$export$2ec4afd9b3c16a85 = $7a3dcfea67f8da12$var$_Viewer;



/*!
* Copyright (c) Microsoft Corporation.
* Licensed under the MIT License.
*/ const $d76008c8107bb02f$export$83d89fbfd8236492 = '4.0.2';




/*!
* Copyright (c) Microsoft Corporation.
* Licensed under the MIT License.
*/ const $d5b6ce321475881f$export$21c51bc433c16634 = {
    appName: 'SandDance',
    bingsearch: 'Bing',
    bingsearchDescription: (term)=>`Search Bing for "${term}"`,
    buttonClose: 'Close',
    buttonSelect: 'Search & Select',
    buttonColorSchemeMap: 'Map color scheme to filtered data',
    buttonColorSchemeRemap: 'Remap color to filtered data',
    buttonColorSchemeKeep: 'Keep same color scheme',
    buttonCopyToClipboard: 'Copy to clipboard',
    buttonExclude: 'Exclude',
    buttonExport: 'Export',
    buttonExportCount: (total)=>total == 1 ? 'Export 1 row...' : `Export ${total} rows...`,
    buttonIsolate: 'Isolate',
    buttonReset: 'Stop filtering',
    buttonDeselect: 'Clear selection',
    buttonToolbarFloat: 'Float toolbar',
    buttonToolbarDock: 'Dock toolbar',
    buttonToolbarHide: 'Hide toolbar',
    buttonToolbarShow: 'Show toolbar',
    buttonNextDataItem: 'Next data item',
    buttonPrevDataItem: 'Previous data item',
    buttonCreateSnapshot: 'Create snapshot',
    buttonNextSnapshot: 'Next snapshot',
    buttonPrevSnapshot: 'Previous snapshot',
    buttonUpdateSnapshot: 'Update snapshot',
    buttonAddExpression: 'Add expression',
    buttonAddExpressionGroup: 'Add group',
    buttonDeleteExpression: 'Delete',
    buttonDeleteExpressionGroup: 'Delete group',
    buttonClearSnapshots: 'Clear snapshots',
    buttonDeleteSnapshot: 'Delete snapshot',
    buttonEditSnapshot: 'Edit snapshot',
    buttonMoveUp: 'Move up',
    buttonMoveDown: 'Move down',
    buttonShowVegaSpec: 'Show Vega spec',
    buttonLaunchVegaEditor: 'Open Vega Editor',
    buttonCameraHome: 'Center chart in window',
    buttonTooltipMapping: 'Tooltip columns...',
    buttonBackgroundImage: 'Background image...',
    buttonTransitionReverse: 'Play Reverse',
    buttonTransitionPause: 'Pause',
    buttonTransitionPlay: 'Play',
    buttonUndo: 'Undo',
    buttonRedo: 'Redo',
    buttonColumnTypes: 'Column types...',
    buttonApply: 'Apply',
    buttonRemove: 'Remove',
    buttonResetToDefault: 'Reset to default',
    chartTypeBarChartH: 'Bar',
    chartTypeBarChartV: 'Column',
    chartTypeDensity: 'Density',
    chartTypeGrid: 'Grid',
    chartTypeScatterPlot: 'Scatter',
    chartTypeStacks: 'Stacks',
    chartTypeStrips: 'Strips',
    chartTypeTreeMap: 'Treemap',
    defaultFileName: 'sanddance-data',
    errorExportFilenameEmpty: 'Filename cannot be blank',
    errorExportFilenameCharacters: (characters)=>`A filename cannot contain any of the following characters: ${characters}`,
    errorColumnMustBeNumeric: 'Numeric column required for this chart type.',
    errorNumericValue: 'Value must be numeric',
    errorImageFormat: 'File is not an image',
    labelBackgroundImageDialogTitle: 'Background image',
    labelBackgroundImageSubtext: 'Background image can only be shown on Scatterplot, Density, and Stacks charts. Columns must be numeric type.',
    labelBackgroundLeft: 'Left extent',
    labelBackgroundRight: 'Right extent',
    labelBackgroundBottom: 'Bottom extent',
    labelBackgroundTop: 'Top extent',
    labelBlank: 'blank',
    labelNull: 'null',
    labelTrue: 'true',
    labelFalse: 'false',
    labelSystemInfo: 'System info',
    labelChangeColumnType: 'Change column type',
    labelChartSettings: 'Chart settings',
    labelEditColumn: 'Edit',
    labelColumnName: 'Column name',
    labelColumnType: 'Column type',
    labelColumnDistinct: 'Distinct values',
    labelColumnHasColorData: 'Has color data',
    labelColumnIsColorData: 'Is color data',
    labelColumnQuantitativeMin: 'Min',
    labelColumnQuantitativeMax: 'Max',
    labelColumnQuantitativeMean: 'Mean',
    labelDataBrowser: 'Data browser',
    labelDataScope: 'Scope',
    labelExport: 'Export Data',
    labelExportFormat: 'File format',
    labelExportCSV: '.CSV - Comma separated values',
    labelExportHTML: '.HTML - A SandDance html page embedding this data',
    labelExportJSON: '.JSON - JavaScript object notation',
    labelExportTSV: '.TSV - Tab separated values',
    labelHistory: 'History',
    labelHistoryWarning: 'This will erase your current history.',
    labelTools: 'Tools',
    labelHoldCamera: 'Keep previous camera position',
    labelVegaSpec: 'Vega specification',
    labelColor: 'Chart color',
    labelError: 'Error',
    labelExportFileName: 'File name',
    labelSnapshots: 'Snapshots',
    labelSnapshotSettingThumbnailWidth: 'Thumbnail image width',
    labelSearch: 'Select by search',
    labelSearchClause: 'Clause',
    labelSearchColumn: 'Field',
    labelSearchOperator: 'Operator',
    labelSearchValue: 'Value',
    labelSearchValuePlaceholder: 'Value to search for',
    labelChart: 'Chart',
    labelChartCanvas: 'Chart canvas',
    labelColumnMapping: 'Column Mapping',
    labelChartTypeOptions: 'Chart options',
    labelColorBin: 'Color binning',
    labelColorOptions: 'Color options',
    labelColorBinExplanation: 'For numeric columns',
    labelColorFieldInfo: (colorColumnName, colorColumnType, categoricalNumeric, distinctValueCount)=>`Field <span className="fieldname">${colorColumnName}</span> is of type <span className="fieldtype">${colorColumnType}</span>${categoricalNumeric ? ` and has ${distinctValueCount} distinct values` : ''}.`,
    labelColorFieldIsColorData: (colorColumnName)=>`Field <span className="fieldname">${colorColumnName}</span> contains direct color data.`,
    labelColorBinNone: 'None (continuous)',
    labelColorBinQuantize: 'Quantize',
    labelColorBinQuantile: 'Quantile',
    labelColorFilter: 'Note: Colors will be re-mapped to the filter when viewing this snapshot.',
    labelColorScheme: 'Scheme',
    labelTotal: 'Total by',
    labelTotalByCountSquare: 'Count (Grid layout)',
    labelTotalByCountStrip: 'Count (Strip layout)',
    labelTotalBySumStrip: 'Sum (Strip layout)',
    labelTotalBySumTreemap: 'Sum (Treemap layout)',
    labelTotalBySumStripPercent: 'Sum as percentage (Strip layout)',
    labelColumnColor: 'Color by',
    labelColumnFacet: 'Facet by',
    labelFacetLayout: 'Facet layout',
    labelFacetLayoutWrap: 'Wrap',
    // labelFacetLayoutHorizontal: 'Horizontal',
    // labelFacetLayoutVertical: 'Vertical',
    labelFacetLayoutCross: "\u229E",
    labelColumnFacetV: 'Cross facet by',
    labelColumnSort: 'Sort by',
    labelColumnX: 'X Axis',
    labelColumnY: 'Y Axis',
    labelColumnZ: 'Z Axis',
    labelColumnSize: 'Size by',
    labelColumnGroup: 'Group by',
    labelAliasColor: 'Color',
    labelAliasFacet: 'Facet',
    labelAliasFacetV: 'Vertical facet',
    labelAliasSort: 'Sort',
    labelAliasX: 'X Axis',
    labelAliasY: 'Y Axis',
    labelAliasZ: 'Z Axis',
    labelAliasSize: 'Size',
    labelAliasGroup: 'Group',
    labelDataItemIsFiltered: 'Item is filtered from view',
    labelHistoryInit: 'Initial view',
    labelHistoryFilterClear: 'Clear filter',
    labelHistoryFilterIExclude: 'Exclude filter',
    labelHistoryFilterIsolate: 'Isolate filter',
    labelHistoryChangeChartType: (chart)=>`Change chart type to ${chart}`,
    labelHistoryMapColumn: (column)=>`Map ${column} role`,
    labelHistoryUnMapColumn: (column)=>`Unmap ${column} role`,
    labelHistoryReviveSnapshot: 'Revive snapshot',
    labelHistoryColorBin: 'Change color binning',
    labelHistoryDirectColor: 'Change direct color',
    labelRenderer: 'Renderer quality',
    labelRendererAdvancedDisabled: 'Renderer quality (Enhanced 3D mode not supported on this device)',
    labelRendererBasic: 'Standard mode',
    labelRendererAdvanced: 'Enhanced 3D mode',
    labelRendererOptions: 'Renderer options ...',
    labelRendererOptionsDialogTitle: 'Renderer options',
    labelRendererOptionsAntialias: 'Antialias',
    labelRendererOptionsBloom: 'Bloom highlighting (for selections)',
    labelRendererOptionsBloomIntensity: 'Intensity',
    labelRendererOptionsDof: 'Depth of Field',
    labelRendererOptionsDofRange: 'Focus Range',
    labelRendererOptionsFxaa: 'Antialias',
    labelRendererOptionsShadow: 'Shadows',
    labelRendererOptionsSsao: 'Screen Space Ambient Occlusion',
    labelShowLegend: 'Show legend',
    labelShowAxes: 'Show axes',
    labelSnapshotTitle: 'Title',
    labelSnapshotDescription: 'Note (optional)',
    labelTooltipMapping: 'Tooltip columns',
    labelTransition: 'Transition',
    labelTransitionOptions: 'Transition options',
    labelTransitionScrubber: 'Scrub transition',
    labelTransitionStaggerBy: 'Stagger by',
    labelTransitionStaggerByOrdinal: 'Data order',
    labelTransitionStaggerByColumn: 'Column',
    labelTransitionStaggerByPosition: 'Axis position',
    labelTransitionStaggerOptions: 'Stagger options',
    labelTransitionStaggerReverse: 'Reverse',
    labelTransitionDurations: 'Transition durations',
    labelTransitionCamera: '2D / 3D view',
    labelTransitionDuration: 'Duration',
    labelTransitionStagger: 'Stagger',
    labelVegaSpecData: 'Data reference',
    labelVegaSpecNotes: 'Note: You may need to change the color scheme to make this visible in Vega.',
    labelYes: 'Yes',
    labelNo: 'No',
    labelConfirmation: 'Are you sure?',
    labelColumnTypes: 'Column types',
    loading: 'Loading...',
    schemeCategorical: 'Categorical',
    schemeCyclical: 'Cyclical',
    schemeDiverging: 'Diverging',
    schemeDual: 'Dual',
    schemeSequentialMultiHue: 'Sequential Multi Hue',
    schemeSequentialMultiHueDark: 'For dark backgrounds',
    schemeSequentialMultiHueLight: 'For light backgrounds',
    schemeSequentialSingleHue: 'Sequential Single Hue',
    selectDataSpanAll: 'All rows',
    selectDataSpanFilter: 'Filtered',
    selectDataSpanSelection: 'Selected',
    selectVegaSpecDataNone: 'None',
    selectVegaSpecDataInline: 'Inline - WARNING this may use substantial browser/clipboard memory for large data sets.',
    selectVegaSpecDataUrl: 'URL',
    record: (current, total)=>`${current} of ${total}`,
    searchEQ: '=',
    searchNEQ: '<>',
    searchGT: '>',
    searchGTE: '>=',
    searchLT: '<',
    searchLTE: '<=',
    searchNULL: 'is null or empty',
    searchIN: 'contains',
    searchSW: 'starts with',
    searchWHERE: 'Where',
    searchAND: 'and',
    searchOR: 'or',
    selectAny: '-- any --',
    selectNone: '-- none --',
    selectNumeric: 'Numeric',
    selectNonNumeric: 'Categorical',
    selectDirectColor: 'Direct color',
    selectReference: 'Column mappings',
    tooltipSearch: (column, value)=>`Click to search in '${column}' for "${value}"`,
    labelRequired: 'required',
    labelSystem: 'System',
    labelViewType2d: 'View in 2D',
    labelViewType3d: 'View in 3D',
    labelDataColors: 'Enabled if this data column contains any CSS color values.',
    labelDataNullAll: 'Loading data...',
    labelDataNullFiltered: 'You can filter by first making a selection, then choosing <b>Isolate</b> or <b>Exclude</b> in the top bar.',
    labelDataNullSelection: 'You can select by: <ul><li>clicking the chart axes</li><li>clicking in the legend</li><li>searching</li</ul>',
    labelZeroAll: 'Dataset contains zero rows.',
    labelZeroSearchResults: 'No rows matched your search.',
    signalGroups: [
        {
            prefix: 'Chart',
            label: 'Chart options'
        },
        {
            prefix: 'Mark',
            label: 'Mark options'
        },
        {
            prefix: 'RoleColor',
            label: 'Color options'
        },
        {
            prefix: 'RoleFacet',
            label: 'Facet options'
        },
        {
            prefix: 'RoleSort',
            label: 'Sort options'
        },
        {
            prefix: 'RoleX',
            label: 'X axis options'
        },
        {
            prefix: 'RoleY',
            label: 'Y axis options'
        },
        {
            prefix: 'RoleZ',
            label: 'Z axis options'
        },
        {
            prefix: 'Text',
            label: 'Text options'
        },
        {
            prefix: '*',
            label: 'Options'
        }
    ],
    percentValueFormat: (value)=>`${value}%`
};


/*!
* Copyright (c) Microsoft Corporation.
* Licensed under the MIT License.
*/ 
function $baf9c68afdd76912$export$c25acd513dcc8062(props) {
    return (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement((0, $a601a4135959dcb0$export$e2253033e6e1df16).fluentUI.IconButton, Object.assign({}, props, {
        styles: props.styles || {
            root: {
                color: props.themePalette.black
            },
            rootHovered: {
                background: 'transparent',
                color: props.themePalette.themePrimary
            },
            rootPressed: {
                background: 'transparent'
            },
            menuIcon: {
                display: 'none'
            }
        },
        iconProps: {
            iconName: props.iconName
        },
        menuProps: props.menuProps
    }));
}


/*!
* Copyright (c) Microsoft Corporation.
* Licensed under the MIT License.
*/ var $c0a1d2df3eff3893$exports = {};
"use strict";
/*!
* Copyright (c) Microsoft Corporation.
* Licensed under the MIT License.
*/ var $c0a1d2df3eff3893$var$__createBinding = $c0a1d2df3eff3893$exports && $c0a1d2df3eff3893$exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) desc = {
        enumerable: true,
        get: function() {
            return m[k];
        }
    };
    Object.defineProperty(o, k2, desc);
} : function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
});
var $c0a1d2df3eff3893$var$__exportStar = $c0a1d2df3eff3893$exports && $c0a1d2df3eff3893$exports.__exportStar || function(m, exports1) {
    for(var p in m)if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports1, p)) $c0a1d2df3eff3893$var$__createBinding(exports1, m, p);
};
Object.defineProperty($c0a1d2df3eff3893$exports, "__esModule", {
    value: true
});

$c0a1d2df3eff3893$var$__exportStar((parcelRequire("2FnuA")), $c0a1d2df3eff3893$exports);

$c0a1d2df3eff3893$var$__exportStar((parcelRequire("bvDTm")), $c0a1d2df3eff3893$exports);

$c0a1d2df3eff3893$var$__exportStar((parcelRequire("7Kus9")), $c0a1d2df3eff3893$exports);

$c0a1d2df3eff3893$var$__exportStar((parcelRequire("lSaje")), $c0a1d2df3eff3893$exports);

$c0a1d2df3eff3893$var$__exportStar((parcelRequire("b7pOC")), $c0a1d2df3eff3893$exports);




function $cdd6162a40e9c08a$export$1e096674a95fd43b(insightColumns, actualColumns, transform) {
    //ensure columns exist
    for(const role in insightColumns){
        const columnName = insightColumns[role];
        const column = actualColumns.filter((c)=>c.name === columnName)[0];
        const transformColumn = transform ? transform.filter((t)=>{
            switch(t.type){
                case 'formula':
                    return t.as === columnName;
            }
        })[0] : null;
        if (!(column || transformColumn)) delete insightColumns[role];
    }
}
function $cdd6162a40e9c08a$export$c2563952d877899(chart, totalStyle, insightColumns, actualColumns) {
    //ensure columns are populated
    const nonInternal = actualColumns.filter((c)=>!(0, $1342cf7df79546f0$exports).util.isInternalFieldName(c.name));
    const firstColumn = nonInternal[0];
    const firstColumnName = firstColumn && firstColumn.name;
    const firstQuantitative = nonInternal.filter((c)=>c.quantitative)[0];
    const firstQuantitativeColumnName = firstQuantitative && firstQuantitative.name;
    const ensureColumn = (role, quantitative, treemap)=>{
        if (!insightColumns[role]) {
            if (treemap) insightColumns[role] = $cdd6162a40e9c08a$export$7e0d3b5c6570ae8b(actualColumns).name;
            else insightColumns[role] = quantitative ? firstQuantitativeColumnName : firstColumnName;
        }
    };
    function checkRequiresSize() {
        switch(totalStyle){
            case 'sum-strip':
            case 'sum-strip-percent':
                ensureColumn('size', true);
                break;
            case 'sum-treemap':
                ensureColumn('size', true, true);
                break;
        }
    }
    switch(chart){
        case 'barchart':
        case 'barchartV':
            ensureColumn('x');
            checkRequiresSize();
            break;
        case 'barchartH':
            ensureColumn('y');
            checkRequiresSize();
            break;
        case 'density':
            ensureColumn('x');
            ensureColumn('y');
            checkRequiresSize();
            break;
        case 'scatterplot':
        case 'stacks':
            ensureColumn('x');
            ensureColumn('y');
            break;
        case 'treemap':
            if (!insightColumns.size) insightColumns.size = $cdd6162a40e9c08a$export$7e0d3b5c6570ae8b(actualColumns).name;
            if (!insightColumns.size) //error - no numeric column
            return [
                (0, $d5b6ce321475881f$export$21c51bc433c16634).errorColumnMustBeNumeric
            ];
            break;
    }
}
function $cdd6162a40e9c08a$export$7e0d3b5c6570ae8b(columns) {
    let column = (0, $c0a1d2df3eff3893$exports.preferredColumnForTreemapSize)(columns, true);
    if (!column) column = (0, $c0a1d2df3eff3893$exports.preferredColumnForTreemapSize)(columns, false);
    return column;
}
function $cdd6162a40e9c08a$export$3351a8d90bcc13aa(insight, columns) {
    if (columns && insight.columns && insight.columns.color) return columns.filter((c)=>c.name === insight.columns.color)[0];
}
function $cdd6162a40e9c08a$export$46ec3e17747a00c9(columns) {
    const bounds = [];
    const getBound = (dimension, dataExtent, column)=>{
        const { stats: stats } = column;
        const numericValue = dataExtent === 'max' ? stats.max : stats.min;
        return {
            columnName: column.name,
            dimension: dimension,
            valid: true,
            dataExtent: dataExtent,
            numericValue: numericValue,
            stringValue: numericValue.toString()
        };
    };
    const dataExtents = [
        'max',
        'min'
    ];
    const dimensions = [
        'x',
        'y'
    ];
    columns.forEach((c)=>{
        if (c.quantitative) dimensions.forEach((dimension)=>dataExtents.forEach((dataExtent)=>bounds.push(getBound(dimension, dataExtent, c))));
    });
    return bounds;
}


function $15c8a952544b8f28$var$_BackgroundImageEditor(_props) {
    class __BackgroundImageEditor extends (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.Component {
        constructor(props){
            super(props);
            this.state = {
                backgroundImageColumnBounds: [],
                readyToApply: false,
                hidden: true
            };
        }
        show(insightColumns) {
            const { explorer: explorer, quantitativeColumns: quantitativeColumns } = this.props;
            if (!quantitativeColumns.length) //TODO show error
            return;
            const xCol = quantitativeColumns.filter((c)=>c.name === insightColumns.x)[0];
            const yCol = quantitativeColumns.filter((c)=>c.name === insightColumns.y)[0];
            let backgroundImageColumnBounds;
            if (explorer.imageHolder.backgroundImageColumnBounds.length < quantitativeColumns.length * 4) backgroundImageColumnBounds = (0, $cdd6162a40e9c08a$export$46ec3e17747a00c9)(explorer.state.dataContent.columns);
            else backgroundImageColumnBounds = (0, $1342cf7df79546f0$exports).VegaMorphCharts.util.clone(explorer.imageHolder.backgroundImageColumnBounds);
            const newState = {
                hidden: false,
                xCol: xCol,
                yCol: yCol,
                backgroundImageColumnBounds: backgroundImageColumnBounds
            };
            !xCol || yCol;
            this.setState(newState);
            this.checkReady();
        }
        render() {
            const { props: props, state: state } = this;
            const { explorer: explorer } = props;
            return (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement((0, $f4b615ab5c14d90e$export$3ddf2d174ce01153), {
                hidden: state.hidden,
                onDismiss: ()=>this.setState({
                        hidden: true,
                        backgroundImageFileFormatError: null
                    }),
                modalProps: {
                    containerClassName: 'sanddance-background-image-dialog'
                },
                dialogContentProps: {
                    type: (0, $a601a4135959dcb0$export$e2253033e6e1df16).fluentUI.DialogType.normal,
                    title: (0, $d5b6ce321475881f$export$21c51bc433c16634).labelBackgroundImageDialogTitle,
                    subText: (0, $d5b6ce321475881f$export$21c51bc433c16634).labelBackgroundImageSubtext
                },
                buttons: [
                    (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement((0, $a601a4135959dcb0$export$e2253033e6e1df16).fluentUI.PrimaryButton, {
                        key: 'apply',
                        iconProps: {
                            iconName: 'Photo2Add'
                        },
                        text: (0, $d5b6ce321475881f$export$21c51bc433c16634).buttonApply,
                        onClick: ()=>this.applyImage(true),
                        disabled: !state.readyToApply
                    })
                ]
            }, explorer.imageHolder.img ? (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("div", {
                className: 'thumbnail'
            }, (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("img", {
                src: explorer.imageHolder.img.src
            }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement((0, $a601a4135959dcb0$export$e2253033e6e1df16).fluentUI.DefaultButton, {
                key: 'remove',
                iconProps: {
                    iconName: 'Photo2Remove'
                },
                text: (0, $d5b6ce321475881f$export$21c51bc433c16634).buttonRemove,
                onClick: ()=>{
                    explorer.imageHolder.img = null;
                    this.applyImage(false);
                    this.setState({
                        readyToApply: false
                    });
                }
            })) : (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("div", {
                className: 'thumbnail'
            }, (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("input", {
                type: "file",
                onChange: (e)=>this.readBackgroundImage(e)
            }), state.backgroundImageFileFormatError && (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("div", {
                className: "error"
            }, state.backgroundImageFileFormatError)), this.inputForColumn(state.xCol, 'X axis', 'x', (0, $d5b6ce321475881f$export$21c51bc433c16634).labelBackgroundLeft, (0, $d5b6ce321475881f$export$21c51bc433c16634).labelBackgroundRight), this.inputForColumn(state.yCol, 'Y axis', 'y', (0, $d5b6ce321475881f$export$21c51bc433c16634).labelBackgroundBottom, (0, $d5b6ce321475881f$export$21c51bc433c16634).labelBackgroundTop));
        }
        inputForColumn(column, label, dimension, minLabel, maxLabel) {
            const { props: props, state: state } = this;
            const fieldInput = (label, dataExtent, getDefault)=>{
                const bounds = state.backgroundImageColumnBounds.filter((b)=>b.columnName === (column === null || column === void 0 ? void 0 : column.name) && b.dimension === dimension && b.dataExtent === dataExtent)[0];
                if (!bounds) return null;
                return (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("div", {
                    className: 'axis-bound-field'
                }, (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement((0, $a601a4135959dcb0$export$e2253033e6e1df16).fluentUI.TextField, {
                    label: label,
                    onChange: (e, value)=>{
                        const numericValue = +value;
                        bounds.stringValue = value;
                        bounds.valid = !(!value || isNaN(numericValue));
                        if (bounds.valid) bounds.numericValue = numericValue;
                        this.setState({
                            backgroundImageColumnBounds: [
                                ...state.backgroundImageColumnBounds
                            ]
                        });
                        this.checkReady();
                    },
                    value: bounds.stringValue,
                    errorMessage: bounds.valid ? null : (0, $d5b6ce321475881f$export$21c51bc433c16634).errorNumericValue,
                    onRenderSuffix: (a)=>{
                        return (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement((0, $baf9c68afdd76912$export$c25acd513dcc8062), {
                            iconName: 'ScaleVolume',
                            themePalette: props.themePalette,
                            title: 'Use data extent' //TODO
                            ,
                            onClick: ()=>{
                                bounds.numericValue = getDefault();
                                bounds.stringValue = bounds.numericValue.toString();
                                bounds.valid = true;
                                this.setState({
                                    backgroundImageColumnBounds: [
                                        ...state.backgroundImageColumnBounds
                                    ]
                                });
                                this.checkReady();
                            }
                        });
                    }
                }));
            };
            return (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("div", {
                className: 'axis-bounds'
            }, (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement((0, $a601a4135959dcb0$export$e2253033e6e1df16).fluentUI.Dropdown, {
                label: label,
                options: props.quantitativeColumns.map((c)=>{
                    const option = {
                        key: c.name,
                        text: c.name
                    };
                    return option;
                }),
                onChange: (e, o)=>{
                    const newState = {
                        readyToApply: false
                    };
                    const newColumn = props.quantitativeColumns.filter((c)=>c.name === o.key)[0];
                    switch(dimension){
                        case 'x':
                            newState.xCol = newColumn;
                            break;
                        case 'y':
                            newState.yCol = newColumn;
                            break;
                    }
                    this.setState(newState);
                    this.checkReady();
                },
                selectedKey: column === null || column === void 0 ? void 0 : column.name
            }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("div", {
                className: 'axis-bound-fields'
            }, fieldInput(minLabel, 'min', ()=>column.stats.min), fieldInput(maxLabel, 'max', ()=>column.stats.max)));
        }
        readBackgroundImage(e) {
            if (e.target.files) {
                const file = e.target.files[0];
                const reader = new FileReader();
                reader.onload = ()=>{
                    const img = new Image();
                    img.onerror = ()=>{
                        this.setState({
                            backgroundImageFileFormatError: (0, $d5b6ce321475881f$export$21c51bc433c16634).errorImageFormat
                        });
                    };
                    img.onload = ()=>{
                        //success
                        const { src: src, height: height, width: width } = img;
                        this.props.explorer.imageHolder.img = {
                            src: src,
                            height: height,
                            width: width
                        };
                        this.checkReady();
                    };
                    try {
                        img.src = reader.result;
                    } catch (e) {
                        this.setState({
                            backgroundImageFileFormatError: (0, $d5b6ce321475881f$export$21c51bc433c16634).errorImageFormat
                        });
                    }
                };
                reader.readAsDataURL(file);
            }
        }
        checkReady() {
            //allow state to resolve
            setTimeout(()=>{
                const { state: state, props: props } = this;
                const { explorer: explorer } = props;
                const { backgroundImageColumnBounds: backgroundImageColumnBounds } = state;
                let valid = true;
                const dimensions = [
                    'x',
                    'y'
                ];
                const dataExtents = [
                    'max',
                    'min'
                ];
                [
                    state.xCol,
                    state.yCol
                ].forEach((c)=>dimensions.forEach((dimension)=>dataExtents.forEach((dataExtent)=>{
                            const bounds = backgroundImageColumnBounds.filter((b)=>b.columnName === c.name && b.dataExtent === dataExtent && b.dimension === dimension)[0];
                            if (!bounds.valid) valid = false;
                        })));
                const readyToApply = explorer.imageHolder.img && valid; //TODO if not already applied
                this.setState({
                    readyToApply: readyToApply
                });
            }, 0);
        }
        applyImage(showBackgroundImage) {
            const { props: props, state: state } = this;
            const { explorer: explorer } = props;
            explorer.imageHolder.showBackgroundImage = showBackgroundImage;
            explorer.imageHolder.backgroundImageColumnBounds = (0, $1342cf7df79546f0$exports).VegaMorphCharts.util.clone(state.backgroundImageColumnBounds);
            if (showBackgroundImage) switch(props.chart){
                case 'density':
                case 'scatterplot':
                case 'stacks':
                    break;
                default:
                    //TODO use xcol & ycol
                    //make sure x & y are numeric
                    explorer.changeChartType('scatterplot');
                    return;
            }
            explorer.forceUpdate();
        }
    }
    return new __BackgroundImageEditor(_props);
}
const $15c8a952544b8f28$export$5696019163aa3cca = $15c8a952544b8f28$var$_BackgroundImageEditor;
function $15c8a952544b8f28$export$5aa9f35b88971754(insight, imageHolder, columns) {
    if (!imageHolder.showBackgroundImage || !columns.x || !columns.y) return;
    const { backgroundImageColumnBounds: backgroundImageColumnBounds } = imageHolder;
    const xBounds = backgroundImageColumnBounds.filter((b)=>b.columnName === columns.x && b.dimension === 'x');
    const yBounds = backgroundImageColumnBounds.filter((b)=>b.columnName === columns.y && b.dimension === 'y');
    if (!xBounds.length || !yBounds.length) return;
    const allBounds = [
        ...xBounds,
        ...yBounds
    ];
    for(let i = 0; i < allBounds.length; i++){
        if (!allBounds[i].valid) return;
    }
    const bottom = yBounds.filter((b)=>b.dataExtent === 'min')[0];
    const left = xBounds.filter((b)=>b.dataExtent === 'min')[0];
    const right = xBounds.filter((b)=>b.dataExtent === 'max')[0];
    const top = yBounds.filter((b)=>b.dataExtent === 'max')[0];
    const all = [
        bottom,
        left,
        right,
        top
    ];
    for(let i = 0; i < all.length; i++){
        if (!all[i]) return;
    }
    const { src: src, height: height, width: width } = imageHolder.img;
    insight.backgroundImage = {
        url: src,
        size: {
            height: height,
            width: width
        },
        extents: {
            bottom: bottom.numericValue,
            left: left.numericValue,
            right: right.numericValue,
            top: top.numericValue
        }
    };
    insight.size = insight.backgroundImage.size;
}


/*!
* Copyright (c) Microsoft Corporation.
* Licensed under the MIT License.
*/ 
/*!
* Copyright (c) Microsoft Corporation.
* Licensed under the MIT License.
*/ 
/*!
* Copyright (c) Microsoft Corporation.
* Licensed under the MIT License.
*/ 
const $8f56f1ed6ae42f13$export$8263e1ed1ef30f07 = 200;
function $8f56f1ed6ae42f13$export$931cbfb6bfb85fc(props) {
    const newProps = Object.assign({}, props);
    let selectedKey = null;
    if (newProps.options && newProps.options.length > 1) {
        const selectedOptions = newProps.options.filter((option)=>option.selected);
        if (selectedOptions && selectedOptions.length > 0) selectedKey = selectedOptions[0].key;
    }
    if (newProps.collapseLabel) newProps.onRenderTitle = (a, b)=>{
        return (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("span", null, newProps.label, ": ", a[0].text);
    };
    return (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement((0, $a601a4135959dcb0$export$e2253033e6e1df16).fluentUI.Dropdown, Object.assign({
        dropdownWidth: $8f56f1ed6ae42f13$export$8263e1ed1ef30f07
    }, newProps, {
        label: newProps.collapseLabel ? null : newProps.label,
        selectedKey: selectedKey
    }));
}



/*!
* Copyright (c) Microsoft Corporation.
* Licensed under the MIT License.
*/ 
function $00e2720d7006b5f2$export$d54e4e563d2a9303(explorer, signal) {
    let initialValue;
    try {
        initialValue = explorer.viewer.vegaViewGl.signal(signal.name);
    } catch (error) {
    // continue regardless of error
    }
    return initialValue;
}
function $00e2720d7006b5f2$export$8210dfe1863c478(props) {
    if (!props.explorer.viewer || !props.signal) return null;
    if (props.signal.bind) {
        const input = props.signal.bind.input;
        if (input) {
            const fn = $00e2720d7006b5f2$var$map[input];
            if (fn) {
                const prefix = props.prefix ? `${props.prefix} ` : '';
                const control = fn(prefix, props.signal.bind, props.initialValue, (value)=>{
                    props.onChange && props.onChange(value);
                    props.explorer.signal(props.signal.name, value, props.newViewStateTarget);
                }, props.disabled, props.collapseLabel, props.componentRef);
                return (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("div", {
                    className: "sanddance-signal"
                }, control);
            }
        }
    }
    return null;
}
const $00e2720d7006b5f2$var$map = {};
$00e2720d7006b5f2$var$map['range'] = (prefix, bind, initialValue, onChange, disabled, collapseLabel, ref)=>{
    let debouncer;
    return (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement((0, $a601a4135959dcb0$export$e2253033e6e1df16).fluentUI.Slider, {
        componentRef: ref,
        label: prefix + bind.name,
        max: bind.max,
        min: bind.min,
        step: bind.step,
        defaultValue: initialValue,
        onChange: (value)=>{
            if (debouncer) clearTimeout(debouncer);
            debouncer = setTimeout(()=>onChange(value), bind.debounce || 0);
        },
        disabled: disabled
    });
};
$00e2720d7006b5f2$var$map['select'] = (prefix, bind, initialValue, onChange, disabled, collapseLabel, ref)=>{
    const options = bind.options.map((o, i)=>{
        const option = {
            key: o,
            text: o
        };
        return option;
    });
    const label = prefix + bind.name;
    return (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement((0, $a601a4135959dcb0$export$e2253033e6e1df16).fluentUI.Dropdown, {
        componentRef: ref,
        onRenderTitle: collapseLabel ? (a, b)=>(0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("span", null, label, ": ", a[0].text) : undefined,
        defaultSelectedKey: initialValue,
        label: collapseLabel ? undefined : label,
        options: options,
        onChange: (e, o)=>onChange(o.text),
        disabled: disabled
    });
};
$00e2720d7006b5f2$var$map['checkbox'] = (prefix, bind, initialValue, onChange, disabled, collapseLabel, ref)=>{
    return (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement((0, $a601a4135959dcb0$export$e2253033e6e1df16).fluentUI.Toggle, {
        componentRef: ref,
        defaultChecked: initialValue,
        label: prefix + bind.name,
        onChange: (e, checked)=>onChange(checked),
        disabled: disabled
    });
}; //TODO other signal types



const $3ecc97321af8bbc8$var$maxFacets = 50;
const $3ecc97321af8bbc8$var$roleLabels = {
    color: (0, $d5b6ce321475881f$export$21c51bc433c16634).labelColumnColor,
    facet: (0, $d5b6ce321475881f$export$21c51bc433c16634).labelColumnFacet,
    facetV: (0, $d5b6ce321475881f$export$21c51bc433c16634).labelColumnFacetV,
    group: (0, $d5b6ce321475881f$export$21c51bc433c16634).labelColumnGroup,
    size: (0, $d5b6ce321475881f$export$21c51bc433c16634).labelColumnSize,
    sort: (0, $d5b6ce321475881f$export$21c51bc433c16634).labelColumnSort,
    uid: null,
    x: (0, $d5b6ce321475881f$export$21c51bc433c16634).labelColumnX,
    y: (0, $d5b6ce321475881f$export$21c51bc433c16634).labelColumnY,
    z: (0, $d5b6ce321475881f$export$21c51bc433c16634).labelColumnZ
};
const $3ecc97321af8bbc8$var$aliasLabels = {
    color: (0, $d5b6ce321475881f$export$21c51bc433c16634).labelAliasColor,
    facet: (0, $d5b6ce321475881f$export$21c51bc433c16634).labelAliasFacet,
    facetV: (0, $d5b6ce321475881f$export$21c51bc433c16634).labelAliasFacetV,
    group: (0, $d5b6ce321475881f$export$21c51bc433c16634).labelAliasGroup,
    size: (0, $d5b6ce321475881f$export$21c51bc433c16634).labelAliasSize,
    sort: (0, $d5b6ce321475881f$export$21c51bc433c16634).labelAliasSort,
    uid: null,
    x: (0, $d5b6ce321475881f$export$21c51bc433c16634).labelAliasX,
    y: (0, $d5b6ce321475881f$export$21c51bc433c16634).labelAliasY,
    z: (0, $d5b6ce321475881f$export$21c51bc433c16634).labelAliasZ
};
function $3ecc97321af8bbc8$var$filterColumnList(context, columns) {
    switch(context){
        case 'facet':
        case 'facetV':
            return columns.filter((column)=>column.quantitative || column.stats.distinctValueCount && column.stats.distinctValueCount < $3ecc97321af8bbc8$var$maxFacets);
        default:
            return columns.slice();
    }
}
function $3ecc97321af8bbc8$var$optionsForSpecColumn(sectionName, columns, role, disabledColumnName, selectedColumnName) {
    const filtered = $3ecc97321af8bbc8$var$filterColumnList(role, columns);
    const options = filtered.map((column)=>{
        const option = {
            key: `column:${column.name}`,
            text: column.name,
            data: column,
            selected: selectedColumnName === column.name,
            disabled: disabledColumnName === column.name
        };
        return option;
    });
    if (options.length) {
        const option = {
            key: sectionName,
            text: sectionName,
            itemType: (0, $a601a4135959dcb0$export$e2253033e6e1df16).fluentUI.DropdownMenuItemType.Header
        };
        options.unshift(option);
    }
    return options;
}
function $3ecc97321af8bbc8$var$optionsForReference(sectionName, specRoles) {
    const options = specRoles.map((specRole)=>{
        const option = {
            key: `role:${specRole.role}`,
            text: $3ecc97321af8bbc8$var$aliasLabels[specRole.role],
            data: specRole.role
        };
        return option;
    }).sort((a, b)=>a.text.localeCompare(b.text));
    if (options.length) {
        const option = {
            key: sectionName,
            text: sectionName,
            itemType: (0, $a601a4135959dcb0$export$e2253033e6e1df16).fluentUI.DropdownMenuItemType.Header
        };
        options.unshift(option);
    }
    return options;
}
function $3ecc97321af8bbc8$var$selectFirst(options) {
    for(let i = 0; i < options.length; i++){
        if (options[i].itemType === (0, $a601a4135959dcb0$export$e2253033e6e1df16).fluentUI.DropdownMenuItemType.Header) continue;
        options[i].selected = true;
        return;
    }
}
function $3ecc97321af8bbc8$export$c171b40a34e110b5(props) {
    if (!props.specRole) return null;
    let categoricalColumns;
    let directColorColumns;
    let directColorGroup;
    let referenceGroup = [];
    if (props.specRole.role === 'color') {
        categoricalColumns = props.categoricalColumns.filter((c)=>!c.isColorData);
        directColorColumns = props.categoricalColumns.filter((c)=>c.isColorData);
        directColorGroup = $3ecc97321af8bbc8$var$optionsForSpecColumn((0, $d5b6ce321475881f$export$21c51bc433c16634).selectDirectColor, directColorColumns, 'color', props.disabledColumnName, props.selectedColumnName);
    } else categoricalColumns = props.categoricalColumns;
    if (props.specRole.role === 'sort') {
        const others = props.specCapabilities.roles.filter((specRole)=>specRole.role !== props.specRole.role);
        referenceGroup = $3ecc97321af8bbc8$var$optionsForReference((0, $d5b6ce321475881f$export$21c51bc433c16634).selectReference, others);
    }
    const quantitativeGroup = $3ecc97321af8bbc8$var$optionsForSpecColumn((0, $d5b6ce321475881f$export$21c51bc433c16634).selectNumeric, props.quantitativeColumns, props.specRole.role, props.disabledColumnName, props.selectedColumnName);
    const categoricGroup = props.specRole.excludeCategoric ? null : $3ecc97321af8bbc8$var$optionsForSpecColumn((0, $d5b6ce321475881f$export$21c51bc433c16634).selectNonNumeric, categoricalColumns, props.specRole.role, props.disabledColumnName, props.selectedColumnName);
    const options = referenceGroup.concat(quantitativeGroup).concat(categoricGroup).concat(directColorGroup).filter(Boolean);
    return options;
}
function $3ecc97321af8bbc8$export$83b9e0badda50eeb(props) {
    const options = $3ecc97321af8bbc8$export$c171b40a34e110b5(props);
    if (props.specRole.allowNone) options.unshift({
        key: -1,
        text: (0, $d5b6ce321475881f$export$21c51bc433c16634).selectNone
    });
    const hasSelection = options.reduce((p, c)=>{
        return p || c.selected;
    }, false);
    if (!hasSelection) $3ecc97321af8bbc8$var$selectFirst(options);
    let signals;
    if (props.explorer.viewer && props.explorer.viewer.vegaSpec) {
        if (props.specRole.signals) signals = props.explorer.viewer.vegaSpec.signals.filter((s)=>props.specRole.signals.indexOf(s.name) >= 0);
    }
    const label = $3ecc97321af8bbc8$var$roleLabels[props.specRole.role];
    const signalElements = !props.hideSignals && signals && signals.map((signal, i)=>{
        let initialValue;
        try {
            initialValue = props.explorer.viewer.vegaViewGl.signal(signal.name);
        } catch (error) {
        // continue regardless of error
        }
        return (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement((0, $00e2720d7006b5f2$export$8210dfe1863c478), {
            key: signal.name + i + initialValue,
            explorer: props.explorer,
            signal: signal,
            initialValue: initialValue,
            onChange: (value)=>props.onChangeSignal && props.onChangeSignal(signal.name, value),
            collapseLabel: props.collapseLabel
        });
    });
    return (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("div", {
        className: "sanddance-columnMap"
    }, props.prefix, !props.hideDropdown && (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement((0, $8f56f1ed6ae42f13$export$931cbfb6bfb85fc), {
        componentRef: props.componentRef,
        collapseLabel: props.collapseLabel,
        disabled: props.disabled,
        label: label,
        options: options,
        onChange: (e, o)=>props.changeColumnMapping(props.specRole.role, typeof o.data === 'string' ? o.data : (0, $1342cf7df79546f0$exports).VegaMorphCharts.util.clone(o.data)),
        onDismiss: props.onDismiss
    }), signalElements, props.suffix);
}



function $f47e4461409e9b5c$export$48e4a8ab7f4530ac(stage, specCapabilities) {
    for(const axisName in stage.axes)specCapabilities.roles.forEach((specRole)=>{
        if (specRole.role === axisName) {
            const axes = stage.axes[axisName];
            axes.forEach((axis)=>{
                if (axis.title) {
                    const textItem = axis.title;
                    textItem.specRole = specRole;
                }
            });
        }
    });
}
function $f47e4461409e9b5c$var$px(n) {
    return n + 'px';
}
function $f47e4461409e9b5c$var$_PositionedColumnMap(_props) {
    class __PositionedColumnMap extends (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.Component {
        constructor(props){
            super(props);
            const { left: left, top: top } = props;
            this.state = {
                left: left,
                top: top
            };
            this.dropdownRef = (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createRef();
        }
        focus() {
            if (!this.focused) {
                this.focused = true;
                this.dropdownRef.current.focus(true);
            }
        }
        componentDidMount() {
            const size = (0, $1342cf7df79546f0$exports).VegaMorphCharts.util.outerSize(this.div);
            const over = {
                left: Math.max(0, this.state.left + size.width - this.props.container.offsetWidth),
                top: Math.max(0, this.state.top + size.height - this.props.container.offsetHeight)
            };
            if (over.left || over.top) {
                let { left: left, top: top } = this.state;
                left -= over.left;
                top -= over.top;
                this.setState({
                    left: left,
                    top: top
                });
            } else this.focus();
        }
        componentDidUpdate() {
            this.focus();
        }
        render() {
            return (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("div", {
                ref: (div)=>{
                    if (div) this.div = div;
                },
                className: "sanddance-columnMap-absolute",
                style: {
                    position: 'absolute',
                    left: $f47e4461409e9b5c$var$px(this.state.left),
                    top: $f47e4461409e9b5c$var$px(this.state.top)
                }
            }, (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement((0, $3ecc97321af8bbc8$export$83b9e0badda50eeb), Object.assign({}, this.props, {
                componentRef: this.dropdownRef,
                hideSignals: true
            })));
        }
    }
    return new __PositionedColumnMap(_props);
}
const $f47e4461409e9b5c$export$3e341bd56774d659 = $f47e4461409e9b5c$var$_PositionedColumnMap;


/*!
* Copyright (c) Microsoft Corporation.
* Licensed under the MIT License.
*/ 




function $0edfbb46d4822ac6$var$_ColumnTypeChanger(_props) {
    class __ColumnTypeChanger extends (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.Component {
        constructor(props){
            super(props);
            this.state = this.getInitialState();
        }
        getInitialState() {
            const { props: props } = this;
            return {
                dialogHidden: true,
                confirmationHidden: true,
                quantitativeColumns: props.initialQuantitativeColumns.map((c)=>(0, $1342cf7df79546f0$exports).VegaMorphCharts.util.clone(c)),
                categoricalColumns: props.initialCategoricalColumns.map((c)=>(0, $1342cf7df79546f0$exports).VegaMorphCharts.util.clone(c)),
                columnTypes: null
            };
        }
        closeDialog() {
            this.setState(this.getInitialState());
        }
        openConfirmation(columnTypes) {
            this.setState({
                columnTypes: columnTypes,
                confirmationHidden: false
            });
        }
        render() {
            const { props: props, state: state } = this;
            const hasChanges = props.initialQuantitativeColumns.some((c, i)=>{
                return c.quantitative !== state.quantitativeColumns[i].quantitative;
            });
            return (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("div", null, (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement((0, $a601a4135959dcb0$export$e2253033e6e1df16).fluentUI.DefaultButton, {
                text: (0, $d5b6ce321475881f$export$21c51bc433c16634).buttonColumnTypes,
                onClick: ()=>this.setState({
                        dialogHidden: false
                    })
            }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement((0, $f4b615ab5c14d90e$export$3ddf2d174ce01153), {
                minWidth: "80%",
                hidden: state.dialogHidden,
                onDismiss: ()=>this.closeDialog(),
                dialogContentProps: {
                    className: `sanddance-dialog ${props.theme}`,
                    type: (0, $a601a4135959dcb0$export$e2253033e6e1df16).fluentUI.DialogType.normal,
                    title: (0, $d5b6ce321475881f$export$21c51bc433c16634).labelColumnTypes
                },
                buttons: [
                    (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement((0, $a601a4135959dcb0$export$e2253033e6e1df16).fluentUI.DefaultButton, {
                        key: "revert",
                        text: (0, $d5b6ce321475881f$export$21c51bc433c16634).buttonResetToDefault,
                        onClick: ()=>this.openConfirmation(null),
                        iconProps: {
                            iconName: 'Undo'
                        }
                    }),
                    (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement((0, $a601a4135959dcb0$export$e2253033e6e1df16).fluentUI.DefaultButton, {
                        key: "apply",
                        text: (0, $d5b6ce321475881f$export$21c51bc433c16634).buttonApply,
                        onClick: ()=>{
                            const columnTypes = {};
                            state.quantitativeColumns.forEach((c)=>{
                                columnTypes[c.name] = c.quantitative ? c.type : 'string';
                            });
                            state.categoricalColumns.forEach((c)=>{
                                columnTypes[c.name] = 'string';
                            });
                            this.openConfirmation(columnTypes);
                        },
                        iconProps: {
                            iconName: 'Accept'
                        },
                        disabled: !hasChanges
                    })
                ]
            }, (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("div", {
                className: 'sanddance-columnTypes'
            }, state.quantitativeColumns.length > 0 && (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("div", null, (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("h3", null, (0, $d5b6ce321475881f$export$21c51bc433c16634).selectNumeric), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("table", null, (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("thead", null, (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("tr", null, (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("th", null, (0, $d5b6ce321475881f$export$21c51bc433c16634).labelEditColumn), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("th", null, (0, $d5b6ce321475881f$export$21c51bc433c16634).labelColumnName), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("th", null, (0, $d5b6ce321475881f$export$21c51bc433c16634).labelColumnQuantitativeMin), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("th", null, (0, $d5b6ce321475881f$export$21c51bc433c16634).labelColumnQuantitativeMax), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("th", null, (0, $d5b6ce321475881f$export$21c51bc433c16634).labelColumnQuantitativeMean), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("th", null, (0, $d5b6ce321475881f$export$21c51bc433c16634).labelColumnDistinct))), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("tbody", null, state.quantitativeColumns.map((c, i)=>(0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("tr", {
                    key: i,
                    className: c.quantitative ? '' : 'changed'
                }, (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("td", null, (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement((0, $baf9c68afdd76912$export$c25acd513dcc8062), {
                    iconName: 'Edit',
                    onClick: undefined,
                    menuProps: {
                        items: [
                            (0, $d5b6ce321475881f$export$21c51bc433c16634).selectNumeric,
                            (0, $d5b6ce321475881f$export$21c51bc433c16634).selectNonNumeric
                        ].map((t)=>{
                            return {
                                key: t,
                                text: t,
                                onClick: ()=>{
                                    c.quantitative = t === (0, $d5b6ce321475881f$export$21c51bc433c16634).selectNumeric;
                                    this.setState({
                                        quantitativeColumns: [
                                            ...state.quantitativeColumns
                                        ]
                                    });
                                }
                            };
                        })
                    },
                    themePalette: props.themePalette,
                    title: (0, $d5b6ce321475881f$export$21c51bc433c16634).labelChangeColumnType
                })), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("td", null, c.name), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("td", null, c.stats.min), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("td", null, c.stats.max), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("td", null, c.stats.mean), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("td", null, c.stats.distinctValueCount)))))), state.categoricalColumns.length > 0 && (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("div", null, (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("h3", null, (0, $d5b6ce321475881f$export$21c51bc433c16634).selectNonNumeric), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("table", null, (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("thead", null, (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("tr", null, (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("th", null, (0, $d5b6ce321475881f$export$21c51bc433c16634).labelColumnName), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("th", null, (0, $d5b6ce321475881f$export$21c51bc433c16634).labelColumnType), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("th", null, (0, $d5b6ce321475881f$export$21c51bc433c16634).labelColumnDistinct), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("th", null, (0, $d5b6ce321475881f$export$21c51bc433c16634).labelColumnHasColorData), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("th", null, (0, $d5b6ce321475881f$export$21c51bc433c16634).labelColumnIsColorData))), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("tbody", null, state.categoricalColumns.map((c, i)=>(0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("tr", {
                    key: i
                }, (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("td", null, c.name), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("td", null, c.type), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("td", null, c.stats.distinctValueCount), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("td", null, (!!c.stats.hasColorData).toString()), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("td", null, (!!c.isColorData).toString())))))))), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement((0, $f4b615ab5c14d90e$export$3ddf2d174ce01153), {
                hidden: state.confirmationHidden,
                onDismiss: ()=>this.setState({
                        confirmationHidden: true
                    }),
                dialogContentProps: {
                    className: `sanddance-dialog ${props.theme}`,
                    type: (0, $a601a4135959dcb0$export$e2253033e6e1df16).fluentUI.DialogType.normal,
                    title: (0, $d5b6ce321475881f$export$21c51bc433c16634).labelConfirmation,
                    subText: (0, $d5b6ce321475881f$export$21c51bc433c16634).labelHistoryWarning
                },
                buttons: (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement((0, $a601a4135959dcb0$export$e2253033e6e1df16).fluentUI.PrimaryButton, {
                    text: (0, $d5b6ce321475881f$export$21c51bc433c16634).buttonApply,
                    onClick: ()=>{
                        this.closeDialog();
                        this.props.onConfirmUpdate(this.state.columnTypes);
                    },
                    iconProps: {
                        iconName: 'Accept'
                    }
                })
            }));
        }
    }
    return new __ColumnTypeChanger(_props);
}
const $0edfbb46d4822ac6$export$12df67f310f5f846 = $0edfbb46d4822ac6$var$_ColumnTypeChanger;


/*!
* Copyright (c) Microsoft Corporation.
* Licensed under the MIT License.
*/ /*!
* Copyright (c) Microsoft Corporation.
* Licensed under the MIT License.
*/ const $c90c20f7be6ae7d5$export$c4b7cd609ccf4a5a = (title, embed)=>`<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>${title}</title>
    <link rel="stylesheet" type="text/css" href="https://unpkg.com/@msrvida/sanddance-explorer@4/dist/css/sanddance-explorer.css" />
    <link rel="stylesheet" type="text/css" href="https://unpkg.com/@msrvida/sanddance-embed@4/dist/css/sanddance-embed.css" />
</head>
<body>
    <script src="https://unpkg.com/react@17/umd/react.production.min.js"></script>
    <script src="https://unpkg.com/react-dom@17/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/vega@5.32/build/vega.min.js"></script>
    <script src="https://unpkg.com/@fluentui/react@8/dist/fluentui-react.js"></script>
    <script src="https://unpkg.com/@msrvida/fluentui-icons@1/dist/umd/fluentui-icons.js"></script>
    <script src="https://unpkg.com/@msrvida/sanddance-explorer@4/dist/umd/sanddance-explorer.js"></script>
    <script src="https://unpkg.com/@msrvida/sanddance-embed@4/dist/umd/sanddance-embed.js"></script>
    ${embed}
</body>
</html>`;




/*!
* Copyright (c) Microsoft Corporation.
* Licensed under the MIT License.
*/ function $3a2778f19bd71931$export$65aea4b3b539487b(data, delimiter) {
    const fields = Object.keys(data[0]);
    const file = data.map((row)=>{
        return fields.map((fieldName)=>{
            const value = row[fieldName];
            if (typeof value === 'number') return value;
            if (typeof value === 'string') {
                if (value.indexOf(delimiter) >= 0) return `"${value.replace(/"/g, '""')}"`;
                else return value;
            }
            return '';
        }).join(delimiter);
    });
    file.unshift(fields.join(delimiter));
    return file.join('\n');
}




const $cff73bb5fafa0795$var$exportTypes = [
    [
        'json',
        (0, $d5b6ce321475881f$export$21c51bc433c16634).labelExportJSON
    ],
    [
        'csv',
        (0, $d5b6ce321475881f$export$21c51bc433c16634).labelExportCSV
    ],
    [
        'tsv',
        (0, $d5b6ce321475881f$export$21c51bc433c16634).labelExportTSV
    ],
    [
        'html',
        (0, $d5b6ce321475881f$export$21c51bc433c16634).labelExportHTML
    ]
];
function $cff73bb5fafa0795$var$_DataExportPicker(_props) {
    class __DataExportPicker extends (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.Component {
        constructor(props){
            super(props);
            this.state = this.getInitialState(this.props);
        }
        getInitialState(props) {
            const initialState = {
                initializer: props.initializer,
                dialogHidden: true,
                exportType: $cff73bb5fafa0795$var$exportTypes[0][0],
                fileName: props.initializer.fileName,
                fileNameError: '',
                working: false
            };
            return initialState;
        }
        componentDidUpdate() {
            if (!(0, $e295d8097c1ad61a$exports).deepCompare(this.props.initializer, this.state.initializer)) this.setState(this.getInitialState(this.props));
        }
        // Converts to dataExport type and calls dataExportHandler to deal with data
        createExport(exportType, displayName) {
            const final = (data)=>{
                this.props.dataExportHandler(data, exportType, displayName);
                this.close();
            };
            const json = JSON.stringify(this.props.data, $cff73bb5fafa0795$var$columnReplacer);
            switch(exportType){
                case 'json':
                    final(json);
                    break;
                case 'csv':
                    final((0, $3a2778f19bd71931$export$65aea4b3b539487b)(JSON.parse(json), ','));
                    break;
                case 'tsv':
                    final((0, $3a2778f19bd71931$export$65aea4b3b539487b)(JSON.parse(json), '\t'));
                    break;
                case 'html':
                    {
                        const csv = (0, $3a2778f19bd71931$export$65aea4b3b539487b)(JSON.parse(json), ',');
                        const html = (0, $c90c20f7be6ae7d5$export$c4b7cd609ccf4a5a)(`${(0, $d5b6ce321475881f$export$21c51bc433c16634).appName} - ${escape(displayName)}`, $cff73bb5fafa0795$var$embedScript(csv, displayName));
                        final(html);
                    }
            }
        }
        close() {
            this.setState({
                dialogHidden: true,
                working: false
            });
        }
        render() {
            const closeDialog = ()=>this.close();
            if (this.state.delayAction) requestAnimationFrame(()=>{
                //allow render to complete
                if (this.state.delayAction) {
                    this.state.delayAction();
                    this.setState({
                        delayAction: null
                    });
                }
            });
            const disabled = this.state.working || this.state.dialogHidden;
            return (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("div", null, (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement((0, $a601a4135959dcb0$export$e2253033e6e1df16).fluentUI.DefaultButton, {
                className: "search-action search-bottom-action",
                text: (0, $d5b6ce321475881f$export$21c51bc433c16634).buttonExportCount(this.props.data.length),
                onClick: ()=>this.setState({
                        dialogHidden: false
                    }),
                disabled: this.props.disabled
            }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement((0, $f4b615ab5c14d90e$export$3ddf2d174ce01153), {
                hidden: this.state.dialogHidden,
                onDismiss: closeDialog,
                dialogContentProps: {
                    className: `sanddance-dialog ${this.props.theme}`,
                    type: (0, $a601a4135959dcb0$export$e2253033e6e1df16).fluentUI.DialogType.normal,
                    title: (0, $d5b6ce321475881f$export$21c51bc433c16634).labelExport
                },
                buttons: [
                    (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement((0, $a601a4135959dcb0$export$e2253033e6e1df16).fluentUI.PrimaryButton, {
                        key: 0,
                        disabled: disabled || !!this.state.fileNameError,
                        onClick: (e)=>this.setState({
                                delayAction: ()=>this.createExport(this.state.exportType, this.state.fileName),
                                working: true
                            }),
                        text: (0, $d5b6ce321475881f$export$21c51bc433c16634).buttonExport,
                        iconProps: {
                            iconName: 'Download'
                        }
                    })
                ]
            }, (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement((0, $a601a4135959dcb0$export$e2253033e6e1df16).fluentUI.TextField, {
                label: (0, $d5b6ce321475881f$export$21c51bc433c16634).labelExportFileName,
                onChange: (e, displayName)=>{
                    const displayNameError = $cff73bb5fafa0795$var$getFileNameError(displayName);
                    this.setState({
                        fileName: displayName,
                        fileNameError: displayNameError
                    });
                },
                errorMessage: this.state.fileNameError,
                value: this.state.fileName
            }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement((0, $a601a4135959dcb0$export$e2253033e6e1df16).fluentUI.ChoiceGroup, {
                className: "sanddance-form-separate",
                disabled: disabled,
                selectedKey: this.state.exportType,
                options: $cff73bb5fafa0795$var$exportTypes.map(([exportType, text])=>{
                    return {
                        key: exportType,
                        text: text,
                        disabled: false
                    };
                }),
                onChange: (ev, option)=>this.setState({
                        exportType: option.key
                    }),
                label: (0, $d5b6ce321475881f$export$21c51bc433c16634).labelExportFormat
            })));
        }
    }
    return new __DataExportPicker(_props);
}
const $cff73bb5fafa0795$export$b1b568728c48eba1 = $cff73bb5fafa0795$var$_DataExportPicker;
const $cff73bb5fafa0795$var$illegalChars = '\\/:*?"<>|';
function $cff73bb5fafa0795$var$getFileNameError(displayName) {
    if (!displayName) return (0, $d5b6ce321475881f$export$21c51bc433c16634).errorExportFilenameEmpty;
    for(let i = 0; i < $cff73bb5fafa0795$var$illegalChars.length; i++){
        if (displayName.indexOf($cff73bb5fafa0795$var$illegalChars[i]) >= 0) return (0, $d5b6ce321475881f$export$21c51bc433c16634).errorExportFilenameCharacters($cff73bb5fafa0795$var$illegalChars);
    }
}
function $cff73bb5fafa0795$export$748f956e607b675b(fileName) {
    $cff73bb5fafa0795$var$exportTypes.forEach(([exportType])=>{
        const re = new RegExp(`\\.${exportType}`, 'ig');
        fileName = fileName.replace(re, '');
    });
    return fileName;
}
function $cff73bb5fafa0795$var$columnReplacer(name, value) {
    if ((0, $1342cf7df79546f0$exports).util.isInternalFieldName(name, true)) return undefined;
    return value === null ? '' : value;
}
function $cff73bb5fafa0795$var$embedScript(csv, displayName, snapshots) {
    const dataFile = {
        type: 'csv',
        displayName: displayName,
        snapshots: snapshots
    };
    return `<pre id='csv-data' style='display:none'>${csv}</pre>
    <script>SandDanceEmbed.load(Object.assign({rawText: document.getElementById('csv-data').innerText}, ${JSON.stringify(dataFile)}))</script>`;
}
function $cff73bb5fafa0795$export$9f4b684ea6be1a90(data, displayName, snapshots) {
    const json = JSON.stringify(data, $cff73bb5fafa0795$var$columnReplacer);
    const csv = (0, $3a2778f19bd71931$export$65aea4b3b539487b)(JSON.parse(json), ',');
    const html = (0, $c90c20f7be6ae7d5$export$c4b7cd609ccf4a5a)(`${(0, $d5b6ce321475881f$export$21c51bc433c16634).appName} - ${escape(displayName)}`, $cff73bb5fafa0795$var$embedScript(csv, displayName, snapshots));
    return html;
}


/*!
* Copyright (c) Microsoft Corporation.
* Licensed under the MIT License.
*/ 



/*!
* Copyright (c) Microsoft Corporation.
* Licensed under the MIT License.
*/ 

function $5b1483fb7f067be1$export$eb2fcfdbd7ba97d4(props) {
    return (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("div", {
        className: (0, $e295d8097c1ad61a$exports).classList('sanddance-group', props.className)
    }, (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("div", {
        className: "group-head"
    }, (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("label", null, props.label), props.labelCount && (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("span", {
        className: "count"
    }, "(", props.labelCount, ")")), props.children && (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("div", {
        className: "group-body"
    }, props.children));
}





/*!
* Copyright (c) Microsoft Corporation.
* Licensed under the MIT License.
*/ 
function $2ec5b051a3376e1a$export$ce08aabc421980f4(props) {
    return (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("div", null, props.allColumns.map((c, i)=>(0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("div", {
            key: c.name
        }, (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("label", null, (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement((0, $a601a4135959dcb0$export$e2253033e6e1df16).fluentUI.Toggle, {
            checked: props.exclusions.indexOf(c.name) < 0,
            inlineLabel: true,
            label: c.name,
            onChange: ()=>props.toggleExclusion(c.name)
        })))));
}




const $b4b5d5b480eaf9ae$var$singleFacetLayouts = [
    {
        facetStyle: 'wrap',
        text: (0, $d5b6ce321475881f$export$21c51bc433c16634).labelFacetLayoutWrap
    }
];
const $b4b5d5b480eaf9ae$export$3fab399b77d7be2a = [
    {
        key: 'grid',
        text: (0, $d5b6ce321475881f$export$21c51bc433c16634).chartTypeGrid
    },
    {
        key: 'scatterplot',
        text: (0, $d5b6ce321475881f$export$21c51bc433c16634).chartTypeScatterPlot
    },
    {
        key: 'density',
        text: (0, $d5b6ce321475881f$export$21c51bc433c16634).chartTypeDensity
    },
    {
        key: 'barchartV',
        text: (0, $d5b6ce321475881f$export$21c51bc433c16634).chartTypeBarChartV
    },
    {
        key: 'barchartH',
        text: (0, $d5b6ce321475881f$export$21c51bc433c16634).chartTypeBarChartH
    },
    {
        key: 'treemap',
        text: (0, $d5b6ce321475881f$export$21c51bc433c16634).chartTypeTreeMap
    },
    {
        key: 'strips',
        text: (0, $d5b6ce321475881f$export$21c51bc433c16634).chartTypeStrips
    },
    {
        key: 'stacks',
        text: (0, $d5b6ce321475881f$export$21c51bc433c16634).chartTypeStacks
    }
];
function $b4b5d5b480eaf9ae$export$7d1536ca08644643(key) {
    for(let i = 0; i < $b4b5d5b480eaf9ae$export$3fab399b77d7be2a.length; i++){
        if (key === $b4b5d5b480eaf9ae$export$3fab399b77d7be2a[i].key) return $b4b5d5b480eaf9ae$export$3fab399b77d7be2a[i].text;
    }
}
function $b4b5d5b480eaf9ae$var$_Chart(_props) {
    class __Chart extends (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.Component {
        constructor(props){
            super(props);
            this.state = {
                showTooltipDialog: false
            };
            this.choiceRef = (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createRef();
            props.explorer.dialogFocusHandler.focus = ()=>{
                var _a;
                return (_a = this.choiceRef.current) === null || _a === void 0 ? void 0 : _a.focus();
            };
        }
        render() {
            const { props: props } = this;
            const { explorer: explorer, specCapabilities: specCapabilities } = props;
            const signals = explorer.viewer && explorer.viewer.vegaSpec && specCapabilities && specCapabilities.signals && explorer.viewer.vegaSpec.signals.filter((s)=>specCapabilities.signals.indexOf(s.name) >= 0);
            const hasOptions = !!signals || (specCapabilities === null || specCapabilities === void 0 ? void 0 : specCapabilities.backgroundImage);
            return (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("div", null, (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement((0, $5b1483fb7f067be1$export$eb2fcfdbd7ba97d4), {
                label: (0, $d5b6ce321475881f$export$21c51bc433c16634).labelChart
            }, (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("div", {
                className: "calculator"
            }, (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement((0, $a601a4135959dcb0$export$e2253033e6e1df16).fluentUI.ChoiceGroup, {
                componentRef: this.choiceRef,
                selectedKey: props.chart,
                className: "sanddance-chart-type",
                options: $b4b5d5b480eaf9ae$export$3fab399b77d7be2a.map((o)=>{
                    return Object.assign(Object.assign({}, o), {
                        disabled: props.disabled || o.key === 'treemap' && props.quantitativeColumns.length === 0
                    });
                }),
                onChange: (e, o)=>props.explorer.changeChartType(o.key)
            }))), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement((0, $5b1483fb7f067be1$export$eb2fcfdbd7ba97d4), {
                label: (0, $d5b6ce321475881f$export$21c51bc433c16634).labelColumnMapping
            }, (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("div", null, specCapabilities && specCapabilities.roles.map((specRole, i)=>{
                const specColumnInRole = props.insightColumns[specRole.role];
                const selectedColumnName = specColumnInRole;
                let disabledColumnName;
                let prefix;
                let suffix;
                let hideDropdown = false;
                let { totalStyle: totalStyle } = props;
                if (!totalStyle) totalStyle = 'count-square';
                let { facetStyle: facetStyle } = props;
                if (!facetStyle) facetStyle = 'wrap';
                switch(specRole.role){
                    case 'facet':
                        suffix = (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement((0, $8f56f1ed6ae42f13$export$931cbfb6bfb85fc), {
                            disabled: !props.insightColumns.facet,
                            collapseLabel: props.collapseLabels,
                            label: (0, $d5b6ce321475881f$export$21c51bc433c16634).labelFacetLayout,
                            calloutProps: {
                                style: {
                                    minWidth: '18em'
                                }
                            },
                            options: [
                                {
                                    key: 'header1',
                                    text: `${(0, $d5b6ce321475881f$export$21c51bc433c16634).labelFacetLayout}:`,
                                    itemType: (0, $a601a4135959dcb0$export$e2253033e6e1df16).fluentUI.DropdownMenuItemType.Header
                                },
                                ...$b4b5d5b480eaf9ae$var$singleFacetLayouts.map((f)=>{
                                    const o = {
                                        key: f.facetStyle,
                                        text: f.text,
                                        data: f,
                                        selected: facetStyle === f.facetStyle
                                    };
                                    return o;
                                }),
                                {
                                    key: 'divider',
                                    text: '-',
                                    itemType: (0, $a601a4135959dcb0$export$e2253033e6e1df16).fluentUI.DropdownMenuItemType.Divider
                                },
                                {
                                    key: 'header2',
                                    text: `${(0, $d5b6ce321475881f$export$21c51bc433c16634).labelColumnFacetV}:`,
                                    itemType: (0, $a601a4135959dcb0$export$e2253033e6e1df16).fluentUI.DropdownMenuItemType.Header
                                },
                                ...(0, $3ecc97321af8bbc8$export$c171b40a34e110b5)(Object.assign(Object.assign({}, props), {
                                    specRole: specRole,
                                    selectedColumnName: props.insightColumns.facetV
                                })).map((o)=>{
                                    if (o.itemType !== (0, $a601a4135959dcb0$export$e2253033e6e1df16).fluentUI.DropdownMenuItemType.Header) {
                                        const facetData = {
                                            facetStyle: 'cross',
                                            column: o.data
                                        };
                                        o.data = facetData;
                                        o.text = `${(0, $d5b6ce321475881f$export$21c51bc433c16634).labelFacetLayoutCross} ${o.text}`;
                                    }
                                    return o;
                                })
                            ],
                            onChange: (e, o)=>{
                                const facetData = o.data;
                                props.changeColumnMapping('facet', 'facet', null, {
                                    facetStyle: facetData.facetStyle
                                });
                                if (facetData.facetStyle === 'cross') props.changeColumnMapping('facetV', (0, $1342cf7df79546f0$exports).VegaMorphCharts.util.clone(facetData.column));
                            }
                        });
                        break;
                    case 'facetV':
                        hideDropdown = true;
                        break;
                    case 'size':
                        {
                            const options = [
                                {
                                    key: 'count-square',
                                    text: (0, $d5b6ce321475881f$export$21c51bc433c16634).labelTotalByCountSquare,
                                    data: 'count-square',
                                    selected: !totalStyle || totalStyle === 'count-square'
                                },
                                {
                                    key: 'count-strip',
                                    text: (0, $d5b6ce321475881f$export$21c51bc433c16634).labelTotalByCountStrip,
                                    data: 'count-strip',
                                    selected: totalStyle === 'count-strip'
                                },
                                {
                                    key: 'sum-strip',
                                    text: (0, $d5b6ce321475881f$export$21c51bc433c16634).labelTotalBySumStrip,
                                    data: 'sum-strip',
                                    selected: totalStyle === 'sum-strip'
                                },
                                {
                                    key: 'sum-treemap',
                                    text: (0, $d5b6ce321475881f$export$21c51bc433c16634).labelTotalBySumTreemap,
                                    data: 'sum-treemap',
                                    selected: totalStyle === 'sum-treemap',
                                    disabled: props.quantitativeColumns.length === 0
                                }
                            ];
                            if (specCapabilities.percentage) options.push({
                                key: 'sum-strip-percent',
                                text: (0, $d5b6ce321475881f$export$21c51bc433c16634).labelTotalBySumStripPercent,
                                data: 'sum-strip-percent',
                                selected: totalStyle === 'sum-strip-percent',
                                disabled: props.quantitativeColumns.length === 0
                            });
                            prefix = !specCapabilities.countsAndSums ? null : (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement((0, $8f56f1ed6ae42f13$export$931cbfb6bfb85fc), {
                                collapseLabel: props.collapseLabels,
                                label: (0, $d5b6ce321475881f$export$21c51bc433c16634).labelTotal,
                                calloutProps: {
                                    style: {
                                        minWidth: '18em'
                                    }
                                },
                                options: options,
                                onChange: (e, o)=>{
                                    const totalStyle = o.data;
                                    let defaultColumn;
                                    if (totalStyle.indexOf('sum-') === 0) {
                                        if (totalStyle === 'sum-treemap') defaultColumn = (0, $cdd6162a40e9c08a$export$7e0d3b5c6570ae8b)(props.allColumns);
                                        defaultColumn = defaultColumn || props.quantitativeColumns[0];
                                    }
                                    props.changeColumnMapping('size', 'size', defaultColumn, {
                                        totalStyle: totalStyle
                                    });
                                }
                            });
                            break;
                        }
                }
                const disabled = props.disabled || specRole.disabled || specRole.role === 'size' && !(!specCapabilities.countsAndSums || totalStyle.indexOf('sum-') === 0) || specRole.role === 'sort' && specCapabilities.countsAndSums && totalStyle === 'sum-treemap';
                return (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement((0, $3ecc97321af8bbc8$export$83b9e0badda50eeb), Object.assign({}, props, {
                    prefix: prefix,
                    suffix: suffix,
                    collapseLabel: props.collapseLabels,
                    disabled: disabled,
                    disabledColumnName: disabledColumnName,
                    selectedColumnName: selectedColumnName,
                    specRole: specRole,
                    key: i,
                    onChangeSignal: (name, value)=>props.onChangeSignal(specRole.role, selectedColumnName, name, value),
                    hideDropdown: hideDropdown
                }));
            }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement((0, $a601a4135959dcb0$export$e2253033e6e1df16).fluentUI.DefaultButton, {
                className: 'sanddance-chart-button',
                text: (0, $d5b6ce321475881f$export$21c51bc433c16634).buttonTooltipMapping,
                onClick: ()=>this.setState({
                        showTooltipDialog: true
                    })
            }))), hasOptions && (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement((0, $5b1483fb7f067be1$export$eb2fcfdbd7ba97d4), {
                label: (0, $d5b6ce321475881f$export$21c51bc433c16634).labelChartTypeOptions
            }, signals && signals.map((signal, i)=>(0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement((0, $00e2720d7006b5f2$export$8210dfe1863c478), {
                    key: i,
                    signal: signal,
                    explorer: explorer,
                    initialValue: (0, $00e2720d7006b5f2$export$d54e4e563d2a9303)(explorer, signal),
                    disabled: props.disabled || this.disableSignal(signal),
                    collapseLabel: props.collapseLabels,
                    newViewStateTarget: false
                })), (specCapabilities === null || specCapabilities === void 0 ? void 0 : specCapabilities.backgroundImage) && (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement((0, $a601a4135959dcb0$export$e2253033e6e1df16).fluentUI.DefaultButton, {
                className: 'sanddance-chart-button',
                text: (0, $d5b6ce321475881f$export$21c51bc433c16634).buttonBackgroundImage,
                onClick: ()=>{
                    let insightColumns;
                    switch(props.chart){
                        case 'scatterplot':
                        case 'stacks':
                            insightColumns = props.insightColumns;
                            break;
                    }
                    if (!insightColumns) insightColumns = props.explorer.changeChartType('scatterplot');
                    this.backgroundImageEditor.show(insightColumns);
                }
            })), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement((0, $f4b615ab5c14d90e$export$3ddf2d174ce01153), {
                hidden: !this.state.showTooltipDialog,
                onDismiss: ()=>this.setState({
                        showTooltipDialog: false
                    }),
                title: (0, $d5b6ce321475881f$export$21c51bc433c16634).labelTooltipMapping
            }, (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement((0, $2ec5b051a3376e1a$export$ce08aabc421980f4), {
                allColumns: props.allColumns,
                exclusions: props.tooltipExclusions,
                toggleExclusion: props.toggleTooltipExclusion
            })), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement((0, $15c8a952544b8f28$export$5696019163aa3cca), Object.assign({}, props, {
                ref: (e)=>this.backgroundImageEditor = e
            })));
        }
        disableSignal(signal) {
            if (this.props.view === '2d' && signal.name === (0, $1342cf7df79546f0$exports).constants.SignalNames.ZGrounded) return true;
            return false;
        }
    }
    return new __Chart(_props);
}
const $b4b5d5b480eaf9ae$export$acaa6426d77a227e = $b4b5d5b480eaf9ae$var$_Chart;


/*!
* Copyright (c) Microsoft Corporation.
* Licensed under the MIT License.
*/ /*!
* Copyright (c) Microsoft Corporation.
* Licensed under the MIT License.
*/ 
/*!
* Copyright (c) Microsoft Corporation.
* Licensed under the MIT License.
*/ 
function $4b388f5c1e44e369$export$2c73285ae9390cec(props) {
    return (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement((0, $a601a4135959dcb0$export$e2253033e6e1df16).fluentUI.TextField, Object.assign({
        onKeyUp: (e)=>{
            e.nativeEvent.stopImmediatePropagation();
        }
    }, props));
}




const $420fc835a380b3a6$export$210195f4ae250f0a = 100;
function $420fc835a380b3a6$export$c2b32f315f251228(column) {
    const type = column && column.type;
    switch(type){
        case 'boolean':
            return [
                [
                    '==',
                    (0, $d5b6ce321475881f$export$21c51bc433c16634).searchEQ
                ],
                [
                    '!=',
                    (0, $d5b6ce321475881f$export$21c51bc433c16634).searchNEQ
                ],
                [
                    'isnullorEmpty',
                    (0, $d5b6ce321475881f$export$21c51bc433c16634).searchNULL
                ]
            ];
        case 'date':
        case 'integer':
        case 'number':
            return [
                [
                    '==',
                    (0, $d5b6ce321475881f$export$21c51bc433c16634).searchEQ
                ],
                [
                    '!=',
                    (0, $d5b6ce321475881f$export$21c51bc433c16634).searchNEQ
                ],
                [
                    '>',
                    (0, $d5b6ce321475881f$export$21c51bc433c16634).searchGT
                ],
                [
                    '>=',
                    (0, $d5b6ce321475881f$export$21c51bc433c16634).searchGTE
                ],
                [
                    '<',
                    (0, $d5b6ce321475881f$export$21c51bc433c16634).searchLT
                ],
                [
                    '<=',
                    (0, $d5b6ce321475881f$export$21c51bc433c16634).searchLTE
                ],
                [
                    'isnullorEmpty',
                    (0, $d5b6ce321475881f$export$21c51bc433c16634).searchNULL
                ]
            ];
        case 'string':
        default:
            return [
                [
                    '==',
                    (0, $d5b6ce321475881f$export$21c51bc433c16634).searchEQ
                ],
                [
                    '!=',
                    (0, $d5b6ce321475881f$export$21c51bc433c16634).searchNEQ
                ],
                [
                    '>',
                    (0, $d5b6ce321475881f$export$21c51bc433c16634).searchGT
                ],
                [
                    '>=',
                    (0, $d5b6ce321475881f$export$21c51bc433c16634).searchGTE
                ],
                [
                    '<',
                    (0, $d5b6ce321475881f$export$21c51bc433c16634).searchLT
                ],
                [
                    '<=',
                    (0, $d5b6ce321475881f$export$21c51bc433c16634).searchLTE
                ],
                [
                    'contains',
                    (0, $d5b6ce321475881f$export$21c51bc433c16634).searchIN
                ],
                [
                    'starts',
                    (0, $d5b6ce321475881f$export$21c51bc433c16634).searchSW
                ],
                [
                    'isnullorEmpty',
                    (0, $d5b6ce321475881f$export$21c51bc433c16634).searchNULL
                ]
            ];
    }
}
function $420fc835a380b3a6$var$getExpressionClauses(currClause, disableOR) {
    const keys = [
        [
            '&&',
            (0, $d5b6ce321475881f$export$21c51bc433c16634).searchAND
        ]
    ];
    if (!disableOR) keys.push([
        '||',
        (0, $d5b6ce321475881f$export$21c51bc433c16634).searchOR
    ]);
    return keys.map((key, i)=>{
        const [clause, text] = key;
        const selected = currClause == clause; //deliberate double equal 
        const option = {
            key: i,
            text: text,
            data: clause,
            selected: selected
        };
        return option;
    });
}
function $420fc835a380b3a6$var$getOperators(ex, column) {
    let anySelected = false;
    const validOperators = $420fc835a380b3a6$export$c2b32f315f251228(column);
    const options = validOperators.map((validoperator)=>{
        const [op, text] = validoperator;
        const selected = ex.operator === op;
        anySelected = anySelected || selected;
        const option = {
            key: op,
            text: text,
            data: op,
            selected: selected
        };
        return option;
    });
    if (!anySelected) options[0].selected = true;
    return options;
}
function $420fc835a380b3a6$var$getDistinctValues(data, columnName) {
    const distinctMap = {};
    for(let i = 0; i < data.length; i++){
        const row = data[i];
        const value = row[columnName];
        distinctMap[value] = true;
    }
    return Object.keys(distinctMap).sort();
}
function $420fc835a380b3a6$var$getValues(ex, column, data, autoCompleteDistinctValues) {
    const stats = column && column.stats;
    if (stats && stats.distinctValueCount < $420fc835a380b3a6$export$210195f4ae250f0a) {
        if (!autoCompleteDistinctValues[column.name]) autoCompleteDistinctValues[column.name] = $420fc835a380b3a6$var$getDistinctValues(data, column.name);
        return autoCompleteDistinctValues[column.name].map((v, i)=>({
                key: i,
                text: v
            }));
    }
    return [];
}
function $420fc835a380b3a6$export$c72d34660a162238(ex) {
    if (ex.operator === 'isnullorEmpty') return '';
    return typeof ex.value === 'string' ? ex.value : ex.value == null ? '' : ex.value.toString();
}
function $420fc835a380b3a6$export$793106cac50ab579(props) {
    const ex = props.searchExpression;
    const possibleValues = $420fc835a380b3a6$var$getValues(ex, props.column, props.data, props.autoCompleteDistinctValues);
    //TODO better date handling with calendar picker
    return (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("div", null, props.index > 0 && (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement((0, $8f56f1ed6ae42f13$export$931cbfb6bfb85fc), {
        collapseLabel: props.collapseLabels,
        className: "search-field",
        label: (0, $d5b6ce321475881f$export$21c51bc433c16634).labelSearchClause,
        dropdownWidth: 120,
        disabled: !ex.unlocked || props.disableOR,
        options: $420fc835a380b3a6$var$getExpressionClauses(ex.clause, props.disableOR),
        onChange: (e, o)=>props.onUpdateExpression({
                clause: o.data
            }, props.index)
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement((0, $8f56f1ed6ae42f13$export$931cbfb6bfb85fc), {
        componentRef: props.dropdownRef,
        collapseLabel: props.collapseLabels,
        className: "search-field",
        label: (0, $d5b6ce321475881f$export$21c51bc433c16634).labelSearchColumn,
        options: [
            {
                key: '',
                text: (0, $d5b6ce321475881f$export$21c51bc433c16634).selectAny,
                data: null,
                selected: ex.name === null
            }
        ].concat(props.columns.map((c, i)=>({
                key: c.name,
                text: c.name,
                data: c,
                selected: c.name === ex.name
            }))),
        onChange: (e, o)=>props.onUpdateExpression({
                name: o.data && o.data.name || null
            }, props.index)
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement((0, $8f56f1ed6ae42f13$export$931cbfb6bfb85fc), {
        collapseLabel: props.collapseLabels,
        className: "search-field",
        label: (0, $d5b6ce321475881f$export$21c51bc433c16634).labelSearchOperator,
        dropdownWidth: 120,
        options: $420fc835a380b3a6$var$getOperators(ex, props.column),
        onChange: (e, o)=>props.onUpdateExpression({
                operator: o.data
            }, props.index)
    }), possibleValues.length > 0 && (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement((0, $a601a4135959dcb0$export$e2253033e6e1df16).fluentUI.ComboBox, {
        className: "search-field",
        label: props.collapseLabels ? null : (0, $d5b6ce321475881f$export$21c51bc433c16634).labelSearchValue,
        placeholder: (0, $d5b6ce321475881f$export$21c51bc433c16634).labelSearchValuePlaceholder,
        disabled: ex.operator === 'isnullorEmpty',
        dropdownWidth: (0, $8f56f1ed6ae42f13$export$8263e1ed1ef30f07),
        allowFreeform: true,
        autoComplete: "on",
        errorMessage: ex.errorMessage,
        text: $420fc835a380b3a6$export$c72d34660a162238(ex),
        options: $420fc835a380b3a6$var$getValues(ex, props.column, props.data, props.autoCompleteDistinctValues),
        onChange: (e, o, i, value)=>{
            if (o) value = o.text;
            props.onUpdateExpression({
                value: value
            }, props.index);
        }
    }), possibleValues.length === 0 && (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement((0, $4b388f5c1e44e369$export$2c73285ae9390cec), {
        className: "search-field",
        label: props.collapseLabels ? null : (0, $d5b6ce321475881f$export$21c51bc433c16634).labelSearchValue,
        placeholder: (0, $d5b6ce321475881f$export$21c51bc433c16634).labelSearchValuePlaceholder,
        disabled: ex.operator === 'isnullorEmpty',
        errorMessage: ex.errorMessage,
        value: $420fc835a380b3a6$export$c72d34660a162238(ex),
        onChange: (e, v)=>props.onUpdateExpression({
                value: v
            }, props.index)
    }));
}



/*!
* Copyright (c) Microsoft Corporation.
* Licensed under the MIT License.
*/ 
function $f9294a04a77df05a$export$353f5b6fc5456de1(props) {
    return (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement((0, $a601a4135959dcb0$export$e2253033e6e1df16).fluentUI.DefaultButton, Object.assign({}, props, {
        styles: {
            root: Object.assign({
                backgroundColor: 'transparent',
                height: '30px',
                width: props.width,
                padding: 0
            }, props.rootStyle),
            rootDisabled: {
                backgroundColor: 'transparent'
            },
            icon: {
                color: props.themePalette.themePrimary
            },
            label: {
                fontWeight: '400',
                textAlign: props.textAlign || 'left'
            }
        },
        iconProps: {
            iconName: props.iconName
        }
    }));
}






const $7c89aab16f679c36$var$maxClauses = 5;
function $7c89aab16f679c36$var$getColumnWithName(columnName, columns) {
    for(let i = 0; i < columns.length; i++){
        if (columns[i].name === columnName) return columns[i];
    }
}
function $7c89aab16f679c36$var$validateExpression(ex) {
    if (ex.operator === 'isnullorEmpty') {
        ex.errorMessage = null;
        return;
    }
    const s = (0, $420fc835a380b3a6$export$c72d34660a162238)(ex);
    if (s.length === 0) ex.errorMessage = (0, $d5b6ce321475881f$export$21c51bc433c16634).labelRequired;
    else ex.errorMessage = null;
}
function $7c89aab16f679c36$var$clearExpressionValidation(ex) {
    if (ex.operator === 'isnullorEmpty') {
        ex.errorMessage = null;
        return;
    }
    const s = (0, $420fc835a380b3a6$export$c72d34660a162238)(ex);
    if (s.length !== 0) ex.errorMessage = null;
}
function $7c89aab16f679c36$var$getGroupClauses(currClause, index, disableGroupOR) {
    let keys;
    if (index === 0) keys = [
        [
            null,
            (0, $d5b6ce321475881f$export$21c51bc433c16634).searchWHERE
        ]
    ];
    else {
        keys = [
            [
                '&&',
                (0, $d5b6ce321475881f$export$21c51bc433c16634).searchAND
            ]
        ];
        if (!disableGroupOR) keys.push([
            '||',
            (0, $d5b6ce321475881f$export$21c51bc433c16634).searchOR
        ]);
    }
    return keys.map((key, i)=>{
        const [clause, text] = key;
        const selected = currClause == clause; //deliberate double equal 
        const option = {
            key: i,
            text: text,
            data: clause,
            selected: selected
        };
        return option;
    });
}
function $7c89aab16f679c36$var$_Search(_props) {
    class __Search extends (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.Component {
        constructor(props){
            super(props);
            this.state = this.getInitialState(this.props);
            this.dropdownRef = (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createRef();
            props.explorer.dialogFocusHandler.focus = ()=>{
                var _a;
                return (_a = this.dropdownRef.current) === null || _a === void 0 ? void 0 : _a.focus();
            };
        }
        getInitialState(props) {
            const initialState = {
                groups: props.initializer.search || [
                    this.newGroup(0, null)
                ],
                sortedColumns: [
                    ...props.initializer.columns
                ].sort((a, b)=>a.name.localeCompare(b.name)),
                initializer: props.initializer
            };
            initialState.groups.forEach((group)=>{
                group.expressions.forEach((ex)=>ex.unlocked = group.expressions.length <= 2);
            });
            return initialState;
        }
        componentDidUpdate() {
            if (!(0, $e295d8097c1ad61a$exports).deepCompare(this.props.initializer, this.state.initializer)) this.setState(this.getInitialState(this.props));
        }
        validateAndSearch() {
            const groups = [
                ...this.state.groups
            ];
            groups.forEach((group)=>{
                group.expressions.forEach($7c89aab16f679c36$var$validateExpression);
                const errors = group.expressions.reduce((p, c)=>p || c.errorMessage, '');
                if (errors) this.setState({
                    groups: groups
                });
                else this.props.onSelect(this.state.groups);
            });
        }
        newGroup(key, clause) {
            const group = {
                key: key,
                clause: clause,
                expressions: [
                    this.newExpression(0, null)
                ]
            };
            return group;
        }
        updateGroup(partialGroup, groupIndex) {
            const groups = [
                ...this.state.groups
            ];
            const group = Object.assign(Object.assign({}, groups[groupIndex]), partialGroup);
            groups[groupIndex] = group;
            this.setState({
                groups: groups
            });
        }
        addGroup() {
            const groups = [
                ...this.state.groups
            ];
            const maxKey = groups.reduce((max, p)=>p.key > max ? p.key : max, groups[0].key);
            const newGroup = this.newGroup(maxKey + 1, '&&');
            groups.push(newGroup);
            this.setState({
                groups: groups
            });
        }
        deleteGroup(groupIndex) {
            const groups = [
                ...this.state.groups
            ];
            groups.splice(groupIndex, 1);
            this.setState({
                groups: groups
            });
        }
        newExpression(key, clause) {
            const ex = {
                key: key,
                clause: clause,
                name: null,
                operator: 'contains',
                value: ''
            };
            return ex;
        }
        addExpression(groupIndex) {
            const groups = [
                ...this.state.groups
            ];
            const group = groups[groupIndex];
            const maxKey = group.expressions.reduce((max, p)=>p.key > max ? p.key : max, group.expressions[0].key);
            const newEx = this.newExpression(maxKey + 1, '&&');
            group.expressions.push(newEx);
            if (group.expressions.length === 2) newEx.unlocked = true;
            else {
                group.expressions.forEach((ex)=>ex.unlocked = false);
                newEx.clause = group.expressions[1].clause;
            }
            this.setState({
                groups: groups
            });
        }
        updateExpression(partialEx, groupIndex, index) {
            const groups = [
                ...this.state.groups
            ];
            const group = groups[groupIndex];
            const ex = (0, $1342cf7df79546f0$exports).VegaMorphCharts.util.clone(group.expressions[index]);
            if (ex.name !== partialEx.name) {
                //choose an appropriate operator when switching data type
                const oldColumn = $7c89aab16f679c36$var$getColumnWithName(ex.name, this.state.sortedColumns);
                const newColumn = $7c89aab16f679c36$var$getColumnWithName(partialEx.name, this.state.sortedColumns);
                const oldType = oldColumn && oldColumn.type;
                const newType = newColumn && newColumn.type;
                if (oldType !== newType) {
                    const newOperators = (0, $420fc835a380b3a6$export$c2b32f315f251228)(newColumn).map((validOperator)=>validOperator[0]);
                    //see if old operator is compatible
                    if (newOperators.indexOf(ex.operator) < 0) //not compatible, so choose "equal"
                    partialEx.operator = '==';
                }
            }
            Object.assign(ex, partialEx);
            $7c89aab16f679c36$var$clearExpressionValidation(ex);
            group.expressions[index] = ex;
            this.setState({
                groups: groups
            });
        }
        deleteExpression(groupIndex, index) {
            const groups = [
                ...this.state.groups
            ];
            const group = groups[groupIndex];
            const expressions = [
                ...group.expressions
            ];
            expressions.splice(index, 1);
            if (expressions.length === 2) expressions[1].unlocked = true;
            group.expressions = expressions;
            this.setState({
                groups: groups
            });
        }
        render() {
            return (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement((0, $5b1483fb7f067be1$export$eb2fcfdbd7ba97d4), {
                className: "sanddance-search",
                label: (0, $d5b6ce321475881f$export$21c51bc433c16634).labelSearch
            }, (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("div", null, this.state.groups.map((group, groupIndex)=>(0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("div", {
                    className: "sanddance-search-group",
                    key: group.key
                }, (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement((0, $8f56f1ed6ae42f13$export$931cbfb6bfb85fc), {
                    collapseLabel: this.props.collapseLabels,
                    className: "search-group-clause",
                    label: (0, $d5b6ce321475881f$export$21c51bc433c16634).labelSearchClause,
                    disabled: groupIndex === 0 || this.props.disableGroupOR,
                    dropdownWidth: 120,
                    options: $7c89aab16f679c36$var$getGroupClauses(group.clause, groupIndex, this.props.disableGroupOR),
                    onChange: (e, o)=>this.updateGroup({
                            clause: o.data
                        }, groupIndex)
                }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("div", null, group.expressions.map((ex, i)=>(0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("div", {
                        className: "sanddance-search-expression",
                        key: ex.key
                    }, (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement((0, $420fc835a380b3a6$export$793106cac50ab579), {
                        dropdownRef: groupIndex === 0 && i === 0 ? this.dropdownRef : undefined,
                        collapseLabels: this.props.collapseLabels,
                        onUpdateExpression: (ex, i)=>this.updateExpression(ex, groupIndex, i),
                        autoCompleteDistinctValues: this.props.autoCompleteDistinctValues,
                        index: i,
                        columns: this.state.sortedColumns,
                        data: this.props.data,
                        searchExpression: ex,
                        disableOR: this.props.disableExpressionOR,
                        column: $7c89aab16f679c36$var$getColumnWithName(ex.name, this.state.sortedColumns)
                    }), group.expressions.length > 1 && (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement((0, $f9294a04a77df05a$export$353f5b6fc5456de1), {
                        themePalette: this.props.themePalette,
                        className: "search-action",
                        iconName: "Cancel",
                        onClick: ()=>this.deleteExpression(groupIndex, i),
                        text: (0, $d5b6ce321475881f$export$21c51bc433c16634).buttonDeleteExpression
                    })))), group.expressions.length < $7c89aab16f679c36$var$maxClauses && (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("div", null, (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement((0, $f9294a04a77df05a$export$353f5b6fc5456de1), {
                    themePalette: this.props.themePalette,
                    className: "search-action",
                    iconName: "Add",
                    onClick: ()=>this.addExpression(groupIndex),
                    text: (0, $d5b6ce321475881f$export$21c51bc433c16634).buttonAddExpression
                })), this.state.groups.length > 1 && (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement((0, $f9294a04a77df05a$export$353f5b6fc5456de1), {
                    themePalette: this.props.themePalette,
                    className: "search-action",
                    iconName: "Cancel",
                    onClick: ()=>this.deleteGroup(groupIndex),
                    text: (0, $d5b6ce321475881f$export$21c51bc433c16634).buttonDeleteExpressionGroup
                }))), this.state.groups.length < $7c89aab16f679c36$var$maxClauses && (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("div", null, (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement((0, $f9294a04a77df05a$export$353f5b6fc5456de1), {
                themePalette: this.props.themePalette,
                className: "search-action search-bottom-action",
                iconName: "Add",
                onClick: ()=>this.addGroup(),
                text: (0, $d5b6ce321475881f$export$21c51bc433c16634).buttonAddExpressionGroup
            }))), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement((0, $a601a4135959dcb0$export$e2253033e6e1df16).fluentUI.PrimaryButton, {
                className: "search-action search-bottom-action",
                text: (0, $d5b6ce321475881f$export$21c51bc433c16634).buttonSelect,
                onClick: ()=>this.validateAndSearch()
            }));
        }
    }
    return new __Search(_props);
}
const $7c89aab16f679c36$export$4b85d3515bd863a5 = $7c89aab16f679c36$var$_Search;


/*!
* Copyright (c) Microsoft Corporation.
* Licensed under the MIT License.
*/ 


var $4293b5c02e7b8c3d$var$PresenterElement = (0, $1342cf7df79546f0$exports).VegaMorphCharts.PresenterElement;
function $4293b5c02e7b8c3d$export$f80a6900d44a74ee(viewer) {
    const tags = viewer.presenter.getElement($4293b5c02e7b8c3d$var$PresenterElement.gl).getElementsByTagName('canvas');
    if (tags) return tags[0];
}
function $4293b5c02e7b8c3d$export$95ea862e038e2d34(viewer) {
    const canvas = $4293b5c02e7b8c3d$export$f80a6900d44a74ee(viewer);
    if (canvas) canvas.tabIndex = -1;
}
const $4293b5c02e7b8c3d$export$8e76ac9f37578d1b = {
    webgl: !!document.createElement('canvas').getContext('webgl'),
    webgl2: !!document.createElement('canvas').getContext('webgl2')
};







/*!
* Copyright (c) Microsoft Corporation.
* Licensed under the MIT License.
*/ const $ce16cf456563b677$export$83d89fbfd8236492 = '4.1.8';


var $e46ab1f70cbc9878$var$SandDance = $1342cf7df79546f0$exports;
var $e46ab1f70cbc9878$var$DataRefType;
(function(DataRefType) {
    DataRefType[DataRefType["none"] = 0] = "none";
    DataRefType[DataRefType["inline"] = 1] = "inline";
    DataRefType[DataRefType["url"] = 2] = "url";
})($e46ab1f70cbc9878$var$DataRefType || ($e46ab1f70cbc9878$var$DataRefType = {}));
function $e46ab1f70cbc9878$var$filterSignals(signal) {
    switch(signal.name){
        case $e46ab1f70cbc9878$var$SandDance.constants.SignalNames.XBins:
        case $e46ab1f70cbc9878$var$SandDance.constants.SignalNames.YBins:
        case $e46ab1f70cbc9878$var$SandDance.constants.SignalNames.FacetBins:
        case $e46ab1f70cbc9878$var$SandDance.constants.SignalNames.FacetVBins:
        case $e46ab1f70cbc9878$var$SandDance.constants.SignalNames.ColorBinCount:
        case $e46ab1f70cbc9878$var$SandDance.constants.SignalNames.ColorReverse:
        case $e46ab1f70cbc9878$var$SandDance.constants.SignalNames.PointScale:
        case $e46ab1f70cbc9878$var$SandDance.constants.SignalNames.TreeMapMethod:
        case $e46ab1f70cbc9878$var$SandDance.constants.SignalNames.ZGrounded:
            return false;
        default:
            return !!signal.bind;
    }
}
function $e46ab1f70cbc9878$var$cloneData(vegaSpec) {
    const data0 = vegaSpec.data[0];
    const valuesData = data0;
    const values = valuesData.values;
    delete valuesData.values;
    const data = $e46ab1f70cbc9878$var$SandDance.VegaMorphCharts.util.clone(vegaSpec.data);
    valuesData.values = values;
    return {
        data: data,
        values: values
    };
}
function $e46ab1f70cbc9878$var$cloneScales(vegaSpec) {
    return $e46ab1f70cbc9878$var$SandDance.VegaMorphCharts.util.clone(vegaSpec.scales);
}
function $e46ab1f70cbc9878$var$serializeSpec(vegaSpec, datafile, dataRefType, transform, scheme) {
    const scales = $e46ab1f70cbc9878$var$cloneScales(vegaSpec);
    const colorScale = scales.filter((scale)=>scale.name === $e46ab1f70cbc9878$var$SandDance.constants.ScaleNames.Color)[0];
    if (scheme.indexOf('dual_') >= 0) colorScale.range = $e46ab1f70cbc9878$var$SandDance.colorSchemes.filter((cs)=>cs.scheme === scheme)[0].colors;
    const clone = $e46ab1f70cbc9878$var$cloneData(vegaSpec);
    const data0 = clone.data[0];
    if (dataRefType === $e46ab1f70cbc9878$var$DataRefType.inline) {
        const valuesData = data0;
        valuesData.format = {
            parse: 'auto',
            type: 'json'
        };
        valuesData.values = clone.values;
    } else if (dataRefType === $e46ab1f70cbc9878$var$DataRefType.none) {
        const valuesData = data0;
        valuesData.values = [];
        if (transform) {
            if (valuesData.transform) valuesData.transform.push.apply(valuesData.transform, transform);
            else valuesData.transform = transform;
        }
    } else if (dataRefType === $e46ab1f70cbc9878$var$DataRefType.url) {
        const urlData = data0;
        urlData.url = datafile.dataUrl;
        urlData.format = {
            parse: 'auto',
            type: datafile.type
        };
        if (transform) {
            if (urlData.transform) urlData.transform.push.apply(urlData.transform, transform);
            else urlData.transform = transform;
        }
    }
    return Object.assign(Object.assign({}, vegaSpec), {
        data: clone.data,
        scales: scales
    });
}
function $e46ab1f70cbc9878$var$defaultDataRefType(datafile) {
    if (datafile.dataUrl) return $e46ab1f70cbc9878$var$DataRefType.url;
    return $e46ab1f70cbc9878$var$DataRefType.none;
}
function $e46ab1f70cbc9878$var$initState(props) {
    return {
        showSystemDialog: false,
        showVegaDialog: false,
        dataRefType: $e46ab1f70cbc9878$var$defaultDataRefType(props.dataFile),
        spec: null
    };
}
function $e46ab1f70cbc9878$var$signalGroupKey(key) {
    for(let i = 0; i < (0, $d5b6ce321475881f$export$21c51bc433c16634).signalGroups.length; i++){
        if ((0, $d5b6ce321475881f$export$21c51bc433c16634).signalGroups[i].prefix === key) return key;
    }
    return '*';
}
function $e46ab1f70cbc9878$var$vegaSignalGroups(vegaSignals) {
    const signalGroupMap = {};
    vegaSignals.forEach((vs)=>{
        const split = vs.name.split('_');
        const key = $e46ab1f70cbc9878$var$signalGroupKey(split[0]);
        signalGroupMap[key] = signalGroupMap[key] || [];
        signalGroupMap[key].push(vs);
    });
    return signalGroupMap;
}
function $e46ab1f70cbc9878$var$_Settings(_props) {
    class __Settings extends (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.Component {
        constructor(props){
            super(props);
            this.state = $e46ab1f70cbc9878$var$initState(props);
        }
        render() {
            const { props: props, state: state } = this;
            if (!props.explorer.viewer || !props.explorer.viewer.vegaSpec) return null;
            const options = [
                {
                    key: $e46ab1f70cbc9878$var$DataRefType.none,
                    text: (0, $d5b6ce321475881f$export$21c51bc433c16634).selectVegaSpecDataNone,
                    selected: this.state.dataRefType === $e46ab1f70cbc9878$var$DataRefType.none,
                    data: $e46ab1f70cbc9878$var$DataRefType.none
                },
                !props.dataFile.rawText && {
                    key: $e46ab1f70cbc9878$var$DataRefType.url,
                    text: (0, $d5b6ce321475881f$export$21c51bc433c16634).selectVegaSpecDataUrl,
                    selected: this.state.dataRefType === $e46ab1f70cbc9878$var$DataRefType.url,
                    data: $e46ab1f70cbc9878$var$DataRefType.url
                },
                {
                    key: $e46ab1f70cbc9878$var$DataRefType.inline,
                    text: (0, $d5b6ce321475881f$export$21c51bc433c16634).selectVegaSpecDataInline,
                    selected: this.state.dataRefType === $e46ab1f70cbc9878$var$DataRefType.inline,
                    data: $e46ab1f70cbc9878$var$DataRefType.inline
                }
            ].filter(Boolean);
            const signalGroupMap = $e46ab1f70cbc9878$var$vegaSignalGroups(props.explorer.viewer.vegaSpec.signals);
            let first = true;
            return (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("div", null, (0, $d5b6ce321475881f$export$21c51bc433c16634).signalGroups.map((sg, gi)=>{
                const vegaSignals = signalGroupMap[sg.prefix];
                if (vegaSignals) {
                    const filteredVegaSignals = vegaSignals.filter($e46ab1f70cbc9878$var$filterSignals);
                    if (filteredVegaSignals.length > 0) return (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement((0, $5b1483fb7f067be1$export$eb2fcfdbd7ba97d4), {
                        key: sg.prefix,
                        label: sg.label
                    }, filteredVegaSignals.map((signal, i)=>{
                        const ref = (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createRef();
                        if (first) {
                            first = false;
                            props.explorer.dialogFocusHandler.focus = ()=>{
                                const f = ref.current;
                                if (f === null || f === void 0 ? void 0 : f.focus) f.focus();
                            };
                        }
                        return (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement((0, $00e2720d7006b5f2$export$8210dfe1863c478), {
                            componentRef: ref,
                            key: i,
                            signal: signal,
                            explorer: props.explorer,
                            initialValue: (0, $00e2720d7006b5f2$export$d54e4e563d2a9303)(props.explorer, signal),
                            newViewStateTarget: false
                        });
                    }));
                }
            }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement((0, $5b1483fb7f067be1$export$eb2fcfdbd7ba97d4), {
                label: (0, $d5b6ce321475881f$export$21c51bc433c16634).labelChartCanvas
            }, (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement((0, $a601a4135959dcb0$export$e2253033e6e1df16).fluentUI.Toggle, {
                label: (0, $d5b6ce321475881f$export$21c51bc433c16634).labelShowAxes,
                defaultChecked: !props.hideAxes,
                onChange: (e, checked)=>props.onToggleAxes(!checked)
            }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement((0, $a601a4135959dcb0$export$e2253033e6e1df16).fluentUI.Toggle, {
                label: (0, $d5b6ce321475881f$export$21c51bc433c16634).labelShowLegend,
                defaultChecked: !props.hideLegend,
                onChange: (e, checked)=>props.onToggleLegend(!checked)
            })), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement((0, $5b1483fb7f067be1$export$eb2fcfdbd7ba97d4), {
                label: (0, $d5b6ce321475881f$export$21c51bc433c16634).labelTools
            }, (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement((0, $a601a4135959dcb0$export$e2253033e6e1df16).fluentUI.DefaultButton, {
                text: (0, $d5b6ce321475881f$export$21c51bc433c16634).buttonShowVegaSpec,
                onClick: ()=>this.setState({
                        showVegaDialog: true,
                        spec: $e46ab1f70cbc9878$var$serializeSpec(props.explorer.viewer.vegaSpec, props.dataFile, this.state.dataRefType, props.explorer.viewer.getInsight().transform, this.props.scheme)
                    })
            })), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement((0, $5b1483fb7f067be1$export$eb2fcfdbd7ba97d4), {
                label: (0, $d5b6ce321475881f$export$21c51bc433c16634).labelSnapshots
            }, (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement((0, $a601a4135959dcb0$export$e2253033e6e1df16).fluentUI.Slider, {
                label: (0, $d5b6ce321475881f$export$21c51bc433c16634).labelSnapshotSettingThumbnailWidth,
                onChange: (value)=>{
                    this.props.explorer.snapshotThumbWidth = value;
                },
                min: 100,
                max: 800,
                defaultValue: this.props.explorer.snapshotThumbWidth
            })), props.additionalSettings && props.additionalSettings.map((g, i)=>(0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement((0, $5b1483fb7f067be1$export$eb2fcfdbd7ba97d4), {
                    key: i,
                    label: g.groupLabel
                }, g.children)), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement((0, $5b1483fb7f067be1$export$eb2fcfdbd7ba97d4), {
                label: (0, $d5b6ce321475881f$export$21c51bc433c16634).labelSystem
            }, (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement((0, $a601a4135959dcb0$export$e2253033e6e1df16).fluentUI.DefaultButton, {
                text: (0, $d5b6ce321475881f$export$21c51bc433c16634).labelSystemInfo,
                onClick: ()=>this.setState({
                        showSystemDialog: true
                    })
            })), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement((0, $f4b615ab5c14d90e$export$3ddf2d174ce01153), {
                hidden: !state.showVegaDialog,
                onDismiss: ()=>this.setState($e46ab1f70cbc9878$var$initState(this.props)),
                minWidth: "80%",
                title: (0, $d5b6ce321475881f$export$21c51bc433c16634).labelVegaSpec,
                buttons: [
                    (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement((0, $a601a4135959dcb0$export$e2253033e6e1df16).fluentUI.PrimaryButton, {
                        key: "copy",
                        iconProps: {
                            iconName: 'Copy'
                        },
                        text: (0, $d5b6ce321475881f$export$21c51bc433c16634).buttonCopyToClipboard,
                        onClick: ()=>{
                            const pre = document.getElementById('sanddance-vega-spec');
                            const range = document.createRange();
                            range.selectNode(pre);
                            const selection = window.getSelection();
                            selection.removeAllRanges();
                            selection.addRange(range);
                            document.execCommand('copy');
                        }
                    }),
                    (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement((0, $a601a4135959dcb0$export$e2253033e6e1df16).fluentUI.DefaultButton, {
                        key: "edit",
                        iconProps: {
                            iconName: 'OpenInNewWindow'
                        },
                        text: (0, $d5b6ce321475881f$export$21c51bc433c16634).buttonLaunchVegaEditor,
                        onClick: ()=>{
                            window.open('https://vega.github.io/editor/', '_blank');
                        }
                    })
                ]
            }, (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement((0, $8f56f1ed6ae42f13$export$931cbfb6bfb85fc), {
                label: (0, $d5b6ce321475881f$export$21c51bc433c16634).labelVegaSpecData,
                options: options,
                onChange: (e, o)=>this.setState({
                        dataRefType: o.data,
                        spec: $e46ab1f70cbc9878$var$serializeSpec(props.explorer.viewer.vegaSpec, props.dataFile, o.data, props.explorer.viewer.getInsight().transform, this.props.scheme)
                    })
            }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("pre", {
                id: "sanddance-vega-spec"
            }, JSON.stringify(this.state.spec, null, 2)), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("div", null, (0, $d5b6ce321475881f$export$21c51bc433c16634).labelVegaSpecNotes)), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement((0, $f4b615ab5c14d90e$export$3ddf2d174ce01153), {
                hidden: !state.showSystemDialog,
                onDismiss: ()=>this.setState($e46ab1f70cbc9878$var$initState(this.props)),
                title: (0, $d5b6ce321475881f$export$21c51bc433c16634).labelSystemInfo
            }, (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("ul", null, this.props.children, (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("li", null, "SandDanceExplorer version: ", (0, $ce16cf456563b677$export$83d89fbfd8236492)), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("li", null, "SandDanceReact version: ", $d76008c8107bb02f$export$83d89fbfd8236492), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("li", null, "SandDance version: ", $e46ab1f70cbc9878$var$SandDance.version), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("li", null, "Vega-MorphCharts version: ", $e46ab1f70cbc9878$var$SandDance.VegaMorphCharts.version), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("li", null, "WebGL enabled: ", (0, $4293b5c02e7b8c3d$export$8e76ac9f37578d1b).webgl ? (0, $d5b6ce321475881f$export$21c51bc433c16634).labelYes : (0, $d5b6ce321475881f$export$21c51bc433c16634).labelNo), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("li", null, "WebGL2 enabled: ", (0, $4293b5c02e7b8c3d$export$8e76ac9f37578d1b).webgl2 ? (0, $d5b6ce321475881f$export$21c51bc433c16634).labelYes : (0, $d5b6ce321475881f$export$21c51bc433c16634).labelNo))));
        }
    }
    return new __Settings(_props);
}
const $e46ab1f70cbc9878$export$c72f6eaae7b9adff = $e46ab1f70cbc9878$var$_Settings;


/*!
* Copyright (c) Microsoft Corporation.
* Licensed under the MIT License.
*/ 




function $e07b04fee87ea13f$var$_SnapshotEditor(_props) {
    class __SnapshotEditor extends (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.Component {
        constructor(props){
            super(props);
            this.state = {
                showEditFormDialog: false,
                title: '',
                description: '',
                image: null,
                bgColor: null,
                insight: null,
                editIndex: -1
            };
        }
        resize(src, thumbWidth) {
            if (!src) return;
            const img = new Image();
            img.onload = ()=>{
                const canvas = document.createElement('canvas'), ctx = canvas.getContext('2d');
                const ratio = img.width / thumbWidth;
                canvas.height = img.height / ratio;
                canvas.width = thumbWidth;
                ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
                const image = canvas.toDataURL();
                this.setState({
                    image: image
                });
            };
            img.src = src;
        }
        editSnapshot(snapshot, editIndex = -1) {
            if (snapshot) this.setState(Object.assign(Object.assign({
                showEditFormDialog: true
            }, snapshot), {
                editIndex: editIndex
            }));
            else {
                const { explorer: explorer } = this.props;
                const signalValues = explorer.viewer.getSignalValues();
                explorer.viewer.deselect().then(()=>{
                    const canvas = (0, $4293b5c02e7b8c3d$export$f80a6900d44a74ee)(explorer.viewer);
                    const bgColor = canvas && window.getComputedStyle(canvas).backgroundColor;
                    const insight = (0, $1342cf7df79546f0$exports).VegaMorphCharts.util.clone(explorer.viewer.getInsight());
                    delete insight.size;
                    insight.signalValues = signalValues;
                    const title = this.props.getTitle && this.props.getTitle(insight) || '';
                    const description = this.props.getDescription && this.props.getDescription(insight) || '';
                    this.setState({
                        showEditFormDialog: true,
                        bgColor: bgColor,
                        title: title,
                        description: description,
                        insight: insight,
                        image: null,
                        editIndex: editIndex
                    });
                    //allow deselection to render
                    setTimeout(()=>{
                        explorer.viewer.presenter.canvasToDataURL().then((dataUrl)=>{
                            this.resize(dataUrl, explorer.snapshotThumbWidth);
                        });
                    }, 500);
                });
            }
        }
        render() {
            var _a, _b;
            const { explorer: explorer } = this.props;
            return (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement((0, $f4b615ab5c14d90e$export$3ddf2d174ce01153), {
                modalProps: {
                    className: (0, $e295d8097c1ad61a$exports).classList('sanddance-snapshot-dialog', this.props.theme)
                },
                minWidth: `${explorer.snapshotThumbWidth + 64}px`,
                hidden: !this.state.showEditFormDialog,
                onDismiss: ()=>this.setState({
                        showEditFormDialog: false
                    }),
                title: this.state.editIndex >= 0 ? (0, $d5b6ce321475881f$export$21c51bc433c16634).buttonEditSnapshot : (0, $d5b6ce321475881f$export$21c51bc433c16634).buttonCreateSnapshot,
                buttons: (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement((0, $a601a4135959dcb0$export$e2253033e6e1df16).fluentUI.PrimaryButton, {
                    disabled: !this.state.image || !this.state.title,
                    key: 0,
                    onClick: (e)=>{
                        const setup = (0, $1342cf7df79546f0$exports).VegaMorphCharts.util.clone(explorer.getSetup());
                        if (setup.camera !== 'hold') //get the latest camera movement, instead of what's in state
                        setup.camera = explorer.viewer.getCamera();
                        const snapshot = {
                            title: this.state.title,
                            description: this.state.description,
                            insight: this.state.insight,
                            image: this.state.image,
                            bgColor: this.state.bgColor,
                            setup: setup
                        };
                        this.props.modifySnapShot && this.props.modifySnapShot(snapshot);
                        this.props.onWriteSnapshot(snapshot, this.state.editIndex);
                        this.setState({
                            showEditFormDialog: false,
                            title: '',
                            description: '',
                            image: null
                        });
                    },
                    iconProps: {
                        iconName: 'Camera'
                    },
                    text: this.state.editIndex >= 0 ? (0, $d5b6ce321475881f$export$21c51bc433c16634).buttonUpdateSnapshot : (0, $d5b6ce321475881f$export$21c51bc433c16634).buttonCreateSnapshot
                })
            }, (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement((0, $a601a4135959dcb0$export$e2253033e6e1df16).fluentUI.TextField, {
                label: (0, $d5b6ce321475881f$export$21c51bc433c16634).labelSnapshotTitle,
                onChange: (e, title)=>this.setState({
                        title: title
                    }),
                value: this.state.title
            }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement((0, $a601a4135959dcb0$export$e2253033e6e1df16).fluentUI.TextField, {
                label: (0, $d5b6ce321475881f$export$21c51bc433c16634).labelSnapshotDescription,
                onChange: (e, description)=>this.setState({
                        description: description
                    }),
                value: this.state.description,
                multiline: true
            }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("div", {
                className: 'thumbnail'
            }, !this.state.image && (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement((0, $a601a4135959dcb0$export$e2253033e6e1df16).fluentUI.Spinner, null), this.state.image && (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("img", {
                src: this.state.image,
                style: {
                    backgroundColor: this.state.bgColor
                }
            })), ((_b = (_a = explorer.viewer) === null || _a === void 0 ? void 0 : _a.colorContexts) === null || _b === void 0 ? void 0 : _b.length) > 1 && (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("div", null, (0, $d5b6ce321475881f$export$21c51bc433c16634).labelColorFilter));
        }
    }
    return new __SnapshotEditor(_props);
}
const $e07b04fee87ea13f$export$15b376344cc89d12 = $e07b04fee87ea13f$var$_SnapshotEditor;


/*!
* Copyright (c) Microsoft Corporation.
* Licensed under the MIT License.
*/ 





function $ce6d2e0261fc46dc$var$_Snapshots(_props) {
    class __Snapshots extends (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.Component {
        constructor(props){
            super(props);
            this.state = {
                confirmation: null,
                title: '',
                description: '',
                image: null,
                bgColor: null,
                insight: null
            };
        }
        render() {
            const items = [
                {
                    key: 'clear',
                    text: (0, $d5b6ce321475881f$export$21c51bc433c16634).buttonClearSnapshots,
                    onClick: ()=>this.setState({
                            confirmation: {
                                buttonText: (0, $d5b6ce321475881f$export$21c51bc433c16634).buttonClearSnapshots,
                                handler: ()=>this.props.onClearSnapshots()
                            }
                        }),
                    disabled: this.props.snapshots.length === 0
                }
            ];
            if (this.props.getTopActions) items.push.apply(items, this.props.getTopActions(this.props.snapshots));
            const ref = (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createRef();
            this.props.explorer.dialogFocusHandler.focus = ()=>{
                var _a;
                (_a = ref.current) === null || _a === void 0 || _a.focus();
            };
            return (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement((0, $5b1483fb7f067be1$export$eb2fcfdbd7ba97d4), {
                className: "sanddance-snapshots",
                label: (0, $d5b6ce321475881f$export$21c51bc433c16634).labelSnapshots
            }, (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("div", null, (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement((0, $a601a4135959dcb0$export$e2253033e6e1df16).fluentUI.PrimaryButton, {
                componentRef: ref,
                text: (0, $d5b6ce321475881f$export$21c51bc433c16634).buttonCreateSnapshot,
                onClick: (e)=>this.props.editor.editSnapshot(),
                split: true,
                menuProps: {
                    items: items
                }
            }), this.props.getChildren && this.props.getChildren(this.props.snapshots), this.state.confirmation && (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement((0, $f4b615ab5c14d90e$export$3ddf2d174ce01153), {
                hidden: false,
                buttons: (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement((0, $a601a4135959dcb0$export$e2253033e6e1df16).fluentUI.PrimaryButton, {
                    key: 0,
                    onClick: (e)=>{
                        this.setState({
                            confirmation: null
                        });
                        this.state.confirmation.handler();
                    },
                    iconProps: {
                        iconName: 'Delete'
                    },
                    text: this.state.confirmation.buttonText
                }),
                onDismiss: ()=>this.setState({
                        confirmation: null
                    })
            }, (0, $d5b6ce321475881f$export$21c51bc433c16634).labelConfirmation), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("div", null, this.props.snapshots.map((snapshot, i)=>{
                const actions = this.props.getActions && this.props.getActions(snapshot, i) || [];
                actions.push({
                    iconButtonProps: {
                        themePalette: this.props.themePalette,
                        title: (0, $d5b6ce321475881f$export$21c51bc433c16634).buttonEditSnapshot,
                        onClick: (e)=>this.props.editor.editSnapshot(snapshot, i),
                        iconName: 'Edit'
                    }
                });
                if (this.props.snapshots.length > 1) actions.push({
                    iconButtonProps: {
                        disabled: i === 0,
                        themePalette: this.props.themePalette,
                        title: (0, $d5b6ce321475881f$export$21c51bc433c16634).buttonMoveUp,
                        onClick: (e)=>this.props.onMoveUp(i),
                        iconName: 'SortUp'
                    }
                }, {
                    iconButtonProps: {
                        disabled: i > this.props.snapshots.length - 2,
                        themePalette: this.props.themePalette,
                        title: (0, $d5b6ce321475881f$export$21c51bc433c16634).buttonMoveDown,
                        onClick: (e)=>this.props.onMoveDown(i),
                        iconName: 'SortDown'
                    }
                });
                actions.push({
                    iconButtonProps: {
                        themePalette: this.props.themePalette,
                        title: (0, $d5b6ce321475881f$export$21c51bc433c16634).buttonDeleteSnapshot,
                        onClick: ()=>this.setState({
                                confirmation: {
                                    buttonText: (0, $d5b6ce321475881f$export$21c51bc433c16634).buttonDeleteSnapshot,
                                    handler: ()=>this.props.onRemoveSnapshot(i)
                                }
                            }),
                        iconName: 'Delete'
                    }
                });
                return (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("div", {
                    key: i,
                    className: (0, $e295d8097c1ad61a$exports).classList('snapshot', i === this.props.selectedSnapshotIndex && 'selected')
                }, (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("div", {
                    onClick: (e)=>this.props.onSnapshotClick(snapshot, i)
                }, (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("div", {
                    className: 'title'
                }, snapshot.title), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("div", {
                    className: 'thumbnail'
                }, (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("img", {
                    title: snapshot.description,
                    src: snapshot.image,
                    style: {
                        backgroundColor: snapshot.bgColor
                    }
                }))), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement($ce6d2e0261fc46dc$var$Actions, {
                    actions: actions,
                    snapshot: snapshot
                }));
            }))));
        }
    }
    return new __Snapshots(_props);
}
const $ce6d2e0261fc46dc$export$3e09886744a57615 = $ce6d2e0261fc46dc$var$_Snapshots;
function $ce6d2e0261fc46dc$var$Actions(props) {
    return (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("div", {
        className: "actions"
    }, props.actions.map((action, i)=>{
        if (action.iconButtonProps) return (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement((0, $baf9c68afdd76912$export$c25acd513dcc8062), Object.assign({
            key: i
        }, action.iconButtonProps));
        if (action.element) return action.element;
    }));
}


/*!
* Copyright (c) Microsoft Corporation.
* Licensed under the MIT License.
*/ 






const $7169c11dc639bbc5$var$positions = [
    [
        'x',
        (0, $d5b6ce321475881f$export$21c51bc433c16634).labelAliasX
    ],
    [
        'y',
        (0, $d5b6ce321475881f$export$21c51bc433c16634).labelAliasY
    ],
    [
        'z',
        (0, $d5b6ce321475881f$export$21c51bc433c16634).labelAliasZ
    ]
];
const $7169c11dc639bbc5$var$autoScrubInterval = 50; //tune to get the smoothest animation while able to do an update pass through React
function $7169c11dc639bbc5$var$_TransitionEditor(_props) {
    class __TransitionEditor extends (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.Component {
        constructor(props){
            super(props);
            this.state = Object.assign({
                scrub: 100,
                pauseDisabled: true
            }, this.initialCalc(props.transitionDurations));
            this.autoScrubber = new $7169c11dc639bbc5$var$AutoScrubber($7169c11dc639bbc5$var$autoScrubInterval, (direction, interval)=>{
                const totalMs = this.state.totalTransition * 1000;
                const currentMs = this.state.scrub / 100 * totalMs;
                const scrubMs = currentMs + direction * interval;
                let scrub = scrubMs / totalMs * 100;
                if (direction < 0 && scrub <= 0) {
                    scrub = 0;
                    this.autoScrubber.stop();
                }
                if (direction > 0 && scrub >= 100) {
                    scrub = 100;
                    this.autoScrubber.stop();
                }
                this.setScrubState(scrub);
            });
        }
        initialCalc(transitionDurations) {
            const totalTransition = (transitionDurations.position + transitionDurations.stagger) / 1000;
            const staggerPercent = transitionDurations.stagger === 0 ? 1 : transitionDurations.stagger / (totalTransition * 1000) * 100;
            const viewTransition = transitionDurations.view / 1000;
            return {
                totalTransition: totalTransition,
                staggerPercent: staggerPercent,
                viewTransition: viewTransition
            };
        }
        setScrubState(scrub) {
            const { morphChartsRenderResult: morphChartsRenderResult, morphchartsref: morphchartsref } = this.props.explorer.viewer.presenter;
            morphchartsref.core.renderer.transitionTime = scrub / 100;
            morphChartsRenderResult.setTransitionTimeAxesVisibility();
            scrub = Math.round(scrub);
            this.setState({
                scrub: scrub,
                pauseDisabled: this.autoScrubber.isStopped()
            });
        }
        setDurations() {
            setTimeout(()=>{
                const { props: props, state: state } = this;
                const { totalTransition: totalTransition, staggerPercent: staggerPercent, viewTransition: viewTransition } = state;
                const stagger = totalTransition * staggerPercent / 100;
                const { transitionDurations: transitionDurations } = props;
                transitionDurations.position = (totalTransition - stagger) * 1000;
                transitionDurations.stagger = stagger * 1000;
                transitionDurations.view = viewTransition * 1000;
                $7169c11dc639bbc5$export$39fa25c8c3576e7a(props.explorer.viewer, transitionDurations);
                props.changeSetup(null, false);
            });
        }
        render() {
            const { props: props, state: state } = this;
            const { explorer: explorer, transitionDurations: transitionDurations, changeSetup: changeSetup } = props;
            const sliderRef = (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createRef();
            explorer.dialogFocusHandler.focus = ()=>{
                var _a;
                return (_a = sliderRef.current) === null || _a === void 0 ? void 0 : _a.focus();
            };
            return (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("div", null, (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement((0, $5b1483fb7f067be1$export$eb2fcfdbd7ba97d4), {
                label: (0, $d5b6ce321475881f$export$21c51bc433c16634).labelTransition
            }, (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement((0, $a601a4135959dcb0$export$e2253033e6e1df16).fluentUI.Slider, {
                componentRef: sliderRef,
                label: (0, $d5b6ce321475881f$export$21c51bc433c16634).labelTransitionScrubber,
                min: 0,
                max: 100,
                valueFormat: (0, $d5b6ce321475881f$export$21c51bc433c16634).percentValueFormat,
                value: state.scrub,
                onChange: (scrub)=>{
                    this.autoScrubber.stop();
                    this.setScrubState(scrub);
                }
            }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement((0, $baf9c68afdd76912$export$c25acd513dcc8062), {
                themePalette: props.themePalette,
                title: (0, $d5b6ce321475881f$export$21c51bc433c16634).buttonTransitionReverse,
                iconName: 'PlayReverseResume',
                onClick: ()=>{
                    this.autoScrubber.toggleScrubbing(-1);
                    if (state.scrub === 0) this.setState({
                        scrub: 100
                    });
                }
            }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement((0, $baf9c68afdd76912$export$c25acd513dcc8062), {
                themePalette: props.themePalette,
                title: (0, $d5b6ce321475881f$export$21c51bc433c16634).buttonTransitionPause,
                iconName: 'Pause',
                onClick: ()=>{
                    this.autoScrubber.togglePause();
                },
                disabled: state.pauseDisabled
            }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement((0, $baf9c68afdd76912$export$c25acd513dcc8062), {
                themePalette: props.themePalette,
                title: (0, $d5b6ce321475881f$export$21c51bc433c16634).buttonTransitionPlay,
                iconName: 'PlayResume',
                onClick: ()=>{
                    this.autoScrubber.toggleScrubbing(1);
                    if (state.scrub === 100) this.setState({
                        scrub: 0
                    });
                }
            })), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement((0, $5b1483fb7f067be1$export$eb2fcfdbd7ba97d4), {
                label: (0, $d5b6ce321475881f$export$21c51bc433c16634).labelTransitionOptions
            }, (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement((0, $a601a4135959dcb0$export$e2253033e6e1df16).fluentUI.Toggle, {
                label: (0, $d5b6ce321475881f$export$21c51bc433c16634).labelHoldCamera,
                checked: explorer.state.holdCamera,
                onChange: (e, holdCamera)=>{
                    changeSetup({
                        holdCamera: holdCamera
                    }, false);
                }
            }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement((0, $a601a4135959dcb0$export$e2253033e6e1df16).fluentUI.ChoiceGroup, {
                label: (0, $d5b6ce321475881f$export$21c51bc433c16634).labelTransitionStaggerBy,
                selectedKey: props.transitionType,
                options: [
                    {
                        key: 'ordinal',
                        text: (0, $d5b6ce321475881f$export$21c51bc433c16634).labelTransitionStaggerByOrdinal
                    },
                    {
                        key: 'column',
                        text: (0, $d5b6ce321475881f$export$21c51bc433c16634).labelTransitionStaggerByColumn
                    },
                    {
                        key: 'position',
                        text: (0, $d5b6ce321475881f$export$21c51bc433c16634).labelTransitionStaggerByPosition
                    }
                ],
                onChange: (e, o)=>{
                    const transitionType = o.key;
                    changeSetup({
                        transitionType: transitionType
                    }, true);
                }
            })), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement((0, $5b1483fb7f067be1$export$eb2fcfdbd7ba97d4), {
                label: (0, $d5b6ce321475881f$export$21c51bc433c16634).labelTransitionStaggerOptions
            }, (()=>{
                switch(props.transitionType){
                    case 'column':
                        return (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement((0, $8f56f1ed6ae42f13$export$931cbfb6bfb85fc), {
                            collapseLabel: props.compactUI,
                            label: (0, $d5b6ce321475881f$export$21c51bc433c16634).labelTransitionStaggerByColumn,
                            options: $7169c11dc639bbc5$var$getColumnOptions(props, props.transitionColumn.name),
                            onChange: (e, o)=>{
                                changeSetup({
                                    transitionColumn: o.data
                                }, true);
                            }
                        });
                    case 'position':
                        return (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement((0, $8f56f1ed6ae42f13$export$931cbfb6bfb85fc), {
                            collapseLabel: props.compactUI,
                            label: (0, $d5b6ce321475881f$export$21c51bc433c16634).labelTransitionStaggerByPosition,
                            options: $7169c11dc639bbc5$var$positions.map(([key, text])=>{
                                return {
                                    key: key,
                                    text: text,
                                    selected: props.transitionDimension === key
                                };
                            }),
                            onChange: (e, o)=>{
                                changeSetup({
                                    transitionDimension: o.key
                                }, true);
                            }
                        });
                }
            })(), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement((0, $a601a4135959dcb0$export$e2253033e6e1df16).fluentUI.Toggle, {
                label: (0, $d5b6ce321475881f$export$21c51bc433c16634).labelTransitionStaggerReverse,
                checked: props.transitionReverse,
                onChange: (e, transitionReverse)=>changeSetup({
                        transitionReverse: transitionReverse
                    }, true)
            })), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement((0, $5b1483fb7f067be1$export$eb2fcfdbd7ba97d4), {
                label: (0, $d5b6ce321475881f$export$21c51bc433c16634).labelTransitionDurations
            }, (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement((0, $a601a4135959dcb0$export$e2253033e6e1df16).fluentUI.Slider, {
                label: (0, $d5b6ce321475881f$export$21c51bc433c16634).labelTransitionDuration,
                onChange: (totalTransition)=>{
                    this.setState({
                        totalTransition: totalTransition
                    });
                    this.setDurations();
                },
                min: 0,
                max: 5,
                step: 0.1,
                value: state.totalTransition
            }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement((0, $a601a4135959dcb0$export$e2253033e6e1df16).fluentUI.Slider, {
                label: (0, $d5b6ce321475881f$export$21c51bc433c16634).labelTransitionStagger,
                onChange: (staggerPercent)=>{
                    this.setState({
                        staggerPercent: staggerPercent
                    });
                    this.setDurations();
                },
                min: 0,
                max: 100,
                valueFormat: (0, $d5b6ce321475881f$export$21c51bc433c16634).percentValueFormat,
                value: state.staggerPercent
            }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement((0, $a601a4135959dcb0$export$e2253033e6e1df16).fluentUI.Slider, {
                label: (0, $d5b6ce321475881f$export$21c51bc433c16634).labelTransitionCamera,
                onChange: (viewTransition)=>{
                    this.setState({
                        viewTransition: viewTransition
                    });
                    this.setDurations();
                },
                min: 0,
                max: 5,
                step: 0.1,
                value: state.viewTransition
            }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement((0, $f9294a04a77df05a$export$353f5b6fc5456de1), {
                themePalette: props.themePalette,
                onClick: ()=>{
                    const defaults = (0, $1342cf7df79546f0$exports).VegaMorphCharts.defaults.defaultPresenterConfig.transitionDurations;
                    const { position: position, stagger: stagger, view: view } = defaults;
                    transitionDurations.position = position;
                    transitionDurations.stagger = stagger;
                    transitionDurations.view = view;
                    this.setState(Object.assign({}, this.initialCalc(transitionDurations)));
                    this.setDurations();
                },
                text: (0, $d5b6ce321475881f$export$21c51bc433c16634).buttonResetToDefault
            })));
        }
    }
    return new __TransitionEditor(_props);
}
const $7169c11dc639bbc5$export$df231814b4232ebd = $7169c11dc639bbc5$var$_TransitionEditor;
function $7169c11dc639bbc5$var$groupOptions(sectionName, columns, selectedKey) {
    const options = columns.map((column)=>{
        const option = {
            key: `column:${column.name}`,
            text: column.name,
            data: column,
            selected: column.name === selectedKey
        };
        return option;
    });
    if (options.length) {
        const option = {
            key: sectionName,
            text: sectionName,
            itemType: (0, $a601a4135959dcb0$export$e2253033e6e1df16).fluentUI.DropdownMenuItemType.Header
        };
        options.unshift(option);
    }
    return options;
}
function $7169c11dc639bbc5$var$getColumnOptions(props, selectedKey) {
    const quantitativeGroup = $7169c11dc639bbc5$var$groupOptions((0, $d5b6ce321475881f$export$21c51bc433c16634).selectNumeric, props.quantitativeColumns, selectedKey);
    const categoricGroup = $7169c11dc639bbc5$var$groupOptions((0, $d5b6ce321475881f$export$21c51bc433c16634).selectNonNumeric, props.categoricalColumns, selectedKey);
    return quantitativeGroup.concat(categoricGroup);
}
function $7169c11dc639bbc5$export$d5639c01d489b0c(state) {
    const reverse = state.transitionReverse;
    switch(state.transitionType){
        case 'ordinal':
            return {
                type: 'ordinal',
                reverse: reverse
            };
        case 'column':
            return {
                type: 'column',
                column: state.transitionColumn,
                reverse: reverse
            };
        case 'position':
            return {
                type: 'position',
                dimension: state.transitionDimension,
                reverse: reverse
            };
    }
}
function $7169c11dc639bbc5$export$39fa25c8c3576e7a(viewer, transitionDurations) {
    var _a, _b;
    const config = (_b = (_a = viewer === null || viewer === void 0 ? void 0 : viewer.presenter) === null || _a === void 0 ? void 0 : _a.morphchartsref) === null || _b === void 0 ? void 0 : _b.core.config;
    if (config) {
        const { position: position, stagger: stagger } = transitionDurations;
        config.transitionDuration = position;
        config.transitionStaggering = stagger;
    }
}
class $7169c11dc639bbc5$var$AutoScrubber {
    constructor(interval, onInterval){
        this.interval = interval;
        this.onInterval = onInterval;
    }
    getSignedInterval() {
        return this.interval * this.direction;
    }
    toggleScrubbing(direction) {
        if (this.isScrubbing() && direction === this.direction) this.pause();
        else this.start(direction);
    }
    isPaused() {
        return !this.isScrubbing() && this.direction !== undefined;
    }
    isStopped() {
        return !this.isScrubbing() && this.direction === undefined;
    }
    isScrubbing() {
        return this.autoScrubTimer !== undefined;
    }
    togglePause() {
        if (this.isScrubbing()) this.pause();
        else if (this.direction) this.start(this.direction);
    }
    start(direction) {
        this.direction = direction;
        if (!this.isScrubbing()) this.autoScrubTimer = setInterval(()=>this.onInterval(this.direction, this.interval), this.interval);
    }
    pause() {
        clearInterval(this.autoScrubTimer);
        this.autoScrubTimer = undefined;
    }
    stop() {
        this.pause();
        this.direction = undefined;
    }
}


var $688b2ed8e5aa6452$exports = {};

$parcel$export($688b2ed8e5aa6452$exports, "Explorer", () => $688b2ed8e5aa6452$export$43584986cb77a794);
/*!
* Copyright (c) Microsoft Corporation.
* Licensed under the MIT License.
*/ 


/*!
* Copyright (c) Microsoft Corporation.
* Licensed under the MIT License.
*/ 



const $46e7ccd2bf7a69a1$var$className = 'sanddance-panel-tools';
function $46e7ccd2bf7a69a1$var$ensureToolbar(panel) {
    const existing = panel.getElementsByClassName($46e7ccd2bf7a69a1$var$className);
    if (existing.length > 0) return existing[0];
    else {
        const div = (0, $1342cf7df79546f0$exports).VegaMorphCharts.util.addDiv(panel, $46e7ccd2bf7a69a1$var$className);
        panel.insertAdjacentElement('afterbegin', div);
        return div;
    }
}
function $46e7ccd2bf7a69a1$export$225a002951c27da7(presenter, showLegend, props) {
    const panel = presenter.getElement((0, $1342cf7df79546f0$exports).VegaMorphCharts.PresenterElement.panel);
    const div = $46e7ccd2bf7a69a1$var$ensureToolbar(panel);
    (0, $a601a4135959dcb0$export$e2253033e6e1df16).reactDOM.render($46e7ccd2bf7a69a1$var$ColorMap(props), div);
    panel.style.display = showLegend ? '' : 'none';
}
function $46e7ccd2bf7a69a1$var$ColorMap(props) {
    const menuProps = {
        items: [
            {
                key: 'new',
                text: (0, $d5b6ce321475881f$export$21c51bc433c16634).buttonColorSchemeRemap,
                disabled: !props.canRemap || props.isRemap,
                onClick: ()=>props.colorMapHandler(true)
            },
            {
                key: 'old',
                text: (0, $d5b6ce321475881f$export$21c51bc433c16634).buttonColorSchemeKeep,
                disabled: !props.canRemap || !props.isRemap,
                onClick: ()=>props.colorMapHandler(false)
            }
        ]
    };
    return (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("div", null, (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement((0, $baf9c68afdd76912$export$c25acd513dcc8062), {
        styles: {
            menuIcon: {
                display: 'none'
            }
        },
        themePalette: props.themePalette,
        title: (0, $d5b6ce321475881f$export$21c51bc433c16634).buttonColorSchemeMap,
        onClick: null,
        iconName: props.canRemap ? 'FiltersSolid' : 'Filters',
        menuProps: menuProps
    }));
}


/*!
* Copyright (c) Microsoft Corporation.
* Licensed under the MIT License.
*/ function $e3b58b932870fa44$export$ba25af89e7ea3c1a(newColumn, oldColumn, oldScheme) {
    if (oldColumn && oldColumn.quantitative === newColumn.quantitative && $e3b58b932870fa44$var$defaultColorScheme(oldColumn) === $e3b58b932870fa44$var$defaultColorScheme(newColumn)) return oldScheme;
    return $e3b58b932870fa44$var$defaultColorScheme(newColumn);
}
function $e3b58b932870fa44$var$defaultColorScheme(c) {
    if (c.quantitative) return 'redyellowgreen';
    else if (c.stats.distinctValueCount === 2) return 'dual_redgreen';
    else if (c.stats.distinctValueCount <= 10) return 'category10';
    return 'category20';
}



/*!
* Copyright (c) Microsoft Corporation.
* Licensed under the MIT License.
*/ 



function $9609e207e93b7923$export$2e2bcd8739ae039(x) {
    return Math.abs(x = Math.round(x)) >= 1e21 ? x.toLocaleString("en").replace(/,/g, "") : x.toString(10);
}
function $9609e207e93b7923$export$8f8e23dd27dc19f5(x, p) {
    if ((i = (x = p ? x.toExponential(p - 1) : x.toExponential()).indexOf("e")) < 0) return null; // NaN, Infinity
    var i, coefficient = x.slice(0, i);
    // The string returned by toExponential either has the form \d\.\d+e[-+]\d+
    // (e.g., 1.2e+3) or the form \de[-+]\d+ (e.g., 1e+3).
    return [
        coefficient.length > 1 ? coefficient[0] + coefficient.slice(2) : coefficient,
        +x.slice(i + 1)
    ];
}


function $75b9c15a84f36786$export$2e2bcd8739ae039(x) {
    return x = (0, $9609e207e93b7923$export$8f8e23dd27dc19f5)(Math.abs(x)), x ? x[1] : NaN;
}


function $a4f5516ee00a18bc$export$2e2bcd8739ae039(grouping, thousands) {
    return function(value, width) {
        var i = value.length, t = [], j = 0, g = grouping[0], length = 0;
        while(i > 0 && g > 0){
            if (length + g + 1 > width) g = Math.max(1, width - length);
            t.push(value.substring(i -= g, i + g));
            if ((length += g + 1) > width) break;
            g = grouping[j = (j + 1) % grouping.length];
        }
        return t.reverse().join(thousands);
    };
}


function $3db498c77a24c909$export$2e2bcd8739ae039(numerals) {
    return function(value) {
        return value.replace(/[0-9]/g, function(i) {
            return numerals[+i];
        });
    };
}


// [[fill]align][sign][symbol][0][width][,][.precision][~][type]
var $beac99c87b86c748$var$re = /^(?:(.)?([<>=^]))?([+\-( ])?([$#])?(0)?(\d+)?(,)?(\.\d+)?(~)?([a-z%])?$/i;
function $beac99c87b86c748$export$2e2bcd8739ae039(specifier) {
    if (!(match = $beac99c87b86c748$var$re.exec(specifier))) throw new Error("invalid format: " + specifier);
    var match;
    return new $beac99c87b86c748$export$963aac351db36ed4({
        fill: match[1],
        align: match[2],
        sign: match[3],
        symbol: match[4],
        zero: match[5],
        width: match[6],
        comma: match[7],
        precision: match[8] && match[8].slice(1),
        trim: match[9],
        type: match[10]
    });
}
$beac99c87b86c748$export$2e2bcd8739ae039.prototype = $beac99c87b86c748$export$963aac351db36ed4.prototype; // instanceof
function $beac99c87b86c748$export$963aac351db36ed4(specifier) {
    this.fill = specifier.fill === undefined ? " " : specifier.fill + "";
    this.align = specifier.align === undefined ? ">" : specifier.align + "";
    this.sign = specifier.sign === undefined ? "-" : specifier.sign + "";
    this.symbol = specifier.symbol === undefined ? "" : specifier.symbol + "";
    this.zero = !!specifier.zero;
    this.width = specifier.width === undefined ? undefined : +specifier.width;
    this.comma = !!specifier.comma;
    this.precision = specifier.precision === undefined ? undefined : +specifier.precision;
    this.trim = !!specifier.trim;
    this.type = specifier.type === undefined ? "" : specifier.type + "";
}
$beac99c87b86c748$export$963aac351db36ed4.prototype.toString = function() {
    return this.fill + this.align + this.sign + this.symbol + (this.zero ? "0" : "") + (this.width === undefined ? "" : Math.max(1, this.width | 0)) + (this.comma ? "," : "") + (this.precision === undefined ? "" : "." + Math.max(0, this.precision | 0)) + (this.trim ? "~" : "") + this.type;
};


// Trims insignificant zeros, e.g., replaces 1.2000k with 1.2k.
function $bd6ac69290a29cb5$export$2e2bcd8739ae039(s) {
    out: for(var n = s.length, i = 1, i0 = -1, i1; i < n; ++i)switch(s[i]){
        case ".":
            i0 = i1 = i;
            break;
        case "0":
            if (i0 === 0) i0 = i;
            i1 = i;
            break;
        default:
            if (!+s[i]) break out;
            if (i0 > 0) i0 = 0;
            break;
    }
    return i0 > 0 ? s.slice(0, i0) + s.slice(i1 + 1) : s;
}




var $58e383fbc32baa60$export$6863724d9a42263;
function $58e383fbc32baa60$export$2e2bcd8739ae039(x, p) {
    var d = (0, $9609e207e93b7923$export$8f8e23dd27dc19f5)(x, p);
    if (!d) return x + "";
    var coefficient = d[0], exponent = d[1], i = exponent - ($58e383fbc32baa60$export$6863724d9a42263 = Math.max(-8, Math.min(8, Math.floor(exponent / 3))) * 3) + 1, n = coefficient.length;
    return i === n ? coefficient : i > n ? coefficient + new Array(i - n + 1).join("0") : i > 0 ? coefficient.slice(0, i) + "." + coefficient.slice(i) : "0." + new Array(1 - i).join("0") + (0, $9609e207e93b7923$export$8f8e23dd27dc19f5)(x, Math.max(0, p + i - 1))[0]; // less than 1y!
}



function $3903417d864b94de$export$2e2bcd8739ae039(x, p) {
    var d = (0, $9609e207e93b7923$export$8f8e23dd27dc19f5)(x, p);
    if (!d) return x + "";
    var coefficient = d[0], exponent = d[1];
    return exponent < 0 ? "0." + new Array(-exponent).join("0") + coefficient : coefficient.length > exponent + 1 ? coefficient.slice(0, exponent + 1) + "." + coefficient.slice(exponent + 1) : coefficient + new Array(exponent - coefficient.length + 2).join("0");
}


var $865b2da11efc775a$export$2e2bcd8739ae039 = {
    "%": function(x, p) {
        return (x * 100).toFixed(p);
    },
    "b": function(x) {
        return Math.round(x).toString(2);
    },
    "c": function(x) {
        return x + "";
    },
    "d": (0, $9609e207e93b7923$export$2e2bcd8739ae039),
    "e": function(x, p) {
        return x.toExponential(p);
    },
    "f": function(x, p) {
        return x.toFixed(p);
    },
    "g": function(x, p) {
        return x.toPrecision(p);
    },
    "o": function(x) {
        return Math.round(x).toString(8);
    },
    "p": function(x, p) {
        return (0, $3903417d864b94de$export$2e2bcd8739ae039)(x * 100, p);
    },
    "r": (0, $3903417d864b94de$export$2e2bcd8739ae039),
    "s": (0, $58e383fbc32baa60$export$2e2bcd8739ae039),
    "X": function(x) {
        return Math.round(x).toString(16).toUpperCase();
    },
    "x": function(x) {
        return Math.round(x).toString(16);
    }
};



function $aca4ed01afa40869$export$2e2bcd8739ae039(x) {
    return x;
}


var $afe689d3eee04304$var$map = Array.prototype.map, $afe689d3eee04304$var$prefixes = [
    "y",
    "z",
    "a",
    "f",
    "p",
    "n",
    "\xb5",
    "m",
    "",
    "k",
    "M",
    "G",
    "T",
    "P",
    "E",
    "Z",
    "Y"
];
function $afe689d3eee04304$export$2e2bcd8739ae039(locale) {
    var group = locale.grouping === undefined || locale.thousands === undefined ? (0, $aca4ed01afa40869$export$2e2bcd8739ae039) : (0, $a4f5516ee00a18bc$export$2e2bcd8739ae039)($afe689d3eee04304$var$map.call(locale.grouping, Number), locale.thousands + ""), currencyPrefix = locale.currency === undefined ? "" : locale.currency[0] + "", currencySuffix = locale.currency === undefined ? "" : locale.currency[1] + "", decimal = locale.decimal === undefined ? "." : locale.decimal + "", numerals = locale.numerals === undefined ? (0, $aca4ed01afa40869$export$2e2bcd8739ae039) : (0, $3db498c77a24c909$export$2e2bcd8739ae039)($afe689d3eee04304$var$map.call(locale.numerals, String)), percent = locale.percent === undefined ? "%" : locale.percent + "", minus = locale.minus === undefined ? "-" : locale.minus + "", nan = locale.nan === undefined ? "NaN" : locale.nan + "";
    function newFormat(specifier) {
        specifier = (0, $beac99c87b86c748$export$2e2bcd8739ae039)(specifier);
        var fill = specifier.fill, align = specifier.align, sign = specifier.sign, symbol = specifier.symbol, zero = specifier.zero, width = specifier.width, comma = specifier.comma, precision = specifier.precision, trim = specifier.trim, type = specifier.type;
        // The "n" type is an alias for ",g".
        if (type === "n") comma = true, type = "g";
        else if (!(0, $865b2da11efc775a$export$2e2bcd8739ae039)[type]) precision === undefined && (precision = 12), trim = true, type = "g";
        // If zero fill is specified, padding goes after sign and before digits.
        if (zero || fill === "0" && align === "=") zero = true, fill = "0", align = "=";
        // Compute the prefix and suffix.
        // For SI-prefix, the suffix is lazily computed.
        var prefix = symbol === "$" ? currencyPrefix : symbol === "#" && /[boxX]/.test(type) ? "0" + type.toLowerCase() : "", suffix = symbol === "$" ? currencySuffix : /[%p]/.test(type) ? percent : "";
        // What format function should we use?
        // Is this an integer type?
        // Can this type generate exponential notation?
        var formatType = (0, $865b2da11efc775a$export$2e2bcd8739ae039)[type], maybeSuffix = /[defgprs%]/.test(type);
        // Set the default precision if not specified,
        // or clamp the specified precision to the supported range.
        // For significant precision, it must be in [1, 21].
        // For fixed precision, it must be in [0, 20].
        precision = precision === undefined ? 6 : /[gprs]/.test(type) ? Math.max(1, Math.min(21, precision)) : Math.max(0, Math.min(20, precision));
        function format(value) {
            var valuePrefix = prefix, valueSuffix = suffix, i, n, c;
            if (type === "c") {
                valueSuffix = formatType(value) + valueSuffix;
                value = "";
            } else {
                value = +value;
                // Determine the sign. -0 is not less than 0, but 1 / -0 is!
                var valueNegative = value < 0 || 1 / value < 0;
                // Perform the initial formatting.
                value = isNaN(value) ? nan : formatType(Math.abs(value), precision);
                // Trim insignificant zeros.
                if (trim) value = (0, $bd6ac69290a29cb5$export$2e2bcd8739ae039)(value);
                // If a negative value rounds to zero after formatting, and no explicit positive sign is requested, hide the sign.
                if (valueNegative && +value === 0 && sign !== "+") valueNegative = false;
                // Compute the prefix and suffix.
                valuePrefix = (valueNegative ? sign === "(" ? sign : minus : sign === "-" || sign === "(" ? "" : sign) + valuePrefix;
                valueSuffix = (type === "s" ? $afe689d3eee04304$var$prefixes[8 + (0, $58e383fbc32baa60$export$6863724d9a42263) / 3] : "") + valueSuffix + (valueNegative && sign === "(" ? ")" : "");
                // Break the formatted value into the integer value part that can be
                // grouped, and fractional or exponential suffix part that is not.
                if (maybeSuffix) {
                    i = -1, n = value.length;
                    while(++i < n)if (c = value.charCodeAt(i), 48 > c || c > 57) {
                        valueSuffix = (c === 46 ? decimal + value.slice(i + 1) : value.slice(i)) + valueSuffix;
                        value = value.slice(0, i);
                        break;
                    }
                }
            }
            // If the fill character is not "0", grouping is applied before padding.
            if (comma && !zero) value = group(value, Infinity);
            // Compute the padding.
            var length = valuePrefix.length + value.length + valueSuffix.length, padding = length < width ? new Array(width - length + 1).join(fill) : "";
            // If the fill character is "0", grouping is applied after padding.
            if (comma && zero) value = group(padding + value, padding.length ? width - valueSuffix.length : Infinity), padding = "";
            // Reconstruct the final output based on the desired alignment.
            switch(align){
                case "<":
                    value = valuePrefix + value + valueSuffix + padding;
                    break;
                case "=":
                    value = valuePrefix + padding + value + valueSuffix;
                    break;
                case "^":
                    value = padding.slice(0, length = padding.length >> 1) + valuePrefix + value + valueSuffix + padding.slice(length);
                    break;
                default:
                    value = padding + valuePrefix + value + valueSuffix;
                    break;
            }
            return numerals(value);
        }
        format.toString = function() {
            return specifier + "";
        };
        return format;
    }
    function formatPrefix(specifier, value) {
        var f = newFormat((specifier = (0, $beac99c87b86c748$export$2e2bcd8739ae039)(specifier), specifier.type = "f", specifier)), e = Math.max(-8, Math.min(8, Math.floor((0, $75b9c15a84f36786$export$2e2bcd8739ae039)(value) / 3))) * 3, k = Math.pow(10, -e), prefix = $afe689d3eee04304$var$prefixes[8 + e / 3];
        return function(value) {
            return f(k * value) + prefix;
        };
    }
    return {
        format: newFormat,
        formatPrefix: formatPrefix
    };
}


var $25eae809e43888aa$var$locale;
var $25eae809e43888aa$export$d9468344d3651243;
var $25eae809e43888aa$export$8d85692a469dde6f;
$25eae809e43888aa$export$2e2bcd8739ae039({
    decimal: ".",
    thousands: ",",
    grouping: [
        3
    ],
    currency: [
        "$",
        ""
    ],
    minus: "-"
});
function $25eae809e43888aa$export$2e2bcd8739ae039(definition) {
    $25eae809e43888aa$var$locale = (0, $afe689d3eee04304$export$2e2bcd8739ae039)(definition);
    $25eae809e43888aa$export$d9468344d3651243 = $25eae809e43888aa$var$locale.format;
    $25eae809e43888aa$export$8d85692a469dde6f = $25eae809e43888aa$var$locale.formatPrefix;
    return $25eae809e43888aa$var$locale;
}


var $86b892255d8eb4f0$export$f0297ce57faf7d71;
(function(DataScopeId) {
    DataScopeId[DataScopeId["AllData"] = 0] = "AllData";
    DataScopeId[DataScopeId["SelectedData"] = 1] = "SelectedData";
    DataScopeId[DataScopeId["FilteredData"] = 2] = "FilteredData";
})($86b892255d8eb4f0$export$f0297ce57faf7d71 || ($86b892255d8eb4f0$export$f0297ce57faf7d71 = {}));
function $86b892255d8eb4f0$export$6d13117e74df8390(selectedItemIndex) {
    selectedItemIndex[$86b892255d8eb4f0$export$f0297ce57faf7d71.AllData] = 0;
    selectedItemIndex[$86b892255d8eb4f0$export$f0297ce57faf7d71.FilteredData] = 0;
    selectedItemIndex[$86b892255d8eb4f0$export$f0297ce57faf7d71.SelectedData] = 0;
}
const $86b892255d8eb4f0$var$shortFormat = (0, $25eae809e43888aa$export$d9468344d3651243)('.2~s');
function $86b892255d8eb4f0$var$short(n) {
    return n === -1 ? '--' : n ? n < 1000 ? n.toString() : $86b892255d8eb4f0$var$shortFormat(n) : '0';
}
function $86b892255d8eb4f0$export$3fb74a6ae4f1171d(props) {
    const dataCount = Object.assign({
        all: -1,
        filtered: -1,
        selected: -1
    }, props.dataCount);
    return props.compact ? (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("div", {
        className: (0, $e295d8097c1ad61a$exports).classList('sanddance-datascope', 'compact'),
        onClick: props.onCompactClick
    }, (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement($86b892255d8eb4f0$var$Compact, Object.assign({}, props, {
        dataScopeId: $86b892255d8eb4f0$export$f0297ce57faf7d71.AllData,
        text: (0, $d5b6ce321475881f$export$21c51bc433c16634).selectDataSpanAll,
        count: dataCount.all
    })), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement($86b892255d8eb4f0$var$Compact, Object.assign({}, props, {
        dataScopeId: $86b892255d8eb4f0$export$f0297ce57faf7d71.FilteredData,
        text: (0, $d5b6ce321475881f$export$21c51bc433c16634).selectDataSpanFilter,
        count: dataCount.filtered
    })), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement($86b892255d8eb4f0$var$Compact, Object.assign({}, props, {
        dataScopeId: $86b892255d8eb4f0$export$f0297ce57faf7d71.SelectedData,
        text: (0, $d5b6ce321475881f$export$21c51bc433c16634).selectDataSpanSelection,
        count: dataCount.selected
    }))) : (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("div", {
        className: (0, $e295d8097c1ad61a$exports).classList('sanddance-datascope', 'extended', props.active && 'active')
    }, (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("div", null, (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("div", null, props.dataSet), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("div", {
        className: "datascope-buttons"
    }, (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement($86b892255d8eb4f0$var$DataScopeButton, Object.assign({}, props, {
        dataScopeId: $86b892255d8eb4f0$export$f0297ce57faf7d71.AllData,
        text: (0, $d5b6ce321475881f$export$21c51bc433c16634).selectDataSpanAll,
        count: dataCount.all
    })), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement($86b892255d8eb4f0$var$DataScopeButton, Object.assign({}, props, {
        dataScopeId: $86b892255d8eb4f0$export$f0297ce57faf7d71.FilteredData,
        text: (0, $d5b6ce321475881f$export$21c51bc433c16634).selectDataSpanFilter,
        count: dataCount.filtered
    })), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement($86b892255d8eb4f0$var$DataScopeButton, Object.assign({}, props, {
        dataScopeId: $86b892255d8eb4f0$export$f0297ce57faf7d71.SelectedData,
        text: (0, $d5b6ce321475881f$export$21c51bc433c16634).selectDataSpanSelection,
        count: dataCount.selected
    })))));
}
function $86b892255d8eb4f0$var$Compact(props) {
    return (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("div", {
        title: props.text,
        onClick: ()=>{
            props.onDataScopeClick(props.dataScopeId);
        }
    }, $86b892255d8eb4f0$var$short(props.count));
}
function $86b892255d8eb4f0$var$DataScopeButton(props) {
    return (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement((0, $f9294a04a77df05a$export$353f5b6fc5456de1), {
        themePalette: props.themePalette,
        className: (0, $e295d8097c1ad61a$exports).classList('datascope-button', props.selectedDataScope === props.dataScopeId && 'selected'),
        disabled: props.disabled,
        text: props.text,
        onClick: ()=>{
            props.onDataScopeClick(props.dataScopeId);
        },
        onRenderText: ()=>{
            return (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("div", {
                title: props.count > 0 ? props.count.toString() : ''
            }, (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("label", null, props.text), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("div", null, $86b892255d8eb4f0$var$short(props.count)));
        },
        onRenderIcon: ()=>null
    });
}




/*!
* Copyright (c) Microsoft Corporation.
* Licensed under the MIT License.
*/ 

/*!
* Copyright (c) Microsoft Corporation.
* Licensed under the MIT License.
*/ 

function $c8096a1892befafb$export$fcc7818a78919c8c(props) {
    return (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("div", {
        className: (0, $e295d8097c1ad61a$exports).classList('scrollable-container', props.className),
        role: props.role
    }, (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("div", {
        className: "scrollable"
    }, props.children));
}


/*!
* Copyright (c) Microsoft Corporation.
* Licensed under the MIT License.
*/ var $2752fa503c160704$export$f3b7566ffe363e3b;
(function(SideTabId) {
    SideTabId[SideTabId["ChartType"] = 0] = "ChartType";
    SideTabId[SideTabId["Data"] = 1] = "Data";
    SideTabId[SideTabId["Search"] = 2] = "Search";
    SideTabId[SideTabId["Color"] = 3] = "Color";
    SideTabId[SideTabId["Snapshots"] = 4] = "Snapshots";
    SideTabId[SideTabId["History"] = 5] = "History";
    SideTabId[SideTabId["Transition"] = 6] = "Transition";
    SideTabId[SideTabId["Settings"] = 7] = "Settings";
    SideTabId[SideTabId["Pin"] = 8] = "Pin";
    SideTabId[SideTabId["Collapse"] = 9] = "Collapse";
})($2752fa503c160704$export$f3b7566ffe363e3b || ($2752fa503c160704$export$f3b7566ffe363e3b = {}));




/*!
* Copyright (c) Microsoft Corporation.
* Licensed under the MIT License.
*/ 


function $d7542c73853af2f5$export$a8fc19311f33df91(props) {
    const selected = !props.closed && props.selectedSideTab === props.sideTabId;
    const buttonProps = props.omitAriaSelected ? {} : {
        'aria-selected': selected
    };
    return (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("div", {
        className: (0, $e295d8097c1ad61a$exports).classList('vbutton', selected && 'selected')
    }, props.badgeText && (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("div", {
        className: "count"
    }, props.badgeText), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement((0, $baf9c68afdd76912$export$c25acd513dcc8062), Object.assign({}, buttonProps, {
        role: props.role || 'tab',
        themePalette: props.themePalette,
        className: "vbutton",
        iconName: props.iconName,
        title: props.title,
        onClick: ()=>{
            props.onSideTabClick(props.sideTabId);
        }
    })));
}


function $a4defabaac4a9afe$export$1ba59dacbcbf90fe(props) {
    const sidebuttons = [
        {
            sideTabId: (0, $2752fa503c160704$export$f3b7566ffe363e3b).ChartType,
            iconName: 'BIDashboard',
            title: (0, $d5b6ce321475881f$export$21c51bc433c16634).labelChart
        },
        {
            sideTabId: (0, $2752fa503c160704$export$f3b7566ffe363e3b).Color,
            iconName: 'Color',
            title: (0, $d5b6ce321475881f$export$21c51bc433c16634).labelColor
        },
        {
            sideTabId: (0, $2752fa503c160704$export$f3b7566ffe363e3b).Data,
            iconName: 'Table',
            title: (0, $d5b6ce321475881f$export$21c51bc433c16634).labelDataBrowser
        },
        {
            sideTabId: (0, $2752fa503c160704$export$f3b7566ffe363e3b).Search,
            iconName: 'Search',
            title: (0, $d5b6ce321475881f$export$21c51bc433c16634).labelSearch
        },
        !props.snapshotsHidden && {
            sideTabId: (0, $2752fa503c160704$export$f3b7566ffe363e3b).Snapshots,
            iconName: 'Camera',
            title: (0, $d5b6ce321475881f$export$21c51bc433c16634).labelSnapshots
        },
        {
            sideTabId: (0, $2752fa503c160704$export$f3b7566ffe363e3b).History,
            iconName: 'History',
            title: (0, $d5b6ce321475881f$export$21c51bc433c16634).labelHistory
        },
        {
            sideTabId: (0, $2752fa503c160704$export$f3b7566ffe363e3b).Transition,
            iconName: 'Flow',
            title: (0, $d5b6ce321475881f$export$21c51bc433c16634).labelTransition
        },
        {
            sideTabId: (0, $2752fa503c160704$export$f3b7566ffe363e3b).Settings,
            iconName: 'Settings',
            title: (0, $d5b6ce321475881f$export$21c51bc433c16634).labelChartSettings
        }
    ].filter(Boolean);
    return (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("div", {
        className: (0, $e295d8097c1ad61a$exports).classList('sanddance-sidebar', 'calculator', props.pinned && 'pinned', props.closed && 'closed')
    }, (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("div", {
        className: "sidebar-content"
    }, (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement((0, $86b892255d8eb4f0$export$3fb74a6ae4f1171d), Object.assign({}, props.dataScopeProps)), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("div", {
        className: "vbuttons"
    }, (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("div", {
        className: "sidebar-dialogs",
        role: 'tablist'
    }, sidebuttons.map((sidebutton, i)=>(0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement((0, $d7542c73853af2f5$export$a8fc19311f33df91), Object.assign({
            key: i
        }, props, sidebutton, {
            themePalette: props.themePalette
        })))), !props.hideSidebarControls && (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("div", {
        className: "sidebar-controls"
    }, (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement((0, $d7542c73853af2f5$export$a8fc19311f33df91), Object.assign({}, props, {
        omitAriaSelected: true,
        role: 'button',
        sideTabId: (0, $2752fa503c160704$export$f3b7566ffe363e3b).Pin,
        iconName: props.pinned ? 'Pinned' : 'Pin',
        title: props.pinned ? (0, $d5b6ce321475881f$export$21c51bc433c16634).buttonToolbarFloat : (0, $d5b6ce321475881f$export$21c51bc433c16634).buttonToolbarDock
    })), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement((0, $d7542c73853af2f5$export$a8fc19311f33df91), Object.assign({}, props, {
        omitAriaSelected: true,
        role: 'button',
        sideTabId: (0, $2752fa503c160704$export$f3b7566ffe363e3b).Collapse,
        iconName: props.closed ? 'DoubleChevronRight12' : 'DoubleChevronLeft12',
        title: props.closed ? (0, $d5b6ce321475881f$export$21c51bc433c16634).buttonToolbarShow : (0, $d5b6ce321475881f$export$21c51bc433c16634).buttonToolbarHide
    })))), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement((0, $c8096a1892befafb$export$fcc7818a78919c8c), {
        role: 'tabpanel'
    }, (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("div", {
        className: "sidetab"
    }, props.children)), props.calculating && (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("div", {
        className: "calculating"
    }, (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement((0, $a601a4135959dcb0$export$e2253033e6e1df16).fluentUI.Spinner, {
        size: (0, $a601a4135959dcb0$export$e2253033e6e1df16).fluentUI.SpinnerSize.large
    }))));
}


/*!
* Copyright (c) Microsoft Corporation.
* Licensed under the MIT License.
*/ /*!
* Copyright (c) Microsoft Corporation.
* Licensed under the MIT License.
*/ //adapted from https://github.com/OfficeDev/office-ui-fabric-react/blob/master/packages/fluent-theme/src/fluent/styles/CommandBarButton.styles.ts

const $c05716ad448a35c4$export$26e7026630023d76 = (props)=>{
    const { theme: theme } = props;
    if (!theme) throw new Error('Theme is undefined or null.');
    const { palette: palette, semanticColors: semanticColors } = theme;
    const BUTTON_ICON_CLASSNAME = '.ms-Button-icon';
    return {
        root: [
            Object.assign({}, (0, $a601a4135959dcb0$export$e2253033e6e1df16).fluentUI.getFocusStyle(theme, {
                inset: 2
            })),
            {
                backgroundColor: palette.white
            }
        ],
        rootHovered: {
            backgroundColor: palette.neutralLighter,
            selectors: {
                [BUTTON_ICON_CLASSNAME]: {
                    color: palette.themeDarkAlt
                }
            }
        },
        rootPressed: {
            backgroundColor: palette.neutralLight,
            color: palette.neutralDark,
            selectors: {
                [BUTTON_ICON_CLASSNAME]: {
                    color: palette.themeDark
                }
            }
        },
        rootChecked: {
            backgroundColor: palette.neutralLight,
            color: palette.neutralDark,
            selectors: {
                [BUTTON_ICON_CLASSNAME]: {
                    color: palette.themeDark
                }
            }
        },
        rootCheckedHovered: {
            backgroundColor: palette.neutralQuaternaryAlt,
            color: palette.neutralDark
        },
        rootExpanded: {
            color: palette.neutralDark,
            backgroundColor: palette.neutralLight,
            selectors: {
                [BUTTON_ICON_CLASSNAME]: {
                    color: palette.themeDark
                }
            }
        },
        rootExpandedHovered: {
            background: palette.neutralQuaternaryAlt
        },
        rootDisabled: {
            backgroundColor: palette.white,
            selectors: {
                [BUTTON_ICON_CLASSNAME]: {
                    color: semanticColors.disabledBodySubtext
                }
            }
        },
        splitButtonMenuButton: {
            backgroundColor: palette.white,
            color: palette.neutralSecondary,
            selectors: {
                ':hover': {
                    backgroundColor: palette.neutralLighter,
                    selectors: {
                        [BUTTON_ICON_CLASSNAME]: {
                            color: palette.neutralPrimary
                        }
                    }
                },
                ':active': {
                    backgroundColor: palette.neutralLight,
                    selectors: {
                        [BUTTON_ICON_CLASSNAME]: {
                            color: palette.neutralPrimary
                        }
                    }
                }
            }
        },
        splitButtonMenuButtonDisabled: {
            backgroundColor: palette.white
        },
        icon: {
            color: palette.themePrimary
        }
    };
};


/*!
* Copyright (c) Microsoft Corporation.
* Licensed under the MIT License.
*/ 
const $c0b58eaa2b5865b5$var$s = `
 ......
.......
...
......
 ......
    ...
.......
......
`;
const $c0b58eaa2b5865b5$var$d = $c0b58eaa2b5865b5$var$s.split('\n').map((row, irow)=>row.length ? row.split('').map((char, icol)=>char.trim() ? `M${2 * icol + 1} ${2 * (irow - 1) + 1} v1 h1 v-1 Z` : '').join(' ') : '').join('\n');
function $c0b58eaa2b5865b5$export$e6ff31bff12b7ff4() {
    return (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("svg", {
        xmlns: "http://www.w3.org/2000/svg",
        viewBox: "0 0 16 16"
    }, (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("path", {
        d: $c0b58eaa2b5865b5$var$d
    }));
}





function $17936d27f9fcfa1f$export$1ca1e38143dcc152(props) {
    var _a;
    const zeroResults = props.selectionState.selectedData && props.selectionState.selectedData.length === 0;
    const disabled = !props.loaded;
    const items = [
        {
            key: 'undo',
            name: (0, $d5b6ce321475881f$export$21c51bc433c16634).buttonUndo,
            iconProps: {
                iconName: 'Undo'
            },
            disabled: disabled || props.historyItems.length === 0 || props.historyIndex === 0,
            onClick: props.undo
        },
        {
            key: 'redo',
            name: (0, $d5b6ce321475881f$export$21c51bc433c16634).buttonRedo,
            iconProps: {
                iconName: 'Redo'
            },
            disabled: disabled || props.historyItems.length <= 1 || props.historyIndex >= props.historyItems.length - 1,
            onClick: props.redo
        },
        {
            key: 'deselect',
            name: (0, $d5b6ce321475881f$export$21c51bc433c16634).buttonDeselect,
            iconProps: {
                iconName: 'Cancel'
            },
            disabled: disabled || !props.selectionSearch,
            onClick: props.doDeselect
        },
        {
            key: 'isolate',
            name: (0, $d5b6ce321475881f$export$21c51bc433c16634).buttonIsolate,
            iconProps: {
                iconName: 'Filter'
            },
            disabled: disabled || !props.selectionSearch || zeroResults,
            onClick: ()=>props.doFilter(props.selectionSearch, (0, $d5b6ce321475881f$export$21c51bc433c16634).labelHistoryFilterIsolate)
        },
        {
            key: 'exclude',
            name: (0, $d5b6ce321475881f$export$21c51bc433c16634).buttonExclude,
            iconProps: {
                iconName: 'ClearFilter'
            },
            disabled: disabled || !props.selectionSearch || zeroResults,
            onClick: ()=>props.doFilter((0, $1342cf7df79546f0$exports).searchExpression.invert(props.selectionSearch), (0, $d5b6ce321475881f$export$21c51bc433c16634).labelHistoryFilterIExclude)
        },
        {
            key: 'reset',
            name: (0, $d5b6ce321475881f$export$21c51bc433c16634).buttonReset,
            iconProps: {
                iconName: 'RemoveFilter'
            },
            disabled: disabled || !props.filter,
            onClick: ()=>props.doUnfilter((0, $d5b6ce321475881f$export$21c51bc433c16634).labelHistoryFilterClear)
        }
    ];
    if (props.buttons) items.push.apply(items, props.buttons);
    if (props.collapseLabels) items.forEach((item)=>item.iconOnly = true);
    const farItems = [];
    if (!props.snapshotsHidden) farItems.push({
        key: 'previous-snapshot',
        iconProps: {
            iconName: 'Previous'
        },
        title: (0, $d5b6ce321475881f$export$21c51bc433c16634).buttonPrevSnapshot,
        onClick: props.onSnapshotPreviousClick,
        disabled: !props.snapshots || props.snapshots.length < 2
    }, {
        key: 'snapshot',
        iconProps: {
            iconName: 'Camera'
        },
        title: (0, $d5b6ce321475881f$export$21c51bc433c16634).buttonCreateSnapshot,
        onClick: props.onSnapshotClick,
        disabled: !props.loaded
    }, {
        key: 'next-snapshot',
        iconProps: {
            iconName: 'Next'
        },
        title: (0, $d5b6ce321475881f$export$21c51bc433c16634).buttonNextSnapshot,
        onClick: props.onSnapshotNextClick,
        disabled: !props.snapshots || props.snapshots.length < 2
    });
    farItems.push({
        key: 'view',
        iconProps: {
            iconName: props.view === '2d' ? 'CubeShape' : 'Page'
        },
        title: props.view === '2d' ? (0, $d5b6ce321475881f$export$21c51bc433c16634).labelViewType3d : (0, $d5b6ce321475881f$export$21c51bc433c16634).labelViewType2d,
        onClick: props.onViewClick,
        disabled: !props.loaded
    });
    if ((_a = props.iconButtons) === null || _a === void 0 ? void 0 : _a.length) farItems.push(...props.iconButtons);
    return (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("div", {
        className: "sanddance-explorer-topbar"
    }, (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("div", {
        className: "logo"
    }, (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement((0, $c0b58eaa2b5865b5$export$e6ff31bff12b7ff4), null), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("a", {
        href: props.logoClickUrl || '/',
        target: props.logoClickTarget || '_blank'
    }, (0, $d5b6ce321475881f$export$21c51bc433c16634).appName)), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("div", {
        className: "sanddance-explorer-commandbar"
    }, (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement((0, $a601a4135959dcb0$export$e2253033e6e1df16).fluentUI.Customizer, {
        scopedSettings: {
            CommandBarButton: {
                styles: (buttonProps)=>{
                    buttonProps.theme.palette = props.themePalette;
                    return (0, $c05716ad448a35c4$export$26e7026630023d76)(buttonProps);
                }
            }
        }
    }, (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement((0, $a601a4135959dcb0$export$e2253033e6e1df16).fluentUI.CommandBar, {
        items: items,
        farItems: farItems,
        styles: {
            root: {
                backgroundColor: 'transparent',
                height: 'unset',
                paddingLeft: 0,
                paddingRight: 0
            }
        }
    }))));
}


/*!
* Copyright (c) Microsoft Corporation.
* Licensed under the MIT License.
*/ 
const $105d7d4c8faa6087$export$9d26f8f2be82424f = (dataFile, columnTypes)=>new Promise((resolve, reject)=>{
        const vega = (0, $1342cf7df79546f0$exports).VegaMorphCharts.base.vega;
        const loader = vega.loader();
        function handleRawText(text) {
            let data;
            try {
                data = vega.read(text, {
                    type: dataFile.type,
                    parse: {}
                });
            } catch (e) {
                reject(e);
            }
            if (data) $105d7d4c8faa6087$export$c084150d12efae43(data, dataFile.type, columnTypes).then((dc)=>{
                if (dataFile.snapshotsUrl) fetch(dataFile.snapshotsUrl).then((response)=>response.json()).then((snapshots)=>{
                    dc.snapshots = snapshots;
                    resolve(dc);
                }).catch(reject);
                else if (dataFile.snapshots) {
                    dc.snapshots = dataFile.snapshots;
                    resolve(dc);
                } else resolve(dc);
            }).catch(reject);
        }
        if (dataFile.dataUrl) loader.load(dataFile.dataUrl).then(handleRawText).catch(reject);
        else if (dataFile.rawText) handleRawText(dataFile.rawText);
        else reject('dataFile object must have either dataUrl or rawText property set.');
    });
const $105d7d4c8faa6087$export$c084150d12efae43 = (data, type, columnTypes)=>new Promise((resolve, reject)=>{
        const parse = type === 'csv' || type === 'tsv';
        if (parse) //convert empty strings to null so that vega.inferType will get dates
        data.forEach((row)=>{
            for(const column in row)if (row[column] === '') row[column] = null;
        });
        const columns = (0, $1342cf7df79546f0$exports).util.getColumnsFromData((0, $1342cf7df79546f0$exports).VegaMorphCharts.base.vega.inferTypes, data, columnTypes).filter((c)=>c.name && c.name.trim()).sort((a, b)=>a.name.localeCompare(b.name));
        if (parse) {
            const booleanColumns = columns.filter((c)=>c.type === 'boolean');
            const dateColumns = columns.filter((c)=>c.type === 'date');
            const numericColumns = columns.filter((c)=>c.type === 'integer' || c.type === 'number');
            data.forEach((obj)=>{
                booleanColumns.forEach((c)=>{
                    obj[c.name] = ('' + obj[c.name]).toLowerCase() === 'true';
                });
                dateColumns.forEach((c)=>{
                    const input = obj[c.name];
                    if (input !== null) {
                        const d = new Date(input);
                        d.input = input;
                        obj[c.name] = d;
                    }
                });
                numericColumns.forEach((c)=>{
                    const n = parseFloat(obj[c.name]);
                    obj[c.name] = isNaN(n) ? null : n;
                });
            });
        }
        resolve({
            data: data,
            columns: columns
        });
    });


/*!
* Copyright (c) Microsoft Corporation.
* Licensed under the MIT License.
*/ /*!
* Copyright (c) Microsoft Corporation.
* Licensed under the MIT License.
*/ 
var $a7be03ae5c68c2c3$var$util = (0, $1342cf7df79546f0$exports).VegaMorphCharts.util;
const $a7be03ae5c68c2c3$export$3465a0e7b289ab72 = {};
$a7be03ae5c68c2c3$export$3465a0e7b289ab72[''] = {
    themePrimary: '#0078d4',
    themeLighterAlt: '#eff6fc',
    themeLighter: '#deecf9',
    themeLight: '#c7e0f4',
    themeTertiary: '#71afe5',
    themeSecondary: '#2b88d8',
    themeDarkAlt: '#106ebe',
    themeDark: '#005a9e',
    themeDarker: '#004578',
    neutralLighterAlt: '#faf9f8',
    neutralLighter: '#f3f2f1',
    neutralLight: '#edebe9',
    neutralQuaternaryAlt: '#e1dfdd',
    neutralQuaternary: '#d0d0d0',
    neutralTertiaryAlt: '#c8c6c4',
    neutralTertiary: '#595959',
    neutralSecondary: '#373737',
    neutralSecondaryAlt: '#373737',
    neutralPrimaryAlt: '#2f2f2f',
    neutralPrimary: '#000000',
    neutralDark: '#151515',
    black: '#0b0b0b',
    white: '#ffffff'
};
$a7be03ae5c68c2c3$export$3465a0e7b289ab72['dark-theme'] = {
    themePrimary: '#0078d4',
    themeLighterAlt: '#eff6fc',
    themeLighter: '#deecf9',
    themeLight: '#c7e0f4',
    themeTertiary: '#71afe5',
    themeSecondary: '#2b88d8',
    themeDarkAlt: '#106ebe',
    themeDark: '#005a9e',
    themeDarker: '#004578',
    neutralLighterAlt: '#0b0b0b',
    neutralLighter: '#151515',
    neutralLight: '#252525',
    neutralQuaternaryAlt: '#2f2f2f',
    neutralQuaternary: '#373737',
    neutralTertiaryAlt: '#595959',
    neutralTertiary: '#c8c8c8',
    neutralSecondary: '#d0d0d0',
    neutralSecondaryAlt: '#d0d0d0',
    neutralPrimaryAlt: '#dadada',
    neutralPrimary: '#ffffff',
    neutralDark: '#f4f4f4',
    black: '#f8f8f8',
    white: '#000000'
};
function $a7be03ae5c68c2c3$export$93a255849c3bdb97(themePalette) {
    const c = $a7be03ae5c68c2c3$var$util.colorFromString(themePalette.themeSecondary);
    c[3] = 256 / 3; // one-third opacity background
    return {
        axisLine: themePalette.black,
        axisText: themePalette.black,
        gridLine: themePalette.neutralLight,
        backgroundColor: themePalette.white,
        hoveredCube: themePalette.black,
        clickableText: themePalette.themeDark,
        clickableTextHighlight: $a7be03ae5c68c2c3$var$util.colorToString(c),
        searchText: themePalette.neutralPrimary,
        searchTextHighlight: themePalette.neutralPrimaryAlt
    };
}





const $2273a7d1147da1bc$export$a5975749f0374264 = 'Segoe UI, sans-serif';
const $2273a7d1147da1bc$export$fb736e4909afb3d7 = {
    colors: (0, $a7be03ae5c68c2c3$export$93a255849c3bdb97)((0, $a7be03ae5c68c2c3$export$3465a0e7b289ab72)['']),
    fontFamily: $2273a7d1147da1bc$export$a5975749f0374264
};
const $2273a7d1147da1bc$export$7e33de69431bbb06 = 300;
const $2273a7d1147da1bc$export$6093ee13d2f7fa25 = {
    advanced: false,
    advancedOptions: {
        bloomIntensity: 2,
        isBloomEnabled: false,
        isDofEnabled: false,
        dofFocusRange: 0.25,
        isFxaaEnabled: false,
        isShadowEnabled: true,
        isSsaoEnabled: true
    },
    basicOptions: {
        antialias: true
    }
};
function $2273a7d1147da1bc$export$d1b579ecf4cf2d3f(props) {
    const renderer = props.initialRenderer || $2273a7d1147da1bc$export$6093ee13d2f7fa25;
    if (!renderer.advancedOptions) renderer.advancedOptions = $2273a7d1147da1bc$export$6093ee13d2f7fa25.advancedOptions;
    if (!renderer.basicOptions) renderer.basicOptions = $2273a7d1147da1bc$export$6093ee13d2f7fa25.basicOptions;
    const state = {
        calculating: null,
        errors: null,
        autoCompleteDistinctValues: {},
        colorBin: null,
        dataContent: null,
        dataFile: null,
        search: null,
        totalStyle: null,
        facetStyle: 'wrap',
        filter: null,
        filteredData: null,
        specCapabilities: null,
        size: {
            height: null,
            width: null
        },
        scheme: null,
        transform: null,
        columns: null,
        chart: 'grid',
        signalValues: null,
        hideAxes: false,
        hideLegend: false,
        sideTabId: (0, $2752fa503c160704$export$f3b7566ffe363e3b).ChartType,
        dataScopeId: (0, $86b892255d8eb4f0$export$f0297ce57faf7d71).AllData,
        selectedItemIndex: {},
        sidebarClosed: props.initialSidebarClosed === undefined ? false : props.initialSidebarClosed,
        sidebarPinned: props.initialSidebarPinned === undefined ? true : props.initialSidebarPinned,
        view: props.initialView || '2d',
        snapshots: [],
        selectedSnapshotIndex: -1,
        tooltipExclusions: [],
        positionedColumnMapProps: null,
        note: null,
        historyIndex: -1,
        historyItems: [],
        renderer: renderer,
        transitionType: 'ordinal',
        transitionDimension: 'x',
        transitionDurations: (0, $1342cf7df79546f0$exports).VegaMorphCharts.util.clone((0, $1342cf7df79546f0$exports).VegaMorphCharts.defaults.defaultPresenterConfig.transitionDurations)
    };
    (0, $86b892255d8eb4f0$export$6d13117e74df8390)(state.selectedItemIndex);
    return state;
}



/*!
* Copyright (c) Microsoft Corporation.
* Licensed under the MIT License.
*/ 

/*!
* Copyright (c) Microsoft Corporation.
* Licensed under the MIT License.
*/ 
/*!
* Copyright (c) Microsoft Corporation.
* Licensed under the MIT License.
*/ 
/*!
* Copyright (c) Microsoft Corporation.
* Licensed under the MIT License.
*/ 
function $e94be5df56df841b$export$535452b9416b5e17(selected, scheme) {
    return {
        key: scheme,
        text: scheme,
        selected: selected === scheme,
        scheme: scheme,
        children: $e94be5df56df841b$export$dc7e195cef98649[scheme]
    };
}
function $e94be5df56df841b$export$3482e66b4441447f(key, text) {
    return {
        key: key,
        text: text,
        itemType: (0, $a601a4135959dcb0$export$e2253033e6e1df16).fluentUI.DropdownMenuItemType.Header
    };
}
const $e94be5df56df841b$export$dc7e195cef98649 = {};


const $604fb89637945be9$var$p8 = `${12.5}%`;
const $604fb89637945be9$var$p9 = `${100 / 9}%`;
const $604fb89637945be9$var$p10 = `${10}%`;
const $604fb89637945be9$var$p12 = `${100 / 12}%`;
const $604fb89637945be9$var$p20 = `${5}%`;
let $604fb89637945be9$var$loaded = false;
function $604fb89637945be9$var$load() {
    (0, $e94be5df56df841b$export$dc7e195cef98649)['accent'] = (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("div", {
        className: "swatch"
    }, (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("div", {
        title: "#7fc97f",
        style: {
            width: $604fb89637945be9$var$p8,
            background: 'rgb(127, 201, 127)'
        }
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("div", {
        title: "#beaed4",
        style: {
            width: $604fb89637945be9$var$p8,
            background: 'rgb(190, 174, 212)'
        }
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("div", {
        title: "#fdc086",
        style: {
            width: $604fb89637945be9$var$p8,
            background: 'rgb(253, 192, 134)'
        }
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("div", {
        title: "#ffff99",
        style: {
            width: $604fb89637945be9$var$p8,
            background: 'rgb(255, 255, 153)'
        }
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("div", {
        title: "#386cb0",
        style: {
            width: $604fb89637945be9$var$p8,
            background: 'rgb(56, 108, 176)'
        }
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("div", {
        title: "#f0027f",
        style: {
            width: $604fb89637945be9$var$p8,
            background: 'rgb(240, 2, 127)'
        }
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("div", {
        title: "#bf5b17",
        style: {
            width: $604fb89637945be9$var$p8,
            background: 'rgb(191, 91, 23)'
        }
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("div", {
        title: "#666666",
        style: {
            width: $604fb89637945be9$var$p8,
            background: 'rgb(102, 102, 102)'
        }
    }));
    (0, $e94be5df56df841b$export$dc7e195cef98649)['category10'] = (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("div", {
        className: "swatch"
    }, (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("div", {
        title: "#1f77b4",
        style: {
            width: $604fb89637945be9$var$p10,
            background: 'rgb(31, 119, 180)'
        }
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("div", {
        title: "#ff7f0e",
        style: {
            width: $604fb89637945be9$var$p10,
            background: 'rgb(255, 127, 14)'
        }
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("div", {
        title: "#2ca02c",
        style: {
            width: $604fb89637945be9$var$p10,
            background: 'rgb(44, 160, 44)'
        }
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("div", {
        title: "#d62728",
        style: {
            width: $604fb89637945be9$var$p10,
            background: 'rgb(214, 39, 40)'
        }
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("div", {
        title: "#9467bd",
        style: {
            width: $604fb89637945be9$var$p10,
            background: 'rgb(148, 103, 189)'
        }
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("div", {
        title: "#8c564b",
        style: {
            width: $604fb89637945be9$var$p10,
            background: 'rgb(140, 86, 75)'
        }
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("div", {
        title: "#e377c2",
        style: {
            width: $604fb89637945be9$var$p10,
            background: 'rgb(227, 119, 194)'
        }
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("div", {
        title: "#7f7f7f",
        style: {
            width: $604fb89637945be9$var$p10,
            background: 'rgb(127, 127, 127)'
        }
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("div", {
        title: "#bcbd22",
        style: {
            width: $604fb89637945be9$var$p10,
            background: 'rgb(188, 189, 34)'
        }
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("div", {
        title: "#17becf",
        style: {
            width: $604fb89637945be9$var$p10,
            background: 'rgb(23, 190, 207)'
        }
    }));
    (0, $e94be5df56df841b$export$dc7e195cef98649)['category20'] = (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("div", {
        className: "swatch"
    }, (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("div", {
        title: "#1f77b4",
        style: {
            width: $604fb89637945be9$var$p20,
            background: 'rgb(31, 119, 180)'
        }
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("div", {
        title: "#aec7e8",
        style: {
            width: $604fb89637945be9$var$p20,
            background: 'rgb(174, 199, 232)'
        }
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("div", {
        title: "#ff7f0e",
        style: {
            width: $604fb89637945be9$var$p20,
            background: 'rgb(255, 127, 14)'
        }
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("div", {
        title: "#ffbb78",
        style: {
            width: $604fb89637945be9$var$p20,
            background: 'rgb(255, 187, 120)'
        }
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("div", {
        title: "#2ca02c",
        style: {
            width: $604fb89637945be9$var$p20,
            background: 'rgb(44, 160, 44)'
        }
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("div", {
        title: "#98df8a",
        style: {
            width: $604fb89637945be9$var$p20,
            background: 'rgb(152, 223, 138)'
        }
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("div", {
        title: "#d62728",
        style: {
            width: $604fb89637945be9$var$p20,
            background: 'rgb(214, 39, 40)'
        }
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("div", {
        title: "#ff9896",
        style: {
            width: $604fb89637945be9$var$p20,
            background: 'rgb(255, 152, 150)'
        }
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("div", {
        title: "#9467bd",
        style: {
            width: $604fb89637945be9$var$p20,
            background: 'rgb(148, 103, 189)'
        }
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("div", {
        title: "#c5b0d5",
        style: {
            width: $604fb89637945be9$var$p20,
            background: 'rgb(197, 176, 213)'
        }
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("div", {
        title: "#8c564b",
        style: {
            width: $604fb89637945be9$var$p20,
            background: 'rgb(140, 86, 75)'
        }
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("div", {
        title: "#c49c94",
        style: {
            width: $604fb89637945be9$var$p20,
            background: 'rgb(196, 156, 148)'
        }
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("div", {
        title: "#e377c2",
        style: {
            width: $604fb89637945be9$var$p20,
            background: 'rgb(227, 119, 194)'
        }
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("div", {
        title: "#f7b6d2",
        style: {
            width: $604fb89637945be9$var$p20,
            background: 'rgb(247, 182, 210)'
        }
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("div", {
        title: "#7f7f7f",
        style: {
            width: $604fb89637945be9$var$p20,
            background: 'rgb(127, 127, 127)'
        }
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("div", {
        title: "#c7c7c7",
        style: {
            width: $604fb89637945be9$var$p20,
            background: 'rgb(199, 199, 199)'
        }
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("div", {
        title: "#bcbd22",
        style: {
            width: $604fb89637945be9$var$p20,
            background: 'rgb(188, 189, 34)'
        }
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("div", {
        title: "#dbdb8d",
        style: {
            width: $604fb89637945be9$var$p20,
            background: 'rgb(219, 219, 141)'
        }
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("div", {
        title: "#17becf",
        style: {
            width: $604fb89637945be9$var$p20,
            background: 'rgb(23, 190, 207)'
        }
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("div", {
        title: "#9edae5",
        style: {
            width: $604fb89637945be9$var$p20,
            background: 'rgb(158, 218, 229)'
        }
    }));
    (0, $e94be5df56df841b$export$dc7e195cef98649)['category20b'] = (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("div", {
        className: "swatch"
    }, (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("div", {
        title: "#393b79",
        style: {
            width: $604fb89637945be9$var$p20,
            background: 'rgb(57, 59, 121)'
        }
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("div", {
        title: "#5254a3",
        style: {
            width: $604fb89637945be9$var$p20,
            background: 'rgb(82, 84, 163)'
        }
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("div", {
        title: "#6b6ecf",
        style: {
            width: $604fb89637945be9$var$p20,
            background: 'rgb(107, 110, 207)'
        }
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("div", {
        title: "#9c9ede",
        style: {
            width: $604fb89637945be9$var$p20,
            background: 'rgb(156, 158, 222)'
        }
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("div", {
        title: "#637939",
        style: {
            width: $604fb89637945be9$var$p20,
            background: 'rgb(99, 121, 57)'
        }
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("div", {
        title: "#8ca252",
        style: {
            width: $604fb89637945be9$var$p20,
            background: 'rgb(140, 162, 82)'
        }
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("div", {
        title: "#b5cf6b",
        style: {
            width: $604fb89637945be9$var$p20,
            background: 'rgb(181, 207, 107)'
        }
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("div", {
        title: "#cedb9c",
        style: {
            width: $604fb89637945be9$var$p20,
            background: 'rgb(206, 219, 156)'
        }
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("div", {
        title: "#8c6d31",
        style: {
            width: $604fb89637945be9$var$p20,
            background: 'rgb(140, 109, 49)'
        }
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("div", {
        title: "#bd9e39",
        style: {
            width: $604fb89637945be9$var$p20,
            background: 'rgb(189, 158, 57)'
        }
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("div", {
        title: "#e7ba52",
        style: {
            width: $604fb89637945be9$var$p20,
            background: 'rgb(231, 186, 82)'
        }
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("div", {
        title: "#e7cb94",
        style: {
            width: $604fb89637945be9$var$p20,
            background: 'rgb(231, 203, 148)'
        }
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("div", {
        title: "#843c39",
        style: {
            width: $604fb89637945be9$var$p20,
            background: 'rgb(132, 60, 57)'
        }
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("div", {
        title: "#ad494a",
        style: {
            width: $604fb89637945be9$var$p20,
            background: 'rgb(173, 73, 74)'
        }
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("div", {
        title: "#d6616b",
        style: {
            width: $604fb89637945be9$var$p20,
            background: 'rgb(214, 97, 107)'
        }
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("div", {
        title: "#e7969c",
        style: {
            width: $604fb89637945be9$var$p20,
            background: 'rgb(231, 150, 156)'
        }
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("div", {
        title: "#7b4173",
        style: {
            width: $604fb89637945be9$var$p20,
            background: 'rgb(123, 65, 115)'
        }
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("div", {
        title: "#a55194",
        style: {
            width: $604fb89637945be9$var$p20,
            background: 'rgb(165, 81, 148)'
        }
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("div", {
        title: "#ce6dbd",
        style: {
            width: $604fb89637945be9$var$p20,
            background: 'rgb(206, 109, 189)'
        }
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("div", {
        title: "#de9ed6",
        style: {
            width: $604fb89637945be9$var$p20,
            background: 'rgb(222, 158, 214)'
        }
    }));
    (0, $e94be5df56df841b$export$dc7e195cef98649)['category20c'] = (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("div", {
        className: "swatch"
    }, (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("div", {
        title: "#3182bd",
        style: {
            width: $604fb89637945be9$var$p20,
            background: 'rgb(49, 130, 189)'
        }
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("div", {
        title: "#6baed6",
        style: {
            width: $604fb89637945be9$var$p20,
            background: 'rgb(107, 174, 214)'
        }
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("div", {
        title: "#9ecae1",
        style: {
            width: $604fb89637945be9$var$p20,
            background: 'rgb(158, 202, 225)'
        }
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("div", {
        title: "#c6dbef",
        style: {
            width: $604fb89637945be9$var$p20,
            background: 'rgb(198, 219, 239)'
        }
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("div", {
        title: "#e6550d",
        style: {
            width: $604fb89637945be9$var$p20,
            background: 'rgb(230, 85, 13)'
        }
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("div", {
        title: "#fd8d3c",
        style: {
            width: $604fb89637945be9$var$p20,
            background: 'rgb(253, 141, 60)'
        }
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("div", {
        title: "#fdae6b",
        style: {
            width: $604fb89637945be9$var$p20,
            background: 'rgb(253, 174, 107)'
        }
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("div", {
        title: "#fdd0a2",
        style: {
            width: $604fb89637945be9$var$p20,
            background: 'rgb(253, 208, 162)'
        }
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("div", {
        title: "#31a354",
        style: {
            width: $604fb89637945be9$var$p20,
            background: 'rgb(49, 163, 84)'
        }
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("div", {
        title: "#74c476",
        style: {
            width: $604fb89637945be9$var$p20,
            background: 'rgb(116, 196, 118)'
        }
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("div", {
        title: "#a1d99b",
        style: {
            width: $604fb89637945be9$var$p20,
            background: 'rgb(161, 217, 155)'
        }
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("div", {
        title: "#c7e9c0",
        style: {
            width: $604fb89637945be9$var$p20,
            background: 'rgb(199, 233, 192)'
        }
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("div", {
        title: "#756bb1",
        style: {
            width: $604fb89637945be9$var$p20,
            background: 'rgb(117, 107, 177)'
        }
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("div", {
        title: "#9e9ac8",
        style: {
            width: $604fb89637945be9$var$p20,
            background: 'rgb(158, 154, 200)'
        }
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("div", {
        title: "#bcbddc",
        style: {
            width: $604fb89637945be9$var$p20,
            background: 'rgb(188, 189, 220)'
        }
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("div", {
        title: "#dadaeb",
        style: {
            width: $604fb89637945be9$var$p20,
            background: 'rgb(218, 218, 235)'
        }
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("div", {
        title: "#636363",
        style: {
            width: $604fb89637945be9$var$p20,
            background: 'rgb(99, 99, 99)'
        }
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("div", {
        title: "#969696",
        style: {
            width: $604fb89637945be9$var$p20,
            background: 'rgb(150, 150, 150)'
        }
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("div", {
        title: "#bdbdbd",
        style: {
            width: $604fb89637945be9$var$p20,
            background: 'rgb(189, 189, 189)'
        }
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("div", {
        title: "#d9d9d9",
        style: {
            width: $604fb89637945be9$var$p20,
            background: 'rgb(217, 217, 217)'
        }
    }));
    (0, $e94be5df56df841b$export$dc7e195cef98649)['dark2'] = (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("div", {
        className: "swatch"
    }, (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("div", {
        title: "#1b9e77",
        style: {
            width: $604fb89637945be9$var$p8,
            background: 'rgb(27, 158, 119)'
        }
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("div", {
        title: "#d95f02",
        style: {
            width: $604fb89637945be9$var$p8,
            background: 'rgb(217, 95, 2)'
        }
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("div", {
        title: "#7570b3",
        style: {
            width: $604fb89637945be9$var$p8,
            background: 'rgb(117, 112, 179)'
        }
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("div", {
        title: "#e7298a",
        style: {
            width: $604fb89637945be9$var$p8,
            background: 'rgb(231, 41, 138)'
        }
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("div", {
        title: "#66a61e",
        style: {
            width: $604fb89637945be9$var$p8,
            background: 'rgb(102, 166, 30)'
        }
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("div", {
        title: "#e6ab02",
        style: {
            width: $604fb89637945be9$var$p8,
            background: 'rgb(230, 171, 2)'
        }
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("div", {
        title: "#a6761d",
        style: {
            width: $604fb89637945be9$var$p8,
            background: 'rgb(166, 118, 29)'
        }
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("div", {
        title: "#666666",
        style: {
            width: $604fb89637945be9$var$p8,
            background: 'rgb(102, 102, 102)'
        }
    }));
    (0, $e94be5df56df841b$export$dc7e195cef98649)['paired'] = (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("div", {
        className: "swatch"
    }, (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("div", {
        title: "#a6cee3",
        style: {
            width: $604fb89637945be9$var$p12,
            background: 'rgb(166, 206, 227)'
        }
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("div", {
        title: "#1f78b4",
        style: {
            width: $604fb89637945be9$var$p12,
            background: 'rgb(31, 120, 180)'
        }
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("div", {
        title: "#b2df8a",
        style: {
            width: $604fb89637945be9$var$p12,
            background: 'rgb(178, 223, 138)'
        }
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("div", {
        title: "#33a02c",
        style: {
            width: $604fb89637945be9$var$p12,
            background: 'rgb(51, 160, 44)'
        }
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("div", {
        title: "#fb9a99",
        style: {
            width: $604fb89637945be9$var$p12,
            background: 'rgb(251, 154, 153)'
        }
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("div", {
        title: "#e31a1c",
        style: {
            width: $604fb89637945be9$var$p12,
            background: 'rgb(227, 26, 28)'
        }
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("div", {
        title: "#fdbf6f",
        style: {
            width: $604fb89637945be9$var$p12,
            background: 'rgb(253, 191, 111)'
        }
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("div", {
        title: "#ff7f00",
        style: {
            width: $604fb89637945be9$var$p12,
            background: 'rgb(255, 127, 0)'
        }
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("div", {
        title: "#cab2d6",
        style: {
            width: $604fb89637945be9$var$p12,
            background: 'rgb(202, 178, 214)'
        }
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("div", {
        title: "#6a3d9a",
        style: {
            width: $604fb89637945be9$var$p12,
            background: 'rgb(106, 61, 154)'
        }
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("div", {
        title: "#ffff99",
        style: {
            width: $604fb89637945be9$var$p12,
            background: 'rgb(255, 255, 153)'
        }
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("div", {
        title: "#b15928",
        style: {
            width: $604fb89637945be9$var$p12,
            background: 'rgb(177, 89, 40)'
        }
    }));
    (0, $e94be5df56df841b$export$dc7e195cef98649)['pastel1'] = (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("div", {
        className: "swatch"
    }, (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("div", {
        title: "#fbb4ae",
        style: {
            width: $604fb89637945be9$var$p9,
            background: 'rgb(251, 180, 174)'
        }
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("div", {
        title: "#b3cde3",
        style: {
            width: $604fb89637945be9$var$p9,
            background: 'rgb(179, 205, 227)'
        }
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("div", {
        title: "#ccebc5",
        style: {
            width: $604fb89637945be9$var$p9,
            background: 'rgb(204, 235, 197)'
        }
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("div", {
        title: "#decbe4",
        style: {
            width: $604fb89637945be9$var$p9,
            background: 'rgb(222, 203, 228)'
        }
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("div", {
        title: "#fed9a6",
        style: {
            width: $604fb89637945be9$var$p9,
            background: 'rgb(254, 217, 166)'
        }
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("div", {
        title: "#ffffcc",
        style: {
            width: $604fb89637945be9$var$p9,
            background: 'rgb(255, 255, 204)'
        }
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("div", {
        title: "#e5d8bd",
        style: {
            width: $604fb89637945be9$var$p9,
            background: 'rgb(229, 216, 189)'
        }
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("div", {
        title: "#fddaec",
        style: {
            width: $604fb89637945be9$var$p9,
            background: 'rgb(253, 218, 236)'
        }
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("div", {
        title: "#f2f2f2",
        style: {
            width: $604fb89637945be9$var$p9,
            background: 'rgb(242, 242, 242)'
        }
    }));
    (0, $e94be5df56df841b$export$dc7e195cef98649)['pastel2'] = (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("div", {
        className: "swatch"
    }, (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("div", {
        title: "#b3e2cd",
        style: {
            width: $604fb89637945be9$var$p8,
            background: 'rgb(179, 226, 205)'
        }
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("div", {
        title: "#fdcdac",
        style: {
            width: $604fb89637945be9$var$p8,
            background: 'rgb(253, 205, 172)'
        }
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("div", {
        title: "#cbd5e8",
        style: {
            width: $604fb89637945be9$var$p8,
            background: 'rgb(203, 213, 232)'
        }
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("div", {
        title: "#f4cae4",
        style: {
            width: $604fb89637945be9$var$p8,
            background: 'rgb(244, 202, 228)'
        }
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("div", {
        title: "#e6f5c9",
        style: {
            width: $604fb89637945be9$var$p8,
            background: 'rgb(230, 245, 201)'
        }
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("div", {
        title: "#fff2ae",
        style: {
            width: $604fb89637945be9$var$p8,
            background: 'rgb(255, 242, 174)'
        }
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("div", {
        title: "#f1e2cc",
        style: {
            width: $604fb89637945be9$var$p8,
            background: 'rgb(241, 226, 204)'
        }
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("div", {
        title: "#cccccc",
        style: {
            width: $604fb89637945be9$var$p8,
            background: 'rgb(204, 204, 204)'
        }
    }));
    (0, $e94be5df56df841b$export$dc7e195cef98649)['set1'] = (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("div", {
        className: "swatch"
    }, (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("div", {
        title: "#e41a1c",
        style: {
            width: $604fb89637945be9$var$p9,
            background: 'rgb(228, 26, 28)'
        }
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("div", {
        title: "#377eb8",
        style: {
            width: $604fb89637945be9$var$p9,
            background: 'rgb(55, 126, 184)'
        }
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("div", {
        title: "#4daf4a",
        style: {
            width: $604fb89637945be9$var$p9,
            background: 'rgb(77, 175, 74)'
        }
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("div", {
        title: "#984ea3",
        style: {
            width: $604fb89637945be9$var$p9,
            background: 'rgb(152, 78, 163)'
        }
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("div", {
        title: "#ff7f00",
        style: {
            width: $604fb89637945be9$var$p9,
            background: 'rgb(255, 127, 0)'
        }
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("div", {
        title: "#ffff33",
        style: {
            width: $604fb89637945be9$var$p9,
            background: 'rgb(255, 255, 51)'
        }
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("div", {
        title: "#a65628",
        style: {
            width: $604fb89637945be9$var$p9,
            background: 'rgb(166, 86, 40)'
        }
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("div", {
        title: "#f781bf",
        style: {
            width: $604fb89637945be9$var$p9,
            background: 'rgb(247, 129, 191)'
        }
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("div", {
        title: "#999999",
        style: {
            width: $604fb89637945be9$var$p9,
            background: 'rgb(153, 153, 153)'
        }
    }));
    (0, $e94be5df56df841b$export$dc7e195cef98649)['set2'] = (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("div", {
        className: "swatch"
    }, (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("div", {
        title: "#66c2a5",
        style: {
            width: $604fb89637945be9$var$p8,
            background: 'rgb(102, 194, 165)'
        }
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("div", {
        title: "#fc8d62",
        style: {
            width: $604fb89637945be9$var$p8,
            background: 'rgb(252, 141, 98)'
        }
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("div", {
        title: "#8da0cb",
        style: {
            width: $604fb89637945be9$var$p8,
            background: 'rgb(141, 160, 203)'
        }
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("div", {
        title: "#e78ac3",
        style: {
            width: $604fb89637945be9$var$p8,
            background: 'rgb(231, 138, 195)'
        }
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("div", {
        title: "#a6d854",
        style: {
            width: $604fb89637945be9$var$p8,
            background: 'rgb(166, 216, 84)'
        }
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("div", {
        title: "#ffd92f",
        style: {
            width: $604fb89637945be9$var$p8,
            background: 'rgb(255, 217, 47)'
        }
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("div", {
        title: "#e5c494",
        style: {
            width: $604fb89637945be9$var$p8,
            background: 'rgb(229, 196, 148)'
        }
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("div", {
        title: "#b3b3b3",
        style: {
            width: $604fb89637945be9$var$p8,
            background: 'rgb(179, 179, 179)'
        }
    }));
    (0, $e94be5df56df841b$export$dc7e195cef98649)['set3'] = (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("div", {
        className: "swatch"
    }, (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("div", {
        title: "#8dd3c7",
        style: {
            width: $604fb89637945be9$var$p12,
            background: 'rgb(141, 211, 199)'
        }
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("div", {
        title: "#ffffb3",
        style: {
            width: $604fb89637945be9$var$p12,
            background: 'rgb(255, 255, 179)'
        }
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("div", {
        title: "#bebada",
        style: {
            width: $604fb89637945be9$var$p12,
            background: 'rgb(190, 186, 218)'
        }
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("div", {
        title: "#fb8072",
        style: {
            width: $604fb89637945be9$var$p12,
            background: 'rgb(251, 128, 114)'
        }
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("div", {
        title: "#80b1d3",
        style: {
            width: $604fb89637945be9$var$p12,
            background: 'rgb(128, 177, 211)'
        }
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("div", {
        title: "#fdb462",
        style: {
            width: $604fb89637945be9$var$p12,
            background: 'rgb(253, 180, 98)'
        }
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("div", {
        title: "#b3de69",
        style: {
            width: $604fb89637945be9$var$p12,
            background: 'rgb(179, 222, 105)'
        }
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("div", {
        title: "#fccde5",
        style: {
            width: $604fb89637945be9$var$p12,
            background: 'rgb(252, 205, 229)'
        }
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("div", {
        title: "#d9d9d9",
        style: {
            width: $604fb89637945be9$var$p12,
            background: 'rgb(217, 217, 217)'
        }
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("div", {
        title: "#bc80bd",
        style: {
            width: $604fb89637945be9$var$p12,
            background: 'rgb(188, 128, 189)'
        }
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("div", {
        title: "#ccebc5",
        style: {
            width: $604fb89637945be9$var$p12,
            background: 'rgb(204, 235, 197)'
        }
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("div", {
        title: "#ffed6f",
        style: {
            width: $604fb89637945be9$var$p12,
            background: 'rgb(255, 237, 111)'
        }
    }));
    (0, $e94be5df56df841b$export$dc7e195cef98649)['tableau10'] = (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("div", {
        className: "swatch"
    }, (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("div", {
        title: "#4c78a8",
        style: {
            width: $604fb89637945be9$var$p10,
            background: 'rgb(76, 120, 168)'
        }
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("div", {
        title: "#f58518",
        style: {
            width: $604fb89637945be9$var$p10,
            background: 'rgb(245, 133, 24)'
        }
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("div", {
        title: "#e45756",
        style: {
            width: $604fb89637945be9$var$p10,
            background: 'rgb(228, 87, 86)'
        }
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("div", {
        title: "#72b7b2",
        style: {
            width: $604fb89637945be9$var$p10,
            background: 'rgb(114, 183, 178)'
        }
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("div", {
        title: "#54a24b",
        style: {
            width: $604fb89637945be9$var$p10,
            background: 'rgb(84, 162, 75)'
        }
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("div", {
        title: "#eeca3b",
        style: {
            width: $604fb89637945be9$var$p10,
            background: 'rgb(238, 202, 59)'
        }
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("div", {
        title: "#b279a2",
        style: {
            width: $604fb89637945be9$var$p10,
            background: 'rgb(178, 121, 162)'
        }
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("div", {
        title: "#ff9da6",
        style: {
            width: $604fb89637945be9$var$p10,
            background: 'rgb(255, 157, 166)'
        }
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("div", {
        title: "#9d755d",
        style: {
            width: $604fb89637945be9$var$p10,
            background: 'rgb(157, 117, 93)'
        }
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("div", {
        title: "#bab0ac",
        style: {
            width: $604fb89637945be9$var$p10,
            background: 'rgb(186, 176, 172)'
        }
    }));
    (0, $e94be5df56df841b$export$dc7e195cef98649)['tableau20'] = (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("div", {
        className: "swatch"
    }, (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("div", {
        title: "#4c78a8",
        style: {
            width: $604fb89637945be9$var$p20,
            background: 'rgb(76, 120, 168)'
        }
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("div", {
        title: "#9ecae9",
        style: {
            width: $604fb89637945be9$var$p20,
            background: 'rgb(158, 202, 233)'
        }
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("div", {
        title: "#f58518",
        style: {
            width: $604fb89637945be9$var$p20,
            background: 'rgb(245, 133, 24)'
        }
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("div", {
        title: "#ffbf79",
        style: {
            width: $604fb89637945be9$var$p20,
            background: 'rgb(255, 191, 121)'
        }
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("div", {
        title: "#54a24b",
        style: {
            width: $604fb89637945be9$var$p20,
            background: 'rgb(84, 162, 75)'
        }
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("div", {
        title: "#88d27a",
        style: {
            width: $604fb89637945be9$var$p20,
            background: 'rgb(136, 210, 122)'
        }
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("div", {
        title: "#b79a20",
        style: {
            width: $604fb89637945be9$var$p20,
            background: 'rgb(183, 154, 32)'
        }
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("div", {
        title: "#f2cf5b",
        style: {
            width: $604fb89637945be9$var$p20,
            background: 'rgb(242, 207, 91)'
        }
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("div", {
        title: "#439894",
        style: {
            width: $604fb89637945be9$var$p20,
            background: 'rgb(67, 152, 148)'
        }
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("div", {
        title: "#83bcb6",
        style: {
            width: $604fb89637945be9$var$p20,
            background: 'rgb(131, 188, 182)'
        }
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("div", {
        title: "#e45756",
        style: {
            width: $604fb89637945be9$var$p20,
            background: 'rgb(228, 87, 86)'
        }
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("div", {
        title: "#ff9d98",
        style: {
            width: $604fb89637945be9$var$p20,
            background: 'rgb(255, 157, 152)'
        }
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("div", {
        title: "#79706e",
        style: {
            width: $604fb89637945be9$var$p20,
            background: 'rgb(121, 112, 110)'
        }
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("div", {
        title: "#bab0ac",
        style: {
            width: $604fb89637945be9$var$p20,
            background: 'rgb(186, 176, 172)'
        }
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("div", {
        title: "#d67195",
        style: {
            width: $604fb89637945be9$var$p20,
            background: 'rgb(214, 113, 149)'
        }
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("div", {
        title: "#fcbfd2",
        style: {
            width: $604fb89637945be9$var$p20,
            background: 'rgb(252, 191, 210)'
        }
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("div", {
        title: "#b279a2",
        style: {
            width: $604fb89637945be9$var$p20,
            background: 'rgb(178, 121, 162)'
        }
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("div", {
        title: "#d6a5c9",
        style: {
            width: $604fb89637945be9$var$p20,
            background: 'rgb(214, 165, 201)'
        }
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("div", {
        title: "#9e765f",
        style: {
            width: $604fb89637945be9$var$p20,
            background: 'rgb(158, 118, 95)'
        }
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("div", {
        title: "#d8b5a5",
        style: {
            width: $604fb89637945be9$var$p20,
            background: 'rgb(216, 181, 165)'
        }
    }));
    $604fb89637945be9$var$loaded = true;
}
function $604fb89637945be9$export$f3a499247c9822d1(selected) {
    if (!$604fb89637945be9$var$loaded) $604fb89637945be9$var$load();
    return [
        (0, $e94be5df56df841b$export$535452b9416b5e17)(selected, 'accent'),
        (0, $e94be5df56df841b$export$535452b9416b5e17)(selected, 'category10'),
        (0, $e94be5df56df841b$export$535452b9416b5e17)(selected, 'category20'),
        (0, $e94be5df56df841b$export$535452b9416b5e17)(selected, 'category20b'),
        (0, $e94be5df56df841b$export$535452b9416b5e17)(selected, 'category20c'),
        (0, $e94be5df56df841b$export$535452b9416b5e17)(selected, 'dark2'),
        (0, $e94be5df56df841b$export$535452b9416b5e17)(selected, 'paired'),
        (0, $e94be5df56df841b$export$535452b9416b5e17)(selected, 'pastel1'),
        (0, $e94be5df56df841b$export$535452b9416b5e17)(selected, 'pastel2'),
        (0, $e94be5df56df841b$export$535452b9416b5e17)(selected, 'set1'),
        (0, $e94be5df56df841b$export$535452b9416b5e17)(selected, 'set2'),
        (0, $e94be5df56df841b$export$535452b9416b5e17)(selected, 'set3'),
        (0, $e94be5df56df841b$export$535452b9416b5e17)(selected, 'tableau10'),
        (0, $e94be5df56df841b$export$535452b9416b5e17)(selected, 'tableau20')
    ];
}


/*!
* Copyright (c) Microsoft Corporation.
* Licensed under the MIT License.
*/ 

let $557d0cbc8fb1bfa4$var$loaded = false;
function $557d0cbc8fb1bfa4$var$load() {
    (0, $e94be5df56df841b$export$dc7e195cef98649)['rainbow'] = (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("svg", {
        viewBox: "0,0,1,1",
        preserveAspectRatio: "none"
    }, (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("defs", null, (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("linearGradient", {
        id: "gradient-rainbow"
    }, (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "0%",
        stopColor: "#6e40aa"
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "10%",
        stopColor: "#bf3caf"
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "20%",
        stopColor: "#fe4b83"
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "30%",
        stopColor: "#ff7847"
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "40%",
        stopColor: "#e2b72f"
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "50%",
        stopColor: "#aff05b"
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "60%",
        stopColor: "#52f667"
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "70%",
        stopColor: "#1ddfa3"
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "80%",
        stopColor: "#23abd8"
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "90%",
        stopColor: "#4c6edb"
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "100%",
        stopColor: "#6e40aa"
    }))), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("rect", {
        fill: "url(#gradient-rainbow)",
        x: "0",
        y: "0",
        width: "1",
        height: "1"
    }));
    (0, $e94be5df56df841b$export$dc7e195cef98649)['sinebow'] = (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("svg", {
        viewBox: "0,0,1,1",
        preserveAspectRatio: "none"
    }, (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("defs", null, (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("linearGradient", {
        id: "gradient-sinebow"
    }, (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "0%",
        stopColor: "#ff4040"
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "10%",
        stopColor: "#e78d0b"
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "20%",
        stopColor: "#a7d503"
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "30%",
        stopColor: "#58fc2a"
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "40%",
        stopColor: "#18f472"
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "50%",
        stopColor: "#00bfbf"
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "60%",
        stopColor: "#1872f4"
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "70%",
        stopColor: "#582afc"
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "80%",
        stopColor: "#a703d5"
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "90%",
        stopColor: "#e70b8d"
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "100%",
        stopColor: "#ff4040"
    }))), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("rect", {
        fill: "url(#gradient-sinebow)",
        x: "0",
        y: "0",
        width: "1",
        height: "1"
    }));
    $557d0cbc8fb1bfa4$var$loaded = true;
}
function $557d0cbc8fb1bfa4$export$6b2b632c28721cf0(selected) {
    if (!$557d0cbc8fb1bfa4$var$loaded) $557d0cbc8fb1bfa4$var$load();
    return [
        (0, $e94be5df56df841b$export$535452b9416b5e17)(selected, 'rainbow'),
        (0, $e94be5df56df841b$export$535452b9416b5e17)(selected, 'sinebow')
    ];
}


/*!
* Copyright (c) Microsoft Corporation.
* Licensed under the MIT License.
*/ 

let $c865794ee37c2239$var$loaded = false;
function $c865794ee37c2239$var$load() {
    (0, $e94be5df56df841b$export$dc7e195cef98649)['blueorange'] = (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("svg", {
        viewBox: "0,0,1,1",
        preserveAspectRatio: "none"
    }, (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("defs", null, (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("linearGradient", {
        id: "gradient-blueorange"
    }, (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "0%",
        stopColor: "rgb(5, 48, 97)"
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "10%",
        stopColor: "rgb(34, 101, 163)"
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "20%",
        stopColor: "rgb(75, 148, 196)"
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "30%",
        stopColor: "rgb(143, 194, 221)"
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "40%",
        stopColor: "rgb(205, 227, 238)"
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "50%",
        stopColor: "rgb(242, 240, 235)"
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "60%",
        stopColor: "rgb(253, 221, 179)"
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "70%",
        stopColor: "rgb(248, 182, 100)"
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "80%",
        stopColor: "rgb(221, 132, 31)"
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "90%",
        stopColor: "rgb(178, 90, 9)"
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "100%",
        stopColor: "rgb(127, 59, 8)"
    }))), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("rect", {
        fill: "url(#gradient-blueorange)",
        x: "0",
        y: "0",
        width: "1",
        height: "1"
    }));
    (0, $e94be5df56df841b$export$dc7e195cef98649)['brownbluegreen'] = (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("svg", {
        viewBox: "0,0,1,1",
        preserveAspectRatio: "none"
    }, (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("defs", null, (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("linearGradient", {
        id: "gradient-brownbluegreen"
    }, (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "0%",
        stopColor: "rgb(84, 48, 5)"
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "10%",
        stopColor: "rgb(139, 84, 15)"
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "20%",
        stopColor: "rgb(188, 132, 53)"
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "30%",
        stopColor: "rgb(222, 190, 123)"
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "40%",
        stopColor: "rgb(242, 228, 192)"
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "50%",
        stopColor: "rgb(238, 241, 234)"
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "60%",
        stopColor: "rgb(195, 231, 226)"
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "70%",
        stopColor: "rgb(127, 201, 191)"
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "80%",
        stopColor: "rgb(57, 152, 143)"
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "90%",
        stopColor: "rgb(10, 103, 95)"
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "100%",
        stopColor: "rgb(0, 60, 48)"
    }))), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("rect", {
        fill: "url(#gradient-brownbluegreen)",
        x: "0",
        y: "0",
        width: "1",
        height: "1"
    }));
    (0, $e94be5df56df841b$export$dc7e195cef98649)['purplegreen'] = (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("svg", {
        viewBox: "0,0,1,1",
        preserveAspectRatio: "none"
    }, (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("defs", null, (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("linearGradient", {
        id: "gradient-purplegreen"
    }, (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "0%",
        stopColor: "rgb(64, 0, 75)"
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "10%",
        stopColor: "rgb(115, 47, 128)"
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "20%",
        stopColor: "rgb(154, 109, 170)"
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "30%",
        stopColor: "rgb(193, 164, 205)"
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "40%",
        stopColor: "rgb(228, 210, 230)"
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "50%",
        stopColor: "rgb(239, 240, 239)"
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "60%",
        stopColor: "rgb(214, 238, 209)"
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "70%",
        stopColor: "rgb(162, 215, 158)"
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "80%",
        stopColor: "rgb(92, 173, 101)"
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "90%",
        stopColor: "rgb(33, 120, 57)"
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "100%",
        stopColor: "rgb(0, 68, 27)"
    }))), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("rect", {
        fill: "url(#gradient-purplegreen)",
        x: "0",
        y: "0",
        width: "1",
        height: "1"
    }));
    (0, $e94be5df56df841b$export$dc7e195cef98649)['pinkyellowgreen'] = (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("svg", {
        viewBox: "0,0,1,1",
        preserveAspectRatio: "none"
    }, (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("defs", null, (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("linearGradient", {
        id: "gradient-pinkyellowgreen"
    }, (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "0%",
        stopColor: "rgb(142, 1, 82)"
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "10%",
        stopColor: "rgb(192, 38, 126)"
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "20%",
        stopColor: "rgb(221, 114, 173)"
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "30%",
        stopColor: "rgb(240, 179, 214)"
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "40%",
        stopColor: "rgb(250, 221, 237)"
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "50%",
        stopColor: "rgb(245, 243, 239)"
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "60%",
        stopColor: "rgb(225, 242, 202)"
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "70%",
        stopColor: "rgb(182, 222, 135)"
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "80%",
        stopColor: "rgb(128, 187, 71)"
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "90%",
        stopColor: "rgb(79, 145, 37)"
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "100%",
        stopColor: "rgb(39, 100, 25)"
    }))), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("rect", {
        fill: "url(#gradient-pinkyellowgreen)",
        x: "0",
        y: "0",
        width: "1",
        height: "1"
    }));
    (0, $e94be5df56df841b$export$dc7e195cef98649)['purpleorange'] = (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("svg", {
        viewBox: "0,0,1,1",
        preserveAspectRatio: "none"
    }, (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("defs", null, (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("linearGradient", {
        id: "gradient-purpleorange"
    }, (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "0%",
        stopColor: "rgb(45, 0, 75)"
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "10%",
        stopColor: "rgb(85, 45, 132)"
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "20%",
        stopColor: "rgb(129, 112, 172)"
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "30%",
        stopColor: "rgb(176, 170, 208)"
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "40%",
        stopColor: "rgb(215, 215, 233)"
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "50%",
        stopColor: "rgb(243, 238, 234)"
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "60%",
        stopColor: "rgb(253, 221, 179)"
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "70%",
        stopColor: "rgb(248, 182, 100)"
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "80%",
        stopColor: "rgb(221, 132, 31)"
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "90%",
        stopColor: "rgb(178, 90, 9)"
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "100%",
        stopColor: "rgb(127, 59, 8)"
    }))), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("rect", {
        fill: "url(#gradient-purpleorange)",
        x: "0",
        y: "0",
        width: "1",
        height: "1"
    }));
    (0, $e94be5df56df841b$export$dc7e195cef98649)['redblue'] = (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("svg", {
        viewBox: "0,0,1,1",
        preserveAspectRatio: "none"
    }, (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("defs", null, (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("linearGradient", {
        id: "gradient-redblue"
    }, (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "0%",
        stopColor: "rgb(103, 0, 31)"
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "10%",
        stopColor: "rgb(172, 32, 47)"
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "20%",
        stopColor: "rgb(213, 96, 80)"
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "30%",
        stopColor: "rgb(241, 163, 133)"
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "40%",
        stopColor: "rgb(251, 215, 196)"
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "50%",
        stopColor: "rgb(242, 239, 238)"
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "60%",
        stopColor: "rgb(205, 227, 238)"
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "70%",
        stopColor: "rgb(143, 194, 221)"
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "80%",
        stopColor: "rgb(75, 148, 196)"
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "90%",
        stopColor: "rgb(34, 101, 163)"
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "100%",
        stopColor: "rgb(5, 48, 97)"
    }))), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("rect", {
        fill: "url(#gradient-redblue)",
        x: "0",
        y: "0",
        width: "1",
        height: "1"
    }));
    (0, $e94be5df56df841b$export$dc7e195cef98649)['redgrey'] = (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("svg", {
        viewBox: "0,0,1,1",
        preserveAspectRatio: "none"
    }, (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("defs", null, (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("linearGradient", {
        id: "gradient-redgrey"
    }, (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "0%",
        stopColor: "rgb(103, 0, 31)"
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "10%",
        stopColor: "rgb(172, 32, 47)"
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "20%",
        stopColor: "rgb(213, 96, 80)"
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "30%",
        stopColor: "rgb(241, 163, 133)"
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "40%",
        stopColor: "rgb(252, 216, 197)"
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "50%",
        stopColor: "rgb(250, 244, 241)"
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "60%",
        stopColor: "rgb(223, 223, 223)"
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "70%",
        stopColor: "rgb(184, 184, 184)"
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "80%",
        stopColor: "rgb(134, 134, 134)"
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "90%",
        stopColor: "rgb(78, 78, 78)"
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "100%",
        stopColor: "rgb(26, 26, 26)"
    }))), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("rect", {
        fill: "url(#gradient-redgrey)",
        x: "0",
        y: "0",
        width: "1",
        height: "1"
    }));
    (0, $e94be5df56df841b$export$dc7e195cef98649)['redyellowblue'] = (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("svg", {
        viewBox: "0,0,1,1",
        preserveAspectRatio: "none"
    }, (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("defs", null, (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("linearGradient", {
        id: "gradient-redyellowblue"
    }, (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "0%",
        stopColor: "rgb(165, 0, 38)"
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "10%",
        stopColor: "rgb(212, 50, 44)"
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "20%",
        stopColor: "rgb(241, 110, 67)"
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "30%",
        stopColor: "rgb(252, 172, 100)"
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "40%",
        stopColor: "rgb(254, 221, 144)"
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "50%",
        stopColor: "rgb(250, 248, 193)"
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "60%",
        stopColor: "rgb(220, 241, 236)"
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "70%",
        stopColor: "rgb(171, 214, 232)"
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "80%",
        stopColor: "rgb(117, 171, 208)"
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "90%",
        stopColor: "rgb(74, 116, 180)"
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "100%",
        stopColor: "rgb(49, 54, 149)"
    }))), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("rect", {
        fill: "url(#gradient-redyellowblue)",
        x: "0",
        y: "0",
        width: "1",
        height: "1"
    }));
    (0, $e94be5df56df841b$export$dc7e195cef98649)['redyellowgreen'] = (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("svg", {
        viewBox: "0,0,1,1",
        preserveAspectRatio: "none"
    }, (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("defs", null, (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("linearGradient", {
        id: "gradient-redyellowgreen"
    }, (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "0%",
        stopColor: "rgb(165, 0, 38)"
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "10%",
        stopColor: "rgb(212, 50, 44)"
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "20%",
        stopColor: "rgb(241, 110, 67)"
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "30%",
        stopColor: "rgb(252, 172, 99)"
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "40%",
        stopColor: "rgb(254, 221, 141)"
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "50%",
        stopColor: "rgb(249, 247, 174)"
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "60%",
        stopColor: "rgb(215, 238, 142)"
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "70%",
        stopColor: "rgb(164, 216, 110)"
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "80%",
        stopColor: "rgb(100, 188, 97)"
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "90%",
        stopColor: "rgb(34, 150, 79)"
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "100%",
        stopColor: "rgb(0, 104, 55)"
    }))), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("rect", {
        fill: "url(#gradient-redyellowgreen)",
        x: "0",
        y: "0",
        width: "1",
        height: "1"
    }));
    (0, $e94be5df56df841b$export$dc7e195cef98649)['spectral'] = (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("svg", {
        viewBox: "0,0,1,1",
        preserveAspectRatio: "none"
    }, (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("defs", null, (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("linearGradient", {
        id: "gradient-spectral"
    }, (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "0%",
        stopColor: "rgb(158, 1, 66)"
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "10%",
        stopColor: "rgb(209, 60, 75)"
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "20%",
        stopColor: "rgb(240, 112, 74)"
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "30%",
        stopColor: "rgb(252, 172, 99)"
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "40%",
        stopColor: "rgb(254, 221, 141)"
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "50%",
        stopColor: "rgb(251, 248, 176)"
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "60%",
        stopColor: "rgb(224, 243, 161)"
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "70%",
        stopColor: "rgb(169, 221, 162)"
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "80%",
        stopColor: "rgb(105, 189, 169)"
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "90%",
        stopColor: "rgb(66, 136, 181)"
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "100%",
        stopColor: "rgb(94, 79, 162)"
    }))), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("rect", {
        fill: "url(#gradient-spectral)",
        x: "0",
        y: "0",
        width: "1",
        height: "1"
    }));
    $c865794ee37c2239$var$loaded = true;
}
function $c865794ee37c2239$export$ab7b13a7cc99f3af(selected) {
    if (!$c865794ee37c2239$var$loaded) $c865794ee37c2239$var$load();
    return [
        (0, $e94be5df56df841b$export$535452b9416b5e17)(selected, 'blueorange'),
        (0, $e94be5df56df841b$export$535452b9416b5e17)(selected, 'brownbluegreen'),
        (0, $e94be5df56df841b$export$535452b9416b5e17)(selected, 'purplegreen'),
        (0, $e94be5df56df841b$export$535452b9416b5e17)(selected, 'pinkyellowgreen'),
        (0, $e94be5df56df841b$export$535452b9416b5e17)(selected, 'purpleorange'),
        (0, $e94be5df56df841b$export$535452b9416b5e17)(selected, 'redblue'),
        (0, $e94be5df56df841b$export$535452b9416b5e17)(selected, 'redgrey'),
        (0, $e94be5df56df841b$export$535452b9416b5e17)(selected, 'redyellowblue'),
        (0, $e94be5df56df841b$export$535452b9416b5e17)(selected, 'redyellowgreen'),
        (0, $e94be5df56df841b$export$535452b9416b5e17)(selected, 'spectral')
    ];
}



/*!
* Copyright (c) Microsoft Corporation.
* Licensed under the MIT License.
*/ 


let $76702a7bfec8e284$var$loaded = false;
function $76702a7bfec8e284$var$load() {
    (0, $1342cf7df79546f0$exports).colorSchemes.filter((cs)=>cs.colors.length === 2).map((binaryScheme, i)=>{
        (0, $e94be5df56df841b$export$dc7e195cef98649)[binaryScheme.scheme] = (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("div", {
            className: "swatch"
        }, binaryScheme.colors.map((color, j)=>(0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("div", {
                key: j,
                title: color,
                style: {
                    width: '50%',
                    backgroundColor: color
                }
            })));
    });
    $76702a7bfec8e284$var$loaded = true;
}
function $76702a7bfec8e284$export$d1699a1bbdf17835(selected) {
    if (!$76702a7bfec8e284$var$loaded) $76702a7bfec8e284$var$load();
    return (0, $1342cf7df79546f0$exports).colorSchemes.filter((cs)=>cs.colors.length === 2).map((binaryScheme, i)=>(0, $e94be5df56df841b$export$535452b9416b5e17)(selected, binaryScheme.scheme));
}




/*!
* Copyright (c) Microsoft Corporation.
* Licensed under the MIT License.
*/ 


let $f0ccc6e9e43e6b56$var$loaded = false;
function $f0ccc6e9e43e6b56$var$load() {
    (0, $e94be5df56df841b$export$dc7e195cef98649)['viridis'] = (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("svg", {
        viewBox: "0,0,1,1",
        preserveAspectRatio: "none"
    }, (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("defs", null, (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("linearGradient", {
        id: "gradient-viridis"
    }, (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "0%",
        stopColor: "#440154"
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "10%",
        stopColor: "#482475"
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "20%",
        stopColor: "#414487"
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "30%",
        stopColor: "#355f8d"
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "40%",
        stopColor: "#2a788e"
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "50%",
        stopColor: "#21918c"
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "60%",
        stopColor: "#22a884"
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "70%",
        stopColor: "#44bf70"
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "80%",
        stopColor: "#7ad151"
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "90%",
        stopColor: "#bddf26"
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "100%",
        stopColor: "#fde725"
    }))), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("rect", {
        fill: "url(#gradient-viridis)",
        x: "0",
        y: "0",
        width: "1",
        height: "1"
    }));
    (0, $e94be5df56df841b$export$dc7e195cef98649)['inferno'] = (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("svg", {
        viewBox: "0,0,1,1",
        preserveAspectRatio: "none"
    }, (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("defs", null, (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("linearGradient", {
        id: "gradient-inferno"
    }, (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "0%",
        stopColor: "#000004"
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "10%",
        stopColor: "#160b39"
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "20%",
        stopColor: "#420a68"
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "30%",
        stopColor: "#6a176e"
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "40%",
        stopColor: "#932667"
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "50%",
        stopColor: "#bc3754"
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "60%",
        stopColor: "#dd513a"
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "70%",
        stopColor: "#f37819"
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "80%",
        stopColor: "#fca50a"
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "90%",
        stopColor: "#f6d746"
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "100%",
        stopColor: "#fcffa4"
    }))), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("rect", {
        fill: "url(#gradient-inferno)",
        x: "0",
        y: "0",
        width: "1",
        height: "1"
    }));
    (0, $e94be5df56df841b$export$dc7e195cef98649)['magma'] = (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("svg", {
        viewBox: "0,0,1,1",
        preserveAspectRatio: "none"
    }, (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("defs", null, (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("linearGradient", {
        id: "gradient-magma"
    }, (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "0%",
        stopColor: "#000004"
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "10%",
        stopColor: "#140e36"
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "20%",
        stopColor: "#3b0f70"
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "30%",
        stopColor: "#641a80"
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "40%",
        stopColor: "#8c2981"
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "50%",
        stopColor: "#b73779"
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "60%",
        stopColor: "#de4968"
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "70%",
        stopColor: "#f7705c"
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "80%",
        stopColor: "#fe9f6d"
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "90%",
        stopColor: "#fecf92"
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "100%",
        stopColor: "#fcfdbf"
    }))), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("rect", {
        fill: "url(#gradient-magma)",
        x: "0",
        y: "0",
        width: "1",
        height: "1"
    }));
    (0, $e94be5df56df841b$export$dc7e195cef98649)['plasma'] = (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("svg", {
        viewBox: "0,0,1,1",
        preserveAspectRatio: "none"
    }, (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("defs", null, (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("linearGradient", {
        id: "gradient-plasma"
    }, (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "0%",
        stopColor: "#0d0887"
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "10%",
        stopColor: "#41049d"
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "20%",
        stopColor: "#6a00a8"
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "30%",
        stopColor: "#8f0da4"
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "40%",
        stopColor: "#b12a90"
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "50%",
        stopColor: "#cc4778"
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "60%",
        stopColor: "#e16462"
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "70%",
        stopColor: "#f2844b"
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "80%",
        stopColor: "#fca636"
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "90%",
        stopColor: "#fcce25"
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "100%",
        stopColor: "#f0f921"
    }))), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("rect", {
        fill: "url(#gradient-plasma)",
        x: "0",
        y: "0",
        width: "1",
        height: "1"
    }));
    (0, $e94be5df56df841b$export$dc7e195cef98649)['cividis'] = (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("svg", {
        viewBox: "0,0,1,1",
        preserveAspectRatio: "none"
    }, (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("defs", null, (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("linearGradient", {
        id: "gradient-cividis"
    }, (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "0%",
        stopColor: "#002051"
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "10%",
        stopColor: "#0a326a"
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "20%",
        stopColor: "#2b446e"
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "30%",
        stopColor: "#4d566d"
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "40%",
        stopColor: "#696970"
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "50%",
        stopColor: "#7f7c75"
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "60%",
        stopColor: "#948f78"
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "70%",
        stopColor: "#ada476"
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "80%",
        stopColor: "#caba6a"
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "90%",
        stopColor: "#ead156"
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "100%",
        stopColor: "#fdea45"
    }))), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("rect", {
        fill: "url(#gradient-cividis)",
        x: "0",
        y: "0",
        width: "1",
        height: "1"
    }));
    (0, $e94be5df56df841b$export$dc7e195cef98649)['turbo'] = (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("svg", {
        viewBox: "0,0,1,1",
        preserveAspectRatio: "none"
    }, (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("defs", null, (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("linearGradient", {
        id: "gradient-turbo"
    }, (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "0%",
        stopColor: "#23171b"
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "10%",
        stopColor: "#4a58dd"
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "20%",
        stopColor: "#2f9df5"
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "30%",
        stopColor: "#27d7c4"
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "40%",
        stopColor: "#4df884"
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "50%",
        stopColor: "#95fb51"
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "60%",
        stopColor: "#dedd32"
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "70%",
        stopColor: "#ffa423"
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "80%",
        stopColor: "#f65f18"
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "90%",
        stopColor: "#ba2208"
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "100%",
        stopColor: "#900c00"
    }))), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("rect", {
        fill: "url(#gradient-turbo)",
        x: "0",
        y: "0",
        width: "1",
        height: "1"
    }));
    (0, $e94be5df56df841b$export$dc7e195cef98649)['bluegreen'] = (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("svg", {
        viewBox: "0,0,1,1",
        preserveAspectRatio: "none"
    }, (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("defs", null, (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("linearGradient", {
        id: "gradient-bluegreen"
    }, (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "0%",
        stopColor: "rgb(247, 252, 253)"
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "10%",
        stopColor: "rgb(232, 246, 249)"
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "20%",
        stopColor: "rgb(213, 239, 237)"
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "30%",
        stopColor: "rgb(183, 228, 218)"
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "40%",
        stopColor: "rgb(143, 211, 193)"
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "50%",
        stopColor: "rgb(104, 194, 163)"
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "60%",
        stopColor: "rgb(73, 177, 127)"
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "70%",
        stopColor: "rgb(47, 153, 89)"
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "80%",
        stopColor: "rgb(21, 127, 60)"
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "90%",
        stopColor: "rgb(3, 100, 41)"
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "100%",
        stopColor: "rgb(0, 68, 27)"
    }))), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("rect", {
        fill: "url(#gradient-bluegreen)",
        x: "0",
        y: "0",
        width: "1",
        height: "1"
    }));
    (0, $e94be5df56df841b$export$dc7e195cef98649)['bluepurple'] = (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("svg", {
        viewBox: "0,0,1,1",
        preserveAspectRatio: "none"
    }, (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("defs", null, (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("linearGradient", {
        id: "gradient-bluepurple"
    }, (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "0%",
        stopColor: "rgb(247, 252, 253)"
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "10%",
        stopColor: "rgb(228, 238, 245)"
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "20%",
        stopColor: "rgb(204, 221, 236)"
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "30%",
        stopColor: "rgb(178, 202, 225)"
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "40%",
        stopColor: "rgb(156, 179, 213)"
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "50%",
        stopColor: "rgb(143, 149, 198)"
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "60%",
        stopColor: "rgb(140, 116, 181)"
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "70%",
        stopColor: "rgb(137, 82, 165)"
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "80%",
        stopColor: "rgb(133, 45, 143)"
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "90%",
        stopColor: "rgb(115, 15, 113)"
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "100%",
        stopColor: "rgb(77, 0, 75)"
    }))), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("rect", {
        fill: "url(#gradient-bluepurple)",
        x: "0",
        y: "0",
        width: "1",
        height: "1"
    }));
    (0, $e94be5df56df841b$export$dc7e195cef98649)['goldgreen'] = (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("svg", {
        viewBox: "0,0,1,1",
        preserveAspectRatio: "none"
    }, (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("defs", null, (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("linearGradient", {
        id: "gradient-goldgreen"
    }, (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "0%",
        stopColor: "#f4d166"
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "10%",
        stopColor: "#d5ca60"
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "20%",
        stopColor: "#b6c35c"
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "30%",
        stopColor: "#98bb59"
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "40%",
        stopColor: "#7cb257"
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "50%",
        stopColor: "#60a656"
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "60%",
        stopColor: "#4b9c53"
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "70%",
        stopColor: "#3f8f4f"
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "80%",
        stopColor: "#33834a"
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "90%",
        stopColor: "#257740"
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "100%",
        stopColor: "#146c36"
    }))), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("rect", {
        fill: "url(#gradient-goldgreen)",
        x: "0",
        y: "0",
        width: "1",
        height: "1"
    }));
    (0, $e94be5df56df841b$export$dc7e195cef98649)['goldorange'] = (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("svg", {
        viewBox: "0,0,1,1",
        preserveAspectRatio: "none"
    }, (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("defs", null, (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("linearGradient", {
        id: "gradient-goldorange"
    }, (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "0%",
        stopColor: "#f4d166"
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "10%",
        stopColor: "#f8be5c"
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "20%",
        stopColor: "#f8aa4c"
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "30%",
        stopColor: "#f5983b"
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "40%",
        stopColor: "#f3852a"
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "50%",
        stopColor: "#ef701b"
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "60%",
        stopColor: "#e2621f"
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "70%",
        stopColor: "#d65322"
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "80%",
        stopColor: "#c54923"
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "90%",
        stopColor: "#b14223"
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "100%",
        stopColor: "#9e3a26"
    }))), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("rect", {
        fill: "url(#gradient-goldorange)",
        x: "0",
        y: "0",
        width: "1",
        height: "1"
    }));
    (0, $e94be5df56df841b$export$dc7e195cef98649)['goldred'] = (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("svg", {
        viewBox: "0,0,1,1",
        preserveAspectRatio: "none"
    }, (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("defs", null, (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("linearGradient", {
        id: "gradient-goldred"
    }, (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "0%",
        stopColor: "#f4d166"
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "10%",
        stopColor: "#f6be59"
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "20%",
        stopColor: "#f9aa51"
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "30%",
        stopColor: "#fc964e"
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "40%",
        stopColor: "#f6834b"
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "50%",
        stopColor: "#ee734a"
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "60%",
        stopColor: "#e56249"
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "70%",
        stopColor: "#db5247"
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "80%",
        stopColor: "#cf4244"
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "90%",
        stopColor: "#c43141"
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "100%",
        stopColor: "#b71d3e"
    }))), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("rect", {
        fill: "url(#gradient-goldred)",
        x: "0",
        y: "0",
        width: "1",
        height: "1"
    }));
    (0, $e94be5df56df841b$export$dc7e195cef98649)['greenblue'] = (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("svg", {
        viewBox: "0,0,1,1",
        preserveAspectRatio: "none"
    }, (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("defs", null, (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("linearGradient", {
        id: "gradient-greenblue"
    }, (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "0%",
        stopColor: "rgb(247, 252, 240)"
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "10%",
        stopColor: "rgb(229, 245, 223)"
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "20%",
        stopColor: "rgb(211, 238, 206)"
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "30%",
        stopColor: "rgb(189, 229, 191)"
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "40%",
        stopColor: "rgb(158, 217, 187)"
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "50%",
        stopColor: "rgb(123, 203, 196)"
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "60%",
        stopColor: "rgb(88, 183, 205)"
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "70%",
        stopColor: "rgb(57, 156, 198)"
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "80%",
        stopColor: "rgb(29, 126, 183)"
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "90%",
        stopColor: "rgb(11, 96, 161)"
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "100%",
        stopColor: "rgb(8, 64, 129)"
    }))), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("rect", {
        fill: "url(#gradient-greenblue)",
        x: "0",
        y: "0",
        width: "1",
        height: "1"
    }));
    (0, $e94be5df56df841b$export$dc7e195cef98649)['orangered'] = (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("svg", {
        viewBox: "0,0,1,1",
        preserveAspectRatio: "none"
    }, (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("defs", null, (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("linearGradient", {
        id: "gradient-orangered"
    }, (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "0%",
        stopColor: "rgb(255, 247, 236)"
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "10%",
        stopColor: "rgb(254, 235, 207)"
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "20%",
        stopColor: "rgb(253, 220, 175)"
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "30%",
        stopColor: "rgb(253, 202, 148)"
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "40%",
        stopColor: "rgb(253, 176, 122)"
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "50%",
        stopColor: "rgb(250, 142, 93)"
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "60%",
        stopColor: "rgb(241, 108, 73)"
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "70%",
        stopColor: "rgb(224, 69, 48)"
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "80%",
        stopColor: "rgb(200, 29, 19)"
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "90%",
        stopColor: "rgb(167, 4, 3)"
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "100%",
        stopColor: "rgb(127, 0, 0)"
    }))), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("rect", {
        fill: "url(#gradient-orangered)",
        x: "0",
        y: "0",
        width: "1",
        height: "1"
    }));
    (0, $e94be5df56df841b$export$dc7e195cef98649)['purplebluegreen'] = (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("svg", {
        viewBox: "0,0,1,1",
        preserveAspectRatio: "none"
    }, (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("defs", null, (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("linearGradient", {
        id: "gradient-purplebluegreen"
    }, (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "0%",
        stopColor: "rgb(255, 247, 251)"
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "10%",
        stopColor: "rgb(239, 231, 242)"
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "20%",
        stopColor: "rgb(219, 216, 234)"
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "30%",
        stopColor: "rgb(190, 201, 226)"
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "40%",
        stopColor: "rgb(152, 185, 217)"
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "50%",
        stopColor: "rgb(105, 168, 207)"
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "60%",
        stopColor: "rgb(64, 150, 192)"
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "70%",
        stopColor: "rgb(25, 135, 159)"
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "80%",
        stopColor: "rgb(3, 120, 119)"
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "90%",
        stopColor: "rgb(1, 99, 83)"
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "100%",
        stopColor: "rgb(1, 70, 54)"
    }))), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("rect", {
        fill: "url(#gradient-purplebluegreen)",
        x: "0",
        y: "0",
        width: "1",
        height: "1"
    }));
    (0, $e94be5df56df841b$export$dc7e195cef98649)['purpleblue'] = (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("svg", {
        viewBox: "0,0,1,1",
        preserveAspectRatio: "none"
    }, (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("defs", null, (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("linearGradient", {
        id: "gradient-purpleblue"
    }, (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "0%",
        stopColor: "rgb(255, 247, 251)"
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "10%",
        stopColor: "rgb(239, 234, 244)"
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "20%",
        stopColor: "rgb(219, 218, 235)"
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "30%",
        stopColor: "rgb(191, 201, 226)"
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "40%",
        stopColor: "rgb(155, 185, 217)"
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "50%",
        stopColor: "rgb(114, 168, 207)"
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "60%",
        stopColor: "rgb(67, 148, 195)"
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "70%",
        stopColor: "rgb(26, 125, 182)"
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "80%",
        stopColor: "rgb(6, 103, 161)"
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "90%",
        stopColor: "rgb(4, 82, 129)"
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "100%",
        stopColor: "rgb(2, 56, 88)"
    }))), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("rect", {
        fill: "url(#gradient-purpleblue)",
        x: "0",
        y: "0",
        width: "1",
        height: "1"
    }));
    (0, $e94be5df56df841b$export$dc7e195cef98649)['purplered'] = (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("svg", {
        viewBox: "0,0,1,1",
        preserveAspectRatio: "none"
    }, (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("defs", null, (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("linearGradient", {
        id: "gradient-purplered"
    }, (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "0%",
        stopColor: "rgb(247, 244, 249)"
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "10%",
        stopColor: "rgb(234, 227, 240)"
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "20%",
        stopColor: "rgb(220, 201, 226)"
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "30%",
        stopColor: "rgb(208, 170, 210)"
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "40%",
        stopColor: "rgb(208, 138, 194)"
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "50%",
        stopColor: "rgb(221, 99, 174)"
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "60%",
        stopColor: "rgb(227, 56, 144)"
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "70%",
        stopColor: "rgb(215, 28, 108)"
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "80%",
        stopColor: "rgb(183, 11, 79)"
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "90%",
        stopColor: "rgb(143, 2, 58)"
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "100%",
        stopColor: "rgb(103, 0, 31)"
    }))), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("rect", {
        fill: "url(#gradient-purplered)",
        x: "0",
        y: "0",
        width: "1",
        height: "1"
    }));
    (0, $e94be5df56df841b$export$dc7e195cef98649)['redpurple'] = (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("svg", {
        viewBox: "0,0,1,1",
        preserveAspectRatio: "none"
    }, (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("defs", null, (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("linearGradient", {
        id: "gradient-redpurple"
    }, (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "0%",
        stopColor: "rgb(255, 247, 243)"
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "10%",
        stopColor: "rgb(253, 228, 225)"
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "20%",
        stopColor: "rgb(252, 207, 204)"
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "30%",
        stopColor: "rgb(251, 181, 188)"
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "40%",
        stopColor: "rgb(249, 147, 176)"
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "50%",
        stopColor: "rgb(243, 105, 163)"
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "60%",
        stopColor: "rgb(224, 62, 152)"
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "70%",
        stopColor: "rgb(192, 23, 136)"
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "80%",
        stopColor: "rgb(153, 3, 124)"
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "90%",
        stopColor: "rgb(112, 1, 116)"
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "100%",
        stopColor: "rgb(73, 0, 106)"
    }))), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("rect", {
        fill: "url(#gradient-redpurple)",
        x: "0",
        y: "0",
        width: "1",
        height: "1"
    }));
    (0, $e94be5df56df841b$export$dc7e195cef98649)['yellowgreenblue'] = (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("svg", {
        viewBox: "0,0,1,1",
        preserveAspectRatio: "none"
    }, (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("defs", null, (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("linearGradient", {
        id: "gradient-yellowgreenblue"
    }, (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "0%",
        stopColor: "rgb(255, 255, 217)"
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "10%",
        stopColor: "rgb(239, 249, 189)"
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "20%",
        stopColor: "rgb(213, 238, 179)"
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "30%",
        stopColor: "rgb(169, 221, 183)"
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "40%",
        stopColor: "rgb(115, 201, 189)"
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "50%",
        stopColor: "rgb(69, 180, 194)"
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "60%",
        stopColor: "rgb(40, 151, 191)"
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "70%",
        stopColor: "rgb(32, 115, 178)"
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "80%",
        stopColor: "rgb(35, 78, 160)"
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "90%",
        stopColor: "rgb(28, 49, 133)"
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "100%",
        stopColor: "rgb(8, 29, 88)"
    }))), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("rect", {
        fill: "url(#gradient-yellowgreenblue)",
        x: "0",
        y: "0",
        width: "1",
        height: "1"
    }));
    (0, $e94be5df56df841b$export$dc7e195cef98649)['yellowgreen'] = (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("svg", {
        viewBox: "0,0,1,1",
        preserveAspectRatio: "none"
    }, (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("defs", null, (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("linearGradient", {
        id: "gradient-yellowgreen"
    }, (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "0%",
        stopColor: "rgb(255, 255, 229)"
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "10%",
        stopColor: "rgb(247, 252, 196)"
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "20%",
        stopColor: "rgb(228, 244, 172)"
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "30%",
        stopColor: "rgb(199, 232, 155)"
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "40%",
        stopColor: "rgb(162, 216, 138)"
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "50%",
        stopColor: "rgb(120, 197, 120)"
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "60%",
        stopColor: "rgb(78, 175, 99)"
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "70%",
        stopColor: "rgb(47, 148, 78)"
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "80%",
        stopColor: "rgb(21, 121, 63)"
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "90%",
        stopColor: "rgb(3, 96, 52)"
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "100%",
        stopColor: "rgb(0, 69, 41)"
    }))), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("rect", {
        fill: "url(#gradient-yellowgreen)",
        x: "0",
        y: "0",
        width: "1",
        height: "1"
    }));
    (0, $e94be5df56df841b$export$dc7e195cef98649)['yelloworangebrown'] = (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("svg", {
        viewBox: "0,0,1,1",
        preserveAspectRatio: "none"
    }, (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("defs", null, (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("linearGradient", {
        id: "gradient-yelloworangebrown"
    }, (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "0%",
        stopColor: "rgb(255, 255, 229)"
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "10%",
        stopColor: "rgb(255, 248, 196)"
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "20%",
        stopColor: "rgb(254, 234, 161)"
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "30%",
        stopColor: "rgb(254, 214, 118)"
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "40%",
        stopColor: "rgb(254, 186, 74)"
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "50%",
        stopColor: "rgb(251, 153, 44)"
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "60%",
        stopColor: "rgb(238, 121, 24)"
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "70%",
        stopColor: "rgb(216, 91, 10)"
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "80%",
        stopColor: "rgb(183, 67, 4)"
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "90%",
        stopColor: "rgb(143, 50, 4)"
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "100%",
        stopColor: "rgb(102, 37, 6)"
    }))), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("rect", {
        fill: "url(#gradient-yelloworangebrown)",
        x: "0",
        y: "0",
        width: "1",
        height: "1"
    }));
    (0, $e94be5df56df841b$export$dc7e195cef98649)['yelloworangered'] = (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("svg", {
        viewBox: "0,0,1,1",
        preserveAspectRatio: "none"
    }, (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("defs", null, (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("linearGradient", {
        id: "gradient-yelloworangered"
    }, (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "0%",
        stopColor: "rgb(255, 255, 204)"
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "10%",
        stopColor: "rgb(255, 240, 169)"
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "20%",
        stopColor: "rgb(254, 224, 135)"
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "30%",
        stopColor: "rgb(254, 201, 101)"
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "40%",
        stopColor: "rgb(254, 171, 75)"
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "50%",
        stopColor: "rgb(253, 137, 60)"
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "60%",
        stopColor: "rgb(250, 92, 46)"
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "70%",
        stopColor: "rgb(236, 48, 35)"
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "80%",
        stopColor: "rgb(211, 17, 33)"
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "90%",
        stopColor: "rgb(175, 2, 37)"
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "100%",
        stopColor: "rgb(128, 0, 38)"
    }))), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("rect", {
        fill: "url(#gradient-yelloworangered)",
        x: "0",
        y: "0",
        width: "1",
        height: "1"
    }));
    (0, $e94be5df56df841b$export$dc7e195cef98649)['darkblue'] = (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("svg", {
        viewBox: "0,0,1,1",
        preserveAspectRatio: "none"
    }, (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("defs", null, (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("linearGradient", {
        id: "gradient-darkblue"
    }, (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "0%",
        stopColor: "#323232"
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "10%",
        stopColor: "#2e4463"
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "20%",
        stopColor: "#1e588a"
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "30%",
        stopColor: "#086da7"
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "40%",
        stopColor: "#0082b9"
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "50%",
        stopColor: "#039ac7"
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "60%",
        stopColor: "#12b1d4"
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "70%",
        stopColor: "#2bc8e2"
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "80%",
        stopColor: "#3ddff0"
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "90%",
        stopColor: "#61f4fb"
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "100%",
        stopColor: "#ffffff"
    }))), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("rect", {
        fill: "url(#gradient-darkblue)",
        x: "0",
        y: "0",
        width: "1",
        height: "1"
    }));
    (0, $e94be5df56df841b$export$dc7e195cef98649)['darkgold'] = (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("svg", {
        viewBox: "0,0,1,1",
        preserveAspectRatio: "none"
    }, (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("defs", null, (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("linearGradient", {
        id: "gradient-darkgold"
    }, (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "0%",
        stopColor: "#3c3c3c"
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "10%",
        stopColor: "#554a38"
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "20%",
        stopColor: "#6d5a35"
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "30%",
        stopColor: "#846f32"
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "40%",
        stopColor: "#a0832d"
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "50%",
        stopColor: "#bf9828"
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "60%",
        stopColor: "#dbb022"
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "70%",
        stopColor: "#f0cb23"
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "80%",
        stopColor: "#fae241"
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "90%",
        stopColor: "#fff290"
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "100%",
        stopColor: "#ffffff"
    }))), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("rect", {
        fill: "url(#gradient-darkgold)",
        x: "0",
        y: "0",
        width: "1",
        height: "1"
    }));
    (0, $e94be5df56df841b$export$dc7e195cef98649)['darkgreen'] = (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("svg", {
        viewBox: "0,0,1,1",
        preserveAspectRatio: "none"
    }, (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("defs", null, (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("linearGradient", {
        id: "gradient-darkgreen"
    }, (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "0%",
        stopColor: "#3a3a3a"
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "10%",
        stopColor: "#245447"
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "20%",
        stopColor: "#076a4c"
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "30%",
        stopColor: "#038145"
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "40%",
        stopColor: "#2d9642"
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "50%",
        stopColor: "#5fa941"
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "60%",
        stopColor: "#89bb3f"
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "70%",
        stopColor: "#b3cb3b"
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "80%",
        stopColor: "#dbdc34"
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "90%",
        stopColor: "#ffed39"
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "100%",
        stopColor: "#ffffaa"
    }))), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("rect", {
        fill: "url(#gradient-darkgreen)",
        x: "0",
        y: "0",
        width: "1",
        height: "1"
    }));
    (0, $e94be5df56df841b$export$dc7e195cef98649)['darkmulti'] = (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("svg", {
        viewBox: "0,0,1,1",
        preserveAspectRatio: "none"
    }, (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("defs", null, (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("linearGradient", {
        id: "gradient-darkmulti"
    }, (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "0%",
        stopColor: "#373737"
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "10%",
        stopColor: "#294767"
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "20%",
        stopColor: "#1e5b88"
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "30%",
        stopColor: "#1a748b"
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "40%",
        stopColor: "#1f8e7e"
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "50%",
        stopColor: "#29a869"
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "60%",
        stopColor: "#6abf50"
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "70%",
        stopColor: "#aad332"
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "80%",
        stopColor: "#eae30d"
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "90%",
        stopColor: "#fff166"
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "100%",
        stopColor: "#ffffff"
    }))), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("rect", {
        fill: "url(#gradient-darkmulti)",
        x: "0",
        y: "0",
        width: "1",
        height: "1"
    }));
    (0, $e94be5df56df841b$export$dc7e195cef98649)['darkred'] = (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("svg", {
        viewBox: "0,0,1,1",
        preserveAspectRatio: "none"
    }, (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("defs", null, (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("linearGradient", {
        id: "gradient-darkred"
    }, (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "0%",
        stopColor: "#343434"
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "10%",
        stopColor: "#643633"
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "20%",
        stopColor: "#8c3a36"
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "30%",
        stopColor: "#b03e38"
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "40%",
        stopColor: "#d14632"
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "50%",
        stopColor: "#e75d1e"
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "60%",
        stopColor: "#eb7e20"
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "70%",
        stopColor: "#ed9c25"
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "80%",
        stopColor: "#efb92d"
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "90%",
        stopColor: "#f3d431"
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "100%",
        stopColor: "#ffeb2c"
    }))), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("rect", {
        fill: "url(#gradient-darkred)",
        x: "0",
        y: "0",
        width: "1",
        height: "1"
    }));
    (0, $e94be5df56df841b$export$dc7e195cef98649)['lightgreyred'] = (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("svg", {
        viewBox: "0,0,1,1",
        preserveAspectRatio: "none"
    }, (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("defs", null, (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("linearGradient", {
        id: "gradient-lightgreyred"
    }, (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "0%",
        stopColor: "#efe9e6"
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "10%",
        stopColor: "#e2dcd9"
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "20%",
        stopColor: "#d7cecb"
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "30%",
        stopColor: "#ccc1be"
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "40%",
        stopColor: "#c0b4af"
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "50%",
        stopColor: "#c4a293"
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "60%",
        stopColor: "#d38b66"
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "70%",
        stopColor: "#de7336"
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "80%",
        stopColor: "#e15917"
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "90%",
        stopColor: "#df3a10"
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "100%",
        stopColor: "#dc000b"
    }))), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("rect", {
        fill: "url(#gradient-lightgreyred)",
        x: "0",
        y: "0",
        width: "1",
        height: "1"
    }));
    (0, $e94be5df56df841b$export$dc7e195cef98649)['lightgreyteal'] = (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("svg", {
        viewBox: "0,0,1,1",
        preserveAspectRatio: "none"
    }, (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("defs", null, (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("linearGradient", {
        id: "gradient-lightgreyteal"
    }, (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "0%",
        stopColor: "#e4eaea"
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "10%",
        stopColor: "#d7ddde"
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "20%",
        stopColor: "#cbd1d4"
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "30%",
        stopColor: "#bcc6ca"
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "40%",
        stopColor: "#adbac0"
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "50%",
        stopColor: "#85b2be"
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "60%",
        stopColor: "#4aacc1"
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "70%",
        stopColor: "#22a1c2"
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "80%",
        stopColor: "#2192c0"
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "90%",
        stopColor: "#1e84be"
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "100%",
        stopColor: "#1876bc"
    }))), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("rect", {
        fill: "url(#gradient-lightgreyteal)",
        x: "0",
        y: "0",
        width: "1",
        height: "1"
    }));
    (0, $e94be5df56df841b$export$dc7e195cef98649)['lightmulti'] = (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("svg", {
        viewBox: "0,0,1,1",
        preserveAspectRatio: "none"
    }, (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("defs", null, (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("linearGradient", {
        id: "gradient-lightmulti"
    }, (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "0%",
        stopColor: "#e0f1f2"
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "10%",
        stopColor: "#caebd7"
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "20%",
        stopColor: "#b8e2b3"
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "30%",
        stopColor: "#bddf93"
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "40%",
        stopColor: "#d8e17e"
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "50%",
        stopColor: "#f6e072"
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "60%",
        stopColor: "#f6c659"
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "70%",
        stopColor: "#f4a946"
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "80%",
        stopColor: "#f58a3f"
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "90%",
        stopColor: "#f56c3f"
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "100%",
        stopColor: "#ef4a3c"
    }))), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("rect", {
        fill: "url(#gradient-lightmulti)",
        x: "0",
        y: "0",
        width: "1",
        height: "1"
    }));
    (0, $e94be5df56df841b$export$dc7e195cef98649)['lightorange'] = (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("svg", {
        viewBox: "0,0,1,1",
        preserveAspectRatio: "none"
    }, (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("defs", null, (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("linearGradient", {
        id: "gradient-lightorange"
    }, (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "0%",
        stopColor: "#f2e7da"
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "10%",
        stopColor: "#f7d7bd"
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "20%",
        stopColor: "#f9c7a0"
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "30%",
        stopColor: "#fab78a"
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "40%",
        stopColor: "#faa47a"
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "50%",
        stopColor: "#f8936d"
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "60%",
        stopColor: "#f38264"
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "70%",
        stopColor: "#ed725f"
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "80%",
        stopColor: "#e6605b"
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "90%",
        stopColor: "#dd4f5b"
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "100%",
        stopColor: "#d43d5b"
    }))), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("rect", {
        fill: "url(#gradient-lightorange)",
        x: "0",
        y: "0",
        width: "1",
        height: "1"
    }));
    (0, $e94be5df56df841b$export$dc7e195cef98649)['lighttealblue'] = (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("svg", {
        viewBox: "0,0,1,1",
        preserveAspectRatio: "none"
    }, (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("defs", null, (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("linearGradient", {
        id: "gradient-lighttealblue"
    }, (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "0%",
        stopColor: "#e3e9e0"
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "10%",
        stopColor: "#c4ddd1"
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "20%",
        stopColor: "#a2d1cb"
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "30%",
        stopColor: "#84c4c9"
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "40%",
        stopColor: "#66b5c3"
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "50%",
        stopColor: "#49a7bd"
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "60%",
        stopColor: "#3698b4"
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "70%",
        stopColor: "#3188a9"
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "80%",
        stopColor: "#2d799e"
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "90%",
        stopColor: "#276994"
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "100%",
        stopColor: "#255988"
    }))), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("rect", {
        fill: "url(#gradient-lighttealblue)",
        x: "0",
        y: "0",
        width: "1",
        height: "1"
    }));
    $f0ccc6e9e43e6b56$var$loaded = true;
}
function $f0ccc6e9e43e6b56$export$a4fd36c4882aa76e(selected) {
    if (!$f0ccc6e9e43e6b56$var$loaded) $f0ccc6e9e43e6b56$var$load();
    return [
        (0, $e94be5df56df841b$export$535452b9416b5e17)(selected, 'viridis'),
        (0, $e94be5df56df841b$export$535452b9416b5e17)(selected, 'magma'),
        (0, $e94be5df56df841b$export$535452b9416b5e17)(selected, 'inferno'),
        (0, $e94be5df56df841b$export$535452b9416b5e17)(selected, 'plasma'),
        (0, $e94be5df56df841b$export$535452b9416b5e17)(selected, 'cividis'),
        (0, $e94be5df56df841b$export$535452b9416b5e17)(selected, 'turbo'),
        (0, $e94be5df56df841b$export$535452b9416b5e17)(selected, 'bluegreen'),
        (0, $e94be5df56df841b$export$535452b9416b5e17)(selected, 'bluepurple'),
        (0, $e94be5df56df841b$export$535452b9416b5e17)(selected, 'goldgreen'),
        (0, $e94be5df56df841b$export$535452b9416b5e17)(selected, 'goldorange'),
        (0, $e94be5df56df841b$export$535452b9416b5e17)(selected, 'goldred'),
        (0, $e94be5df56df841b$export$535452b9416b5e17)(selected, 'greenblue'),
        (0, $e94be5df56df841b$export$535452b9416b5e17)(selected, 'orangered'),
        (0, $e94be5df56df841b$export$535452b9416b5e17)(selected, 'purplebluegreen'),
        (0, $e94be5df56df841b$export$535452b9416b5e17)(selected, 'purpleblue'),
        (0, $e94be5df56df841b$export$535452b9416b5e17)(selected, 'purplered'),
        (0, $e94be5df56df841b$export$535452b9416b5e17)(selected, 'redpurple'),
        (0, $e94be5df56df841b$export$535452b9416b5e17)(selected, 'yellowgreenblue'),
        (0, $e94be5df56df841b$export$535452b9416b5e17)(selected, 'yellowgreen'),
        (0, $e94be5df56df841b$export$535452b9416b5e17)(selected, 'yelloworangebrown'),
        (0, $e94be5df56df841b$export$535452b9416b5e17)(selected, 'yelloworangered'),
        (0, $e94be5df56df841b$export$3482e66b4441447f)('schemeSequentialMultiHueDark', (0, $d5b6ce321475881f$export$21c51bc433c16634).schemeSequentialMultiHueDark),
        (0, $e94be5df56df841b$export$535452b9416b5e17)(selected, 'darkblue'),
        (0, $e94be5df56df841b$export$535452b9416b5e17)(selected, 'darkgold'),
        (0, $e94be5df56df841b$export$535452b9416b5e17)(selected, 'darkgreen'),
        (0, $e94be5df56df841b$export$535452b9416b5e17)(selected, 'darkmulti'),
        (0, $e94be5df56df841b$export$535452b9416b5e17)(selected, 'darkred'),
        (0, $e94be5df56df841b$export$3482e66b4441447f)('schemeSequentialMultiHueLight', (0, $d5b6ce321475881f$export$21c51bc433c16634).schemeSequentialMultiHueLight),
        (0, $e94be5df56df841b$export$535452b9416b5e17)(selected, 'lightgreyred'),
        (0, $e94be5df56df841b$export$535452b9416b5e17)(selected, 'lightgreyteal'),
        (0, $e94be5df56df841b$export$535452b9416b5e17)(selected, 'lightmulti'),
        (0, $e94be5df56df841b$export$535452b9416b5e17)(selected, 'lightorange'),
        (0, $e94be5df56df841b$export$535452b9416b5e17)(selected, 'lighttealblue')
    ];
}


/*!
* Copyright (c) Microsoft Corporation.
* Licensed under the MIT License.
*/ 

let $9bfd5718c2e1a138$var$loaded = false;
function $9bfd5718c2e1a138$var$load() {
    (0, $e94be5df56df841b$export$dc7e195cef98649)['blues'] = (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("svg", {
        viewBox: "0,0,1,1",
        preserveAspectRatio: "none"
    }, (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("defs", null, (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("linearGradient", {
        id: "gradient-blues"
    }, (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "0%",
        stopColor: "rgb(247, 251, 255)"
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "10%",
        stopColor: "rgb(227, 238, 249)"
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "20%",
        stopColor: "rgb(207, 225, 242)"
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "30%",
        stopColor: "rgb(181, 212, 233)"
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "40%",
        stopColor: "rgb(147, 195, 223)"
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "50%",
        stopColor: "rgb(109, 174, 213)"
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "60%",
        stopColor: "rgb(75, 151, 201)"
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "70%",
        stopColor: "rgb(47, 126, 188)"
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "80%",
        stopColor: "rgb(24, 100, 170)"
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "90%",
        stopColor: "rgb(10, 74, 144)"
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "100%",
        stopColor: "rgb(8, 48, 107)"
    }))), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("rect", {
        fill: "url(#gradient-blues)",
        x: "0",
        y: "0",
        width: "1",
        height: "1"
    }));
    (0, $e94be5df56df841b$export$dc7e195cef98649)['tealblues'] = (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("svg", {
        viewBox: "0,0,1,1",
        preserveAspectRatio: "none"
    }, (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("defs", null, (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("linearGradient", {
        id: "gradient-tealblues"
    }, (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "0%",
        stopColor: "#bce4d8"
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "10%",
        stopColor: "#a3d6d2"
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "20%",
        stopColor: "#8cc9cd"
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "30%",
        stopColor: "#76bdc7"
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "40%",
        stopColor: "#5fb0c0"
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "50%",
        stopColor: "#45a2b9"
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "60%",
        stopColor: "#3993b0"
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "70%",
        stopColor: "#3584a6"
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "80%",
        stopColor: "#32759b"
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "90%",
        stopColor: "#2f6790"
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "100%",
        stopColor: "#2c5985"
    }))), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("rect", {
        fill: "url(#gradient-tealblues)",
        x: "0",
        y: "0",
        width: "1",
        height: "1"
    }));
    (0, $e94be5df56df841b$export$dc7e195cef98649)['teals'] = (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("svg", {
        viewBox: "0,0,1,1",
        preserveAspectRatio: "none"
    }, (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("defs", null, (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("linearGradient", {
        id: "gradient-teals"
    }, (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "0%",
        stopColor: "#bbdfdf"
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "10%",
        stopColor: "#a2d4d5"
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "20%",
        stopColor: "#8ac9c9"
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "30%",
        stopColor: "#75bcbb"
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "40%",
        stopColor: "#61b0af"
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "50%",
        stopColor: "#4da5a4"
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "60%",
        stopColor: "#379998"
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "70%",
        stopColor: "#2b8b8c"
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "80%",
        stopColor: "#1e7f7f"
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "90%",
        stopColor: "#127273"
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "100%",
        stopColor: "#006667"
    }))), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("rect", {
        fill: "url(#gradient-teals)",
        x: "0",
        y: "0",
        width: "1",
        height: "1"
    }));
    (0, $e94be5df56df841b$export$dc7e195cef98649)['greens'] = (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("svg", {
        viewBox: "0,0,1,1",
        preserveAspectRatio: "none"
    }, (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("defs", null, (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("linearGradient", {
        id: "gradient-greens"
    }, (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "0%",
        stopColor: "rgb(247, 252, 245)"
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "10%",
        stopColor: "rgb(232, 246, 227)"
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "20%",
        stopColor: "rgb(211, 238, 205)"
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "30%",
        stopColor: "rgb(183, 226, 177)"
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "40%",
        stopColor: "rgb(151, 212, 148)"
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "50%",
        stopColor: "rgb(115, 195, 120)"
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "60%",
        stopColor: "rgb(77, 175, 98)"
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "70%",
        stopColor: "rgb(47, 152, 79)"
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "80%",
        stopColor: "rgb(21, 127, 59)"
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "90%",
        stopColor: "rgb(3, 100, 41)"
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "100%",
        stopColor: "rgb(0, 68, 27)"
    }))), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("rect", {
        fill: "url(#gradient-greens)",
        x: "0",
        y: "0",
        width: "1",
        height: "1"
    }));
    (0, $e94be5df56df841b$export$dc7e195cef98649)['greys'] = (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("svg", {
        viewBox: "0,0,1,1",
        preserveAspectRatio: "none"
    }, (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("defs", null, (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("linearGradient", {
        id: "gradient-greys"
    }, (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "0%",
        stopColor: "rgb(255, 255, 255)"
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "10%",
        stopColor: "rgb(242, 242, 242)"
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "20%",
        stopColor: "rgb(226, 226, 226)"
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "30%",
        stopColor: "rgb(206, 206, 206)"
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "40%",
        stopColor: "rgb(180, 180, 180)"
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "50%",
        stopColor: "rgb(151, 151, 151)"
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "60%",
        stopColor: "rgb(122, 122, 122)"
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "70%",
        stopColor: "rgb(95, 95, 95)"
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "80%",
        stopColor: "rgb(64, 64, 64)"
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "90%",
        stopColor: "rgb(30, 30, 30)"
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "100%",
        stopColor: "rgb(0, 0, 0)"
    }))), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("rect", {
        fill: "url(#gradient-greys)",
        x: "0",
        y: "0",
        width: "1",
        height: "1"
    }));
    (0, $e94be5df56df841b$export$dc7e195cef98649)['purples'] = (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("svg", {
        viewBox: "0,0,1,1",
        preserveAspectRatio: "none"
    }, (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("defs", null, (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("linearGradient", {
        id: "gradient-purples"
    }, (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "0%",
        stopColor: "rgb(252, 251, 253)"
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "10%",
        stopColor: "rgb(241, 239, 246)"
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "20%",
        stopColor: "rgb(226, 225, 239)"
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "30%",
        stopColor: "rgb(206, 206, 229)"
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "40%",
        stopColor: "rgb(182, 181, 216)"
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "50%",
        stopColor: "rgb(158, 155, 201)"
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "60%",
        stopColor: "rgb(135, 130, 188)"
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "70%",
        stopColor: "rgb(115, 99, 172)"
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "80%",
        stopColor: "rgb(97, 64, 155)"
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "90%",
        stopColor: "rgb(80, 31, 140)"
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "100%",
        stopColor: "rgb(63, 0, 125)"
    }))), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("rect", {
        fill: "url(#gradient-purples)",
        x: "0",
        y: "0",
        width: "1",
        height: "1"
    }));
    (0, $e94be5df56df841b$export$dc7e195cef98649)['browns'] = (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("svg", {
        viewBox: "0,0,1,1",
        preserveAspectRatio: "none"
    }, (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("defs", null, (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("linearGradient", {
        id: "gradient-browns"
    }, (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "0%",
        stopColor: "#eedbbd"
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "10%",
        stopColor: "#ecca96"
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "20%",
        stopColor: "#e9b97a"
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "30%",
        stopColor: "#e4a865"
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "40%",
        stopColor: "#dc9856"
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "50%",
        stopColor: "#d18954"
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "60%",
        stopColor: "#c7784c"
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "70%",
        stopColor: "#c0673f"
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "80%",
        stopColor: "#b85536"
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "90%",
        stopColor: "#ad4433"
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "100%",
        stopColor: "#9f3632"
    }))), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("rect", {
        fill: "url(#gradient-browns)",
        x: "0",
        y: "0",
        width: "1",
        height: "1"
    }));
    (0, $e94be5df56df841b$export$dc7e195cef98649)['reds'] = (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("svg", {
        viewBox: "0,0,1,1",
        preserveAspectRatio: "none"
    }, (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("defs", null, (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("linearGradient", {
        id: "gradient-reds"
    }, (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "0%",
        stopColor: "rgb(255, 245, 240)"
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "10%",
        stopColor: "rgb(254, 227, 214)"
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "20%",
        stopColor: "rgb(253, 201, 180)"
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "30%",
        stopColor: "rgb(252, 170, 142)"
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "40%",
        stopColor: "rgb(252, 138, 107)"
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "50%",
        stopColor: "rgb(249, 105, 76)"
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "60%",
        stopColor: "rgb(239, 69, 51)"
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "70%",
        stopColor: "rgb(217, 39, 35)"
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "80%",
        stopColor: "rgb(187, 21, 26)"
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "90%",
        stopColor: "rgb(151, 11, 19)"
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "100%",
        stopColor: "rgb(103, 0, 13)"
    }))), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("rect", {
        fill: "url(#gradient-reds)",
        x: "0",
        y: "0",
        width: "1",
        height: "1"
    }));
    (0, $e94be5df56df841b$export$dc7e195cef98649)['oranges'] = (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("svg", {
        viewBox: "0,0,1,1",
        preserveAspectRatio: "none"
    }, (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("defs", null, (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("linearGradient", {
        id: "gradient-oranges"
    }, (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "0%",
        stopColor: "rgb(255, 245, 235)"
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "10%",
        stopColor: "rgb(254, 232, 211)"
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "20%",
        stopColor: "rgb(253, 216, 179)"
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "30%",
        stopColor: "rgb(253, 194, 140)"
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "40%",
        stopColor: "rgb(253, 167, 98)"
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "50%",
        stopColor: "rgb(251, 141, 61)"
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "60%",
        stopColor: "rgb(242, 112, 29)"
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "70%",
        stopColor: "rgb(226, 86, 9)"
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "80%",
        stopColor: "rgb(196, 65, 3)"
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "90%",
        stopColor: "rgb(159, 51, 3)"
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "100%",
        stopColor: "rgb(127, 39, 4)"
    }))), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("rect", {
        fill: "url(#gradient-oranges)",
        x: "0",
        y: "0",
        width: "1",
        height: "1"
    }));
    (0, $e94be5df56df841b$export$dc7e195cef98649)['warmgreys'] = (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("svg", {
        viewBox: "0,0,1,1",
        preserveAspectRatio: "none"
    }, (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("defs", null, (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("linearGradient", {
        id: "gradient-warmgreys"
    }, (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "0%",
        stopColor: "#dcd4d0"
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "10%",
        stopColor: "#cec5c1"
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "20%",
        stopColor: "#c0b8b4"
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "30%",
        stopColor: "#b3aaa7"
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "40%",
        stopColor: "#a59c99"
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "50%",
        stopColor: "#98908c"
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "60%",
        stopColor: "#8b827f"
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "70%",
        stopColor: "#7e7673"
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "80%",
        stopColor: "#726866"
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "90%",
        stopColor: "#665c5a"
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("stop", {
        offset: "100%",
        stopColor: "#59504e"
    }))), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("rect", {
        fill: "url(#gradient-warmgreys)",
        x: "0",
        y: "0",
        width: "1",
        height: "1"
    }));
    $9bfd5718c2e1a138$var$loaded = true;
}
function $9bfd5718c2e1a138$export$9b3c8b6a286fd957(selected) {
    if (!$9bfd5718c2e1a138$var$loaded) $9bfd5718c2e1a138$var$load();
    return [
        (0, $e94be5df56df841b$export$535452b9416b5e17)(selected, 'blues'),
        (0, $e94be5df56df841b$export$535452b9416b5e17)(selected, 'tealblues'),
        (0, $e94be5df56df841b$export$535452b9416b5e17)(selected, 'teals'),
        (0, $e94be5df56df841b$export$535452b9416b5e17)(selected, 'greens'),
        (0, $e94be5df56df841b$export$535452b9416b5e17)(selected, 'browns'),
        (0, $e94be5df56df841b$export$535452b9416b5e17)(selected, 'oranges'),
        (0, $e94be5df56df841b$export$535452b9416b5e17)(selected, 'reds'),
        (0, $e94be5df56df841b$export$535452b9416b5e17)(selected, 'purples'),
        (0, $e94be5df56df841b$export$535452b9416b5e17)(selected, 'warmgreys'),
        (0, $e94be5df56df841b$export$535452b9416b5e17)(selected, 'greys')
    ];
}



const $6b72b192df8d0014$var$maxDistinctColors = 20;
function $6b72b192df8d0014$export$e2fbaa661ec19dbf(props) {
    const { distinctValueCount: distinctValueCount } = props.colorColumn.stats;
    const isDual = distinctValueCount === 2;
    const categoricalNumeric = distinctValueCount > 0 && distinctValueCount < $6b72b192df8d0014$var$maxDistinctColors;
    let isQualitative = false;
    let isQuantitative = false;
    switch(props.colorColumn.type){
        case 'boolean':
        case 'string':
            isQualitative = true;
            break;
        case 'number':
            isQuantitative = true;
            break;
        case 'date':
        case 'integer':
            isQuantitative = true;
            isQualitative = categoricalNumeric;
    }
    const selected = props.scheme;
    const options = [];
    function menu(name, opts) {
        if (options.length) options.push({
            key: 'divider' + options.length,
            text: null,
            itemType: (0, $a601a4135959dcb0$export$e2253033e6e1df16).fluentUI.DropdownMenuItemType.Divider
        });
        options.push({
            key: name,
            text: name,
            itemType: (0, $a601a4135959dcb0$export$e2253033e6e1df16).fluentUI.DropdownMenuItemType.Header
        });
        options.push.apply(options, opts);
    }
    isQualitative && menu((0, $d5b6ce321475881f$export$21c51bc433c16634).schemeCategorical, (0, $604fb89637945be9$export$f3a499247c9822d1)(selected));
    isQuantitative && menu((0, $d5b6ce321475881f$export$21c51bc433c16634).schemeSequentialSingleHue, (0, $9bfd5718c2e1a138$export$9b3c8b6a286fd957)(selected));
    isQuantitative && menu((0, $d5b6ce321475881f$export$21c51bc433c16634).schemeSequentialMultiHue, (0, $f0ccc6e9e43e6b56$export$a4fd36c4882aa76e)(selected));
    isQuantitative && menu((0, $d5b6ce321475881f$export$21c51bc433c16634).schemeDiverging, (0, $c865794ee37c2239$export$ab7b13a7cc99f3af)(selected));
    isQuantitative && menu((0, $d5b6ce321475881f$export$21c51bc433c16634).schemeCyclical, (0, $557d0cbc8fb1bfa4$export$6b2b632c28721cf0)(selected));
    isDual && menu((0, $d5b6ce321475881f$export$21c51bc433c16634).schemeDual, (0, $76702a7bfec8e284$export$d1699a1bbdf17835)(selected));
    return (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("div", {
        className: "sanddance-palette"
    }, (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("div", {
        className: "sanddance-explanation",
        dangerouslySetInnerHTML: {
            __html: (0, $d5b6ce321475881f$export$21c51bc433c16634).labelColorFieldInfo(props.colorColumn.name, props.colorColumn.type, categoricalNumeric, distinctValueCount)
        }
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement((0, $8f56f1ed6ae42f13$export$931cbfb6bfb85fc), {
        collapseLabel: props.collapseLabel,
        disabled: props.disabled,
        dropdownWidth: 400,
        label: (0, $d5b6ce321475881f$export$21c51bc433c16634).labelColorScheme,
        onRenderOption: (option)=>{
            if (option.itemType === (0, $a601a4135959dcb0$export$e2253033e6e1df16).fluentUI.DropdownMenuItemType.Header) return (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("span", null, option.text);
            else return (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("div", {
                className: "sanddance-scheme option"
            }, (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("span", {
                className: "name"
            }, option.scheme), option.children);
        },
        options: options,
        onChange: (e, o)=>{
            props.changeColorScheme(o.scheme);
        }
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("div", {
        className: (0, $e295d8097c1ad61a$exports).classList('sanddance-scheme', props.disabled && 'disabled')
    }, props.scheme && (0, $e94be5df56df841b$export$dc7e195cef98649)[props.scheme]));
}





function $2cfe18e9e3d5fffb$export$892596cec99bc70e(props) {
    const colorColumn = props.dataContent.columns.filter((c)=>c.name === props.colorColumn)[0];
    const disabledColorBin = !colorColumn || !colorColumn.quantitative || props.directColor;
    const colorBin = props.colorBin || 'quantize';
    const dropdownRef = (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createRef();
    props.explorer.dialogFocusHandler.focus = ()=>{
        var _a;
        return (_a = dropdownRef.current) === null || _a === void 0 ? void 0 : _a.focus();
    };
    return (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("div", {
        className: "sanddance-color-dialog"
    }, (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement((0, $5b1483fb7f067be1$export$eb2fcfdbd7ba97d4), {
        label: (0, $d5b6ce321475881f$export$21c51bc433c16634).labelColor
    }, (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement((0, $3ecc97321af8bbc8$export$83b9e0badda50eeb), Object.assign({}, props, {
        componentRef: dropdownRef,
        collapseLabel: props.compactUI,
        selectedColumnName: props.colorColumn,
        specRole: props.specCapabilities && props.specCapabilities.roles.filter((r)=>r.role === 'color')[0],
        key: 0
    })), colorColumn && colorColumn.isColorData && (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("div", {
        className: "sanddance-explanation",
        dangerouslySetInnerHTML: {
            __html: (0, $d5b6ce321475881f$export$21c51bc433c16634).labelColorFieldIsColorData(colorColumn.name)
        }
    }), colorColumn && !colorColumn.isColorData && (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement((0, $6b72b192df8d0014$export$e2fbaa661ec19dbf), {
        collapseLabel: props.compactUI,
        scheme: props.scheme,
        colorColumn: colorColumn,
        changeColorScheme: (scheme)=>{
            props.onColorSchemeChange(scheme);
        },
        disabled: props.disabled || props.directColor || colorColumn && colorColumn.isColorData
    }), colorColumn && !colorColumn.isColorData && (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement((0, $00e2720d7006b5f2$export$8210dfe1863c478), {
        disabled: props.disabled || !colorColumn || props.directColor || colorColumn && colorColumn.isColorData,
        signal: props.colorReverseSignal,
        explorer: props.explorer,
        initialValue: (0, $00e2720d7006b5f2$export$d54e4e563d2a9303)(props.explorer, props.colorReverseSignal),
        onChange: props.onColorReverseChange,
        collapseLabel: props.compactUI
    })), colorColumn && !colorColumn.isColorData && (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement((0, $5b1483fb7f067be1$export$eb2fcfdbd7ba97d4), {
        label: (0, $d5b6ce321475881f$export$21c51bc433c16634).labelColorBin
    }, (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("div", {
        className: "sanddance-explanation"
    }, (0, $d5b6ce321475881f$export$21c51bc433c16634).labelColorBinExplanation), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement((0, $a601a4135959dcb0$export$e2253033e6e1df16).fluentUI.ChoiceGroup, {
        selectedKey: colorBin,
        options: [
            {
                key: 'continuous',
                text: (0, $d5b6ce321475881f$export$21c51bc433c16634).labelColorBinNone,
                disabled: disabledColorBin
            },
            {
                key: 'quantize',
                text: (0, $d5b6ce321475881f$export$21c51bc433c16634).labelColorBinQuantize,
                disabled: disabledColorBin
            },
            {
                key: 'quantile',
                text: (0, $d5b6ce321475881f$export$21c51bc433c16634).labelColorBinQuantile,
                disabled: disabledColorBin
            }
        ],
        onChange: (e, o)=>{
            props.onColorBinChange(o.key);
        }
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement((0, $00e2720d7006b5f2$export$8210dfe1863c478), {
        disabled: props.disabled || disabledColorBin || props.colorBin === 'continuous',
        signal: props.colorBinSignal,
        explorer: props.explorer,
        initialValue: (0, $00e2720d7006b5f2$export$d54e4e563d2a9303)(props.explorer, props.colorBinSignal),
        onChange: props.onColorBinCountChange,
        collapseLabel: props.compactUI
    })), colorColumn && !colorColumn.isColorData && (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement((0, $5b1483fb7f067be1$export$eb2fcfdbd7ba97d4), {
        label: (0, $d5b6ce321475881f$export$21c51bc433c16634).labelColorOptions
    }, (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement((0, $a601a4135959dcb0$export$e2253033e6e1df16).fluentUI.Toggle, {
        label: (0, $d5b6ce321475881f$export$21c51bc433c16634).selectDirectColor,
        disabled: !colorColumn.stats.hasColorData,
        checked: !!(colorColumn.stats.hasColorData && props.directColor),
        onChange: (e, checked)=>props.onDirectColorChange(checked)
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("div", {
        className: "sanddance-explanation",
        dangerouslySetInnerHTML: {
            __html: (0, $d5b6ce321475881f$export$21c51bc433c16634).labelDataColors
        }
    })));
}


/*!
* Copyright (c) Microsoft Corporation.
* Licensed under the MIT License.
*/ 

/*!
* Copyright (c) Microsoft Corporation.
* Licensed under the MIT License.
*/ 
/*!
* Copyright (c) Microsoft Corporation.
* Licensed under the MIT License.
*/ const $482602738369d734$export$ec835b702d42f3f0 = {
    ENTER: 13
};




function $abe5706469fa09a5$var$isNumber(value) {
    if (typeof value === 'number') return true;
    if (!isNaN(value)) return true;
    return false;
}
function $abe5706469fa09a5$var$isBoolean(value) {
    if (typeof value === 'boolean') return true;
    if (typeof value === 'string') switch(value.toLowerCase()){
        case "true":
        case "false":
            return true;
    }
    return false;
}
function $abe5706469fa09a5$var$bingSearchLink(column, value) {
    if ($abe5706469fa09a5$var$isNumber(value)) return null;
    if ($abe5706469fa09a5$var$isBoolean(value)) return null;
    if (column && column.stats.distinctValueCount === 2) return null;
    return (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("div", {
        className: 'bing-search'
    }, (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("a", {
        href: `https://www.bing.com/search?q=${encodeURIComponent(value)}`,
        target: '_blank',
        title: (0, $d5b6ce321475881f$export$21c51bc433c16634).bingsearchDescription(value),
        "aria-label": (0, $d5b6ce321475881f$export$21c51bc433c16634).bingsearchDescription(value)
    }, (0, $d5b6ce321475881f$export$21c51bc433c16634).bingsearch));
}
function $abe5706469fa09a5$var$displayValue(value) {
    switch(value){
        case '':
            return {
                special: true,
                display: (0, $d5b6ce321475881f$export$21c51bc433c16634).labelBlank
            };
        case null:
            return {
                special: true,
                display: (0, $d5b6ce321475881f$export$21c51bc433c16634).labelNull
            };
        case true:
            return {
                special: true,
                display: (0, $d5b6ce321475881f$export$21c51bc433c16634).labelTrue
            };
        case false:
            return {
                special: true,
                display: (0, $d5b6ce321475881f$export$21c51bc433c16634).labelFalse
            };
        default:
            if (typeof value === 'object') {
                if (value instanceof Date) {
                    const d = value;
                    return $abe5706469fa09a5$var$displayValue(d.input);
                }
                return {
                    special: false,
                    display: value.toLocaleString()
                };
            }
            return {
                special: false,
                display: value
            };
    }
}
function $abe5706469fa09a5$var$displayValueElement(nvp) {
    const d = $abe5706469fa09a5$var$displayValue(nvp.value);
    if (d.special) return (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("i", null, d.display);
    return d.display;
}
function $abe5706469fa09a5$export$e9ab04247990d50b(props) {
    if (!props.item) return null;
    const nameValuePairs = [];
    for(const columnName in props.item){
        if (columnName === (0, $1342cf7df79546f0$exports).constants.GL_ORDINAL && !props.showSystemFields) continue;
        if ((0, $1342cf7df79546f0$exports).util.isInternalFieldName(columnName)) continue;
        const nameValuePair = {
            columnName: columnName,
            value: props.item[columnName]
        };
        if (!props.bingSearchDisabled) nameValuePair.bingSearch = $abe5706469fa09a5$var$bingSearchLink(props.columns.filter((c)=>c.name === columnName)[0], props.item[columnName]);
        nameValuePairs.push(nameValuePair);
    }
    return (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("div", {
        className: "sanddance-dataItem"
    }, nameValuePairs.map((nameValuePair, i)=>{
        const ex = {
            key: 0,
            name: nameValuePair.columnName,
            operator: '==',
            value: nameValuePair.value
        };
        if (nameValuePair.value === null || nameValuePair.value === '') {
            ex.operator = 'isnullorEmpty';
            delete ex.value;
        }
        const searchClick = (e)=>{
            const search = {
                key: 0,
                expressions: [
                    ex
                ]
            };
            props.onSearch(e, [
                search
            ]);
        };
        const title = (0, $d5b6ce321475881f$export$21c51bc433c16634).tooltipSearch(nameValuePair.columnName, $abe5706469fa09a5$var$displayValue(nameValuePair.value).display);
        return (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("div", {
            key: i,
            onClick: !props.disabled ? searchClick : null,
            title: title,
            onKeyUp: (e)=>{
                if (e.keyCode === (0, $482602738369d734$export$ec835b702d42f3f0).ENTER) searchClick(e);
            },
            tabIndex: 0,
            className: "name-value"
        }, (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("div", {
            className: "column-name"
        }, nameValuePair.columnName), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("div", {
            className: "column-value"
        }, $abe5706469fa09a5$var$displayValueElement(nameValuePair)), nameValuePair.bingSearch);
    }));
}








const $9ca0c376beb8c2ec$export$bbe9fd33806c217d = {};
$9ca0c376beb8c2ec$export$bbe9fd33806c217d[(0, $86b892255d8eb4f0$export$f0297ce57faf7d71).AllData] = (0, $d5b6ce321475881f$export$21c51bc433c16634).labelZeroAll;
$9ca0c376beb8c2ec$export$bbe9fd33806c217d[(0, $86b892255d8eb4f0$export$f0297ce57faf7d71).FilteredData] = null; //empty array is not used
$9ca0c376beb8c2ec$export$bbe9fd33806c217d[(0, $86b892255d8eb4f0$export$f0297ce57faf7d71).SelectedData] = (0, $d5b6ce321475881f$export$21c51bc433c16634).labelZeroSearchResults;
const $9ca0c376beb8c2ec$export$79bd5e38ba2a6de0 = {};
$9ca0c376beb8c2ec$export$79bd5e38ba2a6de0[(0, $86b892255d8eb4f0$export$f0297ce57faf7d71).AllData] = (0, $d5b6ce321475881f$export$21c51bc433c16634).labelDataNullAll;
$9ca0c376beb8c2ec$export$79bd5e38ba2a6de0[(0, $86b892255d8eb4f0$export$f0297ce57faf7d71).FilteredData] = (0, $d5b6ce321475881f$export$21c51bc433c16634).labelDataNullFiltered;
$9ca0c376beb8c2ec$export$79bd5e38ba2a6de0[(0, $86b892255d8eb4f0$export$f0297ce57faf7d71).SelectedData] = (0, $d5b6ce321475881f$export$21c51bc433c16634).labelDataNullSelection;
function $9ca0c376beb8c2ec$export$1ce2294f62fa7154(props) {
    function activateRecord(newIndex) {
        props.onActivate(props.data[newIndex], newIndex);
    }
    const { index: index } = props;
    const length = props.data && props.data.length || 0;
    const dropdownRef = (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createRef();
    props.explorer.dialogFocusHandler.focus = ()=>{
        var _a;
        return (_a = dropdownRef.current) === null || _a === void 0 ? void 0 : _a.focus();
    };
    return (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement((0, $5b1483fb7f067be1$export$eb2fcfdbd7ba97d4), {
        label: (0, $d5b6ce321475881f$export$21c51bc433c16634).labelDataBrowser,
        className: "sanddance-dataIndex"
    }, (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement((0, $8f56f1ed6ae42f13$export$931cbfb6bfb85fc), {
        componentRef: dropdownRef,
        label: (0, $d5b6ce321475881f$export$21c51bc433c16634).labelDataScope,
        collapseLabel: true,
        options: [
            {
                key: (0, $86b892255d8eb4f0$export$f0297ce57faf7d71).AllData,
                text: (0, $d5b6ce321475881f$export$21c51bc433c16634).selectDataSpanAll,
                isSelected: props.selectedDataScope === (0, $86b892255d8eb4f0$export$f0297ce57faf7d71).AllData
            },
            {
                key: (0, $86b892255d8eb4f0$export$f0297ce57faf7d71).FilteredData,
                text: (0, $d5b6ce321475881f$export$21c51bc433c16634).selectDataSpanFilter,
                isSelected: props.selectedDataScope === (0, $86b892255d8eb4f0$export$f0297ce57faf7d71).FilteredData
            },
            {
                key: (0, $86b892255d8eb4f0$export$f0297ce57faf7d71).SelectedData,
                text: (0, $d5b6ce321475881f$export$21c51bc433c16634).selectDataSpanSelection,
                isSelected: props.selectedDataScope === (0, $86b892255d8eb4f0$export$f0297ce57faf7d71).SelectedData
            }
        ],
        onChange: (e, o)=>{
            props.onDataScopeClick(o.key);
        }
    }), !props.data && (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("div", {
        dangerouslySetInnerHTML: {
            __html: props.nullMessage
        }
    }), props.data && !props.data.length && (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("div", null, props.zeroMessage), !!length && (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("div", null, (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("div", {
        className: "index"
    }, (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement((0, $baf9c68afdd76912$export$c25acd513dcc8062), {
        themePalette: props.themePalette,
        iconName: "ChevronLeftMed",
        onClick: (e)=>activateRecord(index <= 0 ? length - 1 : index - 1),
        disabled: props.disabled || length === 1,
        title: (0, $d5b6ce321475881f$export$21c51bc433c16634).buttonPrevDataItem
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("span", null, (0, $d5b6ce321475881f$export$21c51bc433c16634).record(index + 1, length)), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement((0, $baf9c68afdd76912$export$c25acd513dcc8062), {
        themePalette: props.themePalette,
        iconName: "ChevronRightMed",
        onClick: (e)=>activateRecord(index >= length - 1 ? 0 : index + 1),
        disabled: props.disabled || length === 1,
        title: (0, $d5b6ce321475881f$export$21c51bc433c16634).buttonNextDataItem
    })), !props.itemVisible && (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("div", {
        className: "item-filtered"
    }, (0, $d5b6ce321475881f$export$21c51bc433c16634).labelDataItemIsFiltered), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement((0, $abe5706469fa09a5$export$e9ab04247990d50b), {
        columns: props.columns,
        item: props.data[index],
        disabled: props.disabled,
        onSearch: props.onSearch,
        bingSearchDisabled: props.bingSearchDisabled
    })), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement((0, $0edfbb46d4822ac6$export$12df67f310f5f846), {
        theme: props.theme,
        themePalette: props.themePalette,
        initialCategoricalColumns: props.categoricalColumns,
        initialQuantitativeColumns: props.quantitativeColumns,
        onConfirmUpdate: props.onUpdateColumnTypes
    }), props.dataExportHandler && props.data && (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement((0, $cff73bb5fafa0795$export$b1b568728c48eba1), {
        theme: props.theme,
        initializer: {
            fileName: `${(0, $cff73bb5fafa0795$export$748f956e607b675b)(props.displayName)} (${props.data.length})`
        },
        data: props.data,
        dataExportHandler: props.dataExportHandler,
        disabled: props.disabled
    }));
}


/*!
* Copyright (c) Microsoft Corporation.
* Licensed under the MIT License.
*/ 




function $1451439fef5c6aa0$export$84202caead5689ba(props) {
    return (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement((0, $5b1483fb7f067be1$export$eb2fcfdbd7ba97d4), {
        label: (0, $d5b6ce321475881f$export$21c51bc433c16634).labelHistory,
        className: "sanddance-history"
    }, (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("ol", null, props.historyItems.map((hi, i)=>{
        let ref;
        if (i === props.historyIndex) {
            ref = (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createRef();
            props.explorer.dialogFocusHandler.focus = ()=>{
                var _a;
                (_a = ref.current) === null || _a === void 0 || _a.focus();
            };
        }
        return (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("li", {
            key: i,
            className: (0, $e295d8097c1ad61a$exports).classList(i === props.historyIndex && 'selected'),
            onKeyUp: (e)=>{
                if (e.keyCode === (0, $482602738369d734$export$ec835b702d42f3f0).ENTER) props.redo(i);
            }
        }, (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement((0, $a601a4135959dcb0$export$e2253033e6e1df16).fluentUI.DefaultButton, {
            className: 'sanddance-history-button',
            componentRef: ref,
            text: hi.label,
            onClick: ()=>props.redo(i)
        }));
    })));
}
function $1451439fef5c6aa0$export$a5701bb72c00a527(historicInsight) {
    const { colorBin: colorBin, columns: columns, directColor: directColor, facetStyle: facetStyle, filter: filter, hideAxes: hideAxes, hideLegend: hideLegend, scheme: scheme, signalValues: signalValues, size: size, totalStyle: totalStyle, transform: transform, chart: chart, view: view } = historicInsight;
    const insight = {
        colorBin: colorBin,
        columns: columns,
        directColor: directColor,
        facetStyle: facetStyle,
        filter: filter,
        hideAxes: hideAxes,
        hideLegend: hideLegend,
        scheme: scheme,
        signalValues: signalValues,
        size: size,
        totalStyle: totalStyle,
        transform: transform,
        chart: chart,
        view: view
    };
    return insight;
}
function $1451439fef5c6aa0$export$5c9ba34b2d024c9b(historyItems, index) {
    let filter = null;
    let historicInsight = {};
    for(let i = 0; i < index + 1; i++){
        const historyItem = historyItems[i];
        if (historyItem) {
            if (historyItem.historicInsight.filter === null) filter = null;
            else if (historyItem.historicInsight.rebaseFilter) filter = historyItem.historicInsight.filter;
            else if (historyItem.historicInsight.filter) filter = (0, $1342cf7df79546f0$exports).searchExpression.narrow(filter, historyItem.historicInsight.filter);
            historicInsight = Object.assign(Object.assign({}, historicInsight), historyItem.historicInsight);
        }
    }
    return Object.assign(Object.assign({}, historicInsight), {
        filter: filter
    });
}









/*!
* Copyright (c) Microsoft Corporation.
* Licensed under the MIT License.
*/ function $c887e455511417d2$var$hasClientXY(e) {
    if (e && e.clientX !== undefined && e.clientX !== undefined) return {
        top: e.clientY,
        left: e.clientX
    };
}
function $c887e455511417d2$export$1690e12b840569b9(e) {
    const xy = $c887e455511417d2$var$hasClientXY(e);
    if (xy) return xy;
    const te = e;
    if (te === null || te === void 0 ? void 0 : te.touches) for(let i = 0; i < te.touches.length; i++){
        const xy = $c887e455511417d2$var$hasClientXY(te.touches[i]);
        if (xy) return xy;
    }
    const el = e.target;
    if (el && el.getClientRects) return el.getClientRects()[0];
}


/*!
* Copyright (c) Microsoft Corporation.
* Licensed under the MIT License.
*/ 
function $d5291de605e66403$export$1915de5807f54194(prefs, partialInsight) {
    if (partialInsight) {
        const specTypePrefs = prefs[partialInsight.chart] || {};
        prefs[partialInsight.chart] = specTypePrefs;
        for(const _role in partialInsight.columns){
            const role = _role;
            if (role === 'color' || role === 'x') {
                const rolePrefs = specTypePrefs[role] || {};
                specTypePrefs[role] = rolePrefs;
                const column = partialInsight.columns[role];
                const copySignalValue = (signalName)=>{
                    if (partialInsight.signalValues && partialInsight.signalValues[signalName] && rolePrefs[column]) {
                        const signalValues = rolePrefs[column].signalValues || {};
                        signalValues[signalName] = partialInsight.signalValues[signalName];
                        rolePrefs[column].signalValues = signalValues;
                    }
                };
                switch(role){
                    case 'color':
                        rolePrefs[column] = {
                            scheme: partialInsight.scheme,
                            colorBin: partialInsight.colorBin
                        };
                        copySignalValue((0, $1342cf7df79546f0$exports).constants.SignalNames.ColorBinCount);
                        break;
                    case 'x':
                        copySignalValue((0, $1342cf7df79546f0$exports).constants.SignalNames.XBins);
                        break;
                }
            }
        }
    }
}
function $d5291de605e66403$export$c2992dc6411becf6(prefs, chart, role, column, signalName, signalValue) {
    const partialInsight = $d5291de605e66403$export$a14483004c11686f(prefs, chart, role, column, {
        signalValues: {}
    });
    partialInsight.signalValues[signalName] = signalValue;
}
function $d5291de605e66403$export$318d2f27a5d54aff(prefs, chart, role, columnName) {
    const specTypePrefs = (0, $1342cf7df79546f0$exports).VegaMorphCharts.util.deepMerge({}, prefs['*'], prefs[chart]);
    const rolePrefs = (0, $1342cf7df79546f0$exports).VegaMorphCharts.util.deepMerge({}, specTypePrefs['*'], specTypePrefs[role]);
    const partialInsight = (0, $1342cf7df79546f0$exports).VegaMorphCharts.util.deepMerge({}, rolePrefs['*'], rolePrefs[columnName]);
    return partialInsight;
}
function $d5291de605e66403$export$a14483004c11686f(prefs, chart, role, column, partialInsight) {
    const SpecTypePrefs = prefs[chart] || {};
    prefs[chart] = SpecTypePrefs;
    const rolePrefs = SpecTypePrefs[role] || {};
    SpecTypePrefs[role] = rolePrefs;
    rolePrefs[column] = (0, $1342cf7df79546f0$exports).VegaMorphCharts.util.deepMerge({}, rolePrefs[column], partialInsight);
    return rolePrefs[column];
}



/*!
* Copyright (c) Microsoft Corporation.
* Licensed under the MIT License.
*/ 
function $5b0ca40e09feefab$var$comparableGroup(group) {
    return Object.assign(Object.assign({}, group), {
        clause: null
    });
}
function $5b0ca40e09feefab$var$compareGroup(a, b) {
    return (0, $1342cf7df79546f0$exports).searchExpression.compareGroup($5b0ca40e09feefab$var$comparableGroup(a), $5b0ca40e09feefab$var$comparableGroup(b));
}
function $5b0ca40e09feefab$export$c2270d7efbef44bf(haystack, needle) {
    const groups = [];
    let found = false;
    //look for item in all
    haystack.forEach((group)=>{
        if ($5b0ca40e09feefab$var$compareGroup(group, needle)) //if it exists, don't add it
        found = true;
        else groups.push(group);
    });
    return {
        groups: groups,
        found: found
    };
}
function $5b0ca40e09feefab$export$3ffa48e55176070e(search) {
    const groups = (0, $1342cf7df79546f0$exports).searchExpression.ensureSearchExpressionGroupArray(search);
    const dialogSearch = groups.map((group, groupIndex)=>{
        return Object.assign(Object.assign({
            key: groupIndex
        }, group), {
            expressions: group.expressions.map((ex, i)=>{
                const ex2 = Object.assign({
                    key: i
                }, ex);
                return ex2;
            })
        });
    });
    return dialogSearch;
}




/*!
* Copyright (c) Microsoft Corporation.
* Licensed under the MIT License.
*/ 




function $24a2c07dd03771c2$var$_Renderer(_props) {
    class __Renderer extends (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.Component {
        constructor(props){
            var _a, _b;
            super(props);
            this.state = this.getInitialState(props);
            if (!((_b = (_a = this.state.viewer) === null || _a === void 0 ? void 0 : _a.presenter) === null || _b === void 0 ? void 0 : _b.morphchartsref)) {
                const t = setInterval(()=>{
                    var _a, _b;
                    const newState = this.getInitialState(props);
                    if (this.mounted && ((_b = (_a = newState.viewer) === null || _a === void 0 ? void 0 : _a.presenter) === null || _b === void 0 ? void 0 : _b.morphchartsref)) {
                        clearInterval(t);
                        this.setState(newState);
                    }
                }, 10);
            }
        }
        componentDidMount() {
            this.mounted = true;
        }
        componentWillUnmount() {
            this.mounted = false;
        }
        getInitialState(props) {
            const { viewer: viewer } = props.explorer;
            return {
                showOptions: false,
                viewer: viewer
            };
        }
        setOptions(newOptions) {
            const { explorer: explorer } = this.props;
            const renderer = Object.assign(Object.assign({}, explorer.state.renderer), newOptions);
            const { onSetupOptionsChanged: onSetupOptionsChanged } = explorer.props;
            if (onSetupOptionsChanged) {
                const setup = explorer.getSetup();
                setup.renderer = renderer;
                onSetupOptionsChanged(setup);
            }
            explorer.setState({
                renderer: renderer
            });
        }
        setBasicOptions(newOptions) {
            this.setOptions({
                advanced: false,
                basicOptions: Object.assign(Object.assign({}, this.props.basicOptions), newOptions)
            });
        }
        setAdvancedOptions(newOptions) {
            this.setOptions({
                advanced: true,
                advancedOptions: Object.assign(Object.assign({}, this.props.advancedOptions), newOptions)
            });
        }
        render() {
            var _a, _b;
            const { props: props, state: state } = this;
            const iconButtonStyles = {
                menuIcon: {
                    display: 'none'
                }
            };
            if (!((_b = (_a = state.viewer) === null || _a === void 0 ? void 0 : _a.presenter) === null || _b === void 0 ? void 0 : _b.morphchartsref)) return (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement((0, $baf9c68afdd76912$export$c25acd513dcc8062), {
                styles: iconButtonStyles,
                className: 'sanddance-advanced-renderer',
                disabled: true,
                iconName: 'HourGlass',
                onClick: undefined,
                themePalette: props.themePalette,
                title: (0, $d5b6ce321475881f$export$21c51bc433c16634).labelRenderer
            });
            else {
                const { morphchartsref: morphchartsref } = state.viewer.presenter;
                const choiceButtonStyle = {
                    border: 'none'
                };
                const { advanced: advanced, advancedOptions: advancedOptions, basicOptions: basicOptions } = props;
                return (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("div", null, (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement((0, $baf9c68afdd76912$export$c25acd513dcc8062), {
                    iconName: 'PicturePosition',
                    title: (0, $d5b6ce321475881f$export$21c51bc433c16634).buttonCameraHome,
                    onClick: props.onHomeClick,
                    styles: iconButtonStyles,
                    themePalette: props.themePalette
                }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement((0, $baf9c68afdd76912$export$c25acd513dcc8062), {
                    styles: iconButtonStyles,
                    className: 'sanddance-advanced-renderer',
                    iconName: advanced ? 'DiamondSolid' : 'Diamond',
                    disabled: !morphchartsref.supportedRenders.advanced,
                    onClick: undefined,
                    themePalette: props.themePalette,
                    title: morphchartsref.supportedRenders.advanced ? (0, $d5b6ce321475881f$export$21c51bc433c16634).labelRenderer : (0, $d5b6ce321475881f$export$21c51bc433c16634).labelRendererAdvancedDisabled,
                    menuProps: {
                        items: [
                            {
                                key: 'basic',
                                text: (0, $d5b6ce321475881f$export$21c51bc433c16634).labelRendererBasic,
                                iconProps: {
                                    iconName: advanced ? null : 'RadioBullet'
                                },
                                onClick: ()=>advanced && this.setOptions({
                                        advanced: false
                                    })
                            },
                            {
                                key: 'advanced',
                                text: (0, $d5b6ce321475881f$export$21c51bc433c16634).labelRendererAdvanced,
                                iconProps: {
                                    iconName: advanced ? 'RadioBullet' : null
                                },
                                onClick: ()=>!advanced && this.setOptions({
                                        advanced: true
                                    })
                            },
                            {
                                key: 'options',
                                text: (0, $d5b6ce321475881f$export$21c51bc433c16634).labelRendererOptions,
                                onClick: (e)=>this.setState({
                                        showOptions: true
                                    })
                            }
                        ]
                    }
                }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement((0, $f4b615ab5c14d90e$export$3ddf2d174ce01153), {
                    hidden: !state.showOptions,
                    dialogContentProps: {
                        className: 'sanddance-renderer-dialog',
                        title: (0, $d5b6ce321475881f$export$21c51bc433c16634).labelRendererOptionsDialogTitle
                    },
                    onDismiss: ()=>this.setState({
                            showOptions: false
                        })
                }, (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("div", null, (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement((0, $f9294a04a77df05a$export$353f5b6fc5456de1), {
                    iconName: advanced ? 'RadioBtnOff' : 'RadioBtnOn',
                    onClick: ()=>this.setOptions({
                            advanced: false
                        }),
                    text: (0, $d5b6ce321475881f$export$21c51bc433c16634).labelRendererBasic,
                    themePalette: props.themePalette,
                    rootStyle: choiceButtonStyle
                }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("ul", null, (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("li", null, (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement((0, $a601a4135959dcb0$export$e2253033e6e1df16).fluentUI.Toggle, {
                    checked: basicOptions.antialias,
                    label: (0, $d5b6ce321475881f$export$21c51bc433c16634).labelRendererOptionsAntialias,
                    onChange: (e, antialias)=>this.setBasicOptions({
                            antialias: antialias
                        })
                })))), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("div", null, (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement((0, $f9294a04a77df05a$export$353f5b6fc5456de1), {
                    iconName: advanced ? 'RadioBtnOn' : 'RadioBtnOff',
                    onClick: ()=>this.setOptions({
                            advanced: true
                        }),
                    text: (0, $d5b6ce321475881f$export$21c51bc433c16634).labelRendererAdvanced,
                    themePalette: props.themePalette,
                    rootStyle: choiceButtonStyle
                }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("ul", null, (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("li", null, (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement((0, $a601a4135959dcb0$export$e2253033e6e1df16).fluentUI.Toggle, {
                    checked: advancedOptions.isShadowEnabled,
                    label: (0, $d5b6ce321475881f$export$21c51bc433c16634).labelRendererOptionsShadow,
                    onChange: (e, isShadowEnabled)=>this.setAdvancedOptions({
                            isShadowEnabled: isShadowEnabled
                        })
                })), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("li", null, (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement((0, $a601a4135959dcb0$export$e2253033e6e1df16).fluentUI.Toggle, {
                    checked: advancedOptions.isSsaoEnabled,
                    label: (0, $d5b6ce321475881f$export$21c51bc433c16634).labelRendererOptionsSsao,
                    onChange: (e, isSsaoEnabled)=>this.setAdvancedOptions({
                            isSsaoEnabled: isSsaoEnabled
                        })
                })), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("li", null, (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement((0, $a601a4135959dcb0$export$e2253033e6e1df16).fluentUI.Toggle, {
                    checked: advancedOptions.isBloomEnabled,
                    label: (0, $d5b6ce321475881f$export$21c51bc433c16634).labelRendererOptionsBloom,
                    onChange: (e, isBloomEnabled)=>this.setAdvancedOptions({
                            isBloomEnabled: isBloomEnabled
                        })
                }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("ul", null, (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("li", null, (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement((0, $a601a4135959dcb0$export$e2253033e6e1df16).fluentUI.Slider, {
                    value: advancedOptions.bloomIntensity,
                    min: 0.1,
                    max: 5,
                    step: 0.01,
                    label: (0, $d5b6ce321475881f$export$21c51bc433c16634).labelRendererOptionsBloomIntensity,
                    onChange: (bloomIntensity)=>this.setAdvancedOptions({
                            bloomIntensity: bloomIntensity,
                            isBloomEnabled: true
                        })
                })))), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("li", null, (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement((0, $a601a4135959dcb0$export$e2253033e6e1df16).fluentUI.Toggle, {
                    checked: advancedOptions.isDofEnabled,
                    label: (0, $d5b6ce321475881f$export$21c51bc433c16634).labelRendererOptionsDof,
                    onChange: (e, isDofEnabled)=>this.setAdvancedOptions({
                            isDofEnabled: isDofEnabled
                        })
                }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("ul", null, (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("li", null, (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement((0, $a601a4135959dcb0$export$e2253033e6e1df16).fluentUI.Slider, {
                    value: advancedOptions.dofFocusRange,
                    min: 0,
                    max: 2,
                    step: 0.01,
                    label: (0, $d5b6ce321475881f$export$21c51bc433c16634).labelRendererOptionsDofRange,
                    onChange: (dofFocusRange)=>this.setAdvancedOptions({
                            dofFocusRange: dofFocusRange,
                            isDofEnabled: true
                        })
                })))), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("li", null, (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement((0, $a601a4135959dcb0$export$e2253033e6e1df16).fluentUI.Toggle, {
                    checked: advancedOptions.isFxaaEnabled,
                    label: (0, $d5b6ce321475881f$export$21c51bc433c16634).labelRendererOptionsFxaa,
                    onChange: (e, isFxaaEnabled)=>this.setAdvancedOptions({
                            isFxaaEnabled: isFxaaEnabled
                        })
                }))))));
            }
        }
    }
    return new __Renderer(_props);
}
const $24a2c07dd03771c2$export$88530751e3977073 = $24a2c07dd03771c2$var$_Renderer;



function $688b2ed8e5aa6452$var$_Explorer(_props) {
    class __Explorer extends (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.Component {
        constructor(props){
            super(props);
            this.dialogFocusHandler = {};
            this.state = (0, $2273a7d1147da1bc$export$d1b579ecf4cf2d3f)(props);
            this.imageHolder = {
                img: null,
                backgroundImageColumnBounds: [],
                showBackgroundImage: false
            };
            this.snapshotThumbWidth = (0, $2273a7d1147da1bc$export$7e33de69431bbb06);
            this.discardColorContextUpdates = true;
            this.updateViewerOptions(Object.assign(Object.assign({}, (0, $1342cf7df79546f0$exports).VegaMorphCharts.util.clone((0, $1342cf7df79546f0$exports).Viewer.defaultViewerOptions)), props.viewerOptions));
        }
        finalize() {
            if (this.viewer) this.viewer.finalize();
        }
        updateViewerOptions(viewerOptions) {
            this.viewerOptions = Object.assign(Object.assign({}, (0, $1342cf7df79546f0$exports).VegaMorphCharts.util.deepMerge((0, $2273a7d1147da1bc$export$fb736e4909afb3d7), {
                tooltipOptions: {
                    prepareDataItem: (item)=>{
                        const ret = {};
                        for(const columnName in item)if (this.state.tooltipExclusions.indexOf(columnName) < 0) ret[columnName] = item[columnName];
                        return ret;
                    }
                }
            }, this.viewerOptions, viewerOptions)), {
                onColorContextChange: ()=>this.manageColorToolbar(),
                onDataFilter: (filter, filteredData)=>{
                    const selectedItemIndex = Object.assign({}, this.state.selectedItemIndex);
                    selectedItemIndex[(0, $86b892255d8eb4f0$export$f0297ce57faf7d71).FilteredData] = 0;
                    this.changeInsight({
                        filter: filter
                    }, {
                        label: this.historicFilterChange,
                        omit: !this.historicFilterChange
                    });
                    this.historicFilterChange = null;
                    this.setState({
                        filteredData: filteredData,
                        selectedItemIndex: selectedItemIndex
                    });
                    if (this.state.sideTabId === (0, $2752fa503c160704$export$f3b7566ffe363e3b).Data && this.state.dataScopeId === (0, $86b892255d8eb4f0$export$f0297ce57faf7d71).FilteredData) //make sure item is active
                    requestAnimationFrame(()=>filteredData && this.silentActivation(filteredData[0]));
                    viewerOptions && viewerOptions.onDataFilter && viewerOptions.onDataFilter(filter, filteredData);
                },
                onSelectionChanged: (newSearch, index, selectedData)=>{
                    if (this.ignoreSelectionChange) return;
                    const selectedItemIndex = Object.assign({}, this.state.selectedItemIndex);
                    selectedItemIndex[(0, $86b892255d8eb4f0$export$f0297ce57faf7d71).SelectedData] = index || 0;
                    let { search: search } = this.state;
                    const { sideTabId: sideTabId } = this.state;
                    if (newSearch) search = (0, $5b0ca40e09feefab$export$3ffa48e55176070e)(newSearch);
                    this.setState({
                        search: search,
                        selectedItemIndex: selectedItemIndex,
                        sideTabId: sideTabId
                    });
                    viewerOptions && viewerOptions.onSelectionChanged && viewerOptions.onSelectionChanged(newSearch, index, selectedData);
                },
                onAxisClick: (e, search)=>{
                    this.toggleableSearch(e, search);
                    viewerOptions && viewerOptions.onAxisClick && viewerOptions.onAxisClick(e, search);
                },
                onLegendHeaderClick: (e)=>{
                    const pos = (0, $c887e455511417d2$export$1690e12b840569b9)(e);
                    const specRole = this.state.specCapabilities && this.state.specCapabilities.roles.filter((r)=>r.role === 'color')[0];
                    const positionedColumnMapProps = Object.assign(Object.assign({}, this.getColumnMapBaseProps()), {
                        collapseLabel: true,
                        container: this.div,
                        selectedColumnName: this.state.columns['color'],
                        onDismiss: ()=>{
                            this.setState({
                                positionedColumnMapProps: null
                            });
                        },
                        specRole: specRole,
                        left: pos.left - this.div.clientLeft,
                        top: pos.top - this.div.clientTop
                    });
                    this.setState({
                        positionedColumnMapProps: positionedColumnMapProps
                    });
                },
                onLegendRowClick: (e, legendRow)=>{
                    this.toggleableSearch(e, legendRow.search);
                    viewerOptions && viewerOptions.onLegendRowClick && viewerOptions.onLegendRowClick(e, legendRow);
                },
                onError: (errors)=>{
                    this.setState({
                        errors: errors
                    });
                    viewerOptions && viewerOptions.onError && viewerOptions.onError(errors);
                },
                onBeforeCreateLayers: (stage, specCapabilities)=>{
                    (0, $f47e4461409e9b5c$export$48e4a8ab7f4530ac)(stage, specCapabilities);
                },
                getTextColor: (o)=>{
                    if (o.specRole) return (0, $1342cf7df79546f0$exports).VegaMorphCharts.util.colorFromString(this.viewerOptions.colors.clickableText);
                    else if (o.metaData && o.metaData.search) return (0, $1342cf7df79546f0$exports).VegaMorphCharts.util.colorFromString(this.viewerOptions.colors.searchText);
                    else return o.color;
                },
                getTextHighlightColor: (o)=>{
                    if (o.specRole) return (0, $1342cf7df79546f0$exports).VegaMorphCharts.util.colorFromString(this.viewerOptions.colors.clickableTextHighlight);
                    else if (o.metaData && o.metaData.search) return (0, $1342cf7df79546f0$exports).VegaMorphCharts.util.colorFromString(this.viewerOptions.colors.searchTextHighlight);
                    else return [
                        0,
                        0,
                        0,
                        0
                    ];
                },
                onTextClick: (e, text)=>{
                    if (e && text) {
                        const pos = (0, $c887e455511417d2$export$1690e12b840569b9)(e);
                        const rect = this.viewer.element.getBoundingClientRect();
                        pos.left += rect.left;
                        pos.top += rect.top;
                        const { specRole: specRole } = text;
                        if (pos && specRole) {
                            const positionedColumnMapProps = Object.assign(Object.assign({}, this.getColumnMapBaseProps()), {
                                collapseLabel: true,
                                container: this.div,
                                selectedColumnName: this.state.columns[specRole.role],
                                onDismiss: ()=>{
                                    this.setState({
                                        positionedColumnMapProps: null
                                    });
                                },
                                specRole: specRole,
                                left: pos.left,
                                top: pos.top
                            });
                            this.setState({
                                positionedColumnMapProps: positionedColumnMapProps
                            });
                        } else this.setState({
                            positionedColumnMapProps: null
                        });
                    }
                },
                onNewViewStateTarget: ()=>this.newViewStateTarget
            });
            if (this.viewer && this.viewer.presenter) {
                const newPresenterStyle = (0, $1342cf7df79546f0$exports).util.getPresenterStyle(this.viewerOptions);
                const mergePrenterStyle = Object.assign(Object.assign({}, this.viewer.presenter.style), newPresenterStyle);
                this.viewer.presenter.style = mergePrenterStyle;
                this.viewer.options = (0, $1342cf7df79546f0$exports).VegaMorphCharts.util.deepMerge(this.viewer.options, this.props.viewerOptions, this.viewerOptions);
            }
        }
        signal(signalName, signalValue, newViewStateTarget) {
            switch(signalName){
                case (0, $1342cf7df79546f0$exports).constants.SignalNames.ColorBinCount:
                case (0, $1342cf7df79546f0$exports).constants.SignalNames.ColorReverse:
                case (0, $1342cf7df79546f0$exports).constants.SignalNames.MarkOpacity:
                    this.discardColorContextUpdates = false;
                    break;
            }
            this.newViewStateTarget = newViewStateTarget;
            this.viewer.vegaViewGl.signal(signalName, signalValue);
            this.viewer.vegaViewGl.runAsync().then(()=>{
                //deeply set the state without a state change. This prevents a redraw if re-rendered
                if (this.state.signalValues) this.state.signalValues[signalName] = signalValue;
                this.discardColorContextUpdates = true;
                this.newViewStateTarget = undefined;
                this.props.onSignalChanged && this.props.onSignalChanged(signalName, signalValue);
            });
        }
        manageColorToolbar() {
            const canRemap = this.viewer.colorContexts && this.viewer.colorContexts.length > 1;
            (0, $46e7ccd2bf7a69a1$export$225a002951c27da7)(this.viewer.presenter, !!this.state.columns.color, {
                themePalette: (0, $a7be03ae5c68c2c3$export$3465a0e7b289ab72)[this.props.theme || ''],
                canRemap: canRemap,
                isRemap: canRemap && this.viewer.currentColorContext > 0,
                colorMapHandler: (remap)=>{
                    this.viewer.currentColorContext = ~~remap;
                    this.viewer.renderSameLayout();
                    this.manageColorToolbar();
                }
            });
        }
        getInsight() {
            return this.viewer.getInsight();
        }
        getSetup() {
            return {
                camera: this.state.holdCamera ? 'hold' : this.state.camera,
                renderer: this.state.renderer,
                transition: (0, $7169c11dc639bbc5$export$d5639c01d489b0c)(this.state),
                transitionDurations: this.state.transitionDurations
            };
        }
        setSetup(setup, newState) {
            newState.camera = undefined;
            if (setup) {
                this.props.onSetupOptionsChanged && this.props.onSetupOptionsChanged(setup);
                const { camera: camera, renderer: renderer, transition: transition, transitionDurations: transitionDurations } = setup;
                newState.renderer = renderer;
                newState.transitionType = transition.type;
                if (camera === 'hold') newState.holdCamera = true;
                else {
                    newState.holdCamera = false;
                    newState.camera = camera;
                }
                if (transition.type === 'column') newState.transitionColumn = transition.column;
                else if (transition.type === 'position') newState.transitionDimension = transition.dimension;
                if (transitionDurations) {
                    newState.transitionDurations = transitionDurations;
                    (0, $7169c11dc639bbc5$export$39fa25c8c3576e7a)(this.viewer, transitionDurations);
                }
            }
        }
        setInsight(historyAction, newState = {}, partialInsight = this.viewer.getInsight(), rebaseFilter, setup) {
            const selectedItemIndex = Object.assign({}, this.state.selectedItemIndex);
            (0, $86b892255d8eb4f0$export$6d13117e74df8390)(selectedItemIndex);
            const historicInsight = Object.assign({
                chart: null,
                scheme: null,
                columns: null,
                filter: null,
                rebaseFilter: rebaseFilter
            }, partialInsight);
            const state = Object.assign({
                filteredData: null,
                selectedItemIndex: selectedItemIndex,
                search: (0, $5b0ca40e09feefab$export$3ffa48e55176070e)(historicInsight.filter)
            }, newState);
            const changeInsight = ()=>{
                this.getColorContext = null;
                this.setSetup(setup, historicInsight);
                this.changeInsight(historicInsight, historyAction, state, setup);
            };
            const currentFilter = this.viewer.getInsight().filter;
            if (rebaseFilter && currentFilter && historicInsight.filter) {
                if ((0, $1342cf7df79546f0$exports).searchExpression.startsWith(historicInsight.filter, currentFilter)) changeInsight();
                else {
                    const { transitionDurations: transitionDurations } = this.state;
                    const renderTime = transitionDurations.position + transitionDurations.stagger;
                    const allowAsyncRenderTime = renderTime + this.viewerOptions.filterRenderingTimerPadding;
                    this.viewer.reset().then(()=>new Promise((resolve, reject)=>{
                            setTimeout(resolve, allowAsyncRenderTime);
                        })).then(changeInsight);
                }
            } else changeInsight();
        }
        handleReviveSnapshot(snapshot, selectedSnapshotIndex) {
            let handled = false;
            if (this.props.onSnapshotClick) {
                this.setState({
                    selectedSnapshotIndex: selectedSnapshotIndex
                });
                handled = this.props.onSnapshotClick(snapshot, selectedSnapshotIndex);
            }
            if (!handled) this.reviveSnapshot(selectedSnapshotIndex);
        }
        reviveSnapshot(snapshotOrIndex) {
            if (typeof snapshotOrIndex === 'number') {
                const selectedSnapshotIndex = snapshotOrIndex;
                const snapshot = this.state.snapshots[selectedSnapshotIndex];
                const newState = {
                    note: snapshot.description,
                    selectedSnapshotIndex: selectedSnapshotIndex
                };
                if (!this.state.sidebarClosed) {
                    newState.sideTabId = (0, $2752fa503c160704$export$f3b7566ffe363e3b).Snapshots;
                    this.scrollSnapshotIntoView(selectedSnapshotIndex);
                }
                if (snapshot.insight) {
                    const { backgroundImage: backgroundImage } = snapshot.insight;
                    this.imageHolder.showBackgroundImage = !!backgroundImage;
                    if (backgroundImage) this.imageHolder.img = {
                        src: backgroundImage.url,
                        height: backgroundImage.size.height,
                        width: backgroundImage.size.width
                    };
                }
                this.setInsight({
                    label: (0, $d5b6ce321475881f$export$21c51bc433c16634).labelHistoryReviveSnapshot
                }, newState, snapshot.insight, true, snapshot.setup);
            } else {
                const snapshot = snapshotOrIndex;
                if (snapshot.insight) this.setInsight({
                    label: (0, $d5b6ce321475881f$export$21c51bc433c16634).labelHistoryReviveSnapshot
                }, {
                    note: snapshot.description,
                    selectedSnapshotIndex: -1
                }, snapshot.insight, true, snapshot.setup); //don't navigate to sideTab
                else this.setState({
                    note: snapshot.description,
                    selectedSnapshotIndex: -1
                });
            }
        }
        load(data, getPartialInsight, optionsOrPrefs) {
            this.setState({
                historyIndex: -1,
                historyItems: []
            });
            this.changeInsight({
                columns: null
            }, {
                label: null,
                omit: true
            }, {
                note: null
            });
            return new Promise((resolve, reject)=>{
                const loadFinal = (dataContent)=>{
                    let partialInsight;
                    this.prefs = optionsOrPrefs && optionsOrPrefs.chartPrefs || optionsOrPrefs || {};
                    this.imageHolder.backgroundImageColumnBounds = (0, $cdd6162a40e9c08a$export$46ec3e17747a00c9)(dataContent.columns);
                    if (getPartialInsight) {
                        partialInsight = getPartialInsight(dataContent.columns);
                        (0, $d5291de605e66403$export$1915de5807f54194)(this.prefs, partialInsight);
                    }
                    if (!partialInsight) {
                        //load recommendation
                        const r = new (0, $c0a1d2df3eff3893$exports.RecommenderSummary)(dataContent.columns, dataContent.data);
                        partialInsight = r.recommend();
                    }
                    partialInsight = Object.assign({
                        facetStyle: 'wrap',
                        filter: null,
                        totalStyle: null,
                        transform: null
                    }, partialInsight);
                    if (partialInsight.chart === 'barchart') partialInsight.chart = 'barchartV';
                    const selectedItemIndex = Object.assign({}, this.state.selectedItemIndex);
                    const sideTabId = (0, $2752fa503c160704$export$f3b7566ffe363e3b).ChartType;
                    (0, $86b892255d8eb4f0$export$6d13117e74df8390)(selectedItemIndex);
                    const newState = Object.assign({
                        camera: undefined,
                        columns: {},
                        dataFile: dataFile,
                        dataContent: dataContent,
                        snapshots: dataContent.snapshots || this.state.snapshots,
                        autoCompleteDistinctValues: {},
                        filteredData: null,
                        tooltipExclusions: optionsOrPrefs && optionsOrPrefs.tooltipExclusions || [],
                        selectedItemIndex: selectedItemIndex,
                        sideTabId: sideTabId
                    }, partialInsight);
                    this.getColorContext = null;
                    (0, $cdd6162a40e9c08a$export$1e096674a95fd43b)(newState.columns, dataContent.columns, newState.transform);
                    const errors = (0, $cdd6162a40e9c08a$export$c2563952d877899)(partialInsight === null || partialInsight === void 0 ? void 0 : partialInsight.chart, partialInsight === null || partialInsight === void 0 ? void 0 : partialInsight.totalStyle, newState.columns, dataContent.columns);
                    newState.errors = errors;
                    newState.transitionColumn = dataContent.columns[0];
                    const setup = optionsOrPrefs && optionsOrPrefs.setup;
                    this.setSetup(setup, newState);
                    //change insight
                    this.changeInsight(partialInsight, {
                        label: (0, $d5b6ce321475881f$export$21c51bc433c16634).labelHistoryInit,
                        insert: true
                    }, newState, optionsOrPrefs && optionsOrPrefs.setup);
                    //make sure item is active
                    this.activateDataBrowserItem(sideTabId, this.state.dataScopeId);
                    resolve();
                };
                let dataFile;
                if (Array.isArray(data)) return (0, $105d7d4c8faa6087$export$c084150d12efae43)(data, 'json', optionsOrPrefs && optionsOrPrefs.columnTypes).then((result)=>{
                    dataFile = {
                        type: 'json'
                    };
                    loadFinal(result);
                }).catch(reject);
                else {
                    dataFile = data;
                    return (0, $105d7d4c8faa6087$export$9d26f8f2be82424f)(dataFile, optionsOrPrefs && optionsOrPrefs.columnTypes).then(loadFinal).catch(reject);
                }
            });
        }
        changeChartType(chart) {
            const partialInsight = Object.assign({}, (0, $d5291de605e66403$export$318d2f27a5d54aff)(this.prefs, chart, '*', '*'));
            const insight = Object.assign({
                chart: chart
            }, partialInsight);
            const columns = (0, $1342cf7df79546f0$exports).VegaMorphCharts.util.deepMerge({}, partialInsight.columns, this.state.columns);
            const { signalValues: signalValues } = this.viewer.getInsight();
            insight.signalValues = Object.assign(Object.assign({}, this.state.signalValues), signalValues);
            insight.columns = Object.assign({}, columns);
            insight.totalStyle = this.state.totalStyle;
            let errors;
            //special case mappings when switching chart type
            if (this.state.chart === 'scatterplot' && (chart === 'barchart' || chart === 'barchartV')) insight.columns = Object.assign(Object.assign({}, columns), {
                sort: columns.y
            });
            else if (this.state.chart === 'scatterplot' && chart === 'barchartH') insight.columns = Object.assign(Object.assign({}, columns), {
                sort: columns.x
            });
            else if (chart === 'treemap') {
                insight.view = '2d';
                if (!columns.size) {
                    //make sure size exists and is numeric
                    let sizeColumn;
                    //first check prefs
                    if (partialInsight && partialInsight.columns && partialInsight.columns.size) {
                        const prefSizeColumn = this.state.dataContent.columns.filter((c)=>c.name === partialInsight.columns.size)[0];
                        if (prefSizeColumn && prefSizeColumn.quantitative) sizeColumn = prefSizeColumn;
                    }
                    if (!sizeColumn) sizeColumn = (0, $cdd6162a40e9c08a$export$7e0d3b5c6570ae8b)(this.state.dataContent.columns);
                    if (!sizeColumn) //error - no numeric columns
                    errors = [
                        (0, $d5b6ce321475881f$export$21c51bc433c16634).errorColumnMustBeNumeric
                    ];
                    else insight.columns = Object.assign(Object.assign({}, columns), {
                        size: sizeColumn.name
                    });
                }
            } else if (chart === 'stacks') insight.view = '3d';
            (0, $cdd6162a40e9c08a$export$1e096674a95fd43b)(insight.columns, this.state.dataContent.columns, this.state.transform);
            errors = (0, $cdd6162a40e9c08a$export$c2563952d877899)(chart, insight.totalStyle, insight.columns, this.state.dataContent.columns);
            this.calculate(()=>{
                this.changeInsight(insight, {
                    label: (0, $d5b6ce321475881f$export$21c51bc433c16634).labelHistoryChangeChartType((0, $b4b5d5b480eaf9ae$export$7d1536ca08644643)(chart))
                }, errors ? {
                    errors: errors,
                    camera: undefined
                } : {
                    camera: undefined
                });
            });
            return insight.columns;
        }
        calculate(calculating) {
            this.setState({
                calculating: calculating
            });
        }
        changeView(view) {
            this.changeInsight({
                view: view
            }, {
                label: view === '2d' ? (0, $d5b6ce321475881f$export$21c51bc433c16634).labelViewType2d : (0, $d5b6ce321475881f$export$21c51bc433c16634).labelViewType3d
            });
        }
        //state members which change the insight
        changeInsight(partialInsight, historyAction, additionalUIState, historicSetup) {
            if (!partialInsight.signalValues) partialInsight.signalValues = null;
            if (partialInsight.chart === 'barchart') partialInsight.chart = 'barchartV';
            this.addHistory(Object.assign(Object.assign({}, partialInsight), {
                historicSetup: historicSetup
            }), historyAction, additionalUIState);
        }
        addHistory(historicInsight, historyAction, additionalUIState) {
            const setCleanState = (newState)=>{
                const cleanState = Object.assign(Object.assign({}, newState), additionalUIState);
                if (!cleanState.note) cleanState.note = null;
                delete cleanState.rebaseFilter;
                if (this.viewer) {
                    const { signalValues: signalValues } = this.viewer.getInsight();
                    cleanState.signalValues = Object.assign(Object.assign(Object.assign({}, this.state.signalValues), signalValues), cleanState.signalValues);
                }
                this.setState(cleanState);
            };
            if (historyAction.omit) {
                setCleanState(historicInsight);
                return;
            }
            const historyItems = this.state.historyItems.slice(0, this.state.historyIndex + 1);
            const historyIndex = historyItems.length;
            historyItems.push({
                label: historyAction.label,
                historicInsight: historicInsight
            });
            if (historyAction.insert) setCleanState({
                historyIndex: historyIndex,
                historyItems: historyItems
            });
            else setCleanState(Object.assign(Object.assign({}, historicInsight), {
                historyIndex: historyIndex,
                historyItems: historyItems
            }));
        }
        replay(index) {
            return (0, $1451439fef5c6aa0$export$5c9ba34b2d024c9b)(this.state.historyItems, index);
        }
        undo() {
            const historyIndex = this.state.historyIndex - 1;
            if (historyIndex < 0) return;
            this.doReplay(historyIndex);
        }
        redo(historyIndex = this.state.historyIndex + 1) {
            if (historyIndex >= this.state.historyItems.length) return;
            this.doReplay(historyIndex);
        }
        doReplay(historyIndex) {
            const newState = this.replay(historyIndex);
            this.rebaseFilter = true;
            this.setSetup(newState.historicSetup, newState);
            this.setState(Object.assign(Object.assign({}, newState), {
                historyIndex: historyIndex
            }));
        }
        changespecCapabilities(specCapabilities) {
            this.setState({
                specCapabilities: specCapabilities
            });
        }
        changeColumnMapping(role, column, options) {
            const columns = Object.assign({}, this.state.columns);
            const label = column ? (0, $d5b6ce321475881f$export$21c51bc433c16634).labelHistoryMapColumn(role) : (0, $d5b6ce321475881f$export$21c51bc433c16634).labelHistoryUnMapColumn(role);
            const final = ()=>{
                const partialInsight = {
                    columns: columns,
                    totalStyle: options ? options.totalStyle : this.state.totalStyle
                };
                const errors = (0, $cdd6162a40e9c08a$export$c2563952d877899)(this.state.chart, partialInsight.totalStyle, partialInsight.columns, this.state.dataContent.columns);
                columns[role] = column && column.name;
                this.changeInsight(partialInsight, {
                    label: label
                }, errors ? {
                    errors: errors,
                    camera: this.viewer.getCamera()
                } : {
                    camera: this.viewer.getCamera()
                });
            };
            const _changeInsight = (newInsight, columnUpdate, historyAction)=>{
                newInsight.columns = (0, $1342cf7df79546f0$exports).VegaMorphCharts.util.deepMerge({}, columns, columnUpdate);
                (0, $d5291de605e66403$export$a14483004c11686f)(this.prefs, this.state.chart, '*', '*', {
                    columns: columnUpdate
                });
                this.changeInsight(newInsight, historyAction, {
                    camera: this.viewer.getCamera()
                });
            };
            if (column) {
                let columnUpdate;
                switch(role){
                    case 'facet':
                        {
                            (0, $d5291de605e66403$export$318d2f27a5d54aff)(this.prefs, this.state.chart, 'facet', column.name);
                            const historicInsight = {
                                columns: columns,
                                facetStyle: options ? options.facetStyle : this.state.facetStyle
                            };
                            columnUpdate = {
                                facet: column.name
                            };
                            _changeInsight(historicInsight, columnUpdate, {
                                label: label
                            });
                            break;
                        }
                    case 'color':
                        {
                            let calculating = null;
                            const historicInsight = {
                                scheme: options && options.scheme,
                                columns: columns,
                                colorBin: this.state.colorBin
                            };
                            if (!historicInsight.scheme) (0, $d5291de605e66403$export$318d2f27a5d54aff)(this.prefs, this.state.chart, 'color', column.name);
                            if (!historicInsight.scheme) historicInsight.scheme = (0, $e3b58b932870fa44$export$ba25af89e7ea3c1a)(column, null, this.state.scheme);
                            if (!column.stats.hasColorData) {
                                historicInsight.directColor = false;
                                if (this.state.directColor !== historicInsight.directColor) calculating = ()=>this._resize();
                            }
                            if (this.state.columns && this.state.columns.color && this.state.columns.color !== column.name) {
                                const currColorColumn = this.state.dataContent.columns.filter((c)=>c.name === this.state.columns.color)[0];
                                if (column.isColorData != currColorColumn.isColorData) calculating = ()=>this._resize();
                            }
                            this.ignoreSelectionChange = true;
                            this.viewer.deselect().then(()=>{
                                this.ignoreSelectionChange = false;
                                //allow deselection to render
                                requestAnimationFrame(()=>{
                                    columnUpdate = {
                                        color: column.name
                                    };
                                    this.getColorContext = null;
                                    this.setState({
                                        calculating: calculating
                                    });
                                    _changeInsight(historicInsight, columnUpdate, {
                                        label: label
                                    });
                                });
                            });
                            break;
                        }
                    case 'x':
                        {
                            (0, $d5291de605e66403$export$318d2f27a5d54aff)(this.prefs, this.state.chart, 'x', column.name);
                            const historicInsight = {
                                columns: columns
                            };
                            columnUpdate = {
                                x: column.name
                            };
                            _changeInsight(historicInsight, columnUpdate, {
                                label: label
                            });
                            break;
                        }
                    case 'size':
                        {
                            (0, $d5291de605e66403$export$318d2f27a5d54aff)(this.prefs, this.state.chart, 'size', column.name);
                            const historicInsight = {
                                totalStyle: options ? options.totalStyle : this.state.totalStyle
                            };
                            columnUpdate = {
                                size: column.name
                            };
                            _changeInsight(historicInsight, columnUpdate, {
                                label: label
                            });
                            break;
                        }
                    default:
                        final();
                        break;
                }
            } else switch(role){
                case 'facet':
                    columns.facet = null;
                    columns.facetV = null;
                    this.changeInsight({
                        columns: columns,
                        facetStyle: 'wrap'
                    }, {
                        label: label
                    });
                    break;
                default:
                    final();
                    break;
            }
        }
        setSideTabId(sideTabId, dataScopeId) {
            if (sideTabId === (0, $2752fa503c160704$export$f3b7566ffe363e3b).Data && dataScopeId == null) //choose most relevant DataScopeId
            dataScopeId = this.getBestDataScopeId();
            if (dataScopeId == null) dataScopeId = this.state.dataScopeId;
            const calculating = ()=>{
                this.dialogFocusHandler.focus && this.dialogFocusHandler.focus();
            };
            this.setState({
                sideTabId: sideTabId,
                dataScopeId: dataScopeId,
                sidebarClosed: false,
                calculating: calculating
            });
            this.activateDataBrowserItem(sideTabId, dataScopeId);
        }
        getBestDataScopeId() {
            let dataScopeId;
            const selectionState = this.viewer && this.viewer.getSelection();
            if (selectionState && selectionState.selectedData && selectionState.selectedData.length) dataScopeId = (0, $86b892255d8eb4f0$export$f0297ce57faf7d71).SelectedData;
            else if (this.state.filteredData) dataScopeId = (0, $86b892255d8eb4f0$export$f0297ce57faf7d71).FilteredData;
            else dataScopeId = (0, $86b892255d8eb4f0$export$f0297ce57faf7d71).AllData;
            return dataScopeId;
        }
        activateDataBrowserItem(sideTabId, dataScopeId) {
            if (!this.viewer) return;
            let itemToActivate;
            if (sideTabId === (0, $2752fa503c160704$export$f3b7566ffe363e3b).Data) switch(dataScopeId){
                case (0, $86b892255d8eb4f0$export$f0297ce57faf7d71).AllData:
                    itemToActivate = this.state.dataContent && this.state.dataContent.data[this.state.selectedItemIndex[(0, $86b892255d8eb4f0$export$f0297ce57faf7d71).AllData]];
                    break;
                case (0, $86b892255d8eb4f0$export$f0297ce57faf7d71).FilteredData:
                    itemToActivate = this.state.filteredData && this.state.filteredData[this.state.selectedItemIndex[(0, $86b892255d8eb4f0$export$f0297ce57faf7d71).FilteredData]];
                    break;
                case (0, $86b892255d8eb4f0$export$f0297ce57faf7d71).SelectedData:
                    {
                        const selection = this.viewer.getSelection() || {};
                        itemToActivate = selection.selectedData && selection.selectedData[this.state.selectedItemIndex[(0, $86b892255d8eb4f0$export$f0297ce57faf7d71).SelectedData]];
                        break;
                    }
            }
            this.silentActivation(itemToActivate);
        }
        silentActivation(itemToActivate) {
            this.ignoreSelectionChange = true;
            const done = ()=>{
                this.ignoreSelectionChange = false;
            };
            if (itemToActivate) return this.viewer.activate(itemToActivate).then(done);
            else return this.viewer.deActivate().then(done);
        }
        sidebar(sidebarClosed, sidebarPinned) {
            this.setState({
                sidebarClosed: sidebarClosed,
                sidebarPinned: sidebarPinned
            });
        }
        resize() {
            this.setState({
                calculating: ()=>this._resize()
            });
        }
        _resize() {
            this.changeInsight({
                size: this.getLayoutDivSize(this.state.sidebarPinned, this.state.sidebarClosed)
            }, {
                label: 'resize',
                omit: true
            });
        }
        viewerMounted(glDiv) {
            this.setState({
                size: this.getLayoutDivSize(this.state.sidebarPinned, this.state.sidebarClosed),
                signalValues: this.state.signalValues
            });
        }
        getLayoutDivSize(pinned, closed) {
            const div = pinned && !closed ? this.layoutDivPinned : this.layoutDivUnpinned;
            return {
                height: div.offsetHeight,
                width: div.offsetWidth
            };
        }
        toggleableSearch(e, search) {
            if (e.ctrlKey) {
                this.setState({
                    search: (0, $5b0ca40e09feefab$export$3ffa48e55176070e)(search)
                });
                this.setSideTabId((0, $2752fa503c160704$export$f3b7566ffe363e3b).Search);
            } else {
                const oldSelection = this.viewer.getSelection();
                if (oldSelection.search) {
                    //look for matching groups and toggle them
                    const result = (0, $5b0ca40e09feefab$export$c2270d7efbef44bf)((0, $1342cf7df79546f0$exports).searchExpression.ensureSearchExpressionGroupArray(oldSelection.search), search);
                    if (result.found) {
                        //removing a group
                        if (result.groups.length === 0) this.doDeselect();
                        else //select with new search removed
                        this.doSelect(result.groups);
                    } else //adding a new group
                    if (e.altKey || e.shiftKey) {
                        let group = true;
                        if (e.altKey) search.clause = '&&';
                        else if (e.shiftKey) {
                            if (this.props.searchORDisabled) group = false;
                            else search.clause = '||';
                        }
                        if (group) {
                            result.groups.push(search);
                            this.doSelect(result.groups);
                        } else this.doSelect(search);
                    } else //replace
                    this.doSelect(search);
                } else this.doSelect(search);
            }
        }
        doFilter(search, historicFilterChange) {
            this.historicFilterChange = historicFilterChange;
            this.viewer.filter(search);
        }
        doUnfilter(historicFilterChange) {
            this.historicFilterChange = historicFilterChange;
            this.viewer.reset();
        }
        doSelect(search) {
            return this.viewer.select(search);
        }
        doDeselect() {
            return this.viewer.deselect();
        }
        writeSnapshot(snapshot, editIndex) {
            let { selectedSnapshotIndex: selectedSnapshotIndex } = this.state;
            let snapshots;
            if (editIndex >= 0) {
                snapshots = [
                    ...this.state.snapshots
                ];
                snapshots[editIndex] = snapshot;
                this.setState({
                    snapshots: snapshots,
                    selectedSnapshotIndex: selectedSnapshotIndex
                });
            } else {
                const note = snapshot.description;
                snapshots = this.state.snapshots.concat(snapshot);
                selectedSnapshotIndex = snapshots.length - 1;
                this.scrollSnapshotIntoView(selectedSnapshotIndex);
                this.setState({
                    sideTabId: (0, $2752fa503c160704$export$f3b7566ffe363e3b).Snapshots,
                    snapshots: snapshots,
                    selectedSnapshotIndex: selectedSnapshotIndex,
                    note: note
                });
            }
            this.props.onSnapshotsChanged && this.props.onSnapshotsChanged(snapshots);
        }
        scrollSnapshotIntoView(selectedSnapshotIndex) {
            clearTimeout(this.scrollSnapshotTimer);
            if (this.state.sidebarClosed) return;
            this.scrollSnapshotTimer = setTimeout(()=>{
                const selectedSnapshotElement = this.div.querySelector(`.snapshot:nth-child(${selectedSnapshotIndex + 1})`);
                if (selectedSnapshotElement) selectedSnapshotElement.scrollIntoView({
                    behavior: 'smooth',
                    block: 'nearest'
                });
            }, 500);
        }
        componentDidMount() {
            if (this.props.mounted) this.props.mounted(this);
        }
        render() {
            var _a, _b, _c;
            const insight = (0, $1451439fef5c6aa0$export$a5701bb72c00a527)(this.state);
            const loaded = !!(insight.columns && this.state.dataContent);
            if (loaded) (0, $15c8a952544b8f28$export$5aa9f35b88971754)(insight, this.imageHolder, this.state.columns);
            const selectionState = this.viewer && this.viewer.getSelection() || {};
            const selectionSearch = selectionState && selectionState.search;
            const columnMapProps = this.getColumnMapBaseProps();
            const datas = {};
            datas[(0, $86b892255d8eb4f0$export$f0297ce57faf7d71).AllData] = this.state.dataContent && this.state.dataContent.data;
            datas[(0, $86b892255d8eb4f0$export$f0297ce57faf7d71).FilteredData] = this.state.filteredData;
            datas[(0, $86b892255d8eb4f0$export$f0297ce57faf7d71).SelectedData] = selectionState && selectionState.selectedData;
            if (this.state.calculating) requestAnimationFrame(()=>{
                //allow render to complete
                if (this.state.calculating) {
                    this.state.calculating();
                    this.setState({
                        calculating: null
                    });
                }
            });
            const theme = this.props.theme || '';
            const themePalette = (0, $a7be03ae5c68c2c3$export$3465a0e7b289ab72)[theme];
            let renderOptions;
            if (loaded) renderOptions = Object.assign(Object.assign({}, this.props.renderOptions), {
                rebaseFilter: ()=>this.rebaseFilter,
                initialColorContext: this.getColorContext && this.getColorContext(this.viewer.insight, insight),
                discardColorContextUpdates: ()=>this.discardColorContextUpdates,
                columns: (_a = this.state.dataContent) === null || _a === void 0 ? void 0 : _a.columns
            });
            return (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("div", {
                ref: (div)=>{
                    if (div) this.div = div;
                },
                className: (0, $e295d8097c1ad61a$exports).classList('sanddance-explorer', this.props.theme)
            }, (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement((0, $17936d27f9fcfa1f$export$1ca1e38143dcc152), {
                collapseLabels: this.props.compactUI,
                historyIndex: this.state.historyIndex,
                historyItems: this.state.historyItems,
                undo: ()=>this.undo(),
                redo: ()=>this.redo(),
                logoClickUrl: this.props.logoClickUrl,
                logoClickTarget: this.props.logoClickTarget,
                themePalette: themePalette,
                loaded: loaded,
                doDeselect: this.doDeselect.bind(this),
                doFilter: this.doFilter.bind(this),
                doUnfilter: this.doUnfilter.bind(this),
                filter: this.state.filter,
                selectionSearch: selectionSearch,
                selectionState: selectionState,
                buttons: this.props.topBarButtonProps,
                iconButtons: this.props.topBarIconButtonProps,
                view: this.state.view,
                snapshotsHidden: (_b = this.props.snapshotProps) === null || _b === void 0 ? void 0 : _b.hidden,
                snapshots: this.state.snapshots,
                onSnapshotPreviousClick: ()=>{
                    let selectedSnapshotIndex;
                    if (this.state.selectedSnapshotIndex === -1) selectedSnapshotIndex = this.state.snapshots.length - 1;
                    else {
                        selectedSnapshotIndex = this.state.selectedSnapshotIndex;
                        selectedSnapshotIndex--;
                        if (selectedSnapshotIndex < 0) selectedSnapshotIndex = this.state.snapshots.length - 1;
                    }
                    this.handleReviveSnapshot(this.state.snapshots[selectedSnapshotIndex], selectedSnapshotIndex);
                },
                onSnapshotClick: ()=>this.snapshotEditor.editSnapshot(),
                onSnapshotNextClick: ()=>{
                    let selectedSnapshotIndex;
                    if (this.state.selectedSnapshotIndex === -1) selectedSnapshotIndex = 0;
                    else {
                        selectedSnapshotIndex = this.state.selectedSnapshotIndex;
                        selectedSnapshotIndex++;
                        if (selectedSnapshotIndex > this.state.snapshots.length - 1) selectedSnapshotIndex = 0;
                    }
                    this.handleReviveSnapshot(this.state.snapshots[selectedSnapshotIndex], selectedSnapshotIndex);
                },
                onViewClick: ()=>{
                    const view = this.state.view === '2d' ? '3d' : '2d';
                    this.changeInsight({
                        view: view
                    }, {
                        label: view === '2d' ? (0, $d5b6ce321475881f$export$21c51bc433c16634).labelViewType2d : (0, $d5b6ce321475881f$export$21c51bc433c16634).labelViewType3d
                    });
                }
            }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("div", {
                className: (0, $e295d8097c1ad61a$exports).classList('sanddance-main', this.state.sidebarPinned && 'pinned', this.state.sidebarClosed && 'closed', (insight.hideLegend || insight.directColor || !(0, $cdd6162a40e9c08a$export$3351a8d90bcc13aa)(insight, this.state.dataContent && this.state.dataContent.columns)) && 'hide-legend')
            }, (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("div", {
                ref: (div)=>{
                    if (div && !this.layoutDivUnpinned) this.layoutDivUnpinned = div;
                },
                className: "sanddance-layout-unpinned"
            }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("div", {
                ref: (div)=>{
                    if (div && !this.layoutDivPinned) this.layoutDivPinned = div;
                },
                className: "sanddance-layout-pinned"
            }), !loaded && (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("div", {
                className: "loading"
            }, (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement((0, $a601a4135959dcb0$export$e2253033e6e1df16).fluentUI.Spinner, {
                size: (0, $a601a4135959dcb0$export$e2253033e6e1df16).fluentUI.SpinnerSize.large,
                label: (0, $d5b6ce321475881f$export$21c51bc433c16634).loading
            })), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement((0, $a4defabaac4a9afe$export$1ba59dacbcbf90fe), {
                themePalette: themePalette,
                calculating: !!this.state.calculating,
                closed: this.state.sidebarClosed,
                hideSidebarControls: this.props.hideSidebarControls,
                snapshotsHidden: (_c = this.props.snapshotProps) === null || _c === void 0 ? void 0 : _c.hidden,
                pinned: this.state.sidebarPinned,
                disabled: !loaded,
                dataScopeProps: {
                    themePalette: themePalette,
                    compact: this.state.sidebarClosed,
                    onCompactClick: ()=>{
                        this.changeInsight({
                            size: this.getLayoutDivSize(this.state.sidebarPinned, false)
                        }, {
                            label: null,
                            omit: true
                        }, {
                            sidebarClosed: false
                        });
                    },
                    dataSet: this.props.datasetElement,
                    dataCount: loaded && {
                        all: this.state.dataContent && this.state.dataContent.data.length,
                        filtered: this.state.filteredData && this.state.filteredData.length,
                        selected: selectionState && selectionState.selectedData && selectionState.selectedData.length
                    },
                    active: this.state.sideTabId === (0, $2752fa503c160704$export$f3b7566ffe363e3b).Data,
                    onDataScopeClick: (dataScopeId)=>this.setSideTabId((0, $2752fa503c160704$export$f3b7566ffe363e3b).Data, dataScopeId),
                    selectedDataScope: this.state.dataScopeId,
                    disabled: !loaded
                },
                onSideTabClick: (sideTabId)=>{
                    //collapse or toggle
                    if (sideTabId === (0, $2752fa503c160704$export$f3b7566ffe363e3b).Collapse || this.state.sideTabId === sideTabId) {
                        let { dataScopeId: dataScopeId, sidebarClosed: sidebarClosed } = this.state;
                        if (sidebarClosed && sideTabId === (0, $2752fa503c160704$export$f3b7566ffe363e3b).Data) dataScopeId = this.getBestDataScopeId();
                        sidebarClosed = !this.state.sidebarClosed;
                        this.changeInsight({
                            size: this.getLayoutDivSize(this.state.sidebarPinned, sidebarClosed)
                        }, {
                            label: null,
                            omit: true
                        }, {
                            dataScopeId: dataScopeId,
                            sidebarClosed: sidebarClosed
                        });
                    } else if (sideTabId === (0, $2752fa503c160704$export$f3b7566ffe363e3b).Pin) this.changeInsight({
                        size: this.getLayoutDivSize(!this.state.sidebarPinned, this.state.sidebarClosed)
                    }, {
                        label: null,
                        omit: true
                    }, {
                        sidebarPinned: !this.state.sidebarPinned
                    });
                    else this.setSideTabId(sideTabId);
                },
                selectedSideTab: this.state.sideTabId
            }, loaded && (()=>{
                switch(this.state.sideTabId){
                    case (0, $2752fa503c160704$export$f3b7566ffe363e3b).ChartType:
                        return (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement((0, $b4b5d5b480eaf9ae$export$acaa6426d77a227e), Object.assign({
                            themePalette: themePalette,
                            collapseLabels: this.props.compactUI,
                            tooltipExclusions: this.state.tooltipExclusions,
                            toggleTooltipExclusion: (columnName)=>{
                                const tooltipExclusions = [
                                    ...this.state.tooltipExclusions
                                ];
                                const i = tooltipExclusions.indexOf(columnName);
                                if (i < 0) tooltipExclusions.push(columnName);
                                else tooltipExclusions.splice(i, 1);
                                this.setState({
                                    tooltipExclusions: tooltipExclusions
                                });
                                this.props.onTooltipExclusionsChanged && this.props.onTooltipExclusionsChanged(tooltipExclusions);
                            },
                            disabled: !loaded || this.state.sidebarClosed
                        }, columnMapProps, {
                            chart: this.state.chart,
                            view: this.state.view,
                            insightColumns: this.state.columns,
                            onChangeSignal: (role, column, name, value)=>(0, $d5291de605e66403$export$c2992dc6411becf6)(this.prefs, this.state.chart, role, column, name, value)
                        }));
                    case (0, $2752fa503c160704$export$f3b7566ffe363e3b).Color:
                        return (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement((0, $2cfe18e9e3d5fffb$export$892596cec99bc70e), Object.assign({
                            compactUI: this.props.compactUI,
                            specCapabilities: this.state.specCapabilities,
                            disabled: !loaded || this.state.sidebarClosed
                        }, columnMapProps, {
                            dataContent: this.state.dataContent,
                            scheme: this.state.scheme,
                            colorBin: this.state.colorBin,
                            colorBinSignal: this.viewer && this.viewer.vegaSpec && this.viewer.vegaSpec.signals.filter((s)=>s.name === (0, $1342cf7df79546f0$exports).constants.SignalNames.ColorBinCount)[0],
                            colorReverseSignal: this.viewer && this.viewer.vegaSpec && this.viewer.vegaSpec.signals.filter((s)=>s.name === (0, $1342cf7df79546f0$exports).constants.SignalNames.ColorReverse)[0],
                            colorColumn: this.state.columns.color,
                            onColorBinChange: (colorBin)=>{
                                this.ignoreSelectionChange = true;
                                this.viewer.deselect().then(()=>{
                                    this.ignoreSelectionChange = false;
                                    //allow deselection to render
                                    requestAnimationFrame(()=>{
                                        this.getColorContext = null;
                                        this.changeInsight({
                                            colorBin: colorBin
                                        }, {
                                            label: (0, $d5b6ce321475881f$export$21c51bc433c16634).labelHistoryColorBin
                                        });
                                        (0, $d5291de605e66403$export$a14483004c11686f)(this.prefs, this.state.chart, 'color', this.state.columns.color, {
                                            colorBin: colorBin
                                        });
                                    });
                                });
                            },
                            onColorSchemeChange: (scheme)=>{
                                this.changeColumnMapping('color', this.state.dataContent.columns.filter((c)=>c.name === this.state.columns.color)[0], {
                                    scheme: scheme
                                });
                                (0, $d5291de605e66403$export$a14483004c11686f)(this.prefs, this.state.chart, 'color', this.state.columns.color, {
                                    scheme: scheme
                                });
                            },
                            onColorBinCountChange: (value)=>{
                                const signalValues = {};
                                signalValues[(0, $1342cf7df79546f0$exports).constants.SignalNames.ColorBinCount] = value;
                                (0, $d5291de605e66403$export$a14483004c11686f)(this.prefs, this.state.chart, 'color', this.state.columns.color, {
                                    signalValues: signalValues
                                });
                            },
                            onColorReverseChange: (value)=>{
                                this.getColorContext = null;
                            },
                            directColor: this.state.directColor,
                            onDirectColorChange: (directColor)=>{
                                this.changeInsight({
                                    directColor: directColor
                                }, {
                                    label: (0, $d5b6ce321475881f$export$21c51bc433c16634).labelHistoryDirectColor
                                }, {
                                    calculating: ()=>this._resize()
                                });
                            }
                        }));
                    case (0, $2752fa503c160704$export$f3b7566ffe363e3b).Data:
                        {
                            const data = datas[this.state.dataScopeId];
                            let itemVisible = true;
                            switch(this.state.dataScopeId){
                                case (0, $86b892255d8eb4f0$export$f0297ce57faf7d71).AllData:
                                    {
                                        const item = this.state.selectedItemIndex[this.state.dataScopeId];
                                        itemVisible = this.state.dataContent && !this.state.filteredData || this.state.filteredData.indexOf(data[item]) >= 0;
                                    }
                            }
                            return (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement((0, $9ca0c376beb8c2ec$export$1ce2294f62fa7154), {
                                explorer: this,
                                theme: this.props.theme,
                                themePalette: themePalette,
                                disabled: !loaded || this.state.sidebarClosed,
                                columns: this.state.dataContent && this.state.dataContent.columns,
                                categoricalColumns: columnMapProps.categoricalColumns,
                                quantitativeColumns: columnMapProps.quantitativeColumns,
                                data: data,
                                displayName: this.state.dataFile && this.state.dataFile.displayName || (0, $d5b6ce321475881f$export$21c51bc433c16634).defaultFileName,
                                nullMessage: (0, $9ca0c376beb8c2ec$export$79bd5e38ba2a6de0)[this.state.dataScopeId],
                                zeroMessage: (0, $9ca0c376beb8c2ec$export$bbe9fd33806c217d)[this.state.dataScopeId],
                                index: this.state.selectedItemIndex[this.state.dataScopeId],
                                itemVisible: itemVisible,
                                dataExportHandler: this.props.dataExportHandler,
                                selectedDataScope: this.state.dataScopeId,
                                onDataScopeClick: (dataScopeId)=>this.setSideTabId((0, $2752fa503c160704$export$f3b7566ffe363e3b).Data, dataScopeId),
                                onActivate: (row, index)=>{
                                    const selectedItemIndex = Object.assign({}, this.state.selectedItemIndex);
                                    selectedItemIndex[this.state.dataScopeId] = index;
                                    this.setState({
                                        selectedItemIndex: selectedItemIndex
                                    });
                                    this.silentActivation(row);
                                },
                                onSearch: (e, search)=>{
                                    if (e.ctrlKey) this.setState({
                                        sideTabId: (0, $2752fa503c160704$export$f3b7566ffe363e3b).Search,
                                        search: search
                                    });
                                    else this.doSelect(search);
                                },
                                bingSearchDisabled: this.props.bingSearchDisabled,
                                onUpdateColumnTypes: (columnTypes)=>{
                                    this.load(this.state.dataFile, null, {
                                        prefs: this.prefs,
                                        columnTypes: columnTypes
                                    });
                                }
                            });
                        }
                    case (0, $2752fa503c160704$export$f3b7566ffe363e3b).Search:
                        return (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement((0, $7c89aab16f679c36$export$4b85d3515bd863a5), {
                            explorer: this,
                            collapseLabels: this.props.compactUI,
                            themePalette: themePalette,
                            disabled: !loaded || this.state.sidebarClosed,
                            disableGroupOR: this.props.searchORDisabled,
                            disableExpressionOR: this.props.searchORDisabled,
                            initializer: {
                                columns: columnMapProps.allColumns,
                                search: this.state.search
                            },
                            autoCompleteDistinctValues: this.state.autoCompleteDistinctValues,
                            onSelect: (expr)=>this.doSelect(expr),
                            data: this.state.dataContent.data
                        });
                    case (0, $2752fa503c160704$export$f3b7566ffe363e3b).Snapshots:
                        return (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement((0, $ce6d2e0261fc46dc$export$3e09886744a57615), Object.assign({}, this.props.snapshotProps, {
                            editor: this.snapshotEditor,
                            themePalette: themePalette,
                            explorer: this,
                            snapshots: this.state.snapshots,
                            selectedSnapshotIndex: this.state.selectedSnapshotIndex,
                            onClearSnapshots: ()=>{
                                const snapshots = [];
                                this.setState({
                                    snapshots: snapshots,
                                    selectedSnapshotIndex: -1
                                });
                                this.props.onSnapshotsChanged && this.props.onSnapshotsChanged(snapshots);
                            },
                            onWriteSnapshot: (s, i)=>this.writeSnapshot(s, i),
                            onRemoveSnapshot: (i)=>{
                                const snapshots = [
                                    ...this.state.snapshots
                                ];
                                snapshots.splice(i, 1);
                                let { selectedSnapshotIndex: selectedSnapshotIndex } = this.state;
                                if (i === selectedSnapshotIndex) selectedSnapshotIndex = -1;
                                else if (selectedSnapshotIndex > i) selectedSnapshotIndex--;
                                this.setState({
                                    snapshots: snapshots,
                                    selectedSnapshotIndex: selectedSnapshotIndex
                                });
                                this.props.onSnapshotsChanged && this.props.onSnapshotsChanged(snapshots);
                            },
                            onSnapshotClick: (snapshot, selectedSnapshotIndex)=>{
                                this.setState({
                                    selectedSnapshotIndex: selectedSnapshotIndex
                                });
                                this.calculate(()=>{
                                    this.handleReviveSnapshot(snapshot, selectedSnapshotIndex);
                                });
                            },
                            onMoveUp: (i)=>{
                                if (i > 0) {
                                    const snapshots = [
                                        ...this.state.snapshots
                                    ];
                                    const temp = snapshots[i - 1];
                                    snapshots[i - 1] = snapshots[i];
                                    snapshots[i] = temp;
                                    let { selectedSnapshotIndex: selectedSnapshotIndex } = this.state;
                                    if (i === selectedSnapshotIndex) selectedSnapshotIndex = i - 1;
                                    else if (i - 1 === selectedSnapshotIndex) selectedSnapshotIndex = i;
                                    this.setState({
                                        snapshots: snapshots,
                                        selectedSnapshotIndex: selectedSnapshotIndex
                                    });
                                    this.props.onSnapshotsChanged && this.props.onSnapshotsChanged(snapshots);
                                }
                            },
                            onMoveDown: (i)=>{
                                if (i < this.state.snapshots.length - 1) {
                                    const snapshots = [
                                        ...this.state.snapshots
                                    ];
                                    const temp = snapshots[i + 1];
                                    snapshots[i + 1] = snapshots[i];
                                    snapshots[i] = temp;
                                    let { selectedSnapshotIndex: selectedSnapshotIndex } = this.state;
                                    if (i === selectedSnapshotIndex) selectedSnapshotIndex = i + 1;
                                    else if (i + 1 === selectedSnapshotIndex) selectedSnapshotIndex = i;
                                    this.setState({
                                        snapshots: snapshots,
                                        selectedSnapshotIndex: selectedSnapshotIndex
                                    });
                                    this.props.onSnapshotsChanged && this.props.onSnapshotsChanged(snapshots);
                                }
                            }
                        }));
                    case (0, $2752fa503c160704$export$f3b7566ffe363e3b).History:
                        return (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement((0, $1451439fef5c6aa0$export$84202caead5689ba), {
                            explorer: this,
                            themePalette: themePalette,
                            historyIndex: this.state.historyIndex,
                            historyItems: this.state.historyItems,
                            redo: (i)=>this.redo(i)
                        });
                    case (0, $2752fa503c160704$export$f3b7566ffe363e3b).Transition:
                        return (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement((0, $7169c11dc639bbc5$export$df231814b4232ebd), Object.assign({}, columnMapProps, this.state, {
                            compactUI: this.props.compactUI,
                            explorer: this,
                            themePalette: themePalette,
                            changeSetup: (newState, affectsStagger)=>{
                                const calculating = ()=>{
                                    if (affectsStagger) this.viewer.assignTransitionStagger((0, $7169c11dc639bbc5$export$d5639c01d489b0c)(this.state));
                                    this.props.onSetupOptionsChanged && this.props.onSetupOptionsChanged(this.getSetup());
                                };
                                if (newState) this.setState(Object.assign(Object.assign({}, newState), {
                                    calculating: calculating
                                }));
                                else calculating();
                            }
                        }));
                    case (0, $2752fa503c160704$export$f3b7566ffe363e3b).Settings:
                        return (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement((0, $e46ab1f70cbc9878$export$c72f6eaae7b9adff), {
                            explorer: this,
                            dataFile: this.state.dataFile,
                            scheme: this.state.scheme,
                            hideLegend: this.state.hideLegend,
                            onToggleLegend: (hideLegend)=>this.setState({
                                    hideLegend: hideLegend,
                                    calculating: ()=>this._resize()
                                }),
                            hideAxes: this.state.hideAxes,
                            onToggleAxes: (hideAxes)=>this.setState({
                                    calculating: ()=>this.setState({
                                            hideAxes: hideAxes
                                        })
                                }),
                            additionalSettings: this.props.additionalSettings
                        }, this.props.systemInfoChildren);
                }
            })()), loaded && (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("div", {
                className: "sanddance-view"
            }, (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement((0, $7a3dcfea67f8da12$export$2ec4afd9b3c16a85), {
                renderOptions: renderOptions,
                viewerOptions: this.viewerOptions,
                ref: (reactViewer)=>{
                    if (reactViewer) this.viewer = reactViewer.viewer;
                },
                onView: (renderResult)=>{
                    this.rebaseFilter = false;
                    this.changespecCapabilities(renderResult.specResult.errors ? renderResult.specResult.specCapabilities : this.viewer.specCapabilities);
                    this.getColorContext = (oldInsight, newInsight)=>{
                        if (!oldInsight && !newInsight) return null;
                        if (!oldInsight || !newInsight) return null;
                        if (oldInsight.scheme !== newInsight.scheme) return null;
                        if (oldInsight.columns.color !== newInsight.columns.color) return null;
                        if (oldInsight.directColor != newInsight.directColor) return null;
                        return this.viewer.colorContexts && this.viewer.colorContexts[this.viewer.currentColorContext];
                    };
                    //don't allow tabbing to the canvas
                    (0, $4293b5c02e7b8c3d$export$95ea862e038e2d34)(this.viewer);
                    this.props.onView && this.props.onView();
                },
                onError: (e)=>{
                    this.props.onError && this.props.onError(e);
                },
                data: this.state.dataContent.data,
                insight: insight,
                setup: this.getSetup(),
                onMount: (el)=>this.viewerMounted(el)
            }), this.state.note && (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("div", {
                className: 'sanddance-note'
            }, (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement((0, $baf9c68afdd76912$export$c25acd513dcc8062), {
                className: 'cancel',
                themePalette: themePalette,
                title: (0, $d5b6ce321475881f$export$21c51bc433c16634).buttonClose,
                iconName: 'Cancel',
                onClick: ()=>this.setState({
                        note: null
                    })
            }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("div", null, this.state.note)), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement((0, $24a2c07dd03771c2$export$88530751e3977073), {
                explorer: this,
                advanced: this.state.renderer.advanced,
                advancedOptions: this.state.renderer.advancedOptions,
                basicOptions: this.state.renderer.basicOptions,
                themePalette: themePalette,
                onHomeClick: ()=>{
                    this.setState({
                        camera: undefined
                    });
                    this.viewer.presenter.homeCamera();
                }
            })), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement((0, $f4b615ab5c14d90e$export$3ddf2d174ce01153), {
                title: (0, $d5b6ce321475881f$export$21c51bc433c16634).labelError,
                hidden: !this.state.errors,
                onDismiss: ()=>{
                    this.setState({
                        errors: null
                    });
                }
            }, this.state.errors && this.state.errors.map((error, i)=>(0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("div", {
                    key: i
                }, error))), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement((0, $e07b04fee87ea13f$export$15b376344cc89d12), Object.assign({
                ref: (se)=>this.snapshotEditor = se
            }, this.props.snapshotProps, {
                explorer: this,
                onWriteSnapshot: (s, i)=>this.writeSnapshot(s, i),
                theme: this.props.theme,
                themePalette: themePalette
            }))), this.state.positionedColumnMapProps && (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement((0, $f47e4461409e9b5c$export$3e341bd56774d659), Object.assign({}, this.state.positionedColumnMapProps)));
        }
        getColumnMapBaseProps() {
            const allColumns = this.state.dataContent && this.state.dataContent.columns.filter((c)=>!(0, $1342cf7df79546f0$exports).util.isInternalFieldName(c.name, true));
            const quantitativeColumns = allColumns && allColumns.filter((c)=>c.quantitative);
            const categoricalColumns = allColumns && allColumns.filter((c)=>!c.quantitative);
            const props = {
                changeColumnMapping: (role, columnOrRole, defaultColumn, options)=>{
                    let column;
                    if (typeof columnOrRole === 'string') {
                        //look up current insight
                        const columnName = this.state.columns[columnOrRole];
                        column = allColumns.filter((c)=>c.name === columnName)[0] || defaultColumn;
                    } else column = columnOrRole;
                    this.changeColumnMapping(role, column, options);
                },
                facetStyle: this.state.facetStyle,
                totalStyle: this.state.totalStyle,
                allColumns: allColumns,
                quantitativeColumns: quantitativeColumns,
                categoricalColumns: categoricalColumns,
                specCapabilities: this.state.specCapabilities,
                explorer: this
            };
            return props;
        }
    }
    return new __Explorer(_props);
}
const $688b2ed8e5aa6452$export$43584986cb77a794 = $688b2ed8e5aa6452$var$_Explorer;




const $a601a4135959dcb0$export$e2253033e6e1df16 = {
    fluentUI: null,
    react: null,
    reactDOM: null
};
function $a601a4135959dcb0$export$1f96ae73734a86cc(fluentUI, react, reactDOM, vega) {
    (0, $a94804e25c3acfaf$export$1f96ae73734a86cc)(react, reactDOM, vega);
    $a601a4135959dcb0$export$e2253033e6e1df16.fluentUI = fluentUI;
    $a601a4135959dcb0$export$e2253033e6e1df16.react = react;
    $a601a4135959dcb0$export$e2253033e6e1df16.reactDOM = reactDOM;
    //inform React that we are using a dynamic base class
    (0, $15c8a952544b8f28$export$5696019163aa3cca).prototype = react.Component.prototype;
    (0, $b4b5d5b480eaf9ae$export$acaa6426d77a227e).prototype = react.Component.prototype;
    (0, $0edfbb46d4822ac6$export$12df67f310f5f846).prototype = react.Component.prototype;
    (0, $cff73bb5fafa0795$export$b1b568728c48eba1).prototype = react.Component.prototype;
    (0, $688b2ed8e5aa6452$export$43584986cb77a794).prototype = react.Component.prototype;
    (0, $f47e4461409e9b5c$export$3e341bd56774d659).prototype = react.Component.prototype;
    (0, $24a2c07dd03771c2$export$88530751e3977073).prototype = react.Component.prototype;
    (0, $7c89aab16f679c36$export$4b85d3515bd863a5).prototype = react.Component.prototype;
    (0, $e07b04fee87ea13f$export$15b376344cc89d12).prototype = react.Component.prototype;
    (0, $ce6d2e0261fc46dc$export$3e09886744a57615).prototype = react.Component.prototype;
    (0, $e46ab1f70cbc9878$export$c72f6eaae7b9adff).prototype = react.Component.prototype;
    (0, $7169c11dc639bbc5$export$df231814b4232ebd).prototype = react.Component.prototype;
}



function $f4b615ab5c14d90e$export$3ddf2d174ce01153(props) {
    return (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement((0, $a601a4135959dcb0$export$e2253033e6e1df16).fluentUI.Dialog, Object.assign({}, props, {
        dialogContentProps: Object.assign({
            type: (0, $a601a4135959dcb0$export$e2253033e6e1df16).fluentUI.DialogType.normal,
            title: props.title
        }, props.dialogContentProps)
    }), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement("div", {
        onKeyUp: (e)=>{
            e.nativeEvent.stopImmediatePropagation();
        }
    }, props.children), (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement((0, $a601a4135959dcb0$export$e2253033e6e1df16).fluentUI.DialogFooter, null, props.buttons, (0, $a601a4135959dcb0$export$e2253033e6e1df16).react.createElement((0, $a601a4135959dcb0$export$e2253033e6e1df16).fluentUI.DefaultButton, {
        iconProps: {
            iconName: 'Cancel'
        },
        onClick: props.onDismiss,
        text: (0, $d5b6ce321475881f$export$21c51bc433c16634).buttonClose
    })));
}


$parcel$exportWildcard($5d1e60eb15fea085$exports, $f4b615ab5c14d90e$exports);










$parcel$exportWildcard($fa693121602b4446$exports, $688b2ed8e5aa6452$exports);


window.SandDanceExplorer = $fa693121602b4446$exports;

})();
